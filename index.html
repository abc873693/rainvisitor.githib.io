<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>RainVisitor Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="RainVisitor Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RainVisitor Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.rainvisitor.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-What’s-new-in-Flutter-3-22" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/0.html" class="article-date">
  <time datetime="2024-09-28T09:12:31.938Z" itemprop="datePublished">2024-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Flutter-3-22-的新功能：WebAssembly、圖形渲染增強功能等等"><a href="#Flutter-3-22-的新功能：WebAssembly、圖形渲染增強功能等等" class="headerlink" title="Flutter 3.22 的新功能：WebAssembly、圖形渲染增強功能等等"></a>Flutter 3.22 的新功能：WebAssembly、圖形渲染增強功能等等</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hf9CEzGh0uhxnzVZi2Kk4g.png" />
</figure>

<p>歡迎回到另一個令人興奮的 Flutter 穩定版本！這次，我們很高興推出 Flutter 3.22。我們將 WebAssembly 帶入穩定通道，為 Android 上的 Impeller 提供功能齊全的 Vulkan 後端，有望實現更流暢的圖形和顯著的效能提升。我們還藉由新的 Widget 狀態屬性、動態視圖調整大小和改進的表單驗證來引入簡化的工作流程。但這還不是全部 - 您會發現風味條件資產捆綁、Firebase Vertex AI 的 Dart 預覽以及更新的 DevTools，讓您的生活更輕鬆。</p>
<p>自上次更新以來，在短短幾個月的時間裡，我們已從 Flutter 社群合併了令人印象深刻的 1595 個拉取請求，其中 37 位新的社群成員首次為 Flutter 貢獻力量！</p>
<p>所以，深入了解 Flutter 社群帶給這個最新版本的最新功能和增強功能吧！</p>
<h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><p>隨著 Flutter 3.22 的發佈，Wasm 現在可在穩定通道上使用，可提供顯著的效能提升。在我們使用 M1 MacBook 上的 Chrome 進行的內部基準測試中，Wonderous 應用程式的畫面渲染時間平均提高了 2 倍，在最壞的情況下提高了 3 倍。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/719/0*x6HEkml8cFGc96hg" />
</figure>

<p>這些增強功能對於具有動畫和豐富轉場的應用程式至關重要，因為在這些應用程式中，維持流暢的畫面速率至關重要。Wasm 透過減少效能瓶頸來幫助實現這一點，從而產生更流暢的動畫和轉場。若要開始使用 Wasm 與您的 Flutter Web 應用程式，請查看我們的 <a href="https://dart.dev/web/wasm">Dart Wasm 文件</a> 和 <a href="https://docs.flutter.dev/platform-integration/web/wasm">Flutter Wasm 文件</a>。若要完整了解公告，請訪問 <a href="https://medium.com/flutter/io24-5e211f708a37">Flutter 在 Google I&#x2F;O 的部落格文章</a>。</p>
<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>Flutter 3.22 對 Impeller 引入了重大更新，Impeller 是為 Flutter 應用程式提供動力的渲染引擎。主要亮點包括：完成 Android 上的 Vulkan 後端，以實現更流暢的圖形和改進的效能；持續優化模糊效果和複雜路徑渲染；以及一個用於使用 Impeller 進行測試的新實驗性 API。根據我們的 <a href="https://github.com/flutter/flutter/wiki/Roadmap#core-framework--engine">路線圖</a>，我們致力於提升 Impeller 的品質和效能，包括完成 iOS 遷移到 Impeller 和擴展 Android 支援。</p>
<h4 id="Impeller"><a href="#Impeller" class="headerlink" title="Impeller"></a>Impeller</h4><h4 id="Android-上的-Vulkan-後端功能完整"><a href="#Android-上的-Vulkan-後端功能完整" class="headerlink" title="Android 上的 Vulkan 後端功能完整"></a><strong>Android 上的 Vulkan 後端功能完整</strong></h4><p>在此版本中，Impeller 的 Android Vulkan 後端功能完整。特別是在過去幾個月裡，團隊一直在努力完成 <a href="https://github.com/flutter/engine/pull/50154">快速進階混合</a> 的實作、使用 <a href="https://github.com/flutter/engine/pull/49543">FragmentProgram API</a> 支援自訂片段著色器、<a href="https://github.com/flutter/engine/pull/50730">PlatformView</a> 支援（儘管它需要 <a href="https://docs.flutter.dev/release/breaking-changes/android-surface-plugins">小型 API 遷移</a>）、以及完整實作 <a href="https://github.com/flutter/flutter/issues/134178">所有模糊樣式</a>。</p>
<h4 id="Android-預覽"><a href="#Android-預覽" class="headerlink" title="Android 預覽"></a>Android 預覽</h4><p>在 3.19 穩定版本中，在發佈 Impeller OpenGL 後端的改進之後，我們邀請使用者在具有和不具有 Vulkan 支援的 Android 設備上試用 Impeller。在過去的幾個月裡，在評估 OpenGL 後端的效能並估計 Vulkan 後端的剩餘工作量之後，我們決定將精力集中在首先使 Vulkan 後端投入生產。</p>
<p>Impeller 解決了著色器編譯卡頓的問題。此外，在我們的基準測試中，它在平均、第 90 個百分位數和第 99 個百分位數畫面時間上優於傳統渲染器。因此，我們認為 Vulkan 後端在 Android 上的效能是可以接受的。在此版本 (3.22) 中，選擇加入 Impeller 的應用程式將在有空的情況下使用 Vulkan 後端。在未來的版本中，這將成為預設設定。當選擇加入 Impeller 的應用程式在不支持 Vulkan 的設備上運行時，Flutter 將自動優雅地回退到使用 Skia 的 OpenGL ES。您無需採取任何措施。在未來，當我們認為 OpenGL ES Impeller 後端已準備好投入生產時，此回退也將使用 Impeller。</p>
<p>隨著 Android 上的 Impeller 預覽繼續在 3.22 穩定版本週期中進行，我們請求 Flutter 開發人員升級到最新的穩定版本，並在 <a href="https://docs.flutter.dev/perf/impeller#android">啟用 Impeller</a> 時提交有關任何發現的不足的錯誤。在此階段的回饋對確保 Impeller 在 Android 上取得成功以及我們能夠在今年晚些時候的版本中自信地將其設為預設渲染器至關重要。Android 硬體生態系統非常多元。因此，關於 Impeller 最有用的回饋應包括有關發生問題的特定設備和 Android 版本的詳細資訊。</p>
<h4 id="模糊效能提升"><a href="#模糊效能提升" class="headerlink" title="模糊效能提升"></a>模糊效能提升</h4><p>模糊已在 Impeller 中為 iOS 和 Android <a href="https://github.com/flutter/engine/pull/47576">重新實作</a>。特別是，新的方法類似於 Skia 的方法，將模糊的 CPU 和 GPU 時間在 <a href="https://flutter-flutter-perf.skia.org/e/?begin=1699468487&amp;end=1710262311&amp;keys=X01fc3d52ebd6fbf38afef91d82ab8d2b&amp;requestType=0&amp;selected=commit=38815&name=%252Carch%253Dintel%252Cbranch%253Dmaster%252Cconfig%253Ddefault%252Cdevice_type%253DiPhone_11%252Cdevice_version%253Dnone%252Chost_type%253Dmac%252Csub_result%253Daverage_frame_rasterizer_time_millis%252Ctest%253Dbackdrop_filter_perf_ios__timeline_summary%252C&amp;xbaroffset=38815">基準測試</a> 中減少了近一半。</p>
<p>下圖顯示了 iPhone 11 設備上最壞情況、第 99 個百分位數、第 90 個百分位數和平均畫面光柵化時間以及 GPU 畫面時間（以毫秒為單位），這些時間是在旨在突出模糊效能的病態基準測試中獲得的。在重寫 Impeller 的模糊之後，背景過濾模糊的 CPU 和 GPU 成本都減少了近一半。這種改進的規模也適用於非病態情況，例如在典型應用程式中出現的情況。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*mtFyiLoIUSqk_zRB" />
<figcaption>iPhone 11 設備上最壞情況、第 99 個百分位數、第 90 個百分位數和平均畫面光柵化時間以及 GPU 畫面時間（以毫秒為單位），這些時間是在旨在突出模糊效能的病態基準測試中獲得的。</figcaption>
</figure>

<h4 id="Stencil-then-Cover"><a href="#Stencil-then-Cover" class="headerlink" title="Stencil-then-Cover"></a>Stencil-then-Cover</h4><p>iOS 和 Android 上的 Impeller 都已 <a href="https://github.com/flutter/engine/pull/51219">遷移到基於 Stencil-then-Cover 方法的新渲染策略</a>，如 <a href="http://www.opengl-redbook.com/">OpenGL Redbook</a> 中的“使用模板緩衝區繪製填充的凹多邊形”章節所述。團隊成員在 GitHub 議題 <a href="https://github.com/flutter/flutter/issues/123671">＃123671</a> 中討論了此技術在適用於 Flutter 時的更多信息。</p>
<p>這種方法解決了光柵線程在 CPU 上為複雜路徑（例如 SVG 和 <a href="https://github.com/flutter/flutter/issues/141961">Lottie 動畫</a>）計算細分的時間過長的問題。在更改之後，包含複雜路徑的畫面的總畫面時間（CPU 上的 UI 線程 + CPU 上的光柵線程 + GPU 工作）要低得多。使用者會注意到 Lottie 動畫和其他複雜路徑的渲染更加流暢，CPU 利用率更低，GPU 利用率略高。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*1lCd7dBwJ0ab_sieDlQNFw.gif" />
<figcaption>(左) Lottie 動畫。以前，Impeller 在最近的 iPhone 上需要 64 毫秒 / 畫面的光柵線程 CPU 時間來渲染它。 (右) 在我們實施了 Stencil-then-Cover 優化之後，相同的動畫在相同的設備上。光柵時間快了將近 10 倍。</figcaption>
</figure>

<p>儘管對這些改進感到滿意，但仍然有更多工作要做。在其他機會中，我們意識到多段線生成在 CPU 配置文件中仍然很突出，我們打算調查將這項工作轉移到 GPU 上。</p>
<h4 id="新的-API"><a href="#新的-API" class="headerlink" title="新的 API"></a>新的 API</h4><p>雖然仍處於實驗階段，但 flutter test 現在接受 <code>--enable-impeller</code> 旗標，它使用 Vulkan 後端來練習 Impeller。</p>
<h3 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h3><h4 id="Widget-狀態屬性"><a href="#Widget-狀態屬性" class="headerlink" title="Widget 狀態屬性"></a>Widget 狀態屬性</h4><p>MaterialState 已移出 Material 函式庫，並重新命名為 WidgetState，以便它可供 Cupertino、基本 Flutter 架構和套件作者使用。有關遷移到新的 WidgetState 的更多信息，請查看 <a href="https://docs.flutter.dev/release/breaking-changes/material-state">遷移指南</a>。</p>
<h4 id="動態視圖調整大小"><a href="#動態視圖調整大小" class="headerlink" title="動態視圖調整大小"></a>動態視圖調整大小</h4><p>對動態視圖調整大小的 <a href="https://github.com/flutter/flutter/pull/140918">增強功能</a> 有利於構建響應式佈局的開發人員，確保 UI 在各種設備螢幕上具有更好的適應性。</p>
<h4 id="改進的表單驗證"><a href="#改進的表單驗證" class="headerlink" title="改進的表單驗證"></a>改進的表單驗證</h4><p>感謝 Flutter 社群成員 <a href="https://github.com/SharbelOkzan">SharbelOkzan</a> 的 <a href="https://github.com/flutter/flutter/pull/135578">貢獻</a>，Flutter 3.22 帶來了更靈活的表單驗證方法，允許開發人員建立更強大的使用者輸入處理，從而提高可用性和安全性。</p>
<h4 id="2D-API-中的協變體"><a href="#2D-API-中的協變體" class="headerlink" title="2D API 中的協變體"></a>2D API 中的協變體</h4><p>減少對 2D 圖形 API 中的類型轉換的需求，簡化了開發工作流程並提高了效能，這對於遊戲和複雜動畫來說很重要。</p>
<h4 id="風味條件資產捆綁"><a href="#風味條件資產捆綁" class="headerlink" title="風味條件資產捆綁"></a>風味條件資產捆綁</h4><p>使用 <a href="https://docs.flutter.dev/deployment/flavors">風味</a> 功能的開發人員現在可以配置單個資產，使其僅在為特定風味構建時才被捆綁。有關更多信息，請查看 <a href="https://docs.flutter.dev/deployment/flavors#conditionally-bundling-assets-based-on-flavor">根據風味有條件地捆綁資產</a>。</p>
<h4 id="使用-Dart-套件轉換資產"><a href="#使用-Dart-套件轉換資產" class="headerlink" title="使用 Dart 套件轉換資產"></a>使用 Dart 套件轉換資產</h4><p>使用者現在可以配置 Dart 套件以在捆綁應用程式的資產時轉換它們。有關更多信息，請查看 <a href="http://docs.flutter.dev/ui/assets/asset-transformation">在構建時轉換資產</a>。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="深度連結"><a href="#深度連結" class="headerlink" title="深度連結"></a>深度連結</h4><p>深度連結可以顯著改善 Flutter 應用程式中的使用者體驗，充當將使用者無縫引導到應用程式中特定內容的捷徑，從而提高參與度和推動銷售。雖然強烈建議使用 iOS 的通用連結和 Android 的應用程式連結，因為它們具有安全性，並且對使用者友好，但設定它們可能有些棘手。</p>
<p>在上次 Flutter 穩定版本中，我們在 DevTools 中引入了一個深度連結驗證工具，該工具支援檢查 Android 應用程式的 Web 組態。在此版本中，我們加入了一組新的功能來幫助驗證 Android 清單檔案中的設定。</p>
<p>有關使用此工具的更多信息，請查看 <a href="https://docs.flutter.dev/tools/devtools/deep-links">驗證深度連結</a>。</p>
<h4 id="預測性返回手勢"><a href="#預測性返回手勢" class="headerlink" title="預測性返回手勢"></a>預測性返回手勢</h4><p>Flutter 現在為 Android 即將推出的預測性返回功能添加了更多支援，使用者可以在返回手勢期間查看之前的路線，甚至查看之前的應用程式。這仍然是 Android 設備上的功能旗標，但您可以找到有關如何自行嘗試 <a href="https://github.com/flutter/flutter/issues/132504#issuecomment-2025776552">在 GitHub 上的詳細信息</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/400/0*8b6DxQuMXAyYVu-w" />
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/400/0*hr_OF9DsfUcsLNHv" />
</figure>

<h4 id="Flutter-工具強制執行-Gradle、AGP、Java-和-Kotlin-的版本要求"><a href="#Flutter-工具強制執行-Gradle、AGP、Java-和-Kotlin-的版本要求" class="headerlink" title="Flutter 工具強制執行 Gradle、AGP、Java 和 Kotlin 的版本要求"></a>Flutter 工具強制執行 Gradle、AGP、Java 和 Kotlin 的版本要求</h4><p>在此版本中，Flutter 工具強制執行關於它支援的 Gradle、Android Gradle Plugin (AGP)、Java 和 Kotlin 版本的政策。最初，工具只提供警告。</p>
<p>目前，支援的版本範圍如下：</p>
<ul>
<li>Gradle - 完全支援 7.0.2 到當前版本，否則警告</li>
<li>AGP - 完全支援 7.0.0 到當前版本，否則警告</li>
<li>Java - 完全支援 Java 11 到當前版本，否則警告</li>
<li>Kotlin - 完全支援 1.5.0 到當前版本，否則警告</li>
</ul>
<p>在下一個主要版本中，這些警告將變成錯誤，可以使用 <code>--android-skip-build-dependency-validation</code> 旗標覆蓋。更一般地說，在完全停止支援（產生錯誤）給定版本的這些相依性之前，工具至少會提供一個版本發佈的警告。</p>
<p>這種政策在 <a href="https://docs.google.com/document/d/1qeeM5QG-jiafttSgvc7yvC19IDRggFFZQTktBVxL6sI/edit?resourcekey=0-HLEAiBOMxAlQxDs-mEeffw">相關的設計規範</a> 中進行了討論。始終歡迎意見和回饋。</p>
<h4 id="在-Android-上的-Gradle-構建腳本中支援使用-Gradle-Kotlin-DSL"><a href="#在-Android-上的-Gradle-構建腳本中支援使用-Gradle-Kotlin-DSL" class="headerlink" title="在 Android 上的 Gradle 構建腳本中支援使用 Gradle Kotlin DSL"></a>在 Android 上的 Gradle 構建腳本中支援使用 Gradle Kotlin DSL</h4><p>Gradle Kotlin DSL 現在在 Flutter 中受支援，為傳統的 Gradle Groovy DSL 提供了替代方案。這種支援允許更美好的程式碼編輯體驗，提供自動完成、快速存取文件、原始碼導航和上下文感知重構功能。</p>
<p>此初始支援由 GitHub 使用者 <a href="https://github.com/bartekpacia">bartekpacia</a> 貢獻。開發人員現在可以选择用 Kotlin 重寫他們的 Gradle 構建腳本以利用這些優點，雖然 Flutter 工具還不支持在使用 flutter create 時選擇 Kotlin 而不是 Groovy。</p>
<p>有關更多詳細信息，請查看由 <a href="https://github.com/bartekpacia">bartekpacia</a> 提交的 <a href="https://github.com/flutter/flutter/pull/140744">PR 140744</a>。</p>
<h4 id="平台視圖改進"><a href="#平台視圖改進" class="headerlink" title="平台視圖改進"></a>平台視圖改進</h4><p><strong>注意所有 Flutter 應用程式開發人員！</strong> 如果您使用 Flutter 構建依賴於原生 Android 組件（例如地圖、Web 視圖或某些 UI 元素）的應用程式，我們有一些重要的消息。</p>
<p>由於 Android 14 中的一個錯誤，使用較舊版本的 Flutter 構建的應用程式可能無法在運行此新 Android 版本的設備上正常工作。</p>
<p>Flutter 3.22 修復了此問題，並改進了 Android 應用程式中這些原生組件的整體效能。因此，要確保您的應用程式在所有 Android 設備上順暢運行，請務必使用 Flutter 3.22 重新構建和發佈您的應用程式。</p>
<p>此更新還包括幕後改進，使 Android 上的平台視圖更加可靠和高效。</p>
<h4 id="停止支援-KitKat"><a href="#停止支援-KitKat" class="headerlink" title="停止支援 KitKat"></a>停止支援 KitKat</h4><p>Flutter 的最低支援 Android 版本現在是 Lollipop (API 21)。從 Flutter 3.22 穩定版本開始，Flutter 將不再在運行 Android KitKat (API 19) 的設備上工作。有關更多詳細信息，請查看我們的 <a href="https://docs.flutter.dev/release/breaking-changes/android-kitkat-deprecation">棄用指南</a>。</p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><h4 id="平台視圖效能"><a href="#平台視圖效能" class="headerlink" title="平台視圖效能"></a>平台視圖效能</h4><p>我們了解到 iOS 上的平台視圖效能一直是許多 Flutter 開發人員的痛點。這在使用平台視圖時，尤其是在捲軸視圖中很明顯。</p>
<p>最近的更新直接解決了這些問題，在嵌入文章中的多個內聯廣告等情況下，效能得到了顯著提升。以下是我們 <a href="https://github.com/flutter/flutter/pull/144745">基準測試</a> 中的一些關鍵改進：</p>
<ul>
<li><strong>減少 GPU 使用量：</strong> GPU 使用量減少了 50%，從而減少了功耗，並可能帶來更流暢的使用者體驗。</li>
<li><strong>改進畫面渲染：</strong> 平均畫面渲染時間減少了 1.66 毫秒（33%）。</li>
<li><strong>最小化卡頓：</strong> 最壞情況的畫面渲染時間減少了 3.8 毫秒（21%）。</li>
</ul>
<p>如果您之前在捲軸視圖中使用多個平台視圖（例如廣告、地圖等）時遇到效能挑戰，這些優化有可能為您帶來更流暢、更靈敏的捲軸體驗。請嘗試一下，並告訴我們您的想法。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*uk0URkHcImHdTq2M" />
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-KX8Ubw77KpdGnPI" />
</figure>

<h3 id="生態系統"><a href="#生態系統" class="headerlink" title="生態系統"></a>生態系統</h3><h4 id="Firebase-Vertex-AI-Dart-SDK-預覽版本"><a href="#Firebase-Vertex-AI-Dart-SDK-預覽版本" class="headerlink" title="Firebase Vertex AI Dart SDK 預覽版本"></a>Firebase Vertex AI Dart SDK 預覽版本</h4><p>Firebase Vertex AI 產品已發佈到公開預覽，並包含 Dart SDK。這使您可以使用 Gemini API 為您的 Dart 或 Flutter 應用程式構建生成式 AI 功能，同時考慮生產、效能和企業規模。SDK 與 <a href="https://firebase.google.com/docs/app-check">Firebase 應用程式檢查</a> 整合，該檢查可以保護您的 API 調用，並保護您的後端基礎設施免遭嚴重的威脅，例如帳單詐騙、釣魚和應用程式冒充。進入 <a href="https://firebase.google.com/docs/vertex-ai/get-started?platform=flutter">Dart 的入門指南</a>，並使用促銷碼開始免費使用它。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*KmIhzrfoyskNW7r8" />
</figure>

<p><a href="https://ai.google.dev/gemini-api/docs/get-started/dart">Google AI Dart SDK</a> 仍然可用，並且建議僅用於原型設計。Google AI 提供免費存取權限（在限制範圍內和有空的情況下）和按使用付費定價。如果您已使用 Google AI Dart SDK 進行原型設計，並且準備遷移到 Firebase Vertex AI，請查看 <a href="https://firebase.google.com/docs/vertex-ai/migrate-to-vertex-ai?platform=flutter">遷移指南</a>。</p>
<h4 id="DevTools-更新"><a href="#DevTools-更新" class="headerlink" title="DevTools 更新"></a>DevTools 更新</h4><p>我們將繼續改進 DevTools，這是 Dart 和 Flutter 的效能和除錯工具套件。此版本包括效能改進、一般潤色以及新的功能，例如在時間軸中包含 CPU 樣本、進階過濾以及支援匯入和匯出記憶體快照。</p>
<p>devtools_extensions 和 devtools_app_shared 套件附帶了其他值得注意的改進，這些套件支援 DevTools 擴展作者。我們加入了支援將擴展連接到新的 Dart 工具 Daemon (DTD)，這使 DevTools 擴展可以存取由其他 DTD 客戶端（例如 IDE）註冊的公開方法，以及允許存取用於與開發專案互動的最小文件系統 API。</p>
<p>若要進一步了解 Flutter 3.22 中包含的所有更新，請查看 DevTools 的發行備註 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.32.0">2.32.0</a>，<a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.33.0">2.33.0</a> 和 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.34.1">2.34.1</a>。</p>
<h4 id="Flutter-的-Google-行動廣告-SDK"><a href="#Flutter-的-Google-行動廣告-SDK" class="headerlink" title="Flutter 的 Google 行動廣告 SDK"></a>Flutter 的 Google 行動廣告 SDK</h4><p>對於那些使用廣告變現 Flutter 應用程式的人來說，我們有一些令人興奮的消息：Flutter 的 Google 行動廣告剛剛發佈了 5.0.1 版的重大更新！</p>
<p><strong>改進對使用者消息平台 (UMP) SDK 的支援：</strong> 此更新加入了對 Android UMP SDK 2.2.0 版和 iOS UMP SDK 2.4.0 版的最新 API 的支援。UMP SDK 對於遵守隱私法規至關重要，它使您更容易獲得使用者對個性化廣告的同意。此新版本引入了一些新的 API 來簡化同意收集過程。</p>
<p><strong>擴展的中介合作夥伴：</strong> 我們透過提供與受歡迎的廣告合作夥伴的整合，擴展了您的廣告變現範圍，包括 <a href="https://pub.dev/packages/gma_mediation_unity">Unity</a>，<a href="https://pub.dev/packages/gma_mediation_meta">Meta</a>，<a href="https://pub.dev/packages/gma_mediation_applovin">AppLovin</a>，<a href="https://pub.dev/packages/gma_mediation_ironsource">Iron Source</a>，<a href="https://pub.dev/packages/gma_mediation_mintegral">Mintegral</a>，<a href="https://pub.dev/packages/gma_mediation_pangle">Pangle</a>，<a href="https://pub.dev/packages/gma_mediation_dtexchange">DT Exchange</a>，<a href="https://pub.dev/packages/gma_mediation_inmobi">InMobi</a> 以及 <a href="https://pub.dev/packages/gma_mediation_liftoffmonetize">Liftoff</a>。您現在可以使用擴展的中介選項和簡化的實作來最大限度地提高您的應用程式收入。</p>
<p>我們鼓勵您在 Flutter 應用程式中試用這些新功能，並告訴我們您希望看到我們支援的哪些其他中介合作夥伴。當我們繼續改進 Flutter 的 Google 行動廣告 SDK 時，您的回饋至關重要。</p>
<h3 id="重大變更和棄用"><a href="#重大變更和棄用" class="headerlink" title="重大變更和棄用"></a>重大變更和棄用</h3><h4 id="移除-v1-Android-嵌入"><a href="#移除-v1-Android-嵌入" class="headerlink" title="移除 v1 Android 嵌入"></a>移除 v1 Android 嵌入</h4><p>版本一 Android 嵌入的刪除正在進行中。這對大多數應用程式可能沒有影響，因為</p>
<ol>
<li>版本二已經是多年的預設版本</li>
<li>Flutter 工具已經會阻止構建版本一應用程式，除非使用 <code>--ignore-deprecation</code> 旗標明確覆蓋。</li>
</ol>
<p>此版本完全中斷了 Flutter 工具對 v1 應用程式的支援。<strong>現在不再可以覆蓋。</strong></p>
<p><strong>Plugin 作者請注意：</strong> 當最初棄用 v1 android 嵌入時，為 Plugin 作者編寫了一個遷移文件，位於 <a href="https://docs.flutter.dev/release/breaking-changes/plugin-api-migration">https://docs.flutter.dev/release/breaking-changes/plugin-api-migration</a>。作為此遷移的一部分，建議 Plugin 作者透過在他們的 <em>Plugin.java</em> 中包含一個具有以下簽名的函式來保持對使用 v1 嵌入的應用程式的支援</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerWith</span><span class="params">(<span class="meta">@NonNull</span> io.flutter.plugin.common.PluginRegistry.Registrar registrar)</span></span><br></pre></td></tr></table></figure>

<p>我們計劃在下一個版本中完全刪除 v1 Android 嵌入，<strong>到那時，包含具有此簽名的函式的 Plugin 將不再編譯</strong>（因為它引用了 v1 android 嵌入中的類型）。</p>
<p>它目前沒有作用，因為此版本已中斷使用 v1 嵌入的應用程式。我們建議 Plugin 作者盡快發佈已移除 v1 程式碼的 Plugin 更新版本，以避免在 Flutter 的未來版本中出現中斷。例如，請查看 <a href="https://github.com/flutter/packages/pull/6494">PR 6494</a>，其中移除了由 Flutter 團隊維護的 Plugin。</p>
<h4 id="在-3-22-中移除的棄用"><a href="#在-3-22-中移除的棄用" class="headerlink" title="在 3.22 中移除的棄用"></a>在 3.22 中移除的棄用</h4><p>此版本中的 <a href="https://docs.flutter.dev/release/breaking-changes">重大變更</a> 包含在 v3.19 發佈之後過期的已棄用 API。若要查看所有受影響的 API，以及其他上下文和遷移指南，請查看 <a href="https://docs.flutter.dev/release/breaking-changes/3-19-deprecations">此版本的棄用指南</a>。<a href="https://docs.flutter.dev/development/tools/flutter-fix">Flutter fix</a> 支援這些 API 的許多功能，包括 IDE 中的快速修復。可以使用 <code>dart fix</code> 命令列工具評估和應用批量修復。</p>
<p>與往常一樣，非常感謝社群為 <a href="https://github.com/flutter/tests/blob/master/README.md">貢獻測試</a> - 這些測試幫助我們識別出這些重大變更。若要進一步了解，請查看 <a href="https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes">Flutter 的重大變更政策</a>。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>Flutter 成功背後的核心是您 - 我們非凡的社群。沒有您無數的貢獻和堅定的熱情，這個版本是不可能實現的。我們衷心感謝您。</p>
<p>準備好探索 Flutter 3.22 了嗎？深入了解完整的發行備註和變更日誌，啟動您的終端機並運行 <code>flutter upgrade</code>。我們迫不及待想看看您會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fbde6c164fe3" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/whats-new-in-flutter-3-22-fbde6c164fe3">Flutter 3.22 的新功能</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/0.html" data-id="cm1ntp44i000iv517fkwx2lvs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-What’s new in Flutter 3.24" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/430aae7c.html" class="article-date">
  <time datetime="2024-08-07T08:40:30.000Z" itemprop="datePublished">2024-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/430aae7c.html">【文章翻譯】What’s new in Flutter 3.24</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="解鎖-Flutter-GPU、多視圖嵌入等等"><a href="#解鎖-Flutter-GPU、多視圖嵌入等等" class="headerlink" title="解鎖 Flutter GPU、多視圖嵌入等等"></a>解鎖 Flutter GPU、多視圖嵌入等等</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EA-cAY6uwkYqYb725vnCIw.png" />
<figcaption>Flutter 3.24 on a blue background</figcaption>
</figure>

<p>歡迎來到最新的 Flutter 更新！Flutter 3.24 充滿了令人興奮的新功能和增強功能，可以提升您的應用程式開發體驗。此版本重點介紹了 Flutter GPU 的預覽版本，它可以在 Flutter 中直接啟用進階圖形和 3D 場景。Web 應用程式現在可以嵌入多個 Flutter 視圖，增強應用程式的多功能性。最後，我們加入了影片廣告支援，以幫助您最大限度地提高收入。</p>
<p>在過去的幾個月裡，Flutter 社群一直非常活躍，擁有 852 個框架提交和 615 個引擎提交。我們很興奮地歡迎 49 位新貢獻者，他們幫助實現了此版本。您的奉獻和熱情推動著 Flutter 的前進。</p>
<p>因此，深入了解 Flutter 社群帶給這個最新版本的最新功能和增強功能吧！</p>
<h3 id="Flutter-架構"><a href="#Flutter-架構" class="headerlink" title="Flutter 架構"></a>Flutter 架構</h3><h4 id="新的-Sliver"><a href="#新的-Sliver" class="headerlink" title="新的 Sliver"></a>新的 Sliver</h4><p>此版本加入了新的 Sliver，可以將它們組合在一起以實現動態 app bar 行為：</p>
<ul>
<li><a href="http://api.flutter.dev/flutter/widgets/PinnedHeaderSliver-class.html">PinnedHeaderSliver</a></li>
<li><a href="http://api.flutter.dev/flutter/widgets/SliverResizingHeader-class.html">SliverResizingHeader</a></li>
</ul>
<p>您可以使用這些新的 Sliver 來製作浮動、保持固定或在使用者捲軸時調整大小的標題。這些新的 Sliver 類似於現有的 <a href="https://api.flutter.dev/flutter/widgets/SliverPersistentHeader-class.html">SliverPersistentHeader</a> 和 <a href="http://sliverappbar/">SliverAppBar</a> Sliver，但具有更簡單的 API，可以組合在一起以實現更大的效果。</p>
<p>這些新的 Sliver 附帶了新的範例程式碼。例如，PinnedHeaderSliver 的 API 文件有一個範例，可以重新建立 iOS 設定應用程式 app bar 的效果：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*bdcb6KGonosfPZ6m" />
</figure>

<h4 id="Cupertino-函式庫中的更新"><a href="#Cupertino-函式庫中的更新" class="headerlink" title="Cupertino 函式庫中的更新"></a>Cupertino 函式庫中的更新</h4><p>在此版本中，我們改進了 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoActionSheet-class.html">CupertinoActionSheet</a> 的保真度。在動作表單的按鈕上滑動手指現在可以提供觸覺回饋。按鈕的字體大小和粗細現在與原生對應物相符。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/655/0*_o_9V0RlITOZdU4v" />
</figure>

<p>我們還為 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoButton-class.html">CupertinoButton</a> 加入了新的焦點屬性，現在您可以自訂已停用的 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoTextField-class.html">CupertinoTextField</a> 的顏色。</p>
<p>Cupertino 函式庫的更新正在進行中，請期待未來版本中的更多更新！</p>
<h4 id="TreeView"><a href="#TreeView" class="headerlink" title="TreeView"></a>TreeView</h4><p><a href="https://pub.dev/packages/two_dimensional_scrollables">two_dimensional_scrollables</a> 套件發佈了 <a href="https://pub.dev/documentation/two_dimensional_scrollables/latest/two_dimensional_scrollables/TreeView-class.html">TreeView</a> Widget，以及幾個用於建立高效能捲軸樹的配套類別，這些樹可以在樹增長時向所有方向捲軸。套件中包含的樣本應用程式也已更新，其中包含幾個使用 <a href="https://pub.dev/documentation/two_dimensional_scrollables/latest/two_dimensional_scrollables/TableView-class.html">TableView</a> 和 <a href="https://pub.dev/documentation/two_dimensional_scrollables/latest/two_dimensional_scrollables/TreeView-class.html">TreeView</a> Widget 的全新範例。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*wcmJCv-6owwsolRl" />
</figure>

<p><a href="https://api.flutter.dev/flutter/widgets/TreeSliver-class.html">TreeSliver</a> 也被加入到框架中，用於在一維捲軸中建立樹。<code>TreeView</code> 和 <code>TreeSliver</code> API 符合，使您能夠輕鬆地在適合您的使用案例之間切換。</p>
<h4 id="CarouselView"><a href="#CarouselView" class="headerlink" title="CarouselView"></a>CarouselView</h4><p>此版本包含了 <a href="https://m3.material.io/components/carousel/overview">Material Design carousel</a> Widget：<code>CarouselView</code>。CarouselView 呈現「<a href="https://m3.material.io/components/carousel/specs#477de3a1-c9df-4742-baf3-bcd5eeb3764c">Uncontained</a>」佈局：一個可捲軸的項目列表，這些項目會捲軸到 container 的邊緣，並且當開頭和末尾項目捲出視圖和捲入視圖時，它們可以動態調整大小。</p>
<figure>
<img alt="Flutter CarouselView example" src="https://cdn-images-1.medium.com/max/512/1*6ytqSvtR2TJzAE6LntHTGw.gif" />
</figure>

<h4 id="Widget提供更多功能"><a href="#Widget提供更多功能" class="headerlink" title="Widget提供更多功能"></a>Widget提供更多功能</h4><p>此版本包含將核心 Widget 邏輯從 Material 函式庫移動到 Widgets 函式庫中以便更廣泛使用，這些邏輯不是設計專用的。這包括：</p>
<ul>
<li><a href="https://github.com/flutter/flutter/pull/148523">Feedback</a> Widget，它提供輕鬆存取設備上的觸覺和音訊回饋，以點擊回應、長按等手勢。</li>
<li><a href="https://github.com/flutter/flutter/pull/148272">ToggleableStateMixin</a> 和 <a href="https://github.com/flutter/flutter/pull/148272">ToggleablePainter</a>，用於建立複選框、開關和單選按鈕等切換 Widget 的基本類別。</li>
</ul>
<h4 id="為-AnimationStatus-增強列舉功能"><a href="#為-AnimationStatus-增強列舉功能" class="headerlink" title="為 AnimationStatus 增強列舉功能"></a>為 AnimationStatus 增強列舉功能</h4><p>在社群成員 <a href="https://github.com/nate-thegrate">nate-thegrate</a> 的出色 <a href="https://github.com/flutter/flutter/pull/147801">貢獻</a> 中，增強的列舉功能被加入到 <a href="https://api.flutter.dev/flutter/animation/AnimationStatus.html">AnimationStatus</a> 中，包括 getter：</p>
<ul>
<li>isDismissed</li>
<li>isCompleted</li>
<li>isRunning</li>
<li>isForwardOrCompleted</li>
</ul>
<p>其中一些 getter 已經存在於 <a href="https://api.flutter.dev/flutter/animation/Animation-class.html">Animation</a> 子類別中，例如 <a href="https://api.flutter.dev/flutter/animation/AnimationController-class.html">AnimationController</a> 和 <a href="https://api.flutter.dev/flutter/animation/CurvedAnimation-class.html">CurvedAnimation</a>。現在，所有這些狀態 getter 都可以在 Animation 子類別中使用，除了 AnimationStatus 之外。最後，一個 <a href="https://api.flutter.dev/flutter/animation/AnimationController/toggle.html"><code>toggle</code></a> 方法被加入到 AnimationController 中，用於切換動畫的方向。</p>
<h4 id="SelectionArea-中的更新"><a href="#SelectionArea-中的更新" class="headerlink" title="SelectionArea 中的更新"></a>SelectionArea 中的更新</h4><p>Flutter 的 <a href="https://api.flutter.dev/flutter/material/SelectionArea-class.html">SelectionArea</a> 現在支援使用滑鼠進行三擊和在觸控設備上雙擊的更多原生手勢。預設情況下，<a href="https://api.flutter.dev/flutter/material/SelectionArea-class.html">SelectionArea</a> 和 <a href="https://api.flutter.dev/flutter/widgets/SelectableRegion-class.html">SelectableRegion</a> Widget 使用這些新的手勢。</p>
<p>三擊</p>
<ul>
<li>三擊 + 拖動：擴展段落塊中的選取範圍。</li>
<li>三擊：選取點擊位置的段落塊。</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*_GmbsIKfnwEAW6G8" />
</figure>

<p>雙擊</p>
<ul>
<li>雙擊 + 拖動：擴展文字區塊中的選取範圍（支援原生 Android&#x2F;Fuchsia&#x2F;iOS 和 iOS 網頁）。</li>
<li>雙擊：選取點擊位置的文字（支援原生 Android&#x2F;Fuchsia&#x2F;iOS 和 Android&#x2F;Fuchsia 網頁）。</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/770/0*DwZgIybQr3FDFxXd" />
</figure>

<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><h4 id="Impeller"><a href="#Impeller" class="headerlink" title="Impeller"></a>Impeller</h4><p><strong>改善效能和保真度</strong></p>
<p>為了在即將到來的穩定版本中移除 iOS 上的 Impeller 選擇不使用設定，團隊一直在努力改進 Impeller 的效能和保真度。例如，針對文字渲染的一系列改進 <a href="https://github.com/flutter/flutter/issues/138798">大幅提高了 emoji 捲軸的效能</a>，消除了捲軸大量 emoji 時的卡頓，這對 Impeller 的文字渲染能力來說是一項極好的壓力測試。</p>
<p>此外，透過 <a href="https://github.com/flutter/engine/pull/53042">解決許多問題</a>，我們也在此版本中大幅改進了 Impeller 文字渲染的保真度。特別是，文字粗細、間距和字距調整現在都與傳統渲染器的文字保真度相符。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gIu2Wm9mpuMGb1JY" />
<figcaption>Before (Note gaps instead of proper kerning, and lighter than intended font weight.)</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tt9hlqhTbrmj4ZCt" />
<figcaption>After</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/739/0*eMboSxWLEJBS_EyL" />
<figcaption>Before (Note incorrect spacing, for example in “vergelijken”)</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/739/0*uxeGJuIKWu0dPW1d" />
<figcaption>After</figcaption>
</figure>

<p><strong>Android 預覽</strong></p>
<p>在此版本中，我們將繼續在 Android 上預覽 Impeller。我們延長了預覽期，因為 Impeller 用於 Platform Views 的 API 在 <a href="https://github.com/flutter/flutter/issues/146499#issuecomment-2082873125">Android 14 中的一個錯誤</a> 導致出現困難。這個錯誤後來被 Android 團隊修補了，但是許多已部署的設備在可預見的將來將運行未修補的 Android 版本。解決這些問題意味著需要額外的 API 遷移，因此需要額外的穩定版本週期。出於謹慎和為了確保 Flutter 應用程式可以在盡可能廣泛的設備上運行，我們將推遲將 Impeller 作為預設渲染器，直到今年晚些時候的穩定版本發佈。</p>
<p>隨著 Android 上的 Impeller 預覽繼續在 3.24 穩定版本週期中進行，我們請求 Flutter 開發人員升級到最新的穩定版本，並在啟用 Impeller 時提交有關任何發現的不足的錯誤。在此階段的回饋對確保 Impeller 在 Android 上取得成功以及我們能夠在今年晚些時候的版本中自信地將其設為預設渲染器至關重要。Android 硬體生態系統比 iOS 生態系統更加多元。因此，關於 Impeller 最有用的回饋應包括有關發生問題的特定設備和 Android 版本的詳細資訊。</p>
<h4 id="改進縮放圖片的預設值"><a href="#改進縮放圖片的預設值" class="headerlink" title="改進縮放圖片的預設值"></a>改進縮放圖片的預設值</h4><p>在此版本中，圖片的預設 <code>FilterQuality</code> 已從 <code>FilterQuality.low</code> 變更為 <code>FilterQuality.medium</code>。當一個大型圖片比其目標矩形大很多時（這是一個常見的情況），<code>FilterQuality.low</code> 會導致圖片看起來更加「像素化」，並且渲染速度比 <code>FilterQuality.medium</code> 慢。未來，團隊還將探索更適合各種 FilterQuality 級別的新名稱。</p>
<h4 id="Flutter-GPU-預覽"><a href="#Flutter-GPU-預覽" class="headerlink" title="Flutter GPU 預覽"></a>Flutter GPU 預覽</h4><p>Flutter 推出了對渲染功能的重大更新，即 Flutter GPU，可在主頻道上使用。此低階圖形 API 允許開發人員使用 Dart 程式碼和 GLSL 著色器建立自訂渲染器，而無需任何原生平台程式碼。</p>
<p>Flutter GPU 擴展了您可以在 Flutter 中直接渲染的內容，啟用進階圖形和 3D 場景。它需要 Impeller 渲染後端，目前在 iOS、macOS 和 Android 上支援。儘管處於早期預覽階段，但 Flutter GPU 的目標是最終支援所有 Flutter 平台。</p>
<p>API 允許完全控制渲染傳遞附件、頂點階段和資料上傳到 GPU。這種靈活性對於建立複雜的渲染解決方案至關重要，從 2D 角色動畫到複雜的 3D 場景。</p>
<p>開發人員可以透過切換到 main channel 並將 flutter_gpu 套件加入到他們的專案中來開始使用 Flutter GPU。接下來的幾個月將看到更多功能和穩定性方面的改進，更高階的渲染函式庫（如 flutter_scene）將簡化這些進階功能的使用。</p>
<p>若要深入了解 Flutter GPU，並了解如何在您的專案中利用它，請查看詳細的 <a href="https://medium.com/flutter/getting-started-with-flutter-gpu-f33d497b7c11">Flutter GPU 部落格文章</a>。無論您是建立遊戲還是複雜的圖形，Flutter 的全新 GPU 功能都讓它成為產品的強大選擇。</p>
<h3 id="網頁"><a href="#網頁" class="headerlink" title="網頁"></a>網頁</h3><h3 id="多視圖嵌入"><a href="#多視圖嵌入" class="headerlink" title="多視圖嵌入"></a>多視圖嵌入</h3><p>Flutter Web 應用程式現在可以利用多視圖嵌入，讓開發人員可以將內容同時渲染到多個 HTML 元素中。此功能稱為「嵌入模式」或「多視圖」，為將 Flutter 視圖整合到現有的 Web 應用程式中提供了靈活性。</p>
<p>在多視圖模式下，Flutter Web 應用程式不會在啟動時立即渲染。相反，它會等到主機應用程式使用 addView 方法加入第一個「視圖」。主機應用程式可以動態加入或移除這些視圖，Flutter 會根據需要調整其 Widget。</p>
<p>若要啟用多視圖模式，請在 <code>flutter_bootstrap.js</code> 檔案中的 <code>initializeEngine</code> 方法中設定 <code>multiViewEnabled: true</code>。然後，可以從 JavaScript 管理視圖，將它們加入到指定的 HTML 元素中，並根據需要移除它們。每次加入和移除視圖都會觸發 Flutter 中的更新，允許動態內容渲染。</p>
<p>此功能對於將 Flutter 整合到需要多個獨立 Flutter 視圖的複雜 Web 應用程式中特別有用。它還支援每個視圖的自訂初始化資料，啟用個人化的設定和互動式體驗。</p>
<p>若要深入了解如何在 Flutter 網頁應用程式中實作多視圖嵌入，請查看 <a href="https://docs.flutter.dev/platform-integration/web/embedding-flutter-web">詳細的文件</a>。</p>
<h3 id="變現"><a href="#變現" class="headerlink" title="變現"></a>變現</h3><h3 id="影片廣告變現支援"><a href="#影片廣告變現支援" class="headerlink" title="影片廣告變現支援"></a>影片廣告變現支援</h3><p>我們推出了一個新的 <a href="https://pub.dev/packages/interactive_media_ads">互動式媒體廣告 (IMA) Plugin</a>，以支援 Flutter 行動應用程式中的串流影片廣告變現。新的 IMA Plugin 為 Flutter 應用程式提供了新的廣告變現機會，這些機會建立在現有的 <a href="https://pub.dev/packages/google_mobile_ads">Google 行動廣告 (GMA) Plugin</a> 之上，該 Plugin 主要支援展示廣告格式。</p>
<p>串流影片廣告通常在影片內容播放之前（開頭廣告）、期間（中間廣告）或之後（結尾廣告）顯示給使用者。一些串流影片廣告也可以跳過。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/836/0*_c0s8KMdLNyfxOMQ" />
</figure>

<p><strong>Flutter IMA 的優點：</strong></p>
<ul>
<li>在 Flutter 應用程式中無縫變現影片播放器內容。例如，當應用程式使用者點擊影片內容上的播放時，您現在可以實作 Flutter IMA Plugin 以首先向使用者顯示一個 15 秒的廣告，然後再開始播放影片內容。</li>
<li>利用原生 IMA SDK 的相同優點，包括存取 Google 優質廣告需求和行業標準合規性（例如 <a href="https://iabtechlab.com/standards/vast/">IAB VAST</a>）。</li>
</ul>
<p>初始發佈版本目前支援 Android 和 iOS 平台上的開頭影片廣告。中間廣告支援將很快提供。我們鼓勵您開始在 Flutter 應用程式影片內容中探索新的 IMA Plugin。如果您在 <a href="https://github.com/flutter/flutter/issues?q=is:issue+is:open+label:%22p:+interactive_media_ads%22">GitHub</a> 上遇到任何問題或疑慮，請告知我們。</p>
<p>資源：<a href="https://pub.dev/packages/interactive_media_ads">Plugin 指南</a>，<a href="https://pub.dev/packages/interactive_media_ads/example">範例應用程式</a>，<a href="https://github.com/flutter/packages/tree/main/packages/interactive_media_ads">Git 儲存庫</a></p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><h3 id="Swift-Package-Manager-初始支援"><a href="#Swift-Package-Manager-初始支援" class="headerlink" title="Swift Package Manager 初始支援"></a>Swift Package Manager 初始支援</h3><p>今天，Flutter 使用 CocoaPods 來管理原生 iOS 或 macOS 相依。</p>
<p>Flutter 3.24 加入了對 Swift Package Manager 的早期支援。這帶來了許多優點，包括：</p>
<ol>
<li><strong>存取 Swift 套件生態系統</strong>。Flutter Plugin 將能夠利用不斷發展的 <a href="https://swiftpackageindex.com/">Swift 套件</a> 生態系統！<br>2. <strong>簡化 Flutter 安裝</strong>。Swift Package Manager 與 Xcode 捆綁在一起。未來，您將不再需要安裝 Ruby 和 CocoaPods 來為 Apple 平台使用 Flutter。</li>
</ol>
<p>我們鼓勵 Plugin 作者 <a href="https://docs.flutter.dev/packages-and-plugins/swift-package-manager/for-plugin-authors#how-to-add-swift-package-manager-support-to-an-existing-flutter-plugin">嘗試將 Swift Package Manager 支援加入到您的 Plugin 中</a>，並提供您體驗的回饋。</p>
<p>如果您對 Flutter 對 Swift Package Manager 的支援有任何回饋，請 <a href="https://github.com/flutter/flutter/issues/new/choose">提交議題</a>。</p>
<h3 id="生態系統"><a href="#生態系統" class="headerlink" title="生態系統"></a>生態系統</h3><h3 id="Shared-Preferences-設定-Plugin-更新"><a href="#Shared-Preferences-設定-Plugin-更新" class="headerlink" title="Shared Preferences 設定 Plugin 更新"></a>Shared Preferences 設定 Plugin 更新</h3><p>我們已在 <a href="https://pub.dev/packages/shared_preferences">shared_preferences</a> Plugin 中加入了兩個新的 API，SharedPreferencesAsync 和 SharedPreferencesWithCache。最重大的變化是 Android 實作使用 Preferences DataStore 而不是 Shared Preferences。</p>
<p>SharedPreferencesAsync 允許使用者直接調用平台以獲取設備上儲存的最新偏好設定，代價是異步和比使用快取版本稍微慢一些。這對於可以由其他系統或隔離區更新的偏好設定很有用，這些偏好設定會使快取過時。</p>
<p>SharedPreferencesWithCache 建立在 SharedPreferencesAsync 之上，允許使用者同步存取偏好設定的本地快取副本。這與舊的 API 相似，但現在可以透過不同的參數多次實例化。</p>
<p>這些新的 API 旨在將來替換目前的 SharedPreferences API。但是，這是生態系統中最常用的 Plugin 之一，我們知道生態系統需要時間才能轉換到新的 API。</p>
<h3 id="Flutter-和-Dart-套件生態系統峰會歐洲-2024"><a href="#Flutter-和-Dart-套件生態系統峰會歐洲-2024" class="headerlink" title="Flutter 和 Dart 套件生態系統峰會歐洲 2024"></a>Flutter 和 Dart 套件生態系統峰會歐洲 2024</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fWo9ieYzQcJjwQBi" />
</figure>

<p>作為 Fluttercon Europe 2024 的一部分，我們舉辦了首屆面對面 Flutter 和 Dart 套件生態系統峰會。這是繼我們於 2023 年 8 月舉辦的第一屆虛擬峰會之後。<a href="https://docs.google.com/document/d/e/2PACX-1vRFLdpIJYO5YPARcyUT1FYPzwkFb1hxh_agqnCXxsyirXocLZS5jobs3xFV5ZGpSQHLHZiBzqbJlXNV/pub">在此</a>查看討論會的重點摘要。</p>
<p>我們很高興地宣布，下一屆峰會將於 2024 年 9 月 20 日在紐約市舉行的 <a href="https://flutterconusa.dev/">Fluttercon USA</a> 舉行！如果您是套件作者或貢獻者，並且將參加 Fluttercon USA 2024，請 <a href="https://rsvp.withgoogle.com/events/flutter-package-ecosystem-summit-usa-2024">註冊</a> 以保留您的峰會席位。</p>
<p>峰會匯集了套件作者和維護者，進行了以下主題的 unconference-style 議程：</p>
<ul>
<li>議程 1 - 原生互操作的過去、現在和未來</li>
<li>議程 2 - 可持續的套件維護模型</li>
<li>議程 3 - 解決套件生態系統碎片化問題</li>
</ul>
<p>我們相信峰會，特別是在更通用的 Flutter 和 Dart 活動的一部分時，是社群之間公開討論的有價值的平台，用於找出關鍵挑戰和集思廣益解決方案。我們期待與社群合作，在未來舉辦更多此類峰會。</p>
<h3 id="DevTools-和-IDE"><a href="#DevTools-和-IDE" class="headerlink" title="DevTools 和 IDE"></a>DevTools 和 IDE</h3><p>此版本包含一些對 Flutter DevTools 工具套件的令人興奮的改進。</p>
<p>如果您曾經想知道您的 Flutter 應用程式是否建立了比預期更多的 Widget，那麼 <strong>DevTools 效能</strong> 工具中的一個新功能可以幫助您。使用新的 <strong>重新建立統計資料</strong> 功能，您可以捕獲有關應用程式中或甚至特定 Flutter 畫面中 Widget 建立次數的資訊。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/749/0*7LXjXlFR9w-VR6xk" />
</figure>

<p><em>DevTools 效能工具的螢幕截圖，追蹤重新建立統計資料。</em></p>
<p>我們已為 <strong>網路分析工具</strong> 和 <strong>Flutter Deep Links 工具</strong> 等工具加入了潤色和關鍵錯誤修復，並且進行了一些一般性改進，以在您從 IDE 中使用 DevTools 時為您提供更好的體驗。說到 IDE，您知道您可以在 IDE 中直接使用每個 DevTools 工具嗎？</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tdpToIuTd-mBq-_R" />
</figure>

<p><em>DevTools 螢幕在 VS Code 視窗中打開。</em></p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*QvoXCNqqfsrMn1oC" />
</figure>

<p><em>DevTools 螢幕在 Android Studio 工具視窗中打開。</em></p>
<p>此版本包含對 VS Code 中的 Flutter 側邊欄的改進，讓您更容易存取您正在尋找的工具。升級到最新版本的 VS Code 和 Flutter 和 Dart 擴展，以存取改進的側邊欄。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/318/0*BzEybhMlV-SnSZZl" />
</figure>

<p><em>Flutter 側邊欄是自適應的，可以調整大小以適合您的工作區</em></p>
<p>此版本還包含對 <a href="https://docs.flutter.dev/tools/devtools/extensions">DevTools Extensions</a> 框架的一些重大改進。您現在可以在除錯 Dart 或 Flutter 測試時使用 DevTools 擴展（由您的套件相依之一提供的工具），或者甚至在您沒有除錯任何內容時，但只是在 IDE 中撰寫程式碼時使用。因此，如果您想在這些使用者旅程中使用工具（或建立工具！），現在已經可以了。</p>
<p>若要進一步了解 Flutter 3.24 中包含的所有更新，請查看 DevTools 的發行備註 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.35.0">2.35.0</a>，<a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.36.0">2.36.0</a> 和 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.37.2">2.37.2</a>。</p>
<h3 id="重大變更和棄用"><a href="#重大變更和棄用" class="headerlink" title="重大變更和棄用"></a>重大變更和棄用</h3><p>此版本中的重大變更包括對 <a href="https://docs.flutter.dev/release/breaking-changes/navigator-and-page-api">Navigator 的頁面 API</a>、<a href="https://docs.flutter.dev/release/breaking-changes/popscope-with-result">PopScope 中的泛型</a>、<a href="https://docs.flutter.dev/platform-integration/web/renderers">Flutter 網頁的預設渲染器</a> 的變更，以及一些新的棄用。在 <a href="https://docs.flutter.dev/release/breaking-changes">重大變更頁面</a> 上查看完整的遷移指南。</p>
<p>與往常一樣，非常感謝社群為 <a href="https://github.com/flutter/tests/blob/master/README.md">貢獻測試</a> - 這些測試幫助我們識別出這些重大變更。若要進一步了解，請查看 <a href="https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes">Flutter 的重大變更政策</a>。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>Flutter 成功背後的核心是您 - 我們非凡的社群。沒有您無數的貢獻和堅定的熱情，這個版本是不可能實現的。我們衷心感謝您。</p>
<p>若要深入了解此版本中所取得的成果，我們邀請您查看 <a href="https://docs.flutter.dev/release/release-notes/release-notes-3.24.0">發行備註</a> 和 <a href="https://github.com/flutter/flutter/blob/main/CHANGELOG.md">變更日誌</a>，以獲取 Flutter 3.24 中加入的內容的完整列表。</p>
<p>Flutter 3.24 與 Dart 3.5 現在已在 stable channel 上提供。開始使用 Flutter 的最新旅程就像運行 flutter upgrade 一樣簡單。我們迫不及待想看看您會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6c040f87d1e4" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/whats-new-in-flutter-3-24-6c040f87d1e4">Flutter 3.24 的新功能</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/430aae7c.html" data-id="cm1khy3qh0004yo17cf9a7s62" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Announcing Flutter 3.24 and Dart 3.5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/6243ded4.html" class="article-date">
  <time datetime="2024-08-07T07:23:41.000Z" itemprop="datePublished">2024-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/6243ded4.html">【文章翻譯】Announcing Flutter 3.24 and Dart 3.5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Flutter-3-24-和-Dart-3-5"><a href="#宣布-Flutter-3-24-和-Dart-3-5" class="headerlink" title="宣布 Flutter 3.24 和 Dart 3.5"></a>宣布 Flutter 3.24 和 Dart 3.5</h2><p>今天，我們將揭曉 <a href="https://medium.com/p/6c040f87d1e4/edit">Flutter 3.24</a> 和 <a href="https://medium.com/dartlang/dart-3.5-6ca36259fa2f">Dart 3.5</a>，以及 <a href="https://ioconnectchina.googlecnapps.cn/">I&#x2F;O 2024 Connect 系列</a> 的最後一站，該系列將在幾個小時內在中國舉行——中國是世界上最活躍的 Flutter 社群之一，這使得這個時刻變得格外特別。</p>
<figure>
<img alt="Dash flies in and lands to the left of an outline of 3.24. She presses a button that fills the 3.24 in with Flutter blue." src="https://cdn-images-1.medium.com/max/1024/1*jzRGig761LnPlvokq2FaVA.gif" />
</figure>

<p>我們在 5 月份的 <a href="https://io.google/2024/">Google I&#x2F;O</a> 上啟動了一系列 <a href="https://medium.com/flutter/io24-5e211f708a37">令人興奮的更新</a>，包括將 WebAssembly 編譯支援升級到 stable channel，改進 Impeller，以及預覽 Dart macros 的未來。</p>
<p>Flutter 3.24 和 Dart 3.5 發佈版本在我們幫助您製作出色的高效能應用程式（這些應用程式可以透過單個共用程式碼庫到達行動、網頁和桌面上的使用者）的使命之上。它們包括對新的 Flutter GPU API 的早期預覽，對網頁上元素嵌入的改進，以及幾個針對那些想要為 iOS 生態系統構建的開發人員的令人興奮的更新，包括對 Swift Package Manager 的早期支援，以及對 Cupertino Widgets 的功能更新。</p>
<p>讓我們開始吧！</p>
<h3 id="Impeller：為跨平台圖形效能樹立新標竿"><a href="#Impeller：為跨平台圖形效能樹立新標竿" class="headerlink" title="Impeller：為跨平台圖形效能樹立新標竿"></a>Impeller：為跨平台圖形效能樹立新標竿</h3><p>從歷史上看，跨平台框架需要在視覺效果上做出妥協，因為它們依賴於底層平台提供的更高級別的抽象。Flutter 採用了不同的方法，它擁有自己的渲染層，可以在每台設備上提供硬體加速的圖形和流暢的效能。我們在 <a href="https://docs.flutter.dev/perf/impeller">Impeller</a> 和 <a href="https://docs.flutter.dev/ui/design/graphics/fragment-shaders">著色器</a> 方面取得了重大進展，為圖形（如 3D）解鎖了令人興奮的新可能性。</p>
<p>我們很興奮地分享全新的 <a href="https://github.com/flutter/engine/blob/main/docs/impeller/Flutter-GPU.md">Flutter GPU API</a> 的早期預覽，這是一個功能強大、低階的圖形 API，直接整合到 Flutter SDK 中。API 允許您定義自訂柵格管道，並將繪製調用直接提交到 GPU，從而可以建立專用的渲染器，例如 2D Canvas 的替代方案、3D 場景圖，甚至用於創造視覺上令人驚豔、高效能和沉浸式體驗的粒子系統，而無需使用通常引擎級別需要的容量。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/796/0*QC1D0LdTgLynDOnV" />
<figcaption>3D animation of a sci-fi space helmet rendered in flutter_scene.</figcaption>
</figure>

<p>考慮到 API 的低階性，我們預計對於那些沒有大量圖形開發經驗的開發人員來說，會有一段學習曲線。這就是為什麼我們正在投資渲染套件，例如新的 <code>flutter_scene</code> 套件，它利用 Flutter GPU API 允許匯入動畫 glTF 模型並構造 3D 場景，使您能夠輕鬆地在 Flutter 和 Dart 中建立 3D 應用程式和遊戲，如下所示。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FY-DFVKPikVM%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DY-DFVKPikVM&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FY-DFVKPikVM%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/21e51abf698b844782de55d81e3cd7b4/href">https://medium.com/media/21e51abf698b844782de55d81e3cd7b4/href</a></iframe>

<p>儘管 Flutter GPU API 提供了令人興奮的可能性，但它仍然處於早期預覽階段，我們可能會對 API 進行重大變更。我們建議在使用 Flutter GPU 時針對 Flutter 的主頻道進行開發。在部落格文章 <a href="https://medium.com/flutter/getting-started-with-flutter-gpu-f33d497b7c11">Introducing Flutter GPU &amp; Flutter Scene</a> 中了解更多資訊。</p>
<h3 id="為-iOS-和-macOS-打造-Flutter：讓為-Apple-生態系統交付美麗、快速的應用程式變得更加容易"><a href="#為-iOS-和-macOS-打造-Flutter：讓為-Apple-生態系統交付美麗、快速的應用程式變得更加容易" class="headerlink" title="為 iOS 和 macOS 打造 Flutter：讓為 Apple 生態系統交付美麗、快速的應用程式變得更加容易"></a>為 iOS 和 macOS 打造 Flutter：讓為 Apple 生態系統交付美麗、快速的應用程式變得更加容易</h3><p>我們的目標是讓您能夠構建出色的應用程式，這些應用程式感覺起來像原生應用程式，並能完美地執行。這項工作的一部分是優化效能，以及最大限度地提高 Flutter 與底層平台的相容性，包括存取 Apple 生態系統的全部功能。</p>
<p>在此版本中，我們引入了對 Swift Package Manager 的早期支援，解鎖了對蓬勃發展的 Swift 套件生態系統的存取，並使 Flutter 外掛能夠利用大量預先構建的功能來加速開發。一旦 Swift Package Manager (SPM) 被 Plugin 開發人員廣泛採用，它應該會簡化 Flutter 安裝過程本身，並降低新手的入門門檻，特別是那些不熟悉 iOS 生態系統的人。我們鼓勵 Plugin 作者 <a href="https://docs.flutter.dev/packages-and-plugins/swift-package-manager/for-plugin-authors#how-to-add-swift-package-manager-support-to-an-existing-flutter-plugin">嘗試將 SPM 支援添加到您的外掛中</a>，並提供您體驗的 <a href="https://github.com/flutter/flutter/issues">回饋</a>。</p>
<p>接下來，我們希望讓您始終能夠滿足設計師的要求，並在 iOS 上提供高保真度的體驗。為了實現這一點，我們開始著手現代化和擴展 Cupertino Widget，解決了 <a href="https://github.com/flutter/flutter/issues?q=is:issue+is:closed+label:%22f:+cupertino%22+sort:updated-desc+closed:2024-04-01..2024-07-01+">Cupertino 中的 15 個問題</a>，並在 <a href="https://docs.flutter.dev/ui/widgets/cupertino">Widget 目錄</a> 中加入了 37 個缺少的 Cupertino Widget。</p>
<p>最後，我們為 Flutter macOS 應用程式添加了 <a href="https://docs.flutter.dev/platform-integration/macos/platform-views"><code>platform_view</code></a> 和 <a href="https://docs.flutter.dev/platform-integration/web/web-content-in-flutter">webview</a> 支援，允許將原生 macOS UI 組件無縫整合到您的 Flutter 應用程式中，以提供更完整、更完善的使用者體驗。</p>
<p>展望未來，我們很興奮能更多地投資於其他 Cupertino Widget 的保真度，與我們的生態系統一起推出 Swift Package Manager，並提供其他調查，讓整合和與 Apple 平台的互操作變得更加容易。</p>
<h3 id="強調充滿活力的-Flutter-社群的全球影響力"><a href="#強調充滿活力的-Flutter-社群的全球影響力" class="headerlink" title="強調充滿活力的 Flutter 社群的全球影響力"></a>強調充滿活力的 Flutter 社群的全球影響力</h3><p>我們還想感謝社群的貢獻，包括您的貢獻！這組版本包含來自 167 多位獨特貢獻者的近 1,500 次提交，其中包括 49 位 <em>全新</em> 貢獻者。我們深受 Flutter 社群持續的高水準活動、承諾和增長所鼓舞，包括積極構建框架的那些人。謝謝您！</p>
<p>我們共同努力的影響力正在世界各地展現出來，創造出數百萬人每天使用的令人難以置信的應用程式和體驗。例如，以下是 <a href="http://flutter.dev/showcase/xiaomi">案例研究</a> 的搶先看，展示了中國科技公司小米的團隊如何以及為什麼使用 Flutter 為該公司備受歡迎的新型電動汽車 <a href="https://www.mi.com/global/discover/article?id=3263&amp;ref=renatomitra.com">小米 SU7</a> 開發一個配套應用程式。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FwfD7ZQhwACU%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DwfD7ZQhwACU&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FwfD7ZQhwACU%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/1e141755d6ab1cd3b7962281efd5e6d3/href">https://medium.com/media/1e141755d6ab1cd3b7962281efd5e6d3/href</a></iframe>

<p>在世界各地出現的許多其他令人興奮的 Flutter 應用程式範例：</p>
<ul>
<li><a href="http://flutter.dev/showcase/sncf-connect">SNCF Connect</a>，法國鐵路和歐洲最大的 Flutter 應用程式（擁有超過 150 個螢幕）的擁有者，與奧運會合作為 Flutter 應用程式交付了許多更新，使數百萬遊客能夠在奧運會期間穿梭於法國各地。</li>
<li><a href="http://flutter.dev/showcase/wolt">Wolt</a>，DoorDash 國際的一部分，使用 Flutter 擴展到商家零售市場。</li>
<li><a href="http://flutter.dev/showcase/whirlpool">惠而浦</a>，一家擁有全球影響力的《財富》500 強公司，正在使用 Flutter 在巴西探索新的銷售管道。</li>
<li><a href="http://flutter.dev/showcase/monta">Monta</a>，一家丹麥的電動汽車充電生態系統初創公司，在短短 3 個月內使用 Flutter 將其第一個行動應用程式推向市場，後來又成功地將其 Web 應用程式移植到 Flutter。</li>
</ul>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>以上只是這些版本中 Flutter 和 Dart 的許多新功能和更新中的一小部分，您可以在 <a href="https://medium.com/p/6c040f87d1e4/edit">Flutter 3.24 技術部落格</a> 文章和 <a href="https://medium.com/dartlang/dart-3.5-6ca36259fa2f">Dart 3.5 部落格文章</a> 中了解更多資訊。</p>
<p>展望未來，我們對 Flutter 的未來充滿期待。我們仍然致力於我們的使命，並且感謝您——無論是貢獻者、社群成員還是 Flutter 開發人員——成為這段非凡旅程的一部分。我們迫不及待想看看您接下來會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=204b7d20c45d" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/flutter-3-24-dart-3-5-204b7d20c45d">宣布 Flutter 3.24 和 Dart 3.5</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/6243ded4.html" data-id="cm1kip5rn00001t1799ek49yl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Getting-started-with-Flutter-GPU" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/8ddf18fb.html" class="article-date">
  <time datetime="2024-08-06T18:02:39.000Z" itemprop="datePublished">2024-08-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Flutter/">Flutter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/8ddf18fb.html">【文章翻譯】Getting started with Flutter GPU</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="在-Flutter-中建立自訂渲染器和渲染-3D-場景"><a href="#在-Flutter-中建立自訂渲染器和渲染-3D-場景" class="headerlink" title="在 Flutter 中建立自訂渲染器和渲染 3D 場景"></a>在 Flutter 中建立自訂渲染器和渲染 3D 場景</h2><p>Flutter 3.24 版本推出了一個新的低階圖形 API，稱為 <a href="https://github.com/flutter/engine/blob/main/docs/impeller/Flutter-GPU.md">Flutter GPU</a>。還有一個由 Flutter GPU 提供支援的 3D 渲染函式庫，稱為 <a href="https://pub.dev/packages/flutter_scene">Flutter Scene</a>（套件：<code>flutter_scene</code>）。Flutter GPU 和 Flutter Scene 目前都處於預覽階段，僅在 Flutter 的 <a href="https://docs.flutter.dev/release/upgrade#other-channels">main channel</a> 上提供（因為依賴於實驗性功能），需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>，並且可能會偶爾推出重大變更。</p>
<p>本文包含這兩個套件的兩個「入門」指南：</p>
<ol>
<li>🔺 <strong>進階：</strong> <a href="#d558">開始使用 Flutter GPU</a><br>如果您是一位經驗豐富的圖形程式設計師，或者您對低階圖形感興趣，並想要從頭開始在 Flutter 中建立渲染器，那麼本指南將幫助您開始使用 Flutter GPU。您將從頭開始繪製第一個三角形……在 Flutter 中！</li>
<li>💚 <strong>中級：</strong> <a href="#6b35">使用 Flutter Scene 進行 3D 渲染</a><strong><br></strong>如果您是一位想要將 3D 功能加入到應用程式中的 Flutter 開發人員，或者您想要使用 Dart 和 Flutter 建立 3D 遊戲，那麼本指南適合您！您將設定一個專案，在 Flutter 中匯入並渲染 3D 資產。</li>
</ol>
<h3 id="開始使用-Flutter-GPU"><a href="#開始使用-Flutter-GPU" class="headerlink" title="開始使用 Flutter GPU"></a>開始使用 Flutter GPU</h3><p>⚠️ 警告！⚠️ Flutter GPU 最終是一個低階 API。絕大多數將從 Flutter GPU 的存在中受益的 Flutter 開發人員，很有可能透過使用在 pub.dev 上發佈的更高級別渲染函式庫來實現，例如 Flutter Scene 渲染套件。如果您對 Flutter GPU API 本身不感興趣，只對 3D 渲染感興趣，請跳轉到 <a href="#6b35">使用 Flutter Scene 進行 3D 渲染</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/900/0*hAqIOVkaI1IWnOHE" />
<figcaption>閃閃發光。這是一個射線行進符號距離場。您可以使用 Flutter GPU 渲染它，但也可以使用 [自訂片段著色器](https://docs.flutter.dev/ui/design/graphics/fragment-shaders) 來實現。</figcaption>
</figure>

<h3 id="開始使用-Flutter-GPU-1"><a href="#開始使用-Flutter-GPU-1" class="headerlink" title="開始使用 Flutter GPU"></a>開始使用 Flutter GPU</h3><p>Flutter GPU 是 Flutter 內建的低階圖形 API。它允許您透過撰寫 Dart 程式碼和 GLSL 著色器在 Flutter 中建立和整合自訂渲染器。無需原生平台程式碼。</p>
<p>目前，Flutter GPU 處於早期預覽階段，並提供基本的柵格化 API，但是隨著 API 接近穩定狀態，將繼續加入和改進更多功能。</p>
<p>Flutter GPU 還需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。這意味著它只能在 Impeller 支援的平台上使用。在撰寫本文時，Impeller 支援：</p>
<ul>
<li>iOS（預設啟用）</li>
<li>macOS（預覽版本選擇性開啟）</li>
<li>Android（預覽版本選擇性開啟）</li>
</ul>
<p>我們在 Flutter GPU 中的目標是最終支援所有 Flutter 的平台目標。最終目標是在 Flutter 中促進一個跨平台渲染解決方案的生態系統，這些方案對於套件作者來說易於維護，對於使用者來說易於安裝。</p>
<p>3D 渲染只是一個可能的使用案例。Flutter GPU 還可以被用來建立專用的 2D 渲染器，或者做一些更非正統的事情，例如渲染 4D 空間的 3D 切片，或投影非歐幾里得空間。</p>
<p>由 Flutter GPU 支援的自訂 2D 渲染器的一個很好的使用案例範例是依賴骨骼網格變形的 2D 角色動畫格式。Spine 2D 就是一個很好的範例。此類骨骼網格解決方案通常具有動畫片段，這些片段會操縱層級結構中骨骼的平移、旋轉和縮放屬性，並且每個頂點都有一些相關的「骨骼權重」，這些權重決定哪些骨骼應該影響頂點以及影響程度。</p>
<p>使用像 <code>drawVertices</code> 這樣的 Canvas 解決方案，需要在 CPU 上為每個頂點應用骨骼權重轉換。使用 Flutter GPU，骨骼轉換可以以統一陣列或甚至紋理採樣器的形式傳遞到頂點著色器，允許根據骨骼狀態和每個頂點骨骼權重在 GPU 上並行計算每個頂點的最終位置。</p>
<p>言歸正傳，讓我們透過一個溫和的介紹開始使用 Flutter GPU：繪製第一個三角形！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JEI3fLDGcRHWKruT" />
</figure>

<h3 id="將-Flutter-GPU-加入您的專案"><a href="#將-Flutter-GPU-加入您的專案" class="headerlink" title="將 Flutter GPU 加入您的專案"></a>將 Flutter GPU 加入您的專案</h3><p>首先，請注意 Flutter GPU 目前處於早期預覽狀態，可能會容易出現 API 故障。目前的 API 已經可以實現很多功能，但經驗豐富的圖形工程師可能會注意到一些缺少的常用功能。Flutter GPU 在接下來的幾個月中將會增加許多功能。</p>
<p>基於這些原因，強烈建議您在針對 Flutter GPU 開發套件時，目前使用 <a href="https://docs.flutter.dev/release/upgrade#other-channels">main channel</a> 的最新版本進行操作。如果您遇到任何意外行為、錯誤或有功能請求，請使用標準的 <a href="https://github.com/flutter/flutter/issues/new/choose">Flutter 議題範本</a> 在 GitHub 上提交議題。與 Flutter GPU 相關的所有追蹤議題都被貼上了 <a href="https://github.com/flutter/flutter/labels/flutter-gpu">flutter-gpu 標籤</a>。</p>
<p>因此，在嘗試使用 Flutter GPU 之前，請透過執行以下命令將 Flutter 切換到 main channel。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>現在建立一個新的 Flutter 專案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_cool_renderer</span><br><span class="line">cd my_cool_renderer</span><br></pre></td></tr></table></figure>

<p>接下來，將 flutter_gpu SDK 套件加入到您的 pubspec 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu --sdk=flutter</span><br></pre></td></tr></table></figure>

<h3 id="建立和匯入著色器組合包。"><a href="#建立和匯入著色器組合包。" class="headerlink" title="建立和匯入著色器組合包。"></a>建立和匯入著色器組合包。</h3><p>為了使用 Flutter GPU 渲染任何內容，您需要撰寫一些 GLSL 著色器。Flutter GPU 的著色器與 Flutter 的 <a href="https://docs.flutter.dev/ui/design/graphics/fragment-shaders">片段著色器</a> 功能使用的著色器具有不同的語義，特別是在統一綁定方面。您還將定義一個頂點著色器來與片段著色器一起使用。</p>
<p>從定義最簡單的著色器開始。您可以將著色器放置在專案中的任何位置，但在此範例中，建立一個 <code>shaders</code> 目錄，並用兩個著色器填充它：<code>simple.vert</code> 和 <code>simple.frag</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：shaders/simple.vert</span><br><span class="line"></span><br><span class="line">in vec2 position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> gl_Position = vec4(position, 0.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在繪製三角形時，您將擁有一個定義每個頂點的資料列表。在本例中，它僅列出 2D 位置。對於這些頂點中的每一個，一個簡單的頂點著色器將這些 2D 位置分配給剪輯空間輸出內在 <code>gl_Position</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：shaders/simple.frag</span><br><span class="line"></span><br><span class="line">out vec4 frag_color;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> frag_color = vec4(0, 1, 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段著色器更簡單；它輸出一個 RGBA 顏色，範圍為 (0, 0, 0, 0) 到 (1, 1, 1, 1)。因此，所有內容都將被渲染為綠色。</p>
<p>好的，現在您已經有了著色器，請使用 Flutter 的預先編譯 (AOT) 著色器編譯器編譯它們。若要設定著色器組合包的自動建立，我們建議您使用 <a href="https://pub.dev/packages/flutter_gpu_shaders">flutter_gpu_shaders</a> 套件。</p>
<p>使用 pub 將 flutter_gpu_shaders 作為專案中的普通相依加入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu_shaders</span><br></pre></td></tr></table></figure>

<p>Flutter GPU 著色器被組合到 <code>.shaderbundle</code> 檔案中，這些檔案可以作為普通資產加入到專案的資產組合包中。著色器組合包包含針對平台目標編譯的著色器原始碼。</p>
<p>接下來，建立一個著色器組合包清單檔案，以描述著色器組合包的內容。將以下內容加入到專案根目錄中的 <code>my_renderer.shaderbundle.json</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;SimpleVertex&quot;: &#123;</span><br><span class="line"> &quot;type&quot;: &quot;vertex&quot;,</span><br><span class="line"> &quot;file&quot;: &quot;shaders/simple.vert&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> &quot;SimpleFragment&quot;: &#123;</span><br><span class="line"> &quot;type&quot;: &quot;fragment&quot;,</span><br><span class="line"> &quot;file&quot;: &quot;shaders/simple.frag&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>著色器組合包中的每個條目都可以具有任意的名稱。就這個例子來說，名稱為「SimpleVertex」和「SimpleFragment」。這些名稱用於在您的應用程式中查找著色器。</p>
<p>接下來，使用 <code>flutter_gpu_shaders</code> 套件建立 shaderbundle。您可以透過啟用實驗性的「原生資產」功能來加入一個自動觸發建立的鉤子。使用以下命令來啟用原生資產並安裝 <code>native_assets_cli</code> 套件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>

<p>在啟用原生資產功能後，在 <code>hook</code> 目錄下加入一個 <code>build.dart</code> 腳本，該腳本將自動觸發建立著色器組合包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：hook/build.dart</span><br><span class="line"></span><br><span class="line">import &#x27;package:native_assets_cli/native_assets_cli.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_gpu_shaders/build.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) async &#123;</span><br><span class="line"> await build(args, (config, output) async &#123;</span><br><span class="line"> await buildShaderBundleJson(</span><br><span class="line"> buildConfig: config,</span><br><span class="line"> buildOutput: output,</span><br><span class="line"> manifestFileName: &#x27;my_renderer.shaderbundle.json&#x27;);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>進行此更改後，當 Flutter 工具建立專案時，<code>buildShaderBundleJson</code> 將建立著色器組合包，並將結果輸出到套件根目錄下的 <code>build/shaderbundles/my_renderer.shaderbundle</code>。</p>
<p>著色器組合包格式本身與您使用的 Flutter 特定版本相關聯，並且可能會隨著時間推移而發生變化。如果您正在編寫建立著色器組合包的套件，請不要將產生的 <code>.shaderbundle</code> 檔案檢查到您的原始碼樹中。相反，請使用建立鉤子來自動化建立過程（如前所述）。</p>
<p>透過這種方式，使用您函式庫的開發人員將始終使用正確格式建立新的著色器組合包！</p>
<p>現在您已經自動建立了著色器組合包，請像普通資產一樣匯入它。將一個資產條目加入到專案的 <code>pubspec.yaml</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"> assets:</span><br><span class="line"> - build/shaderbundles/</span><br></pre></td></tr></table></figure>

<p>未來，原生資產功能將允許建立鉤子將資料資產附加到組合包中。一旦發生這種情況，將不再需要在建立鉤子旁邊加入資產匯入規則。</p>
<p>接下來，加入一些程式碼以在執行時期時載入著色器。建立 <code>lib/shaders.dart</code> 並加入以下程式碼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：lib/shaders.dart</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter_gpu/gpu.dart&#x27; as gpu;</span><br><span class="line"></span><br><span class="line">const String _kShaderBundlePath =</span><br><span class="line"> &#x27;build/shaderbundles/my_renderer.shaderbundle&#x27;;</span><br><span class="line">// NOTE: 如果您正在建立一個函式庫，路徑必須以套件名稱為前綴</span><br><span class="line">// 例如：</span><br><span class="line">// &#x27;packages/my_cool_renderer/build/shaderbundles/my_renderer.shaderbundle&#x27;</span><br><span class="line"></span><br><span class="line">gpu.ShaderLibrary? _shaderLibrary;</span><br><span class="line">gpu.ShaderLibrary get shaderLibrary &#123;</span><br><span class="line"> if (_shaderLibrary != null) &#123;</span><br><span class="line"> return _shaderLibrary!;</span><br><span class="line"> &#125;</span><br><span class="line"> _shaderLibrary = gpu.ShaderLibrary.fromAsset(_kShaderBundlePath);</span><br><span class="line"> if (_shaderLibrary != null) &#123;</span><br><span class="line"> return _shaderLibrary!;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> throw Exception(&quot;Failed to load shader bundle! ($_kShaderBundlePath)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼為 Flutter GPU 著色器執行時期時函式庫建立了一個單例 getter。第一次存取 <code>shaderLibrary</code> 時，將使用 <code>gpu.ShaderLibrary.fromAsset(shader_bundle_path)</code> 使用已建立的資產組合包初始化執行時期著色器函式庫。</p>
<p>現在專案已經設定好可以使用 Flutter GPU 著色器了。是時候渲染那個三角形了！</p>
<h3 id="繪製第一個三角形"><a href="#繪製第一個三角形" class="headerlink" title="繪製第一個三角形"></a>繪製第一個三角形</h3><p>在本指南中，您將建立一個 RGBA Flutter GPU <code>Texture</code> 和一個將紋理作為顏色輸出附加的 <code>RenderPass</code>。然後，您將使用 <a href="https://api.flutter.dev/flutter/dart-ui/Canvas/drawImage.html"><code>Canvas.drawImage</code></a> 在一個 Widget 中渲染紋理。</p>
<p>為了簡潔起見，您將放棄最佳實務，只是在每個畫面中重新建立所有資源。</p>
<p>只要在配置時將您的 <code>Texture</code> 標記為「著色器可讀」，您就可以將其轉換為 <code>dart:ui.Image</code>。若要在 Widget 樹中顯示渲染結果，請將其繪製到 <code>dart:ui.Canvas</code> 上！</p>
<p>您可以透過使用自訂繪製器來為 Widget 樹搭建腳手架來存取 <code>Canvas</code>。將 <code>lib/main.dart</code> 的替換為以下內容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:typed_data&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_gpu/gpu.dart&#x27; as gpu;</span><br><span class="line"></span><br><span class="line">// 注意: 我們之前在設定著色器組合包匯入時已經建立了這個！</span><br><span class="line">import &#x27;shaders.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line"> const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line"> return MaterialApp(</span><br><span class="line"> title: &#x27;Flutter GPU Triangle Example&#x27;,</span><br><span class="line"> home: CustomPaint(</span><br><span class="line"> painter: TrianglePainter(),</span><br><span class="line"> ),</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrianglePainter extends CustomPainter &#123;</span><br><span class="line"> @override</span><br><span class="line"> void paint(Canvas canvas, Size size) &#123;</span><br><span class="line"> // 嘗試存取 `gpu.gpuContext`。</span><br><span class="line"> // 如果 Flutter GPU 不受支援，將會拋出例外。</span><br><span class="line"> print(&#x27;Default color format: &#x27; +</span><br><span class="line"> gpu.gpuContext.defaultColorFormat.toString());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在執行應用程式。提醒一下，Flutter GPU 目前需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。因此，您必須使用 Impeller 支援的平台。對於本指南，我將以 macOS 為目標。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*lKTtaX2ih6dFpSMQ" />
</figure>

<p>如果 Flutter GPU 正在工作，那麼您應該看到預設顏色格式列印到主控台中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter: Default color format: PixelFormat.b8g8r8a8UNormInt</span><br></pre></td></tr></table></figure>

<p>如果 Impeller 未啟用，則在嘗試存取 <code>gpu.gpuContext</code> 時會拋出例外。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception: Flutter GPU requires the Impeller rendering backend to be enabled.</span><br><span class="line"></span><br><span class="line">The relevant error-causing widget was:</span><br><span class="line"> CustomPaint</span><br></pre></td></tr></table></figure>

<p>為了簡潔起見，您只會從這裡開始修改 <code>paint</code> 方法。</p>
<p>首先，建立一個 Flutter GPU <code>Texture</code>，清除它，然後透過將其繪製到 <code>Canvas</code> 上來顯示它。</p>
<p>建立一個與 <code>Canvas</code> 大小相同的 <code>Texture</code>。必須選擇一個 <code>StorageMode</code>。在本例中，您將 <code>Texture</code> 標記為 <code>devicePrivate</code>，因為您只會使用從裝置	（GPU）存取紋理記憶體的指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final texture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate,</span><br><span class="line"> size.width.toInt(), size.height.toInt())!;</span><br></pre></td></tr></table></figure>

<p>如果透過從主機（CPU）上傳來覆寫紋理的資料，則使用 <code>StorageMode.hostVisible</code>。</p>
<p>第三個可用的選項是 <code>StorageMode.deviceTransient</code>，它對於不需要超過單個 <code>RenderPass</code> 生命週期的附件很有用（因此它們可以只存在於磁磚記憶體中，而不需要由 VRAM 分配支援）。通常，深度&#x2F;模板紋理符合此條件。</p>
<p>接下來，定義一個 <code>RenderTarget</code>。渲染目標包含一個「附件」集合，這些附件描述每個片段的記憶體佈局及其在 <code>RenderPass</code> 開始和結束時的設定&#x2F;拆卸行為。</p>
<p>本質上，<code>RenderTarget</code> 是 <code>RenderPass</code> 的一個可重複使用的描述符。</p>
<p>現在，定義一個只包含一個顏色附件的非常簡單的 <code>RenderTarget</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final renderTarget = gpu.RenderTarget.singleColor(</span><br><span class="line"> gpu.ColorAttachment(texture: texture, clearValue: Colors.lightBlue));</span><br></pre></td></tr></table></figure>

<p>請注意，此程式碼將 <code>clearValue</code> 設定為淡藍色。每個附件都有一個 <code>LoadAction</code> 和一個 <code>StoreAction</code>，它們分別確定在傳遞開始和結束時應該對附件的瞬時磁磚記憶體執行什麼操作。</p>
<p>預設情況下，顏色附件被設定為 <code>LoadAction.clear</code>（它會將磁磚記憶體初始化為給定的顏色），以及 <code>StoreAction.store</code>（它會將結果保存到附加紋理的 VRAM 分配中）。</p>
<p>現在，建立一個 <code>CommandBuffer</code>，從中使用之前建立的 <code>RenderTarget</code> 產生一個 <code>RenderPass</code>，然後立即提交 <code>CommandBuffer</code> 以清除紋理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final commandBuffer = gpu.gpuContext.createCommandBuffer();</span><br><span class="line">final renderPass = commandBuffer.createRenderPass(renderTarget);</span><br><span class="line">// ... 繪製呼叫將放在這裡！</span><br><span class="line">commandBuffer.submit();</span><br></pre></td></tr></table></figure>

<p>剩下的就是將已初始化的紋理繪製到 Canvas 上！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final image = texture.asImage();</span><br><span class="line">canvas.drawImage(image, Offset.zero, Paint());</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ebUDtzQOuIGmdlop" />
</figure>

<p>現在您已經建立了一個連接到螢幕上顯示結果的 <code>RenderPass</code>，您就可以開始繪製三角形了。若要執行此操作，請設定以下內容：</p>
<ol>
<li>從我們的著色器建立的 <code>RenderPipeline</code>，以及</li>
<li>包含我們幾何形狀的 GPU 可存取緩衝區（三個頂點位置）。</li>
</ol>
<p>建立 <code>RenderPipeline</code> 很容易。您只需要將函式庫中的頂點和片段著色器組合在一起。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final vert = shaderLibrary[&#x27;SimpleVertex&#x27;]!;</span><br><span class="line">final frag = shaderLibrary[&#x27;SimpleFragment&#x27;]!;</span><br><span class="line">final pipeline = gpu.gpuContext.createRenderPipeline(vert, frag);</span><br></pre></td></tr></table></figure>

<p>現在是幾何形狀。回想一下，「SimpleVertex」著色器只有一個輸入：<code>in vec2 position</code>。因此，若要繪製三個頂點，您需要三組兩個浮點數。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final vertices = Float32List.fromList([</span><br><span class="line"> -0.5, -0.5, // 第一個頂點</span><br><span class="line"> 0.5, -0.5, // 第二個頂點</span><br><span class="line"> 0.0, 0.5, // 第三個頂點</span><br><span class="line">]);</span><br><span class="line">final verticesDeviceBuffer = gpu.gpuContext</span><br><span class="line"> .createDeviceBufferWithCopy(ByteData.sublistView(vertices))!;</span><br></pre></td></tr></table></figure>

<p>剩下的就是綁定新的資源並呼叫 <code>renderPass.draw()</code> 來完成記錄繪製呼叫。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renderPass.bindPipeline(pipeline);</span><br><span class="line"></span><br><span class="line">final verticesView = gpu.BufferView(</span><br><span class="line"> verticesDeviceBuffer,</span><br><span class="line"> offsetInBytes: 0,</span><br><span class="line"> lengthInBytes: verticesDeviceBuffer.sizeInBytes,</span><br><span class="line">);</span><br><span class="line">renderPass.bindVertexBuffer(verticesView, 3);</span><br><span class="line"></span><br><span class="line">renderPass.draw();</span><br></pre></td></tr></table></figure>

<p>如果您啟動應用程式，您現在應該看到一個綠色的三角形！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LWnGU5WPT_Eom0wJ" />
</figure>

<p>太棒了，您使用 Flutter、Dart 和一些 GLSL 從頭開始建立了一個渲染器！</p>
<p>無論這是您第一次渲染三角形，還是您是一位經驗豐富的圖形專家，我希望您能繼續使用 Flutter GPU，並查看我們正在開發的套件，例如 Flutter Scene。</p>
<p>未來，我們希望發佈友好的初學者程式碼實驗室，深入探討 Flutter GPU 的預設行為和最佳實務。我們還沒有討論頂點屬性佈局、紋理綁定、統一和對齊需求、管道混合、深度和模板附件、透視校正等等！</p>
<p>在此之前，我建議您探索 <a href="https://github.com/bdero/flutter_scene">Flutter Scene</a>，作為如何使用 Flutter GPU 的更全面的範例。</p>
<h3 id="使用-Flutter-Scene-進行-3D-渲染"><a href="#使用-Flutter-Scene-進行-3D-渲染" class="headerlink" title="使用 Flutter Scene 進行 3D 渲染"></a>使用 Flutter Scene 進行 3D 渲染</h3><p>Flutter Scene（套件 flutter_scene）是一個新的由 Flutter GPU 提供支援的 3D 場景圖套件，它使 Flutter 開發人員能夠匯入動畫 glTF 模型並渲染即時 3D 場景。</p>
<p>其目的是提供一個套件，讓使用 Flutter 建立互動式 3D 應用程式和遊戲變得容易。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tC68CbPLef2rJp1e" />
</figure>

<p>該套件最初是一個為用 C++ 編寫的 3D 渲染器編寫的 <code>dart:ui</code> 擴展，並直接建立在 Flutter 的原生執行時中，但它已針對 Flutter GPU 重新編寫，具有更靈活的介面。</p>
<p>與 Flutter GPU API 本身一樣，Flutter Scene 目前處於早期預覽狀態，需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。Flutter Scene 通常會跟上 Flutter GPU API 的重大變更，因此強烈建議您在嘗試使用 Flutter Scene 時使用 <a href="https://docs.flutter.dev/release/upgrade#other-channels">main channel</a>。</p>
<p>接下來，使用 Flutter Scene 建立一個應用程式！</p>
<h3 id="設定-Flutter-Scene-專案"><a href="#設定-Flutter-Scene-專案" class="headerlink" title="設定 Flutter Scene 專案"></a>設定 Flutter Scene 專案</h3><p>由於強烈建議您在 <a href="https://docs.flutter.dev/release/upgrade#other-channels">main channel</a> 上使用 Flutter Scene，因此請從切換到它開始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>接下來，建立一個新的 Flutter 專案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_3d_app</span><br><span class="line">cd my_3d_app</span><br></pre></td></tr></table></figure>

<p>Flutter Scene 依賴於實驗性的「原生資產」功能，以自動建立著色器。您將在稍後使用原生資產來設定 Flutter Scene 的 3D 模型自動匯入。</p>
<p>使用以下命令啟用原生資產。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br></pre></td></tr></table></figure>

<p>最後，將 Flutter Scene 作為專案相依性加入。</p>
<p>您還需要在與 Flutter Scene 的 API 互動時使用幾個 <code>vector_math</code> 構造，因此也要加入 <code>vector_math</code> 套件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene vector_math</span><br></pre></td></tr></table></figure>

<p>接下來，匯入一個 3D 模型！</p>
<h3 id="匯入-3D-模型"><a href="#匯入-3D-模型" class="headerlink" title="匯入 3D 模型"></a>匯入 3D 模型</h3><p>首先，您需要一個要渲染的 3D 模型。在本指南中，您將使用一個通用的 <a href="https://en.wikipedia.org/wiki/GlTF">glTF</a> 範例資產：<a href="https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/DamagedHelmet">DamagedHelmet.glb</a>。它看起來像這樣。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/912/0*vVWRLxJ348tCxv7T" />
<figcaption>最初的 Damaged Helmet 模型是由 theblueturtle_ 於 2016 年建立的（許可證：[CC BY-NC 4.0 國際](https://creativecommons.org/licenses/by-nc/4.0/legalcode)）。轉換的 glTF 版本是由 ctxwing 於 2018 年建立的（許可證：[CC BY 4.0 國際](https://creativecommons.org/licenses/by/4.0/legalcode)）。</figcaption>
</figure>

<p>您可以從託管在 GitHub 上的 <a href="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/DamagedHelmet/glTF-Binary/DamagedHelmet.glb">glTF 範例資產儲存庫</a> 中獲得它。將 <code>DamagedHelmet.glb</code> 放置在您的專案根目錄中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/main/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb</span><br></pre></td></tr></table></figure>

<p>與大多數即時 3D 渲染器一樣，Flutter Scene 在內部使用一種專用的 3D 模型格式。您可以使用 Flutter Scene 的離線匯入器工具將標準 glTF 二進位檔案（<code>.glb</code> 檔案）轉換為這種格式。</p>
<p>將 flutter_scene_importer 套件作為普通相依性加入到專案中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene_importer</span><br></pre></td></tr></table></figure>

<p>加入此套件使您可以透過 <code>dart run</code> 手動呼叫匯入器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dart --enable-experiment=native-assets \</span><br><span class="line"> run flutter_scene_importer:import \</span><br><span class="line"> --input &quot;path/to/my/source_model.glb&quot; \</span><br><span class="line"> --output &quot;path/to/my/imported_model.model&quot;</span><br></pre></td></tr></table></figure>

<p>您可以透過使用原生資產建立鉤子來自動執行匯入器。若要執行此操作，首先將 <code>native_assets_cli</code> 作為普通專案相依性安裝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>

<p>現在您可以撰寫建立鉤子了。使用以下內容建立 <code>hook/build.dart</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:native_assets_cli/native_assets_cli.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene_importer/build_hooks.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) &#123;</span><br><span class="line"> build(args, (config, output) async &#123;</span><br><span class="line"> buildModels(buildConfig: config, inputFilePaths: [</span><br><span class="line"> &#x27;DamagedHelmet.glb&#x27;,</span><br><span class="line"> ]);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用來自 <code>flutter_scene_importer</code> 的 <code>buildModels</code> 公用程式，提供要建立的模型列表。路徑相對於專案的建立根目錄。</p>
<p>當 Flutter 工具建立專案時，<code>buildModels</code> 現在將建立著色器組合包，並將結果輸出到套件根目錄下的 <code>build/models/DamagedModel.model</code>。</p>
<p>匯入的模型格式本身與您使用的 Flutter Scene 特定版本相關聯，並且會隨著時間推移而發生變化。在編寫使用 Flutter Scene 的應用程式或函式庫時，請勿將產生的 <code>.model</code> 檔案檢查到您的原始碼樹中。相反，請使用建立鉤子從您的原始模型產生它們（如前所述）。</p>
<p>透過這種方式，隨著時間推移，您升級 Flutter Scene 時，將始終使用正確格式建立新的 <code>.model</code> 檔案！</p>
<p>接下來，像普通資產一樣匯入模型。將一個資產條目加入到專案的 <code>pubspec.yaml</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"> assets:</span><br><span class="line"> - build/models/</span><br></pre></td></tr></table></figure>

<p>未來，原生資產功能將允許建立鉤子將資料資產附加到組合包中。一旦發生這種情況，將不再需要在建立鉤子旁邊加入資產匯入規則。</p>
<h3 id="渲染-3D-場景"><a href="#渲染-3D-場景" class="headerlink" title="渲染 3D 場景"></a>渲染 3D 場景</h3><p>現在是應用程式的程式碼了。</p>
<p>首先，建立一個有狀態的 Widget，以在畫面之間持久保存場景。</p>
<p>您將根據時間進行動畫，因此請將 <code>SingleTickerProviderStateMixin</code> 加入到狀態中，以及一個 <code>elapsedSeconds</code> 成員。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter/scheduler.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/camera.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/node.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/scene.dart&#x27;;</span><br><span class="line">import &#x27;package:vector_math/vector_math.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget&#123;</span><br><span class="line"> const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> MyAppState createState() =&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line"> double elapsedSeconds = 0;</span><br><span class="line"> Scene scene = Scene();</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line"> return MaterialApp(</span><br><span class="line"> title: &#x27;My 3D app&#x27;,</span><br><span class="line"> home: Placeholder(),</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行應用程式作為 smoke test，以確保沒有錯誤。請記住 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/912/0*74qs6ytcTjyVHwML" />
</figure>

<p>在繼續之前，請為動畫設定計時器。覆寫 <code>MyAppState</code> 中的 <code>initState</code> 以呼叫 <code>createTicker</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">createTicker((elapsed) &#123;</span><br><span class="line">setState(() &#123;</span><br><span class="line">elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要 Widget 可見，就會在每個畫面中呼叫計時器回呼。呼叫 <code>setState</code> 會導致此 Widget 在每個畫面中重新建立。</p>
<p>接下來，載入您之前放置在專案中的 3D 模型，並將其加入到場景中。</p>
<p>使用 <code>Node.fromAsset</code> 從資產組合包中載入模型。將以下程式碼放置在 <code>initState</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">model.name = &#x27;Helmet&#x27;;</span><br><span class="line">scene.add(model);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>Node.fromAsset</code> 會非同步地從資產組合包中反序列化模型，並在它準備好被加入到場景中時解析回傳的 <code>Future&lt;Node&gt;</code>。</p>
<p>現在 <code>MyAppState.initState</code> 應如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">createTicker((elapsed) &#123;</span><br><span class="line">setState(() &#123;</span><br><span class="line">elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">model.name = &#x27;Helmet&#x27;;</span><br><span class="line">scene.add(model);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，您仍然沒有真正渲染 3D 場景！若要執行此操作，請使用 <code>Scene.render</code>，它會接收一個 UI <code>Canvas</code>、一個 Flutter Scene <code>Camera</code> 和一個大小。</p>
<p>存取 Canvas 的一種方法是建立一個 <code>CustomPainter</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line"> ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line"> Scene scene;</span><br><span class="line"> Camera camera;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> void paint(Canvas canvas, Size size) &#123;</span><br><span class="line"> scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘記將 <code>shouldRepaint</code> 覆寫設定為回傳 <code>true</code>，這樣自訂繪製器就會在每次重建時重新繪製。</p>
<p>最後，將自訂繪製器加入到原始樹中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">final painter = ScenePainter(</span><br><span class="line">scene: scene,</span><br><span class="line">camera: PerspectiveCamera(</span><br><span class="line">position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line">target: Vector3(0, 0, 0),</span><br><span class="line">),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">return MaterialApp(</span><br><span class="line">title: &#x27;My 3D app&#x27;,</span><br><span class="line">home: CustomPaint(painter: painter),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼指示相機以連續的圓圈移動，但始終面向原點。</p>
<p>最後，啟動應用程式！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/796/0*_-OFc0vhBHAhrPrO" />
</figure>

<p>這是我們匯集的完整原始碼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/camera.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/node.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/scene.dart&#x27;;</span><br><span class="line">import &#x27;package:vector_math/vector_math.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget &#123;</span><br><span class="line"> const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> MyAppState createState() =&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line"> double elapsedSeconds = 0;</span><br><span class="line"> Scene scene = Scene();</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> void initState() &#123;</span><br><span class="line"> createTicker((elapsed) &#123;</span><br><span class="line"> setState(() &#123;</span><br><span class="line"> elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;).start();</span><br><span class="line"></span><br><span class="line"> Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line"> model.name = &#x27;Helmet&#x27;;</span><br><span class="line"> scene.add(model);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> super.initState();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line"> final painter = ScenePainter(</span><br><span class="line"> scene: scene,</span><br><span class="line"> camera: PerspectiveCamera(</span><br><span class="line"> position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line"> target: Vector3(0, 0, 0),</span><br><span class="line"> ),</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"> return MaterialApp(</span><br><span class="line"> title: &#x27;My 3D app&#x27;,</span><br><span class="line"> home: CustomPaint(painter: painter),</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line"> ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line"> Scene scene;</span><br><span class="line"> Camera camera;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> void paint(Canvas canvas, Size size) &#123;</span><br><span class="line"> scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Flutter-的輝煌未來"><a href="#Flutter-的輝煌未來" class="headerlink" title="Flutter 的輝煌未來"></a>Flutter 的輝煌未來</h3><p>如果您能夠成功遵循這些指南之一並讓某樣東西執行起來：太棒了，恭喜您！</p>
<p>Flutter GPU 和 Flutter Scene 都非常年輕，平台支援有限。但我認為總有一天我們會懷念這些不起眼的開端。</p>
<p>透過 Impeller 的努力，Flutter 團隊完全掌控了渲染堆疊，因為我們需要將渲染器專門用於 Flutter 的使用案例。而現在，我們正在開啟 Flutter 歷史的新篇章。一個由您共同掌控渲染的篇章！</p>
<p>Flutter Scene 最初是 Impeller 中的一個 C++ 元件，與 2D Canvas 渲染器以及一個精簡的 <code>dart:ui</code> 擴展一起。在我建立它時，我已經意識到 Flutter Engine 不會是它的最終目的地。</p>
<p>3D 渲染器體系結構決策的海洋浩瀚無垠，沒有哪一種通用的 3D 渲染器能夠很好地解決所有使用案例。「通用」和「高效能」通常是相互矛盾的目標。</p>
<p>充其量，樣樣精通只不過是樣樣不精。</p>
<p>在渲染效能的世界中，情況更糟。專門用於一個使用案例通常意味著降低另一個使用案例的效能。</p>
<p>簡而言之，不可能發佈一個可以解決所有使用案例的通用 3D 渲染器。但通過呈現構建您自己解決方案所需的低階 API（Flutter GPU）並在它之上構建一個有用的通用 3D 渲染器（Flutter Scene），使其易於 Flutter 社群檢查和修改，我們正在為 Flutter 開發人員創造一個空間，讓他們可以享受低淘汰風險和高回報。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/506/1*jfeUgpEP9AgAz94yVxVW1g.gif" />
</figure>

<p>我迫不及待地想看看您將使用這些新功能創作出什麼。敬請期待 Flutter Scene 的未來版本。有很多新功能即將推出。</p>
<p>在此同時，我要回到工作崗位上。</p>
<p>很快見。:)</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f33d497b7c11" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/getting-started-with-flutter-gpu-f33d497b7c11">Flutter GPU 入門指南</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/8ddf18fb.html" data-id="cm1khy3qe0000yo171ysg7laz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GPU/" rel="tag">GPU</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2024-08-06T18:02:39.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/807a2f46.html" class="article-date">
  <time datetime="2024-08-06T10:02:39.000Z" itemprop="datePublished">2024-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/807a2f46.html">【文章翻譯】Getting started with Flutter GPU</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="在-Flutter-中建立自訂渲染器並渲染-3D-場景。"><a href="#在-Flutter-中建立自訂渲染器並渲染-3D-場景。" class="headerlink" title="在 Flutter 中建立自訂渲染器並渲染 3D 場景。"></a>在 Flutter 中建立自訂渲染器並渲染 3D 場景。</h2><p>Flutter 3.24 版本引進了一個新的低階圖形 API，稱為 <a href="https://github.com/flutter/engine/blob/main/docs/impeller/Flutter-GPU.md">Flutter GPU</a>。還有一個由 Flutter GPU 支援的 3D 渲染函式庫，稱為 <a href="https://pub.dev/packages/flutter_scene">Flutter Scene</a>（套件：flutter_scene）。Flutter GPU 和 Flutter Scene 目前都處於預覽階段，僅在 Flutter 的 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a> 上可用（由於依賴實驗性功能），需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>，並且可能偶爾會引入重大變更。</p>
<p>本文包含這兩個套件的兩個「入門」指南：</p>
<ol>
<li>🔺 <strong>進階：</strong><a href="#d558">使用 Flutter GPU 入門</a><br>如果您是經驗豐富的圖形程式設計師，或者您對低階圖形感興趣，並想在 Flutter 中從頭開始建立渲染器，那麼本指南將幫助您開始使用 Flutter GPU。您將從頭開始繪製第一個三角形… 在 Flutter 中！</li>
<li>💚 <strong>中級：</strong><a href="#6b35">使用 Flutter Scene 進行 3D 渲染</a><br>如果您是想要將 3D 功能添加到應用程式中的 Flutter 開發人員，或者您想要使用 Dart 和 Flutter 建立 3D 遊戲，那麼本指南適合您！您將設定一個專案，在 Flutter 中匯入和渲染 3D 資產。</li>
</ol>
<h3 id="使用-Flutter-GPU-入門"><a href="#使用-Flutter-GPU-入門" class="headerlink" title="使用 Flutter GPU 入門"></a>使用 Flutter GPU 入門</h3><p>⚠️ 警告！⚠️ Flutter GPU 最終是一個低階 API。絕大多數將從 Flutter GPU 的存在中受益的 Flutter 開發人員很可能會透過使用在 pub.dev 上發佈的更高階渲染函式庫來做到這一點，例如 Flutter Scene 渲染套件。如果您對 Flutter GPU API 本身不感興趣，而只是對 3D 渲染感興趣，請跳到 <a href="#6b35">使用 Flutter Scene 進行 3D 渲染</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/900/0*hAqIOVkaI1IWnOHE" />
<figcaption>哦，真閃亮。這是一個射線行進的符號距離場。您可以使用 Flutter GPU 渲染它，但使用 [自訂片段著色器](https://docs.flutter.dev/ui/design/graphics/fragment-shaders) 也完全有可能。 </figcaption>
</figure>

<h3 id="使用-Flutter-GPU-入門-1"><a href="#使用-Flutter-GPU-入門-1" class="headerlink" title="使用 Flutter GPU 入門"></a>使用 Flutter GPU 入門</h3><p>Flutter GPU 是 Flutter 內建的低階圖形 API。它允許您透過撰寫 Dart 程式碼和 GLSL 著色器在 Flutter 中建立和整合自訂渲染器。不需要原生平台程式碼。</p>
<p>目前，Flutter GPU 處於早期預覽階段，並提供基本的柵格化 API，但隨著 API 逐漸穩定，將會繼續新增和改進更多功能。</p>
<p>Flutter GPU 還需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。這表示它只能在 Impeller 支援的平台上使用。在撰寫本文時，Impeller 支援：</p>
<ul>
<li>iOS（預設啟用）</li>
<li>macOS（選擇性預覽）</li>
<li>Android（選擇性預覽）</li>
</ul>
<p>我們對 Flutter GPU 的目標是最終支援所有 Flutter 的平台目標。最終目標是促進 Flutter 中跨平台渲染解決方案的生態系統，這些解決方案對於套件作者來說易於維護，對於使用者來說易於安裝。</p>
<p>3D 渲染只是一個可能的用例。Flutter GPU 也可以用於建立專用的 2D 渲染器，或者執行更非正統的操作，例如渲染 4D 空間的 3D 切片，或投影非歐幾里德空間。</p>
<p>由 Flutter GPU 支援的自訂 2D 渲染器的絕佳用例範例將是依賴骨骼網格變形的 2D 角色動畫格式。Spine 2D 就是一個很好的例子。這種骨骼網格解決方案通常具有動畫剪輯，這些剪輯會操縱層次結構中骨骼的平移、旋轉和縮放屬性，並且每個頂點都具有一些關聯的「骨骼權重」，這些權重決定哪些骨骼應該影響頂點，以及影響程度。</p>
<p>使用像 drawVertices 這樣的 Canvas 解決方案，需要在 CPU 上對每個頂點應用骨骼權重轉換。使用 Flutter GPU，骨骼轉換可以以統一陣列或甚至紋理取樣器的形式傳遞到頂點著色器，允許根據骨骼狀態和每個頂點的骨骼權重在 GPU 上並行計算每個頂點的最終位置。</p>
<p>說到此，讓我們透過一個溫和的介紹來開始使用 Flutter GPU：繪製您的第一個三角形！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JEI3fLDGcRHWKruT" />
</figure>

<h3 id="將-Flutter-GPU-加入您的專案"><a href="#將-Flutter-GPU-加入您的專案" class="headerlink" title="將 Flutter GPU 加入您的專案"></a>將 Flutter GPU 加入您的專案</h3><p>首先，請注意 Flutter GPU 目前處於早期預覽狀態，可能會發生 API 斷裂。目前 API 已經可以實現很多功能，但是有經驗的圖形工程師可能會注意到一些缺失的常見功能。Flutter GPU 在接下來的幾個月裡將會新增許多功能。</p>
<p>基於這些原因，強烈建議您在針對 Flutter GPU 開發套件時，暫時使用 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a> 的頂端。如果您遇到任何意外行為、錯誤或有功能請求，請使用標準的 <a href="https://github.com/flutter/flutter/issues/new/choose">Flutter 問題範本</a> 在 GitHub 上提交問題。與 Flutter GPU 相關的所有追蹤問題都標記為 <a href="https://github.com/flutter/flutter/labels/flutter-gpu">flutter-gpu 標籤</a>。</p>
<p>因此，在試驗 Flutter GPU 之前，請透過執行以下命令將 Flutter 切換到 main channel。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>現在建立一個新的 Flutter 專案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_cool_renderer</span><br><span class="line">cd my_cool_renderer</span><br></pre></td></tr></table></figure>

<p>接下來，將 flutter_gpu SDK 套件加入到您的 pubspec 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu --sdk=flutter</span><br></pre></td></tr></table></figure>

<h3 id="建立和匯入著色器捆綁包。"><a href="#建立和匯入著色器捆綁包。" class="headerlink" title="建立和匯入著色器捆綁包。"></a>建立和匯入著色器捆綁包。</h3><p>為了使用 Flutter GPU 渲染任何東西，您需要撰寫一些 GLSL 著色器。Flutter GPU 的著色器與 Flutter 的 <a href="https://docs.flutter.dev/ui/design/graphics/fragment-shaders">片段著色器</a> 功能所使用的著色器具有不同的語義，特別是在統一繫結方面。您還需要定義一個頂點著色器，與片段著色器一起使用。</p>
<p>從定義最簡單的著色器開始。您可以將著色器放置在專案中的任何位置，但是對於此範例，請建立一個 shaders 目錄，並使用兩個著色器填充它：simple.vert 和 simple.frag。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：shaders/simple.vert</span><br><span class="line"></span><br><span class="line">in vec2 position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_Position = vec4(position, 0.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在繪製三角形時，您將擁有一個定義每個頂點的資料列表。在本例中，它僅列出 2D 位置。對於這些頂點中的每一個，簡單的頂點著色器都會將這些 2D 位置分配給剪輯空間輸出內在 gl_Position。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：shaders/simple.frag</span><br><span class="line"></span><br><span class="line">out vec4 frag_color;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  frag_color = vec4(0, 1, 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段著色器甚至更簡單；它輸出一個 RGBA 顏色，範圍為 (0, 0, 0, 0) 到 (1, 1, 1, 1)。因此，所有內容都將被著色為綠色。</p>
<p>好的，現在您有了著色器，請使用 Flutter 的提前編譯 (AOT) 著色器編譯器將它們編譯。為了為著色器捆綁包設定自動化的建置，我們建議您使用 <a href="https://pub.dev/packages/flutter_gpu_shaders">flutter_gpu_shaders</a> 套件。</p>
<p>使用 pub 將 flutter_gpu_shaders 作為專案中的常規相依性加入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu_shaders</span><br></pre></td></tr></table></figure>

<p>Flutter GPU 著色器捆綁到 .shaderbundle 檔案中，可以作為常規資產添加到專案的資產捆綁包中。著色器捆綁包包含針對平台目標的編譯著色器來源。</p>
<p>接下來，建立一個著色器捆綁包宣告檔案，描述著色器捆綁包的內容。將以下內容添加到專案根目錄中的 my_renderer.shaderbundle.json。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;SimpleVertex&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;vertex&quot;,</span><br><span class="line">        &quot;file&quot;: &quot;shaders/simple.vert&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;SimpleFragment&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;fragment&quot;,</span><br><span class="line">        &quot;file&quot;: &quot;shaders/simple.frag&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>著色器捆綁包中的每個條目都可以具有任意名稱。在本例中，名稱是「SimpleVertex」和「SimpleFragment」。這些名稱用於在您的應用程式中查找著色器。</p>
<p>接下來，使用 flutter_gpu_shaders 套件建置 shaderbundle。您可以透過啟用實驗性的「原生資產」功能來新增一個掛鉤，該掛鉤會自動觸發建置。使用以下命令來啟用原生資產並安裝 native_assets_cli 套件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>

<p>啟用原生資產功能後，在掛鉤目錄下新增一個 build.dart 脚本，它將自動觸發建置著色器捆綁包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：hook/build.dart</span><br><span class="line"></span><br><span class="line">import &#x27;package:native_assets_cli/native_assets_cli.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_gpu_shaders/build.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) async &#123;</span><br><span class="line">  await build(args, (config, output) async &#123;</span><br><span class="line">    await buildShaderBundleJson(</span><br><span class="line">        buildConfig: config,</span><br><span class="line">        buildOutput: output,</span><br><span class="line">        manifestFileName: &#x27;my_renderer.shaderbundle.json&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>進行此更改後，當 Flutter 工具建置專案時，buildShaderBundleJson 將建置著色器捆綁包，並將結果輸出到套件根目錄下的 build&#x2F;shaderbundles&#x2F;my_renderer.shaderbundle。</p>
<p>著色器捆綁包格式本身與您使用的 Flutter 特定版本綁定，並且可能會隨著時間推移而改變。如果您正在撰寫一個建置著色器捆綁包的套件，請不要將生成的 .shaderbundle 檔案檢查到您的原始碼樹中。相反，請使用建置掛鉤來自動化建置流程（如前所述）。</p>
<p>這樣一來，使用您函式庫的開發人員將始終使用正確格式建置新的著色器捆綁包！</p>
<p>現在，您已經自動化了著色器捆綁包的建置，請像常規資產一樣匯入它。將資產條目添加到專案的 pubspec.yaml 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  assets:</span><br><span class="line">    - build/shaderbundles/</span><br></pre></td></tr></table></figure>

<p>在未來，原生資產功能將允許建置掛鉤將資料資產附加到捆綁包中。一旦發生這種情況，就不需要再在建置掛鉤旁邊新增資 * * * * *產匯入規則了。</p>
<p>接下來，新增一些程式碼，在執行時載入著色器。建立 lib&#x2F;shaders.dart 並新增以下程式碼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：lib/shaders.dart</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter_gpu/gpu.dart&#x27; as gpu;</span><br><span class="line"></span><br><span class="line">const String _kShaderBundlePath =</span><br><span class="line">    &#x27;build/shaderbundles/my_renderer.shaderbundle&#x27;;</span><br><span class="line">// 注意：如果您正在建立函式庫，則路徑必須以套件名稱為前綴</span><br><span class="line">//      例如：</span><br><span class="line">//      &#x27;packages/my_cool_renderer/build/shaderbundles/my_renderer.shaderbundle&#x27;</span><br><span class="line"></span><br><span class="line">gpu.ShaderLibrary? _shaderLibrary;</span><br><span class="line">gpu.ShaderLibrary get shaderLibrary &#123;</span><br><span class="line">  if (_shaderLibrary != null) &#123;</span><br><span class="line">    return _shaderLibrary!;</span><br><span class="line">  &#125;</span><br><span class="line">  _shaderLibrary = gpu.ShaderLibrary.fromAsset(_kShaderBundlePath);</span><br><span class="line">  if (_shaderLibrary != null) &#123;</span><br><span class="line">    return _shaderLibrary!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  throw Exception(&quot;Failed to load shader bundle! ($_kShaderBundlePath)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼為 Flutter GPU 著色器執行時函式庫建立一個單例 getter。第一次訪問 shaderLibrary 時，會使用 gpu.ShaderLibrary.fromAsset(shader_bundle_path) 使用建置的資產捆綁包初始化執行時著色器函式庫。</p>
<p>專案現在已經設定好使用 Flutter GPU 著色器。是時候渲染那個三角形了！</p>
<h3 id="绘制您的第一個三角形"><a href="#绘制您的第一個三角形" class="headerlink" title="绘制您的第一個三角形"></a>绘制您的第一個三角形</h3><p>對於本指南，您將建立一個 RGBA Flutter GPU 紋理和一個 RenderPass，將紋理作為顏色輸出附加到它。然後，您將使用 <a href="https://api.flutter.dev/flutter/dart-ui/Canvas/drawImage.html">Canvas.drawImage</a> 在 Widget 中渲染紋理。</p>
<p>為了簡潔起見，您將放棄最佳實務，只會為每一幀重新建置所有資源。</p>
<p>只要您在分配紋理時將其標記為「著色器可讀取」，您就可以將其轉換為 dart:ui.Image。若要將渲染結果顯示在 Widget 樹中，請將其繪製到 dart:ui.Canvas 上！</p>
<p>您可以透過使用自訂畫家為 Widget 樹架設腳手架來存取 Canvas。將 lib&#x2F;main.dart 的內容替換為以下內容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:typed_data&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_gpu/gpu.dart&#x27; as gpu;</span><br><span class="line"></span><br><span class="line">// 注意：我們之前在設定著色器捆綁包匯入時建立了它!</span><br><span class="line">import &#x27;shaders.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &#x27;Flutter GPU Triangle Example&#x27;,</span><br><span class="line">      home: CustomPaint(</span><br><span class="line">        painter: TrianglePainter(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrianglePainter extends CustomPainter &#123;</span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    // 嘗試存取 `gpu.gpuContext`。</span><br><span class="line">    // 如果 Flutter GPU 不受支援，將會拋出異常。</span><br><span class="line">    print(&#x27;Default color format: &#x27; +</span><br><span class="line">        gpu.gpuContext.defaultColorFormat.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在，執行應用程式。提醒一下，Flutter GPU 目前需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。因此，您必須使用 Impeller 支援的平台。對於本指南，我將以 macOS 為目標。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*lKTtaX2ih6dFpSMQ" />
</figure>

<p>如果 Flutter GPU 正常工作，那麼您應該會看到預設顏色格式被列印到主控台中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter: Default color format: PixelFormat.b8g8r8a8UNormInt</span><br></pre></td></tr></table></figure>

<p>如果 Impeller 未啟用，則在嘗試存取 gpu.gpuContext 時會拋出異常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception: Flutter GPU requires the Impeller rendering backend to be enabled.</span><br><span class="line"></span><br><span class="line">The relevant error-causing widget was:</span><br><span class="line">  CustomPaint</span><br></pre></td></tr></table></figure>

<p>為了簡便起見，您只會從這裡開始修改 paint 方法。</p>
<p>首先，建立一個 Flutter GPU 紋理，清除它，然後透過將其繪製到 Canvas 上來顯示它。</p>
<p>建立一個與 Canvas 大小相同的紋理。必須選擇一個 <code>StorageMode</code>。在本例中，您將紋理標記為 devicePrivate，因為您將只使用從設備 (GPU) 存取紋理記憶體的指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final texture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate,</span><br><span class="line">    size.width.toInt(), size.height.toInt())!;</span><br></pre></td></tr></table></figure>

<p>如果透過從主機 (CPU) 上傳資料來覆蓋紋理的資料，則使用 <code>StorageMode.hostVisible</code>。</p>
<p>第三個可用的選項是 <code>StorageMode.deviceTransient</code>，它對於不需要超過單個 RenderPass 壽命的附件很有用（因此它們可以只存在於瓦片記憶體中，並且不需要由 VRAM 分配支援）。通常，深度&#x2F;模板紋理符合此標準。</p>
<p>接下來，定義一個 <code>RenderTarget</code>。渲染目標包含一組「附件」，描述每個片段的記憶體佈局及其在 RenderPass 開始和結束時的設定&#x2F;拆卸行為。</p>
<p>本質上，RenderTarget 是 RenderPass 的可重複使用描述器。</p>
<p>現在，定義一個非常簡單的 <code>RenderTarget</code>，它只包含一個顏色附件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final renderTarget = gpu.RenderTarget.singleColor(</span><br><span class="line">gpu.ColorAttachment(texture: texture, clearValue: Colors.lightBlue));</span><br></pre></td></tr></table></figure>

<p>請注意，此程式碼將 clearValue 設定為淡藍色。每個附件都具有 <code>LoadAction</code> 和 <code>StoreAction</code>，它們分別確定在傳遞的開始和結束時應該對附件的臨時瓦片記憶體執行什麼操作。</p>
<p>預設情況下，顏色附件被設定為 <code>LoadAction.clear</code>（它將瓦片記憶體初始化為給定的顏色）和 <code>StoreAction.store</code>（它將結果儲存到附加的紋理的 VRAM 分配中）。</p>
<p>現在，建立一個 <code>CommandBuffer</code>，使用前面的 RenderTarget 從其中產生一個 RenderPass，然後立即提交 CommandBuffer 以清除紋理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final commandBuffer = gpu.gpuContext.createCommandBuffer();</span><br><span class="line">final renderPass = commandBuffer.createRenderPass(renderTarget);</span><br><span class="line">// ... 繪製調用將放在這裡!</span><br><span class="line">commandBuffer.submit();</span><br></pre></td></tr></table></figure>

<p>剩下的就是將初始化的紋理繪製到 Canvas 上！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final image = texture.asImage();</span><br><span class="line">canvas.drawImage(image, Offset.zero, Paint());</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ebUDtzQOuIGmdlop" />
</figure>

<p>現在您有了連接到螢幕顯示結果的 RenderPass，您就可以開始繪製三角形了。若要執行此操作，請設定以下內容：</p>
<ol>
<li>從著色器建立的 RenderPipeline，以及</li>
<li>包含幾何形狀的 GPU 可存取緩衝區（三個頂點位置）。</li>
</ol>
<p>建立 RenderPipeline 很容易。您只需將函式庫中的頂點和片段著色器組合在一起。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final vert = shaderLibrary[&#x27;SimpleVertex&#x27;]!;</span><br><span class="line">final frag = shaderLibrary[&#x27;SimpleFragment&#x27;]!;</span><br><span class="line">final pipeline = gpu.gpuContext.createRenderPipeline(vert, frag);</span><br></pre></td></tr></table></figure>

<p>現在是幾何形狀。回想一下，「SimpleVertex」著色器只有一個輸入：<code>in vec2 position</code>。因此，若要繪製三個頂點，您需要三組兩個浮點數。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final vertices = Float32List.fromList([</span><br><span class="line">  -0.5, -0.5, // 第一個頂點</span><br><span class="line">   0.5, -0.5, // 第二個頂點</span><br><span class="line">   0.0,  0.5, // 第三個頂點</span><br><span class="line">]);</span><br><span class="line">final verticesDeviceBuffer = gpu.gpuContext</span><br><span class="line">    .createDeviceBufferWithCopy(ByteData.sublistView(vertices))!;</span><br></pre></td></tr></table></figure>

<p>剩下的就是繫結新的資源，並呼叫 renderPass.draw() 以完成記錄繪製調用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renderPass.bindPipeline(pipeline);</span><br><span class="line"></span><br><span class="line">final verticesView = gpu.BufferView(</span><br><span class="line">  verticesDeviceBuffer,</span><br><span class="line">  offsetInBytes: 0,</span><br><span class="line">  lengthInBytes: verticesDeviceBuffer.sizeInBytes,</span><br><span class="line">);</span><br><span class="line">renderPass.bindVertexBuffer(verticesView, 3);</span><br><span class="line"></span><br><span class="line">renderPass.draw();</span><br></pre></td></tr></table></figure>

<p>如果您啟動應用程式，您現在應該會看到一個綠色的三角形！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LWnGU5WPT_Eom0wJ" />
</figure>

<p>太棒了，您使用 Flutter、Dart 和一點 GLSL 從頭開始建立了一個渲染器！</p>
<p>無論這是否是您第一次渲染三角形，或者您是經驗豐富的圖形專家，我都希望您能繼續使用 Flutter GPU，並查看我們正在開發的套件，例如 Flutter Scene。</p>
<p>在未來，我們希望發佈友好的初學者程式碼實驗室，深入探討 Flutter GPU 的預設行為和最佳實務。我們還沒討論頂點屬性佈局、紋理繫結、統一和對齊要求、管道混合、深度和模板附件、透視校正等等！</p>
<p>在那之前，我建議您探索 <a href="https://github.com/bdero/flutter_scene">Flutter Scene</a> 作為如何使用 Flutter GPU 的更全面的範例。</p>
<h3 id="使用-Flutter-Scene-進行-3D-渲染"><a href="#使用-Flutter-Scene-進行-3D-渲染" class="headerlink" title="使用 Flutter Scene 進行 3D 渲染"></a>使用 Flutter Scene 進行 3D 渲染</h3><p>Flutter Scene（套件 flutter_scene）是一個新的 3D 場景圖套件，由 Flutter GPU 支援，它使 Flutter 開發人員能夠匯入動畫 glTF 模型並渲染即時 3D 場景。</p>
<p>目的是提供一個套件，讓在 Flutter 中輕鬆建立互動式 3D 應用程式和遊戲。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tC68CbPLef2rJp1e" />
</figure>

<p>該套件最初是作為一個 dart:ui 擴展，用於用 C++ 編寫的 3D 渲染器，並直接建置到 Flutter 的原生執行時中，但它已經使用更靈活的介面針對 Flutter GPU 重新撰寫。</p>
<p>與 Flutter GPU API 本身一樣，Flutter Scene 目前處於早期預覽狀態，需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。Flutter Scene 通常與 Flutter GPU API 的重大變更保持同步，因此強烈建議您在試驗 Flutter Scene 時使用 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a>。</p>
<p>接下來，使用 Flutter Scene 建立一個應用程式！</p>
<h3 id="設定-Flutter-Scene-專案"><a href="#設定-Flutter-Scene-專案" class="headerlink" title="設定 Flutter Scene 專案"></a>設定 Flutter Scene 專案</h3><p>由於強烈建議您針對 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a> 使用 Flutter Scene，請從切換到主頻道開始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>接下來，建立一個新的 Flutter 專案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_3d_app</span><br><span class="line">cd my_3d_app</span><br></pre></td></tr></table></figure>

<p>Flutter Scene 依靠實驗性的「原生資產」功能來自動化著色器的建置。您將在稍後使用原生資產來設定自動匯入 Flutter Scene 的 3D 模型。</p>
<p>使用以下命令啟用原生資產。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br></pre></td></tr></table></figure>

<p>最後，將 Flutter Scene 添加為專案相依性。</p>
<p>您還需要在與 Flutter Scene 的 API 互動時使用一些 vector_math 構造，因此也添加 vector_math 套件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene vector_math</span><br></pre></td></tr></table></figure>

<p>接下來，匯入一個 3D 模型！</p>
<h3 id="匯入-3D-模型"><a href="#匯入-3D-模型" class="headerlink" title="匯入 3D 模型"></a>匯入 3D 模型</h3><p>首先，您需要一個要渲染的 3D 模型。對於本指南，您將使用常見的 <a href="https://en.wikipedia.org/wiki/GlTF">glTF</a> 樣本資產： <a href="https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/DamagedHelmet">DamagedHelmet.glb</a>。以下是它的樣子。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/912/0*vVWRLxJ348tCxv7T" />
<figcaption>原始的 Damaged Helmet 模型由 theblueturtle_ 在 2016 年建立（授權： [CC BY-NC 4.0 國際](https://creativecommons.org/licenses/by-nc/4.0/legalcode)）。轉換後的 glTF 版本由 ctxwing 在 2018 年建立（授權： [CC BY 4.0 國際](https://creativecommons.org/licenses/by/4.0/legalcode)）。 </figcaption>
</figure>

<p>您可以從 GitHub 上託管的 <a href="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/DamagedHelmet/glTF-Binary/DamagedHelmet.glb">glTF 樣本資產儲存庫</a> 中獲取它。將 DamagedHelmet.glb 放置在您的專案根目錄中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/main/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb</span><br></pre></td></tr></table></figure>

<p>像大多數即時 3D 渲染器一樣，Flutter Scene 在內部使用專用的 3D 模型格式。您可以使用 Flutter Scene 的離線匯入器工具將標準 glTF 二進制檔案（.glb 檔案）轉換為此格式。</p>
<p>將 flutter_scene_importer 套件作為常規相依性添加到專案中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene_importer</span><br></pre></td></tr></table></figure>

<p>添加此套件可以使用 dart run 手動呼叫匯入器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dart --enable-experiment=native-assets \</span><br><span class="line">     run flutter_scene_importer:import \</span><br><span class="line">     --input &quot;path/to/my/source_model.glb&quot; \</span><br><span class="line">     --output &quot;path/to/my/imported_model.model&quot;</span><br></pre></td></tr></table></figure>

<p>您可以透過使用原生資產建置掛鉤來自動執行匯入器。若要執行此操作，請先將 native_assets_cli 作為常規專案相依性安裝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>

<p>現在您可以撰寫建置掛鉤了。使用以下內容建立 hook&#x2F;build.dart。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:native_assets_cli/native_assets_cli.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene_importer/build_hooks.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) &#123;</span><br><span class="line">  build(args, (config, output) async &#123;</span><br><span class="line">    buildModels(buildConfig: config, inputFilePaths: [</span><br><span class="line">      &#x27;DamagedHelmet.glb&#x27;,</span><br><span class="line">    ]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 flutter_scene_importer 中的 buildModels 公用程式，提供要建置的模型列表。路徑相對於專案的建置根目錄。</p>
<p>當 Flutter 工具建置專案時，buildModels 現在將建置著色器捆綁包，並將結果輸出到套件根目錄下的 build&#x2F;models&#x2F;DamagedModel.model。</p>
<p>匯入的模型格式本身與您使用的 Flutter Scene 特定版本綁定，並且會隨著時間推移而改變。在撰寫使用 Flutter Scene 的應用程式或函式庫時，請勿將生成的 .model 檔案檢查到您的原始碼樹中。相反，請使用建置掛鉤從您的原始模型中生成它們（如前所述）。</p>
<p>這樣一來，隨著時間推移升級 Flutter Scene 時，您將始終使用正確格式建置新的 .model 檔案！</p>
<p>接下來，像常規資產一樣匯入模型。將資產條目添加到專案的 pubspec.yaml 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  assets:</span><br><span class="line">    - build/models/</span><br></pre></td></tr></table></figure>

<p>在未來，原生資產功能將允許建置掛鉤將資料資產附加到捆綁包中。一旦發生這種情況，就不需要再在建置掛鉤旁邊新增資產匯入規則了。</p>
<h3 id="渲染-3D-場景"><a href="#渲染-3D-場景" class="headerlink" title="渲染 3D 場景"></a>渲染 3D 場景</h3><p>現在是應用程式的程式碼了。</p>
<p>首先，建立一個有狀態的 Widget，用於在多個幀中保留 Scene。</p>
<p>您將根據時間進行動畫處理，因此將 SingleTickerProviderStateMixin 添加到狀態，以及一個 elapsedSeconds 成員。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter/scheduler.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/camera.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/node.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/scene.dart&#x27;;</span><br><span class="line">import &#x27;package:vector_math/vector_math.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget&#123;</span><br><span class="line">  const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  MyAppState createState() =&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line">  double elapsedSeconds = 0;</span><br><span class="line">  Scene scene = Scene();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &#x27;My 3D app&#x27;,</span><br><span class="line">      home: Placeholder(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行應用程式作為冒煙測試，以確保沒有錯誤。請記住要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/912/0*74qs6ytcTjyVHwML" />
</figure>

<p>在繼續之前，請為動畫設定計時器。覆蓋 MyAppState 中的 initState 以呼叫 createTicker。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  createTicker((elapsed) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).start();</span><br><span class="line">  </span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要 Widget 可見，計時器回呼就會為每一幀被呼叫。呼叫 setState 會觸發此 Widget 在每一幀重建。</p>
<p>接下來，載入之前放置在專案中的 3D 模型，並將其添加到 Scene 中。</p>
<p>使用 Node.fromAsset 從資產捆綁包中載入模型。將以下程式碼放置在 initState 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">  model.name = &#x27;Helmet&#x27;;</span><br><span class="line">  scene.add(model);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Node.fromAsset 會異步地從資產捆綁包中反序列化模型，並在模型準備好添加到場景中時解析返回的 Future<Node>。</p>
<p>現在，MyAppState.initState 應該如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  createTicker((elapsed) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).start();</span><br><span class="line">  </span><br><span class="line">  Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">    model.name = &#x27;Helmet&#x27;;</span><br><span class="line">    scene.add(model);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，您仍然沒有實際渲染 3D Scene！若要執行此操作，請使用 <code>Scene.render</code>，它需要 UI Canvas、Flutter Scene Camera 和一個大小。</p>
<p>存取 Canvas 的一種方法是建立一個 CustomPainter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line">  ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line">  Scene scene;</span><br><span class="line">  Camera camera;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘記將 shouldRepaint 覆蓋設置為返回 true，以便在每次重建發生時自訂畫家都會重新繪畫。</p>
<p>最後，將 CustomPainter 添加到源樹中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  final painter = ScenePainter(</span><br><span class="line">    scene: scene,</span><br><span class="line">    camera: PerspectiveCamera(</span><br><span class="line">      position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line">      target: Vector3(0, 0, 0),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return MaterialApp(</span><br><span class="line">    title: &#x27;My 3D app&#x27;,</span><br><span class="line">    home: CustomPaint(painter: painter),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼指示相機沿著一個連續的圓圈移動，但始終面向原點。</p>
<p>最後，啟動應用程式！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/796/0*_-OFc0vhBHAhrPrO" />
</figure>

<p>以下是我們組合的完整源程式碼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/camera.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/node.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/scene.dart&#x27;;</span><br><span class="line">import &#x27;package:vector_math/vector_math.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget &#123;</span><br><span class="line">  const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  MyAppState createState() =&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line">  double elapsedSeconds = 0;</span><br><span class="line">  Scene scene = Scene();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    createTicker((elapsed) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">      model.name = &#x27;Helmet&#x27;;</span><br><span class="line">      scene.add(model);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    super.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final painter = ScenePainter(</span><br><span class="line">      scene: scene,</span><br><span class="line">      camera: PerspectiveCamera(</span><br><span class="line">        position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line">        target: Vector3(0, 0, 0),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &#x27;My 3D app&#x27;,</span><br><span class="line">      home: CustomPaint(painter: painter),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line">  ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line">  Scene scene;</span><br><span class="line">  Camera camera;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Flutter-光明的未來"><a href="#Flutter-光明的未來" class="headerlink" title="Flutter 光明的未來"></a>Flutter 光明的未來</h3><p>如果您能夠成功地遵循這些指南中的其中一個並讓它運行起來：太棒了，恭喜！</p>
<p>Flutter GPU 和 Flutter Scene 都非常年輕，平台支援有限。但我想總有一天，我們會懷念這些不起眼的開端。</p>
<p>隨著 Impeller 的推廣，Flutter 團隊完全掌控了渲染堆疊，因為我们需要針對 Flutter 的用例專門化渲染器。現在，我們正在開啟 Flutter 歷史上的一個新篇章。一個由您共同掌控渲染的篇章！</p>
<p>Flutter Scene 最初是 Impeller 中的 C++ 組件，與 2D Canvas 渲染器一起，帶有一個精簡的 dart:ui 擴展。在我構建它時，我已經意識到 Flutter Engine 不會是它的最終目的地。</p>
<p>3D 渲染器的架構決策海洋是廣闊</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/807a2f46.html" data-id="cm1ntp44g000fv517aks5ds89" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2024-08-06T18:00:29.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/6129811c.html" class="article-date">
  <time datetime="2024-08-06T10:00:29.000Z" itemprop="datePublished">2024-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/6129811c.html">【文章翻譯】Announcing Flutter 3.24 and Dart 3.5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Flutter-3-24-和-Dart-3-5"><a href="#宣布-Flutter-3-24-和-Dart-3-5" class="headerlink" title="宣布 Flutter 3.24 和 Dart 3.5"></a>宣布 Flutter 3.24 和 Dart 3.5</h2><p>今天，我們將揭曉 <a href="https://medium.com/p/6c040f87d1e4/edit">Flutter 3.24</a> 和 <a href="https://medium.com/dartlang/dart-3.5-6ca36259fa2f">Dart 3.5</a>，以及 <a href="https://ioconnectchina.googlecnapps.cn/">I&#x2F;O 2024 Connect 系列</a> 的最後一站，該系列將在幾個小時內在中國舉行——中國是世界上最活躍的 Flutter 社群之一，這使得這個時刻變得格外特別。</p>
<figure>
<img alt="Dash flies in and lands to the left of an outline of 3.24. She presses a button that fills the 3.24 in with Flutter blue." src="https://cdn-images-1.medium.com/max/1024/1*jzRGig761LnPlvokq2FaVA.gif" />
</figure>

<p>我們在 5 月份的 <a href="https://io.google/2024/">Google I&#x2F;O</a> 上啟動了一系列 <a href="https://medium.com/flutter/io24-5e211f708a37">令人興奮的更新</a>，包括將 WebAssembly 編譯支援升級到 stable channel，改進 Impeller，以及預覽 Dart macros 的未來。</p>
<p>Flutter 3.24 和 Dart 3.5 發佈版本在我們幫助您製作出色的高效能應用程式（這些應用程式可以透過單個共用程式碼庫到達行動、網頁和桌面上的使用者）的使命之上。它們包括對新的 Flutter GPU API 的早期預覽，對網頁上元素嵌入的改進，以及幾個針對那些想要為 iOS 生態系統構建的開發人員的令人興奮的更新，包括對 Swift Package Manager 的早期支援，以及對 Cupertino Widgets 的功能更新。</p>
<p>讓我們開始吧！</p>
<h3 id="Impeller：為跨平台圖形效能樹立新標竿"><a href="#Impeller：為跨平台圖形效能樹立新標竿" class="headerlink" title="Impeller：為跨平台圖形效能樹立新標竿"></a>Impeller：為跨平台圖形效能樹立新標竿</h3><p>從歷史上看，跨平台框架需要在視覺效果上做出妥協，因為它們依賴於底層平台提供的更高級別的抽象。Flutter 採用了不同的方法，它擁有自己的渲染層，可以在每台設備上提供硬體加速的圖形和流暢的效能。我們在 <a href="https://docs.flutter.dev/perf/impeller">Impeller</a> 和 <a href="https://docs.flutter.dev/ui/design/graphics/fragment-shaders">著色器</a> 方面取得了重大進展，為圖形（如 3D）解鎖了令人興奮的新可能性。</p>
<p>我們很興奮地分享全新的 <a href="https://github.com/flutter/engine/blob/main/docs/impeller/Flutter-GPU.md">Flutter GPU API</a> 的早期預覽，這是一個功能強大、低階的圖形 API，直接整合到 Flutter SDK 中。API 允許您定義自訂柵格管道，並將繪製調用直接提交到 GPU，從而可以建立專用的渲染器，例如 2D Canvas 的替代方案、3D 場景圖，甚至用於創造視覺上令人驚豔、高效能和沉浸式體驗的粒子系統，而無需使用通常引擎級別需要的容量。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/796/0*QC1D0LdTgLynDOnV" />
<figcaption>3D animation of a sci-fi space helmet rendered in flutter_scene.</figcaption>
</figure>

<p>考慮到 API 的低階性，我們預計對於那些沒有大量圖形開發經驗的開發人員來說，會有一段學習曲線。這就是為什麼我們正在投資渲染套件，例如新的 <code>flutter_scene</code> 套件，它利用 Flutter GPU API 允許匯入動畫 glTF 模型並構造 3D 場景，使您能夠輕鬆地在 Flutter 和 Dart 中建立 3D 應用程式和遊戲，如下所示。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FY-DFVKPikVM%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DY-DFVKPikVM&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FY-DFVKPikVM%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/21e51abf698b844782de55d81e3cd7b4/href">https://medium.com/media/21e51abf698b844782de55d81e3cd7b4/href</a></iframe>

<p>儘管 Flutter GPU API 提供了令人興奮的可能性，但它仍然處於早期預覽階段，我們可能會對 API 進行重大變更。我們建議在使用 Flutter GPU 時針對 Flutter 的主頻道進行開發。在部落格文章 <a href="https://medium.com/flutter/getting-started-with-flutter-gpu-f33d497b7c11">Introducing Flutter GPU &amp; Flutter Scene</a> 中了解更多資訊。</p>
<h3 id="為-iOS-和-macOS-打造-Flutter：讓為-Apple-生態系統交付美麗、快速的應用程式變得更加容易"><a href="#為-iOS-和-macOS-打造-Flutter：讓為-Apple-生態系統交付美麗、快速的應用程式變得更加容易" class="headerlink" title="為 iOS 和 macOS 打造 Flutter：讓為 Apple 生態系統交付美麗、快速的應用程式變得更加容易"></a>為 iOS 和 macOS 打造 Flutter：讓為 Apple 生態系統交付美麗、快速的應用程式變得更加容易</h3><p>我們的目標是讓您能夠構建出色的應用程式，這些應用程式感覺起來像原生應用程式，並能完美地執行。這項工作的一部分是優化效能，以及最大限度地提高 Flutter 與底層平台的相容性，包括存取 Apple 生態系統的全部功能。</p>
<p>在此版本中，我們引入了對 Swift Package Manager 的早期支援，解鎖了對蓬勃發展的 Swift 套件生態系統的存取，並使 Flutter 外掛能夠利用大量預先構建的功能來加速開發。一旦 Swift Package Manager (SPM) 被 Plugin 開發人員廣泛採用，它應該會簡化 Flutter 安裝過程本身，並降低新手的入門門檻，特別是那些不熟悉 iOS 生態系統的人。我們鼓勵 Plugin 作者 <a href="https://docs.flutter.dev/packages-and-plugins/swift-package-manager/for-plugin-authors#how-to-add-swift-package-manager-support-to-an-existing-flutter-plugin">嘗試將 SPM 支援添加到您的外掛中</a>，並提供您體驗的 <a href="https://github.com/flutter/flutter/issues">回饋</a>。</p>
<p>接下來，我們希望讓您始終能夠滿足設計師的要求，並在 iOS 上提供高保真度的體驗。為了實現這一點，我們開始著手現代化和擴展 Cupertino Widget，解決了 <a href="https://github.com/flutter/flutter/issues?q=is:issue+is:closed+label:%22f:+cupertino%22+sort:updated-desc+closed:2024-04-01..2024-07-01+">Cupertino 中的 15 個問題</a>，並在 <a href="https://docs.flutter.dev/ui/widgets/cupertino">Widget 目錄</a> 中加入了 37 個缺少的 Cupertino Widget。</p>
<p>最後，我們為 Flutter macOS 應用程式添加了 <a href="https://docs.flutter.dev/platform-integration/macos/platform-views"><code>platform_view</code></a> 和 <a href="https://docs.flutter.dev/platform-integration/web/web-content-in-flutter">webview</a> 支援，允許將原生 macOS UI 組件無縫整合到您的 Flutter 應用程式中，以提供更完整、更完善的使用者體驗。</p>
<p>展望未來，我們很興奮能更多地投資於其他 Cupertino Widget 的保真度，與我們的生態系統一起推出 Swift Package Manager，並提供其他調查，讓整合和與 Apple 平台的互操作變得更加容易。</p>
<h3 id="強調充滿活力的-Flutter-社群的全球影響力"><a href="#強調充滿活力的-Flutter-社群的全球影響力" class="headerlink" title="強調充滿活力的 Flutter 社群的全球影響力"></a>強調充滿活力的 Flutter 社群的全球影響力</h3><p>我們還想感謝社群的貢獻，包括您的貢獻！這組版本包含來自 167 多位獨特貢獻者的近 1,500 次提交，其中包括 49 位 <em>全新</em> 貢獻者。我們深受 Flutter 社群持續的高水準活動、承諾和增長所鼓舞，包括積極構建框架的那些人。謝謝您！</p>
<p>我們共同努力的影響力正在世界各地展現出來，創造出數百萬人每天使用的令人難以置信的應用程式和體驗。例如，以下是 <a href="http://flutter.dev/showcase/xiaomi">案例研究</a> 的搶先看，展示了中國科技公司小米的團隊如何以及為什麼使用 Flutter 為該公司備受歡迎的新型電動汽車 <a href="https://www.mi.com/global/discover/article?id=3263&amp;ref=renatomitra.com">小米 SU7</a> 開發一個配套應用程式。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FwfD7ZQhwACU?feature=oembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv=wfD7ZQhwACU&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FwfD7ZQhwACU%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/1e141755d6ab1cd3b7962281efd5e6d3/href">https://medium.com/media/1e141755d6ab1cd3b7962281efd5e6d3/href</a></iframe>

<p>在世界各地出現的許多其他令人興奮的 Flutter 應用程式範例：</p>
<ul>
<li><a href="http://flutter.dev/showcase/sncf-connect">SNCF Connect</a>，法國鐵路和歐洲最大的 Flutter 應用程式（擁有超過 150 個螢幕）的擁有者，與奧運會合作為 Flutter 應用程式交付了許多更新，使數百萬遊客能夠在奧運會期間穿梭於法國各地。</li>
<li><a href="http://flutter.dev/showcase/wolt">Wolt</a>，DoorDash 國際的一部分，使用 Flutter 擴展到商家零售市場。</li>
<li><a href="http://flutter.dev/showcase/whirlpool">惠而浦</a>，一家擁有全球影響力的《財富》500 強公司，正在使用 Flutter 在巴西探索新的銷售管道。</li>
<li><a href="http://flutter.dev/showcase/monta">Monta</a>，一家丹麥的電動汽車充電生態系統初創公司，在短短 3 個月內使用 Flutter 將其第一個行動應用程式推向市場，後來又成功地將其 Web 應用程式移植到 Flutter。</li>
</ul>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>以上只是這些版本中 Flutter 和 Dart 的許多新功能和更新中的一小部分，您可以在 <a href="https://medium.com/p/6c040f87d1e4/edit">Flutter 3.24 技術部落格</a> 文章和 <a href="https://medium.com/dartlang/dart-3.5-6ca36259fa2f">Dart 3.5 部落格文章</a> 中了解更多資訊。</p>
<p>展望未來，我們對 Flutter 的未來充滿期待。我們仍然致力於我們的使命，並且感謝您——無論是貢獻者、社群成員還是 Flutter 開發人員——成為這段非凡旅程的一部分。我們迫不及待想看看您接下來會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=204b7d20c45d" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/flutter-3-24-dart-3-5-204b7d20c45d">宣布 Flutter 3.24 和 Dart 3.5</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/6129811c.html" data-id="cm1ntp44g000dv5177y5h9e5b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2024-08-06T18:00:07.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/773d803a.html" class="article-date">
  <time datetime="2024-08-06T10:00:07.000Z" itemprop="datePublished">2024-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/773d803a.html">【文章翻譯】What’s new in Flutter 3.24</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="解鎖-Flutter-GPU、多視圖嵌入等等"><a href="#解鎖-Flutter-GPU、多視圖嵌入等等" class="headerlink" title="解鎖 Flutter GPU、多視圖嵌入等等"></a>解鎖 Flutter GPU、多視圖嵌入等等</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EA-cAY6uwkYqYb725vnCIw.png" />
<figcaption>Flutter 3.24 on a blue background</figcaption>
</figure>

<p>歡迎來到最新的 Flutter 更新！Flutter 3.24 充滿了令人興奮的新功能和增強功能，可以提升您的應用程式開發體驗。此版本重點介紹了 Flutter GPU 的預覽版本，它可以在 Flutter 中直接啟用進階圖形和 3D 場景。Web 應用程式現在可以嵌入多個 Flutter 視圖，增強應用程式的多功能性。最後，我們加入了影片廣告支援，以幫助您最大限度地提高收入。</p>
<p>在過去的幾個月裡，Flutter 社群一直非常活躍，擁有 852 個框架提交和 615 個引擎提交。我們很興奮地歡迎 49 位新貢獻者，他們幫助實現了此版本。您的奉獻和熱情推動著 Flutter 的前進。</p>
<p>因此，深入了解 Flutter 社群帶給這個最新版本的最新功能和增強功能吧！</p>
<h3 id="Flutter-架構"><a href="#Flutter-架構" class="headerlink" title="Flutter 架構"></a>Flutter 架構</h3><h4 id="新的-Sliver"><a href="#新的-Sliver" class="headerlink" title="新的 Sliver"></a>新的 Sliver</h4><p>此版本加入了新的 Sliver，可以將它們組合在一起以實現動態 app bar 行為：</p>
<ul>
<li><a href="http://api.flutter.dev/flutter/widgets/PinnedHeaderSliver-class.html">PinnedHeaderSliver</a></li>
<li><a href="http://api.flutter.dev/flutter/widgets/SliverResizingHeader-class.html">SliverResizingHeader</a></li>
</ul>
<p>您可以使用這些新的 Sliver 來製作浮動、保持固定或在使用者捲軸時調整大小的標題。這些新的 Sliver 類似於現有的 <a href="https://api.flutter.dev/flutter/widgets/SliverPersistentHeader-class.html">SliverPersistentHeader</a> 和 <a href="http://sliverappbar/">SliverAppBar</a> Sliver，但具有更簡單的 API，可以組合在一起以實現更大的效果。</p>
<p>這些新的 Sliver 附帶了新的範例程式碼。例如，PinnedHeaderSliver 的 API 文件有一個範例，可以重新建立 iOS 設定應用程式 app bar 的效果：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*bdcb6KGonosfPZ6m" />
</figure>

<h4 id="Cupertino-函式庫中的更新"><a href="#Cupertino-函式庫中的更新" class="headerlink" title="Cupertino 函式庫中的更新"></a>Cupertino 函式庫中的更新</h4><p>在此版本中，我們改進了 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoActionSheet-class.html">CupertinoActionSheet</a> 的保真度。在動作表單的按鈕上滑動手指現在可以提供觸覺回饋。按鈕的字體大小和粗細現在與原生對應物相符。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/655/0*_o_9V0RlITOZdU4v" />
</figure>

<p>我們還為 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoButton-class.html">CupertinoButton</a> 加入了新的焦點屬性，現在您可以自訂已停用的 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoTextField-class.html">CupertinoTextField</a> 的顏色。</p>
<p>Cupertino 函式庫的更新正在進行中，請期待未來版本中的更多更新！</p>
<h4 id="TreeView"><a href="#TreeView" class="headerlink" title="TreeView"></a>TreeView</h4><p><a href="https://pub.dev/packages/two_dimensional_scrollables">two_dimensional_scrollables</a> 套件發佈了 <a href="https://pub.dev/documentation/two_dimensional_scrollables/latest/two_dimensional_scrollables/TreeView-class.html">TreeView</a> Widget，以及幾個用於建立高效能捲軸樹的配套類別，這些樹可以在樹增長時向所有方向捲軸。套件中包含的樣本應用程式也已更新，其中包含幾個使用 <a href="https://pub.dev/documentation/two_dimensional_scrollables/latest/two_dimensional_scrollables/TableView-class.html">TableView</a> 和 <a href="https://pub.dev/documentation/two_dimensional_scrollables/latest/two_dimensional_scrollables/TreeView-class.html">TreeView</a> Widget 的全新範例。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*wcmJCv-6owwsolRl" />
</figure>

<p><a href="https://api.flutter.dev/flutter/widgets/TreeSliver-class.html">TreeSliver</a> 也被加入到框架中，用於在一維捲軸中建立樹。<code>TreeView</code> 和 <code>TreeSliver</code> API 符合，使您能夠輕鬆地在適合您的使用案例之間切換。</p>
<h4 id="CarouselView"><a href="#CarouselView" class="headerlink" title="CarouselView"></a>CarouselView</h4><p>此版本包含了 <a href="https://m3.material.io/components/carousel/overview">Material Design carousel</a> Widget：<code>CarouselView</code>。CarouselView 呈現「<a href="https://m3.material.io/components/carousel/specs#477de3a1-c9df-4742-baf3-bcd5eeb3764c">Uncontained</a>」佈局：一個可捲軸的項目列表，這些項目會捲軸到 container 的邊緣，並且當開頭和末尾項目捲出視圖和捲入視圖時，它們可以動態調整大小。</p>
<figure>
<img alt="Flutter CarouselView example" src="https://cdn-images-1.medium.com/max/512/1*6ytqSvtR2TJzAE6LntHTGw.gif" />
</figure>

<h4 id="Widget提供更多功能"><a href="#Widget提供更多功能" class="headerlink" title="Widget提供更多功能"></a>Widget提供更多功能</h4><p>此版本包含將核心 Widget 邏輯從 Material 函式庫移動到 Widgets 函式庫中以便更廣泛使用，這些邏輯不是設計專用的。這包括：</p>
<ul>
<li><a href="https://github.com/flutter/flutter/pull/148523">Feedback</a> Widget，它提供輕鬆存取設備上的觸覺和音訊回饋，以點擊回應、長按等手勢。</li>
<li><a href="https://github.com/flutter/flutter/pull/148272">ToggleableStateMixin</a> 和 <a href="https://github.com/flutter/flutter/pull/148272">ToggleablePainter</a>，用於建立複選框、開關<br>和單選按鈕等切換 Widget 的基本類別。</li>
</ul>
<h4 id="為-AnimationStatus-增強列舉功能"><a href="#為-AnimationStatus-增強列舉功能" class="headerlink" title="為 AnimationStatus 增強列舉功能"></a>為 AnimationStatus 增強列舉功能</h4><p>在社群成員 <a href="https://github.com/nate-thegrate">nate-thegrate</a>  的出色 <a href="https://github.com/flutter/flutter/pull/147801">貢獻</a> 中，增強的列舉功能被加入到 <a href="https://api.flutter.dev/flutter/animation/AnimationStatus.html">AnimationStatus</a> 中，包括 getter：</p>
<ul>
<li>isDismissed</li>
<li>isCompleted</li>
<li>isRunning</li>
<li>isForwardOrCompleted</li>
</ul>
<p>其中一些 getter 已經存在於 <a href="https://api.flutter.dev/flutter/animation/Animation-class.html">Animation</a> 子類別中，例如 <a href="https://api.flutter.dev/flutter/animation/AnimationController-class.html">AnimationController</a> 和 <a href="https://api.flutter.dev/flutter/animation/CurvedAnimation-class.html">CurvedAnimation</a>。現在，所有這些狀態 getter 都可以在 Animation 子類別中使用，除了 AnimationStatus 之外。最後，一個 <a href="https://api.flutter.dev/flutter/animation/AnimationController/toggle.html"><code>toggle</code></a> 方法被加入到 AnimationController 中，用於切換動畫的方向。</p>
<h4 id="SelectionArea-中的更新"><a href="#SelectionArea-中的更新" class="headerlink" title="SelectionArea 中的更新"></a>SelectionArea 中的更新</h4><p>Flutter 的 <a href="https://api.flutter.dev/flutter/material/SelectionArea-class.html">SelectionArea</a> 現在支援使用滑鼠進行三擊和在觸控設備上雙擊的更多原生手勢。預設情況下，<a href="https://api.flutter.dev/flutter/material/SelectionArea-class.html">SelectionArea</a> 和 <a href="https://api.flutter.dev/flutter/widgets/SelectableRegion-class.html">SelectableRegion</a> Widget 使用這些新的手勢。</p>
<p>三擊</p>
<ul>
<li>三擊 + 拖動：擴展段落塊中的選取範圍。</li>
<li>三擊：選取點擊位置的段落塊。</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*_GmbsIKfnwEAW6G8" />
</figure>

<p>雙擊</p>
<ul>
<li>雙擊 + 拖動：擴展文字區塊中的選取範圍（支援原生 Android&#x2F;Fuchsia&#x2F;iOS 和 iOS 網頁）。</li>
<li>雙擊：選取點擊位置的文字（支援原生 Android&#x2F;Fuchsia&#x2F;iOS 和 Android&#x2F;Fuchsia 網頁）。</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/770/0*DwZgIybQr3FDFxXd" />
</figure>

<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><h4 id="Impeller"><a href="#Impeller" class="headerlink" title="Impeller"></a>Impeller</h4><p><strong>改善效能和保真度</strong></p>
<p>為了在即將到來的穩定版本中移除 iOS 上的 Impeller 選擇不使用設定，團隊一直在努力改進 Impeller 的效能和保真度。例如，針對文字渲染的一系列改進 <a href="https://github.com/flutter/flutter/issues/138798">大幅提高了 emoji 捲軸的效能</a>，消除了捲軸大量 emoji 時的卡頓，這對 Impeller 的文字渲染能力來說是一項極好的壓力測試。</p>
<p>此外，透過 <a href="https://github.com/flutter/engine/pull/53042">解決許多問題</a>，我們也在此版本中大幅改進了 Impeller 文字渲染的保真度。特別是，文字粗細、間距和字距調整現在都與傳統渲染器的文字保真度相符。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gIu2Wm9mpuMGb1JY" />
<figcaption>Before (Note gaps instead of proper kerning, and lighter than intended font weight.)</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tt9hlqhTbrmj4ZCt" />
<figcaption>After</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/739/0*eMboSxWLEJBS_EyL" />
<figcaption>Before (Note incorrect spacing, for example in “vergelijken”)</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/739/0*uxeGJuIKWu0dPW1d" />
<figcaption>After</figcaption>
</figure>

<p><strong>Android 預覽</strong></p>
<p>在此版本中，我們將繼續在 Android 上預覽 Impeller。我們延長了預覽期，因為 Impeller 用於 Platform Views 的 API 在 <a href="https://github.com/flutter/flutter/issues/146499#issuecomment-2082873125">Android 14 中的一個錯誤</a> 導致出現困難。這個錯誤後來被 Android 團隊修補了，但是許多已部署的設備在可預見的將來將運行未修補的 Android 版本。解決這些問題意味著需要額外的 API 遷移，因此需要額外的穩定版本週期。出於謹慎和為了確保 Flutter 應用程式可以在盡可能廣泛的設備上運行，我們將推遲將 Impeller 作為預設渲染器，直到今年晚些時候的穩定版本發佈。</p>
<p>隨著 Android 上的 Impeller 預覽繼續在 3.24 穩定版本週期中進行，我們請求 Flutter 開發人員升級到最新的穩定版本，並在啟用 Impeller 時提交有關任何發現的不足的錯誤。在此階段的回饋對確保 Impeller 在 Android 上取得成功以及我們能夠在今年晚些時候的版本中自信地將其設為預設渲染器至關重要。Android 硬體生態系統比 iOS 生態系統更加多元。因此，關於 Impeller 最有用的回饋應包括有關發生問題的特定設備和 Android 版本的詳細資訊。</p>
<h4 id="改進縮放圖片的預設值"><a href="#改進縮放圖片的預設值" class="headerlink" title="改進縮放圖片的預設值"></a>改進縮放圖片的預設值</h4><p>在此版本中，圖片的預設 <code>FilterQuality</code> 已從 <code>FilterQuality.low</code> 變更為 <code>FilterQuality.medium</code>。當一個大型圖片比其目標矩形大很多時（這是一個常見的情況），<code>FilterQuality.low</code> 會導致圖片看起來更加「像素化」，並且渲染速度比 <code>FilterQuality.medium</code> 慢。未來，團隊還將探索更適合各種 FilterQuality 級別的新名稱。</p>
<h4 id="Flutter-GPU-預覽"><a href="#Flutter-GPU-預覽" class="headerlink" title="Flutter GPU 預覽"></a>Flutter GPU 預覽</h4><p>Flutter 推出了對渲染功能的重大更新，即 Flutter GPU，可在主頻道上使用。此低階圖形 API 允許開發人員使用 Dart 程式碼和 GLSL 著色器建立自訂渲染器，而無需任何原生平台程式碼。</p>
<p>Flutter GPU 擴展了您可以在 Flutter 中直接渲染的內容，啟用進階圖形和 3D 場景。它需要 Impeller 渲染後端，目前在 iOS、macOS 和 Android 上支援。儘管處於早期預覽階段，但 Flutter GPU 的目標是最終支援所有 Flutter 平台。</p>
<p>API 允許完全控制渲染傳遞附件、頂點階段和資料上傳到 GPU。這種靈活性對於建立複雜的渲染解決方案至關重要，從 2D 角色動畫到複雜的 3D 場景。</p>
<p>開發人員可以透過切換到 main channel 並將 flutter_gpu 套件加入到他們的專案中來開始使用 Flutter GPU。接下來的幾個月將看到更多功能和穩定性方面的改進，更高階的渲染函式庫（如 flutter_scene）將簡化這些進階功能的使用。</p>
<p>若要深入了解 Flutter GPU，並了解如何在您的專案中利用它，請查看詳細的 <a href="https://medium.com/flutter/getting-started-with-flutter-gpu-f33d497b7c11">Flutter GPU 部落格文章</a>。無論您是建立遊戲還是複雜的圖形，Flutter 的全新 GPU 功能都讓它成為產品的強大選擇。</p>
<h3 id="網頁"><a href="#網頁" class="headerlink" title="網頁"></a>網頁</h3><h3 id="多視圖嵌入"><a href="#多視圖嵌入" class="headerlink" title="多視圖嵌入"></a>多視圖嵌入</h3><p>Flutter Web 應用程式現在可以利用多視圖嵌入，讓開發人員可以將內容同時渲染到多個 HTML 元素中。此功能稱為「嵌入模式」或「多視圖」，為將 Flutter 視圖整合到現有的 Web 應用程式中提供了靈活性。</p>
<p>在多視圖模式下，Flutter Web 應用程式不會在啟動時立即渲染。相反，它會等到主機應用程式使用 addView 方法加入第一個「視圖」。主機應用程式可以動態加入或移除這些視圖，Flutter 會根據需要調整其 Widget。</p>
<p>若要啟用多視圖模式，請在 <code>flutter_bootstrap.js</code> 檔案中的 <code>initializeEngine</code> 方法中設定 <code>multiViewEnabled: true</code>。然後，可以從 JavaScript 管理視圖，將它們加入到指定的 HTML 元素中，並根據需要移除它們。每次加入和移除視圖都會觸發 Flutter 中的更新，允許動態內容渲染。</p>
<p>此功能對於將 Flutter 整合到需要多個獨立 Flutter 視圖的複雜 Web 應用程式中特別有用。它還支援每個視圖的自訂初始化資料，啟用個人化的設定和互動式體驗。</p>
<p>若要深入了解如何在 Flutter 網頁應用程式中實作多視圖嵌入，請查看 <a href="https://docs.flutter.dev/platform-integration/web/embedding-flutter-web">詳細的文件</a>。</p>
<h3 id="變現"><a href="#變現" class="headerlink" title="變現"></a>變現</h3><h3 id="影片廣告變現支援"><a href="#影片廣告變現支援" class="headerlink" title="影片廣告變現支援"></a>影片廣告變現支援</h3><p>我們推出了一個新的 <a href="https://pub.dev/packages/interactive_media_ads">互動式媒體廣告 (IMA) Plugin</a>，以支援 Flutter 行動應用程式中的串流影片廣告變現。新的 IMA Plugin 為 Flutter 應用程式提供了新的廣告變現機會，這些機會建立在現有的 <a href="https://pub.dev/packages/google_mobile_ads">Google 行動廣告 (GMA) Plugin</a> 之上，該 Plugin 主要支援展示廣告格式。</p>
<p>串流影片廣告通常在影片內容播放之前（開頭廣告）、期間（中間廣告）或之後（結尾廣告）顯示給使用者。一些串流影片廣告也可以跳過。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/836/0*_c0s8KMdLNyfxOMQ" />
</figure>

<p><strong>Flutter IMA 的優點：</strong></p>
<ul>
<li>在 Flutter 應用程式中無縫變現影片播放器內容。例如，當應用程式使用者點擊影片內容上的播放時，您現在可以實作 Flutter IMA Plugin 以首先向使用者顯示一個 15 秒的廣告，然後再開始播放影片內容。</li>
<li>利用原生 IMA SDK 的相同優點，包括存取 Google 優質廣告需求和行業標準合規性（例如 <a href="https://iabtechlab.com/standards/vast/">IAB VAST</a>）。</li>
</ul>
<p>初始發佈版本目前支援 Android 和 iOS 平台上的開頭影片廣告。中間廣告支援將很快提供。我們鼓勵您開始在 Flutter 應用程式影片內容中探索新的 IMA Plugin。如果您在 <a href="https://github.com/flutter/flutter/issues?q=is:issue+is:open+label:%22p:+interactive_media_ads%22">GitHub</a> 上遇到任何問題或疑慮，請告知我們。</p>
<p>資源：<a href="https://pub.dev/packages/interactive_media_ads">Plugin 指南</a>，<a href="https://pub.dev/packages/interactive_media_ads/example">範例應用程式</a>，<a href="https://github.com/flutter/packages/tree/main/packages/interactive_media_ads">Git 儲存庫</a></p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><h3 id="Swift-Package-Manager-初始支援"><a href="#Swift-Package-Manager-初始支援" class="headerlink" title="Swift Package Manager 初始支援"></a>Swift Package Manager 初始支援</h3><p>今天，Flutter 使用 CocoaPods 來管理原生 iOS 或 macOS 相依。</p>
<p>Flutter 3.24 加入了對 Swift Package Manager 的早期支援。這帶來了許多優點，包括：</p>
<ol>
<li><strong>存取 Swift 套件生態系統</strong>。Flutter Plugin 將能夠利用不斷發展的 <a href="https://swiftpackageindex.com/">Swift 套件</a> 生態系統！</li>
<li><strong>簡化 Flutter 安裝</strong>。Swift Package Manager 與 Xcode 捆綁在一起。未來，您將不再需要安裝 Ruby 和 CocoaPods 來為 Apple 平台使用 Flutter。</li>
</ol>
<p>我們鼓勵 Plugin 作者 <a href="https://docs.flutter.dev/packages-and-plugins/swift-package-manager/for-plugin-authors#how-to-add-swift-package-manager-support-to-an-existing-flutter-plugin">嘗試將 Swift Package Manager 支援加入到您的 Plugin 中</a>，並提供您體驗的回饋。</p>
<p>如果您對 Flutter 對 Swift Package Manager 的支援有任何回饋，請 <a href="https://github.com/flutter/flutter/issues/new/choose">提交議題</a>。</p>
<h3 id="生態系統"><a href="#生態系統" class="headerlink" title="生態系統"></a>生態系統</h3><h3 id="Shared-Preferences-設定-Plugin-更新"><a href="#Shared-Preferences-設定-Plugin-更新" class="headerlink" title="Shared Preferences 設定 Plugin 更新"></a>Shared Preferences 設定 Plugin 更新</h3><p>我們已在 <a href="https://pub.dev/packages/shared_preferences">shared_preferences</a> Plugin 中加入了兩個新的 API，SharedPreferencesAsync 和 SharedPreferencesWithCache。最重大的變化是 Android 實作使用 Preferences DataStore 而不是 Shared Preferences。</p>
<p>SharedPreferencesAsync 允許使用者直接調用平台以獲取設備上儲存的最新偏好設定，代價是異步和比使用快取版本稍微慢一些。這對於可以由其他系統或隔離區更新的偏好設定很有用，這些偏好設定會使快取過時。</p>
<p>SharedPreferencesWithCache 建立在 SharedPreferencesAsync 之上，允許使用者同步存取偏好設定的本地快取副本。這與舊的 API 相似，但現在可以透過不同的參數多次實例化。</p>
<p>這些新的 API 旨在將來替換目前的 SharedPreferences API。但是，這是生態系統中最常用的 Plugin 之一，我們知道生態系統需要時間才能轉換到新的 API。</p>
<h3 id="Flutter-和-Dart-套件生態系統峰會歐洲-2024"><a href="#Flutter-和-Dart-套件生態系統峰會歐洲-2024" class="headerlink" title="Flutter 和 Dart 套件生態系統峰會歐洲 2024"></a>Flutter 和 Dart 套件生態系統峰會歐洲 2024</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fWo9ieYzQcJjwQBi" />
</figure>

<p>作為 Fluttercon Europe 2024 的一部分，我們舉辦了首屆面對面 Flutter 和 Dart 套件生態系統峰會。這是繼我們於 2023 年 8 月舉辦的第一屆虛擬峰會之後。<a href="https://docs.google.com/document/d/e/2PACX-1vRFLdpIJYO5YPARcyUT1FYPzwkFb1hxh_agqnCXxsyirXocLZS5jobs3xFV5ZGpSQHLHZiBzqbJlXNV/pub">在此</a>查看討論會的重點摘要。</p>
<p>我們很高興地宣布，下一屆峰會將於 2024 年 9 月 20 日在紐約市舉行的 <a href="https://flutterconusa.dev/">Fluttercon USA</a> 舉行！如果您是套件作者或貢獻者，並且將參加 Fluttercon USA 2024，請 <a href="https://rsvp.withgoogle.com/events/flutter-package-ecosystem-summit-usa-2024">註冊</a> 以保留您的峰會席位。</p>
<p>峰會匯集了套件作者和維護者，進行了以下主題的 unconference-style 議程：</p>
<ul>
<li>議程 1 - 原生互操作的過去、現在和未來</li>
<li>議程 2 - 可持續的套件維護模型</li>
<li>議程 3 - 解決套件生態系統碎片化問題</li>
</ul>
<p>我們相信峰會，特別是在更通用的 Flutter 和 Dart 活動的一部分時，是社群之間公開討論的有價值的平台，用於找出關鍵挑戰和集思廣益解決方案。我們期待與社群合作，在未來舉辦更多此類峰會。</p>
<h3 id="DevTools-和-IDE"><a href="#DevTools-和-IDE" class="headerlink" title="DevTools 和 IDE"></a>DevTools 和 IDE</h3><p>此版本包含一些對 Flutter DevTools 工具套件的令人興奮的改進。</p>
<p>如果您曾經想知道您的 Flutter 應用程式是否建立了比預期更多的 Widget，那麼 <strong>DevTools 效能</strong> 工具中的一個新功能可以幫助您。使用新的 <strong>重新建立統計資料</strong> 功能，您可以捕獲有關應用程式中或甚至特定 Flutter 畫面中 Widget 建立次數的資訊。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/749/0*7LXjXlFR9w-VR6xk" />
</figure>

<p><em>DevTools 效能工具的螢幕截圖，追蹤重新建立統計資料。</em></p>
<p>我們已為 <strong>網路分析工具</strong> 和 <strong>Flutter Deep Links 工具</strong> 等工具加入了潤色和關鍵錯誤修復，並且進行了一些一般性改進，以在您從 IDE 中使用 DevTools 時為您提供更好的體驗。說到 IDE，您知道您可以在 IDE 中直接使用每個 DevTools 工具嗎？</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tdpToIuTd-mBq-_R" />
</figure>

<p><em>DevTools 螢幕在 VS Code 視窗中打開。</em></p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*QvoXCNqqfsrMn1oC" />
</figure>

<p><em>DevTools 螢幕在 Android Studio 工具視窗中打開。</em></p>
<p>此版本包含對 VS Code 中的 Flutter 側邊欄的改進，讓您更容易存取您正在尋找的工具。升級到最新版本的 VS Code 和 Flutter 和 Dart 擴展，以存取改進的側邊欄。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/318/0*BzEybhMlV-SnSZZl" />
</figure>

<p><em>Flutter 側邊欄是自適應的，可以調整大小以適合您的工作區</em></p>
<p>此版本還包含對 <a href="https://docs.flutter.dev/tools/devtools/extensions">DevTools Extensions</a> 框架的一些重大改進。您現在可以在除錯 Dart 或 Flutter 測試時使用 DevTools 擴展（由您的套件相依之一提供的工具），或者甚至在您沒有除錯任何內容時，但只是在 IDE 中撰寫程式碼時使用。因此，如果您想在這些使用者旅程中使用工具（或建立工具！），現在已經可以了。</p>
<p>若要進一步了解 Flutter 3.24 中包含的所有更新，請查看 DevTools 的發行備註 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.35.0">2.35.0</a>，<a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.36.0">2.36.0</a> 和 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.37.2">2.37.2</a>。</p>
<h3 id="重大變更和棄用"><a href="#重大變更和棄用" class="headerlink" title="重大變更和棄用"></a>重大變更和棄用</h3><p>此版本中的重大變更包括對 <a href="https://docs.flutter.dev/release/breaking-changes/navigator-and-page-api">Navigator 的頁面 API</a>、<a href="https://docs.flutter.dev/release/breaking-changes/popscope-with-result">PopScope 中的泛型</a>、<a href="https://docs.flutter.dev/platform-integration/web/renderers">Flutter 網頁的預設渲染器</a> 的變更，以及一些新的棄用。在 <a href="https://docs.flutter.dev/release/breaking-changes">重大變更頁面</a> 上查看完整的遷移指南。</p>
<p>與往常一樣，非常感謝社群為 <a href="https://github.com/flutter/tests/blob/master/README.md">貢獻測試</a> - 這些測試幫助我們識別出這些重大變更。若要進一步了解，請查看 <a href="https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes">Flutter 的重大變更政策</a>。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>Flutter 成功背後的核心是您 - 我們非凡的社群。沒有您无數的貢獻和堅定的熱情，這個版本是不可能實現的。我們衷心感谢您。</p>
<p>若要深入了解此版本中所取得的成果，我們邀請您查看 <a href="https://docs.flutter.dev/release/release-notes/release-notes-3.24.0">發行備註</a> 和 <a href="https://github.com/flutter/flutter/blob/main/CHANGELOG.md">變更日誌</a>，以獲取 Flutter 3.24 中加入的內容的完整列表。</p>
<p>Flutter 3.24 與 Dart 3.5 現在已在 stable channel 上提供。開始使用 Flutter 的最新旅程就像運行 flutter upgrade 一樣簡單。我們迫不及待想看看您會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6c040f87d1e4" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/whats-new-in-flutter-3-24-6c040f87d1e4">Flutter 3.24 的新功能</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/773d803a.html" data-id="cm1ntp44g000bv517enaa9fmp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2024-05-30T15:37:07.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/3378cc1.html" class="article-date">
  <time datetime="2024-05-30T07:37:07.000Z" itemprop="datePublished">2024-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/3378cc1.html">【文章翻譯】All the Flutter news from a busy Google I/O 2024</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="掌握-Google-I-O-2024-的所有重要產品更新、新資源和成功案例"><a href="#掌握-Google-I-O-2024-的所有重要產品更新、新資源和成功案例" class="headerlink" title="掌握 Google I&#x2F;O 2024 的所有重要產品更新、新資源和成功案例"></a>掌握 Google I&#x2F;O 2024 的所有重要產品更新、新資源和成功案例</h2><p>很難相信 <a href="https://io.google/2024/">Google I&#x2F;O 2024</a> 已經過去兩週了。我們對 Flutter 社群的支持表示衷心的感謝 - 那裡的能量令人振奮！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/549/1*--DvqdXSA38rPuqMK5c0tQ.png" />
<figcaption>Flutter logo illustration</figcaption>
</figure>

<p>我們在幾個部落格、影片和活動中分享了許多產品更新、資源、開發人員故事、技術會議和工作坊 - 我們知道很難記住所有內容。</p>
<p>在下面，您將找到我們在 Google I&#x2F;O 2024 中分享的所有內容的概覽，以及關於您可以在柏林、班加羅爾、北京的 I&#x2F;O Connect 活動和整個夏季的 I&#x2F;O Extended 活動中與我們和其他 Flutter 社群成員聯繫的活動地點和日期的更新。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fx2WOHonEwqM&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dx2WOHonEwqM&amp;image=http%3A%2F%2Fi.ytimg.com%2Fvi%2Fx2WOHonEwqM%2Fhqdefault.jpg&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/712779b5030e3328a07a329d72a40505/href">https://medium.com/media/712779b5030e3328a07a329d72a40505/href</a></iframe>

<h3 id="部落格文章"><a href="#部落格文章" class="headerlink" title="部落格文章"></a>部落格文章</h3><p>我們在 Dart 和 Medium 的部落格中發佈了 <strong>四篇新的部落格文章</strong>：</p>
<ul>
<li><a href="https://medium.com/flutter/io24-5e211f708a37">在 Google I&#x2F;O 2024 中推出 Flutter 3.22 和 Dart 3.4</a></li>
<li><a href="https://medium.com/flutter/fbde6c164fe3">Flutter 3.22 的新功能</a></li>
<li><a href="https://medium.com/flutter/announcing-the-winners-of-the-global-gamers-challenge-1ccf4d271226">宣布全球玩家挑戰賽的獲獎者</a></li>
<li><a href="https://medium.com/dartlang/dart-3-4-bd8d23b4462a">宣布 Dart 3.4</a></li>
</ul>
<p>我們還與 Android 團隊合作了一篇部落格文章，提供了一些關於 <strong>如何為您的專案選擇合適的框架</strong> 的指導; Flutter、Jetpack Compose 和 Kotlin 多平台：</p>
<ul>
<li><a href="https://developers.googleblog.com/en/making-development-across-platforms-easier-for-developers/">讓開發人員更容易跨平台開發</a></li>
</ul>
<h3 id="Google-I-O-演講、Codelab-和工作坊"><a href="#Google-I-O-演講、Codelab-和工作坊" class="headerlink" title="Google I&#x2F;O 演講、Codelab 和工作坊"></a>Google I&#x2F;O 演講、Codelab 和工作坊</h3><p>主要的 Google I&#x2F;O 活動重點介紹了 Dart 和 Flutter 的精彩演講。我們建議您從 <a href="https://www.youtube.com/watch?v=lpnKWK-KEYs">Flutter 的新功能</a> <strong>主旨演講</strong> 開始，然後繼續到我們的 <a href="https://io.google/2024/explore/?q=technical-session,flutter">五場技術會議</a>，這些會議涵蓋了 CameraX、適應性 UI、AI 代理、Gemini 和應用程式深層鏈接等主題。</p>
<p>我們還提供了 <a href="https://io.google/2024/explore/?q=codelab,flutter">三個新的 Codelab</a>，全部集中在使用 Flutter 創建 <a href="https://flutter.dev/games">休閒遊戲</a>。它們可以幫助您開始使用 2D 物理以及添加聲音和音樂。若要了解更多詳細資訊，請查看新的 <a href="https://io.google/2024/explore/?q=workshop,flutter">2D 物理遊戲工作坊</a>。</p>
<h3 id="新的-Flutter-展示案例故事"><a href="#新的-Flutter-展示案例故事" class="headerlink" title="新的 Flutter 展示案例故事"></a>新的 Flutter 展示案例故事</h3><p><a href="https://flutter.dev/showcase">Flutter 展示案例</a> 展示了一系列 Flutter 應用程式，這些應用程式展示了您可以在行動、網頁和桌面端使用 Flutter 创建的引人入勝的使用者體驗。我們為 Google I&#x2F;O 2024 添加了 <strong>四個新的展示案例故事</strong>：</p>
<ul>
<li><a href="https://flutter.dev/showcase/universal-studios">環球影城</a>：<em>環球影城使用 Flutter 打造下一代體驗</em></li>
<li><a href="https://flutter.dev/showcase/supercell">Supercell</a>：<em>Flutter 帮助 Supercell 将 Supercell ID 核心代码大小减少了 45%</em></li>
<li><a href="https://flutter.dev/showcase/etermax">Etermax</a>：<em>Etermax 使用 Flutter 提高了開發人員效率</em></li>
<li><a href="https://flutter.dev/showcase/virgin-money">维珍金融</a>：<em>维珍金融使用 Flutter 统一了应用程序开发</em></li>
</ul>
<h3 id="I-O-Connect-活动"><a href="#I-O-Connect-活动" class="headerlink" title="I&#x2F;O Connect 活动"></a>I&#x2F;O Connect 活动</h3><p>Google I&#x2F;O 并没有以 <a href="https://io.google/2024/">主要活动</a> 在美国加州山景城的海岸线结束。全球有許多 <a href="https://gdg.community.dev/ioextended/">Google I&#x2F;O 社群活動</a>，以及 <a href="https://developers.google.com/events">Google I&#x2F;O Connect</a> 活動，計劃在三個地點舉行：</p>
<ul>
<li>2024 年 6 月 27 日，德國柏林 I&#x2F;O Connect</li>
<li>2024 年 7 月 17 日，印度班加羅爾 I&#x2F;O Connect</li>
<li>2024 年 8 月 7-8 日，中國北京 I&#x2F;O Connect</li>
</ul>
<p>Dart 和 Flutter 團隊將出席所有三場 I&#x2F;O Connect 活動，我們希望與你們中的許多人聯繫！如果您想參加活動，請務必 <a href="https://developers.google.com/events">註冊</a>。我們期待與您聯繫！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7c963c064f8d" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/all-the-flutter-news-from-a-busy-google-i-o-2024-7c963c064f8d">忙碌的 Google I&#x2F;O 2024 中所有 Flutter 消息</a> 最初发布在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人们在那里通过突出显示和回应这个故事来继续讨论。</p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/3378cc1.html" data-id="cm1ntp44g0009v51753ki20jx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2024-05-14T20:36:19.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/d685d4ac.html" class="article-date">
  <time datetime="2024-05-14T12:36:19.000Z" itemprop="datePublished">2024-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/d685d4ac.html">【文章翻譯】Announcing the winners of the Global Gamers Challenge</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布全球遊戲挑戰賽的獲獎者"><a href="#宣布全球遊戲挑戰賽的獲獎者" class="headerlink" title="宣布全球遊戲挑戰賽的獲獎者"></a>宣布全球遊戲挑戰賽的獲獎者</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*S_bBN0WiR_Q5F08J" />
</figure>

<p>我們邀請 Flutter 和 Global Citizen 社群共同合作，打造以幫助地球為中心的史詩級 Flutter 遊戲。數千名來自 50 多個國家的熱情開發人員提交了數百個創新的遊戲專案。</p>
<p>每個專案都旨在賦予玩家知識和行動，以保護我們的星球。從資源保護到對抗污染，這些遊戲不僅提高了我們對緊迫環境問題的集體意識，而且玩起來非常有趣！我們深受參賽作品中令人難以置信的想法和熱情所鼓舞。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F_GgqdB9md1w&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D_GgqdB9md1w&amp;image=http%3A%2F%2Fi.ytimg.com%2Fvi%2F_GgqdB9md1w%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/f79ed19f8ef6235e83b919df5506662f/href">https://medium.com/media/f79ed19f8ef6235e83b919df5506662f/href</a></iframe>

<h3 id="為我們的十大項目敲響最後的鼓聲"><a href="#為我們的十大項目敲響最後的鼓聲" class="headerlink" title="為我們的十大項目敲響最後的鼓聲"></a>為我們的十大項目敲響最後的鼓聲</h3><p>在 103 天的時間裡，這些專案團隊一直在構思、構建、尋求回饋並改進他們的專案。結果——令人興奮的遊戲，鼓勵我們所有人更深入地思考我們如何才能更可持續地生活。以下是他們，按字母順序排列！</p>
<h4 id="Better-World"><a href="#Better-World" class="headerlink" title="Better World"></a><a href="https://devpost.com/software/wip-au-flutter-game">Better World</a></h4><p>包含各種環境主題、色彩繽紛的視覺效果和音樂，以及與組織合作以促進積極行動的想法。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/1*tC1QJGzd_UQhSNuapBbFlA.gif" />
</figure>

<h4 id="Craftown"><a href="#Craftown" class="headerlink" title="Craftown"></a><a href="https://devpost.com/software/craftown">Craftown</a></h4><p>經典即時策略和資源管理遊戲的獨特融合，重點關注可持續發展主題。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/0*5-BTF74D9iY2W-eg" />
</figure>

<h4 id="EcoShift-Chronicles"><a href="#EcoShift-Chronicles" class="headerlink" title="EcoShift Chronicles"></a><a href="https://devpost.com/software/ecoshift-chronicles">EcoShift Chronicles</a></h4><p>以迷人的視覺效果和聲音設計鼓勵積極行動，向玩家展示可理解的選擇及其環境後果。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/0*2tKU55OoZoT6H8Df" />
</figure>

<h4 id="Gomiland"><a href="#Gomiland" class="headerlink" title="Gomiland"></a><a href="https://devpost.com/software/gomiland">Gomiland</a></h4><p>視覺上吸引人、具有教育意義的垃圾管理遊戲，靈感來自日本文化。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/0*9PUEQpgttn8Oib0e" />
</figure>

<h4 id="Last-Bottle"><a href="#Last-Bottle" class="headerlink" title="Last Bottle"></a><a href="https://devpost.com/software/last-bottle">Last Bottle</a></h4><p>迷人的設計和收藏元素，有效地傳達了其關於回收限制和批判性思考環境問題的核心信息。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/0*W8ns7jNJ3jZ0SXbd" />
</figure>

<h4 id="MGame-A-waste-management-game"><a href="#MGame-A-waste-management-game" class="headerlink" title="MGame - A waste management game"></a><a href="https://devpost.com/software/mgame-a-waste-management-game">MGame - A waste management game</a></h4><p>雄心勃勃的模擬遊戲，以引人入勝的方式講述複雜的垃圾管理系統，讓人想起經典的城市建設遊戲。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/0*jof-AXtEcUz1_WFL" />
</figure>

<h4 id="Ocean-Rangers"><a href="#Ocean-Rangers" class="headerlink" title="Ocean Rangers"></a><a href="https://devpost.com/software/projectocean">Ocean Rangers</a></h4><p>引人入勝的故事、引人入勝的角色和策略性遊戲元素為一個熟悉的類型提供了一個帶有環境主題的獨特視角。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/0*P1nBcfMDFwveciQu" />
</figure>

<h4 id="PlasticPunk"><a href="#PlasticPunk" class="headerlink" title="PlasticPunk"></a><a href="https://devpost.com/software/plasticpunk">PlasticPunk</a></h4><p>城市建設風格的遊戲，透過引人入勝的遊戲性和迷人的視覺效果呈現一個複雜的環境挑戰。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/0*9lzHmRWHxSyGI8pl" />
</figure>

<h4 id="Waste-Wise"><a href="#Waste-Wise" class="headerlink" title="Waste Wise"></a><a href="https://devpost.com/software/waste-wise">Waste Wise</a></h4><p>垃圾分類遊戲，具有直觀的遊戲玩法，有效地教育玩家關於正確的垃圾處理。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/0*m_Lo2d9Tfr1eqyUw" />
</figure>

<h4 id="Whaley’s-Bins-Waste-Sorting"><a href="#Whaley’s-Bins-Waste-Sorting" class="headerlink" title="Whaley’s Bins Waste Sorting"></a><a href="https://devpost.com/software/whaley-s-bins-waste-sorting">Whaley’s Bins Waste Sorting</a></h4><p>垃圾分類遊戲，以創意的方式進行垃圾回收教育，採用獨特的像素藝術視覺效果。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/0*4TtFim6qaLkM0-rj" />
</figure>

<p>我們期待在紐約市的 Google 辦公室與這些團隊共度一天，進行研討會等活動，並在 2024 年全球公民節上與其他 60,000 名全球公民一起慶祝！</p>
<p>但是，這些只是超過 30 支獲得全球遊戲挑戰賽獎品的團隊中的 10 支，包括其他進入前 20 名的團隊，您將在「榮譽提名」列表中看到他們。前往 <a href="http://flutter.dev/global-gamers/#winners">flutter.dev&#x2F;global-gamers&#x2F;#winners</a> 查看所有獲獎者！</p>
<p>恭喜所有獲獎者！</p>
<h3 id="這並不代表結束"><a href="#這並不代表結束" class="headerlink" title="這並不代表結束"></a>這並不代表結束</h3><p><em>作者：Lisa Pak，Playing 4 the Planet 聯盟運營主管</em></p>
<p>全球遊戲挑戰賽可能即將結束，但可持續遊戲運動並不會就此結束。在挑戰期間開發的遊戲，以及類似的挑戰，例如 <a href="https://globalgamejam.org/">全球遊戲果醬</a>，有可能接觸到數百萬玩家，在全球範圍內產生積極的環境變革。</p>
<p>以下是一些保持與這個蓬勃發展的運動保持聯繫的方式：</p>
<ul>
<li><strong>加入社群：</strong> 考慮加入專注於具有環保意識的遊戲設計的線上社群和論壇。這些空間提供寶貴的機會，讓您可以分享您的作品並與其他開發者交流想法。</li>
<li><strong>持續玩可持續遊戲：</strong> 注意包含綠色啟動的 <a href="https://globalgamejam.org/">熱門遊戲</a>，例如限時活動、挑戰和新關卡，以讓玩家參與這個重要議題。我們的目標是接觸到盡可能多的人，這些遊戲可能是很好的靈感來源。</li>
<li><strong>讓您的聲音被聽到：</strong> 撰寫您關於可持續遊戲開發的經驗，指導有抱負的開發者，或組織自己的活動。在分享您的知識和專業知識時，無論是技術方面還是環境方面，您不僅支持社群的發展，而且激勵他人開發對地球產生積極影響的遊戲。</li>
</ul>
<h3 id="繼續構建"><a href="#繼續構建" class="headerlink" title="繼續構建"></a><strong>繼續構建</strong></h3><p><em>作者：Clayton Whittle，氣候 SIG 聯席主席</em></p>
<p>遊戲中的可持續發展包括促進運動本身，優先考慮您的團隊遊戲設計實務中的氣候和可持續發展問題，並持續成為可持續遊戲產業的代言人。</p>
<p>綠色遊戲設計是一個不斷發展的領域，具有越來越精細的實務，用於開發能夠產生有形和可衡量影響的遊戲。雖然沒有通用的綠色遊戲設計規則，但遵守標準指南可以顯著地使任何遊戲設計團隊受益。</p>
<ul>
<li><strong>了解您的受眾：</strong> 有效的可持續遊戲始於了解您的受眾的需求和能力。由於可持續遊戲的目標是從某種程度上改變玩家，因此了解您的受眾對於引導這種轉變至關重要。如果您不知道您的受眾在最初的立場在哪裡，那麼要引導他們到預期的終點就會很困難。</li>
<li><strong>要具體：</strong> 集中您的信息以提高其有效性。試圖用一個遊戲來改變玩家的整個世界觀是不切實際的。相反，要找出可以進行變化的特定領域。</li>
<li><strong>促進有效的行動：</strong> 為玩家提供可操作的知識。教導他們可以採取的具有影響力的行動，以做出改變。如果玩家看到他們的行動如何影響生態系統或社會，他們更有可能參與。</li>
<li><strong>注意 <a href="https://en.wikipedia.org/wiki/Greenwashing">綠色洗腦</a>：</strong> 避免表面上的可持續發展努力。綠色洗腦涉及標誌性的可持續性元素，這些元素並沒有真正整合可持續性問題。雖然加入綠色的藝術作品或將角色命名為「回收隊長」似乎很吸引人，但如果遊戲玩法或敘事缺乏有意義的可持續性行動，玩家就會看穿這些表面上的聯繫。</li>
</ul>
<p>請記住，開發具有影響力的綠色遊戲有數不清的方法。您的想法和設計可能超越這些指南進入未知領域。適合您團隊的方法取決於您的使命和受眾。但是，將這些原則納入您的設計討論中，可以幫助確保您的團隊始終關注其影響力使命。</p>
<h3 id="Flutter-如何幫助"><a href="#Flutter-如何幫助" class="headerlink" title="Flutter 如何幫助"></a><strong>Flutter 如何幫助</strong></h3><p>以下是一些 Flutter 如何幫助您減少對遊戲運行位置的擔憂時間，並投入更多時間為您的使命和受眾設計具有影響力的體驗的方式：</p>
<ul>
<li><strong>Flutter 效率高：</strong> 使用 Flutter 的單一程式碼庫開發意味著您只需要編寫一次遊戲，並在各個平台上部署。狀態熱重載等功能可以幫助您快速迭代，加快開發流程。</li>
<li><strong>Flutter 容易學習：</strong> 即使您不是職業遊戲開發人員，從 Flutter 開始也比使用傳統遊戲開發工具更容易。我們還提供了一些資源，例如 <a href="http://flutter.dev/games">Flutter 休閒遊戲工具包</a> 中的遊戲模板，它們可以為您提供起步平台，提升您的遊戲開發技能。</li>
</ul>
<p>感謝大家加入我們的旅程！我們迫不及待想看看您接下來會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1ccf4d271226" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/announcing-the-winners-of-the-global-gamers-challenge-1ccf4d271226">宣布全球遊戲挑戰賽的獲獎者</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/d685d4ac.html" data-id="cm1ntp44f0007v5172o4r8ibw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2024-05-14T20:34:31.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/9e5e250f.html" class="article-date">
  <time datetime="2024-05-14T12:34:31.000Z" itemprop="datePublished">2024-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/9e5e250f.html">【文章翻譯】What’s new in Flutter 3.22</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Flutter-3-22-的新功能：WebAssembly、圖形渲染增強功能，以及更多-AI-整合選項"><a href="#Flutter-3-22-的新功能：WebAssembly、圖形渲染增強功能，以及更多-AI-整合選項" class="headerlink" title="Flutter 3.22 的新功能：WebAssembly、圖形渲染增強功能，以及更多 AI 整合選項"></a>Flutter 3.22 的新功能：WebAssembly、圖形渲染增強功能，以及更多 AI 整合選項</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hf9CEzGh0uhxnzVZi2Kk4g.png" />
</figure>

<p>歡迎回來體驗另一個令人興奮的 Flutter 穩定版本！這次，我們很高興推出 Flutter 3.22。我們將 WebAssembly 帶到了 stable channel，為 Android 上的 Impeller 提供了一個功能齊全的 Vulkan 後端，它承諾提供更流暢的圖形和更大的效能提升。我們還通過新的 Widget 狀態屬性、動態視圖大小調整和改進的表格驗證引入了簡化的工作流程。但這還不是全部 - 您會發現風味條件資產捆綁、Dart 中的 Firebase Vertex AI 預覽以及更新的 DevTools，讓您的生活更輕鬆。</p>
<p>自我們上次更新以來，僅僅幾個月的時間，我們就從 Flutter 社群合併了令人印象深刻的 1595 個 pull request，其中 37 位新社群成員第一次為 Flutter 做出了貢獻！</p>
<p>因此，深入了解 Flutter 社群帶給這個最新版本的最新功能和增強功能吧！</p>
<h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><p>隨著 Flutter 3.22 的發佈，Wasm 現在可在 stable channel 上使用，提供了顯著的效能提升。在我們使用 M1 MacBook 上的 Chrome 進行的內部基準測試中，Wonderous 應用程式的畫面渲染時間平均提高了 2 倍，在最壞情況下提高了 3 倍。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/719/0*x6HEkml8cFGc96hg" />
</figure>

<p>這些增強功能對於具有動畫和豐富轉場的應用程式至關重要，在這些應用程式中，保持流暢的畫面率至關重要。Wasm 通過減少效能瓶頸來幫助實現這一點，從而實現更流暢的動畫和轉場。若要開始使用 Flutter Web 應用程式中的 Wasm，請查看我們的 <a href="https://dart.dev/web/wasm">Dart Wasm 文件</a> 和 <a href="https://docs.flutter.dev/platform-integration/web/wasm">Flutter Wasm 文件</a>。如需完整公告，請訪問 <a href="https://medium.com/flutter/io24-5e211f708a37">Flutter 在 Google I&#x2F;O 部落格文章</a>。</p>
<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>Flutter 3.22 對 Impeller 進行了重大更新，Impeller 是為您的 Flutter 應用程式提供渲染功能的渲染引擎。主要亮點包括為 Android 完成 Vulkan 後端，以實現更流暢的圖形和改進的效能，對模糊效果和複雜路徑渲染進行持續優化，以及一個用於測試 Impeller 的全新實驗性 API。根據我們的 <a href="https://github.com/flutter/flutter/wiki/Roadmap#core-framework--engine">路線圖</a>，我們致力於提高 Impeller 的品質和效能，包括完成 iOS 對 Impeller 的遷移和擴展 Android 支援。</p>
<h4 id="Impeller"><a href="#Impeller" class="headerlink" title="Impeller"></a>Impeller</h4><h4 id="Android-上的-Vulkan-後端功能完整"><a href="#Android-上的-Vulkan-後端功能完整" class="headerlink" title="Android 上的 Vulkan 後端功能完整"></a><strong>Android 上的 Vulkan 後端功能完整</strong></h4><p>在此版本中，Impeller 的 Android Vulkan 後端功能完整。特別是，在過去的幾個月裡，團隊一直在努力完成 <a href="https://github.com/flutter/engine/pull/50154">快速高級混合</a> 的實作、使用 <a href="https://github.com/flutter/engine/pull/49543">FragmentProgram API</a> 支援自定義片段著色器、<a href="https://github.com/flutter/engine/pull/50730">PlatformView</a> 支援（儘管它需要一個 <a href="https://docs.flutter.dev/release/breaking-changes/android-surface-plugins">小型 API 遷移</a>）、以及完全實作 <a href="https://github.com/flutter/flutter/issues/134178">所有模糊樣式</a>。</p>
<h4 id="Android-預覽"><a href="#Android-預覽" class="headerlink" title="Android 預覽"></a>Android 預覽</h4><p>在 3.19 穩定版本中，在發佈了 Impeller 的 OpenGL 後端的改進之後，我們邀請使用者在有和沒有 Vulkan 支援的 Android 設備上嘗試 Impeller。在過去的幾個月裡，在評估了 OpenGL 後端的效能並估計了 Vulkan 後端的剩餘工作量之後，我們決定將精力集中在首先使 Vulkan 後端達到生產就緒狀態。</p>
<p>Impeller 解決了著色器編譯卡頓的問題。此外，在我們的基準測試中，它在平均、第 90 個百分位數和第 99 個百分位數的畫面時間方面優於傳統渲染器。因此，我們認為 Vulkan 後端在 Android 上的效能是可以接受的。在此版本（3.22）中，選擇使用 Impeller 的應用程式將在有可用情況下使用 Vulkan 後端。在未來的版本中，這將成為預設配置。當選擇使用 Impeller 的應用程式在不支持 Vulkan 的設備上運行時，Flutter 將自動優雅地回退到使用帶有 Skia 的 OpenGL ES。您不需要採取任何操作。在將來，當我們認為 OpenGL ES Impeller 後端已達到生產就緒狀態時，這種回退也將使用 Impeller。</p>
<p>隨著 Android 上的 Impeller 預覽繼續在 3.22 穩定版本週期中進行，我們請求 Flutter 開發人員升級到最新的穩定版本，並提交有關在 <a href="https://docs.flutter.dev/perf/impeller#android">啟用 Impeller</a> 時發現的任何不足的錯誤。在此階段的回饋對確保 Impeller 在 Android 上取得成功以及我們能夠在今年晚些時候的版本中自信地將其設為預設渲染器至關重要。Android 硬體生態系統非常多元。因此，關於 Impeller 最有用的回饋應包括有關發生問題的特定設備和 Android 版本的詳細資訊。</p>
<h4 id="模糊效能提升"><a href="#模糊效能提升" class="headerlink" title="模糊效能提升"></a>模糊效能提升</h4><p>模糊已在 iOS 和 Android 上的 Impeller 中 <a href="https://github.com/flutter/engine/pull/47576">重新實作</a>。特別是，這種新方法類似於 Skia 的方法，在 <a href="https://flutter-flutter-perf.skia.org/e/?begin=1699468487&amp;end=1710262311&amp;keys=X01fc3d52ebd6fbf38afef91d82ab8d2b&amp;requestType=0&amp;selected=commit=38815&name=%252Carch%253Dintel%252Cbranch%253Dmaster%252Cconfig%253Ddefault%252Cdevice_type%253DiPhone_11%252Cdevice_version%253Dnone%252Chost_type%253Dmac%252Csub_result%253Daverage_frame_rasterizer_time_millis%252Ctest%253Dbackdrop_filter_perf_ios__timeline_summary%252C&amp;xbaroffset=38815">基準測試</a> 中將模糊的 CPU 和 GPU 時間減少了將近一半。</p>
<p>下圖顯示了在 iPhone 11 設備上，在一個旨在突出顯示模糊效能的病態基準測試中，最壞情況下的第 99 個百分位數、第 90 個百分位數和平均畫面柵格化時間以及 GPU 畫面時間（以毫秒為單位）。在重寫了 Impeller 的模糊之後，背景濾鏡模糊的 CPU 和 GPU 成本都減少了將近一半。這種改進的規模也適用於非病態案例，如典型應用程式中出現的案例。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*mtFyiLoIUSqk_zRB" />
<figcaption>在 iPhone 11 設備上，在一個旨在突出顯示模糊效能的病態基準測試中，第 99 個百分位數、第 90 個百分位數和平均畫面柵格化時間以及 GPU 畫面時間（以毫秒為單位）</figcaption>
</figure>

<h4 id="模板然後覆蓋"><a href="#模板然後覆蓋" class="headerlink" title="模板然後覆蓋"></a>模板然後覆蓋</h4><p>iOS 和 Android 上的 Impeller 已 <a href="https://github.com/flutter/engine/pull/51219">遷移到新的渲染策略</a>，該策略基於 <a href="http://www.opengl-redbook.com/">OpenGL Redbook</a> 中“使用模板緩衝區繪製填充的凹多邊形”一章中描述的模板然後覆蓋方法。團隊成員在 GitHub 議題 <a href="https://github.com/flutter/flutter/issues/123671">＃123671</a> 中討論了此技術在適用於 Flutter 時的更多內容。</p>
<p>這種方法解決了柵格線程花費過多時間在 CPU 上計算複雜路徑（例如 SVG 和 <a href="https://github.com/flutter/flutter/issues/141961">Lottie 動畫</a>）的鑲嵌的問題。在更改之後，包含複雜路徑的畫面的總畫面時間（CPU 上的 UI 線程 + CPU 上的柵格線程 + GPU 工作）要低得多。使用者會注意到 Lottie 動畫和其他複雜路徑的渲染更加流暢，CPU 利用率更低，GPU 利用率略高。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*1lCd7dBwJ0ab_sieDlQNFw.gif" />
<figcaption>(左) Lottie 動畫。以前，Impeller 在最新的 iPhone 上需要 64 毫秒/畫面的柵格線程 CPU 時間來渲染它。（右）在我們實施了模板然後覆蓋優化之後，在同一設備上渲染的相同動畫。柵格時間幾乎快了 10 倍。</figcaption>
</figure>

<p>雖然對這些改进感到滿意，但仍有更多工作要做。除了其他機會以外，我們意識到多邊形生成仍然在 CPU 配置檔中很突出，我們打算調查將這項工作轉移到 GPU，同樣。</p>
<h4 id="新的-API"><a href="#新的-API" class="headerlink" title="新的 API"></a>新的 API</h4><p>儘管仍處於實驗階段，但 flutter test 現在接受 <code>--enable-impeller</code> 標誌，它使用 Vulkan 後端來執行 Impeller。</p>
<h3 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h3><h4 id="Widget-狀態屬性"><a href="#Widget-狀態屬性" class="headerlink" title="Widget 狀態屬性"></a>Widget 狀態屬性</h4><p>MaterialState 已被移出 Material 函式庫並重新命名為 WidgetState，以便它可以被 Cupertino、基本 Flutter 框架和套件作者使用。如需有關遷移到新 WidgetState 的更多資訊，請查看 <a href="https://docs.flutter.dev/release/breaking-changes/material-state">遷移指南</a>。</p>
<h4 id="動態視圖大小調整"><a href="#動態視圖大小調整" class="headerlink" title="動態視圖大小調整"></a>動態視圖大小調整</h4><p>對動態視圖大小調整的 <a href="https://github.com/flutter/flutter/pull/140918">增強功能</a> 有利於構建響應式佈局的開發人員，確保 UI 在各種設備螢幕上具有更好的適應性。</p>
<h4 id="改進的表格驗證"><a href="#改進的表格驗證" class="headerlink" title="改進的表格驗證"></a>改進的表格驗證</h4><p>感謝 Flutter 社群成員 <a href="https://github.com/SharbelOkzan">SharbelOkzan</a> 的 <a href="https://github.com/flutter/flutter/pull/135578">貢獻</a>，Flutter 3.22 帶來了更加靈活的表格驗證方法，允許開發人員建立更加健全的使用者輸入處理，從而提高可用性和安全性。</p>
<h4 id="2D-API-中的協變"><a href="#2D-API-中的協變" class="headerlink" title="2D API 中的協變"></a>2D API 中的協變</h4><p>減少 2D 圖形 API 中需要類型轉換的次數，可以簡化開發工作流程並提高效能，這對於遊戲和複雜動畫至關重要。</p>
<h4 id="風味條件資產捆綁"><a href="#風味條件資產捆綁" class="headerlink" title="風味條件資產捆綁"></a>風味條件資產捆綁</h4><p>使用 <a href="https://docs.flutter.dev/deployment/flavors">風味</a> 功能的開發人員現在可以將個別資產配置為僅在為特定風味構建時捆綁。如需更多信息，請查看 <a href="https://docs.flutter.dev/deployment/flavors#conditionally-bundling-assets-based-on-flavor">根據風味有條件地捆綁資產</a>。</p>
<h4 id="使用-Dart-套件轉換資產"><a href="#使用-Dart-套件轉換資產" class="headerlink" title="使用 Dart 套件轉換資產"></a>使用 Dart 套件轉換資產</h4><p>使用者現在可以將 Dart 套件配置為在捆綁時轉換其應用程式的資產。如需更多信息，請查看 <a href="http://docs.flutter.dev/ui/assets/asset-transformation">在構建時轉換資產</a>。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="深度鏈接"><a href="#深度鏈接" class="headerlink" title="深度鏈接"></a>深度鏈接</h4><p>深度鏈接可以顯著改善 Flutter 應用程式中的使用者體驗，作為捷徑，可以無縫引導使用者到應用程式中的特定內容，提高參與度並推動銷售。雖然 iOS 的通用鏈接和 Android 的應用程序鏈接因其安全性和平易近人的特性而受到高度推薦，但設定它們可能會有點棘手。</p>
<p>在最近的 Flutter 穩定版本中，我們在 DevTools 中引入了一個深度鏈接驗證工具，該工具支援檢查 Android 應用程式的 Web 配置。在此版本中，我們加入了一組新功能，以幫助驗證 Android 清單檔案中的設定。</p>
<p>如需有關使用此工具的更多資訊，請查看 <a href="https://docs.flutter.dev/tools/devtools/deep-links">驗證深度鏈接</a>。</p>
<h4 id="預測性後退手勢"><a href="#預測性後退手勢" class="headerlink" title="預測性後退手勢"></a>預測性後退手勢</h4><p>Flutter 現在為 Android 的預測性後退功能提供更多支援，在這種功能中，使用者可以在後退手勢期間預覽上一個路徑，甚至預覽上一個應用程式。這仍然是 Android 設備上的功能標誌，但您可以在 <a href="https://github.com/flutter/flutter/issues/132504#issuecomment-2025776552">GitHub</a> 上找到有關如何自己嘗試它的詳細信息。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/400/0*8b6DxQuMXAyYVu-w" />
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/400/0*hr_OF9DsfUcsLNHv" />
</figure>

<h4 id="Flutter-工具在-Gradle、AGP、Java-和-Kotlin-上強制執行版本要求"><a href="#Flutter-工具在-Gradle、AGP、Java-和-Kotlin-上強制執行版本要求" class="headerlink" title="Flutter 工具在 Gradle、AGP、Java 和 Kotlin 上強制執行版本要求"></a>Flutter 工具在 Gradle、AGP、Java 和 Kotlin 上強制執行版本要求</h4><p>在此版本中，Flutter 工具強制執行有關它支援的 Gradle、Android Gradle Plugin (AGP)、Java 和 Kotlin 版本的策略。最初，該工具只提供警告。</p>
<p>目前，支援的版本範圍如下：</p>
<ul>
<li>Gradle - 完全支援 7.0.2 到目前版本，否則警告</li>
<li>AGP - 完全支援 7.0.0 到目前版本，否則警告</li>
<li>Java - 完全支援 Java 11 到目前版本，否則警告</li>
<li>Kotlin - 完全支援 1.5.0 到目前版本，否則警告</li>
</ul>
<p>在下次主要發佈版本中，這些警告將變為錯誤，可以使用標誌 <code>--android-skip-build-dependency-validation</code> 覆蓋。更一般地說，該工具在完全放棄支援（生成錯誤）特定版本的這些相依項之前，至少會為一個版本提供警告。</p>
<p>這種策略在 <a href="https://docs.google.com/document/d/1qeeM5QG-jiafttSgvc7yvC19IDRggFFZQTktBVxL6sI/edit?resourcekey=0-HLEAiBOMxAlQxDs-mEeffw">相關設計規格</a> 中進行了討論。評論和回饋始終歡迎。</p>
<h4 id="支援在-Android-上的-Gradle-建構腳本中使用-Gradle-Kotlin-DSL"><a href="#支援在-Android-上的-Gradle-建構腳本中使用-Gradle-Kotlin-DSL" class="headerlink" title="支援在 Android 上的 Gradle 建構腳本中使用 Gradle Kotlin DSL"></a>支援在 Android 上的 Gradle 建構腳本中使用 Gradle Kotlin DSL</h4><p>Gradle Kotlin DSL 現在在 Flutter 中受支援，為傳統的 Gradle Groovy DSL 提供了替代方案。這種支援允許更好的程式碼編輯體驗，包括自動完成、快速存取文檔、來源導航和上下文感知重構。</p>
<p>此初始支援由 GitHub 用戶 <a href="https://github.com/bartekpacia">bartekpacia</a> 貢獻。開發人員現在可以选择使用 Kotlin 重寫其 Gradle 建構腳本，以利用這些優點，儘管 Flutter 工具在使用 flutter create 時還沒有允許在使用 Kotlin 時選擇 Kotlin 而不是 Groovy。</p>
<p>如需更多詳情，請查看由 <a href="https://github.com/bartekpacia">bartekpacia</a> 提交的 <a href="https://github.com/flutter/flutter/pull/140744">PR 140744</a>。</p>
<h4 id="平台視圖改進"><a href="#平台視圖改進" class="headerlink" title="平台視圖改進"></a>平台視圖改進</h4><p><strong>注意所有 Flutter 應用程式開發人員！</strong>如果您使用 Flutter 開發依賴原生 Android 組件（如地圖、Web 視圖或某些 UI 元素）的應用程式，我們有一些重要新聞。</p>
<p>由於 Android 14 中的一個錯誤，使用舊版本 Flutter 構建的應用程式可能無法在運行此新 Android 版本的設備上正常工作。</p>
<p>Flutter 3.22 修復了此問題，並改進了 Android 應用程式中這些原生組件的整體效能。因此，為了確保您的應用程式在所有 Android 設備上順暢運行，請務必使用 Flutter 3.22 重新構建和發佈您的應用程式。</p>
<p>此更新還包含幕後改進，使 Android 上的平台視圖更加可靠和高效。</p>
<h4 id="對-KitKat-的支援結束"><a href="#對-KitKat-的支援結束" class="headerlink" title="對 KitKat 的支援結束"></a>對 KitKat 的支援結束</h4><p>Flutter 現在的最低支援 Android 版本為 Lollipop (API 21)。從 Flutter 的 3.22 穩定版本開始，Flutter 將不再在運行 Android KitKat (API 19) 的設備上工作。如需更多詳情，請查看我們的 <a href="https://docs.flutter.dev/release/breaking-changes/android-kitkat-deprecation">棄用指南</a>。</p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><h4 id="平台視圖效能"><a href="#平台視圖效能" class="headerlink" title="平台視圖效能"></a>平台視圖效能</h4><p>我們了解 iOS 上的平台視圖效能一直是許多 Flutter 開發人員的痛點。這在使用平台視圖時在捲軸視圖中尤為明顯。</p>
<p>最近的更新直接解決了這些擔憂，在嵌入文章中的多個內聯廣告等場景中取得了顯著的改进。以下是我們 <a href="https://github.com/flutter/flutter/pull/144745">基準測試</a> 中的一些主要改進：</p>
<ul>
<li><strong>減少 GPU 使用率：</strong>GPU 使用率降低了 50%，導致功耗降低，使用者體驗可能更加流暢。</li>
<li><strong>改進畫面渲染：</strong>平均畫面渲染時間減少了 1.66 毫秒（33%）。</li>
<li><strong>最小化卡頓：</strong>最壞情況下的畫面渲染時間減少了 3.8 毫秒（21%）。</li>
</ul>
<p>如果您之前在捲軸視圖中使用多個平台視圖（如廣告、地圖等）時遇到過效能挑戰，那麼這些優化將有可能提供更流暢、更響應的捲動體驗。請嘗試一下，並告訴我們您的想法。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*uk0URkHcImHdTq2M" />
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-KX8Ubw77KpdGnPI" />
</figure>

<h3 id="生態系統"><a href="#生態系統" class="headerlink" title="生態系統"></a>生態系統</h3><h4 id="Vertex-AI-for-Firebase-Dart-SDK-預覽版本發佈"><a href="#Vertex-AI-for-Firebase-Dart-SDK-預覽版本發佈" class="headerlink" title="Vertex AI for Firebase Dart SDK 預覽版本發佈"></a>Vertex AI for Firebase Dart SDK 預覽版本發佈</h4><p>Vertex AI for Firebase 產品已發佈為公眾預覽版，並包含 Dart SDK。這使您能夠使用 Gemini API 為您的 Dart 或 Flutter 應用程式構建生成式 AI 功能，同時考慮生產、效能和企業規模。該 SDK 與 <a href="https://firebase.google.com/docs/app-check">Firebase App Check</a> 整合，該檢查保護您的 API 調用，並保護您的後端基礎架構免受嚴重的威脅，例如計費欺詐、釣魚和應用程式冒充。跳轉到 <a href="https://firebase.google.com/docs/vertex-ai/get-started?platform=flutter">Dart 入門</a>，並使用促銷碼免費開始使用它。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*KmIhzrfoyskNW7r8" />
</figure>

<p><a href="https://ai.google.dev/gemini-api/docs/get-started/dart">Google AI Dart SDK</a> 仍然可用，建議僅用於原型設計。Google AI 具有免費的存取權限（在限制和有提供的地方），並提供按使用量付費的定價。如果您一直在使用 Google AI Dart SDK 進行原型設計，並且準備遷移到 Vertex AI for Firebase，請查看 <a href="https://firebase.google.com/docs/vertex-ai/migrate-to-vertex-ai?platform=flutter">遷移指南</a>。</p>
<h4 id="DevTools-更新"><a href="#DevTools-更新" class="headerlink" title="DevTools 更新"></a>DevTools 更新</h4><p>我們將繼續改進 DevTools，這是 Dart 和 Flutter 的效能和除錯工具套件。此版本包含效能提升、一般潤色以及新功能，例如在時間軸中包含 CPU 樣本、高級過濾以及支援匯入和匯出記憶體快照。</p>
<p>其他值得注意的改进已在 devtools_extensions 和 devtools_app_shared 套件中發佈，這些套件支援 DevTools 擴展作者。我们添加了對將擴展連接到新的 Dart Tooling Daemon (DTD) 的支援，這允許 DevTools 擴展存取由其他 DTD 客戶端（例如 IDE）註冊的公用方法，以及存取用於與開發專案互动的最小檔案系統 API。</p>
<p>若要進一步了解 Flutter 3.22 中包含的所有更新，請查看 DevTools 的發行備註 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.32.0">2.32.0</a>，<a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.33.0">2.33.0</a> 和 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.34.1">2.34.1</a>。</p>
<h4 id="Flutter-的-Google-行動廣告-SDK"><a href="#Flutter-的-Google-行動廣告-SDK" class="headerlink" title="Flutter 的 Google 行動廣告 SDK"></a>Flutter 的 Google 行動廣告 SDK</h4><p>對於那些使用廣告變現 Flutter 應用程式的人來說，我們有一些令人興奮的新聞：Flutter 的 Google 行動廣告剛剛發佈了 5.0.1 版本的重大更新！</p>
<p><strong>增強對使用者訊息平台 (UMP) SDK 的支援：</strong>更新添加了對 Android UMP SDK 版本 2.2.0 和 iOS UMP SDK 版本 2.4.0 中的最新 API 的支援。UMP SDK 對於遵守隱私法規至關重要，使您更容易獲得使用者對個性化廣告的同意。此新版本引入了多個新 API 來簡化同意收集流程。</p>
<p><strong>擴展中介夥伴：</strong>我們通過提供與受歡迎的廣告夥伴的整合，拓寬了您的廣告變現範圍，包括 <a href="https://pub.dev/packages/gma_mediation_unity">Unity</a>、<a href="https://pub.dev/packages/gma_mediation_meta">Meta</a>、<a href="https://pub.dev/packages/gma_mediation_applovin">AppLovin</a>、<a href="https://pub.dev/packages/gma_mediation_ironsource">Iron Source</a>、<a href="https://pub.dev/packages/gma_mediation_mintegral">Mintegral</a>、<a href="https://pub.dev/packages/gma_mediation_pangle">Pangle</a>、<a href="https://pub.dev/packages/gma_mediation_dtexchange">DT Exchange</a>、<a href="https://pub.dev/packages/gma_mediation_inmobi">InMobi</a> 和 <a href="https://pub.dev/packages/gma_mediation_liftoffmonetize">Liftoff</a>。您現在可以使用擴展的中介選項和簡化的實作來最大限度地提高應用程式收入。</p>
<p>我們鼓勵您在 Flutter 應用程式中嘗試這些新功能，並告訴我們您希望我們支援哪些其他中介夥伴。您的回饋對於我們持續改進 Flutter 的 Google 行動廣告 SDK 至關重要。</p>
<h3 id="重大變更和棄用"><a href="#重大變更和棄用" class="headerlink" title="重大變更和棄用"></a>重大變更和棄用</h3><h4 id="移除第-1-版-Android-嵌入"><a href="#移除第-1-版-Android-嵌入" class="headerlink" title="移除第 1 版 Android 嵌入"></a>移除第 1 版 Android 嵌入</h4><p>第一版 Android 嵌入的刪除正在進行中。這對大多數應用程式可能沒有影響，因為</p>
<ol>
<li>第 2 版已經成為預設版本很多年了</li>
<li>Flutter 工具將阻止構建第 1 版應用程式，除非使用標誌 <code>--ignore-deprecation</code> 明確覆蓋。</li>
</ol>
<p>此版本完全中斷了 Flutter 工具對第 1 版應用程式的支援。<strong>不再可以覆蓋。</strong></p>
<p><strong>Plugin 作者請注意：</strong>當最初棄用第 1 版 Android 嵌入時，為 Plugin 作者編寫了遷移文檔，網址為 <a href="https://docs.flutter.dev/release/breaking-changes/plugin-api-migration">https://docs.flutter.dev/release/breaking-changes/plugin-api-migration</a>。作為此遷移的一部分，建議 Plugin 作者通過在他們的 <em>Plugin.java</em> 中包含一個具有以下簽名的方法來保持對使用第 1 版嵌入的應用程式的支援</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerWith</span><span class="params">(<span class="meta">@NonNull</span> io.flutter.plugin.common.PluginRegistry.Registrar registrar)</span></span><br></pre></td></tr></table></figure>

<p>我們計劃在下一個版本中完全刪除第 1 版 Android 嵌入，<strong>屆時包含具有此簽名的 Plugin 方法將無法編譯</strong>（因為它引用了第 1 版 Android 嵌入的類型）。</p>
<p>它目前沒有任何作用，因為此版本中斷了使用第 1 版嵌入的應用程式。我們建議 Plugin 作者儘快發佈更新版本的 Plugin，其中刪除了第 1 版程式碼，以避免在 Flutter 的未來版本中出現故障。例如，請查看 <a href="https://github.com/flutter/packages/pull/6494">PR 6494</a>，該 PR 刪除了 Flutter 團隊維護的 Plugin。</p>
<h4 id="在-3-22-中移除的棄用"><a href="#在-3-22-中移除的棄用" class="headerlink" title="在 3.22 中移除的棄用"></a>在 3.22 中移除的棄用</h4><p>此版本中的 <a href="https://docs.flutter.dev/release/breaking-changes">重大變更</a> 包括在 v3.19 發佈之後過期的棄用 API。若要查看所有受影響的 API，以及其他上下文和遷移指南，請查看 <a href="https://docs.flutter.dev/release/breaking-changes/3-19-deprecations">此版本中的棄用指南</a>。其中許多受到 <a href="https://docs.flutter.dev/development/tools/flutter-fix">Flutter fix</a> 的支援，包括 IDE 中的快速修復。可以使用 dart fix 命令行工具評估和應用批量修復。</p>
<p>與往常一樣，非常感謝社群為 <a href="https://github.com/flutter/tests/blob/master/README.md">貢獻測試</a> - 這些測試幫助我們識別出這些重大變更。若要進一步了解，請查看 <a href="https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes">Flutter 的重大變更策略</a>。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>Flutter 成功背後的核心是您 - 我們非凡的社群。沒有您無數的貢獻和堅定的熱情，這個版本是不可能實現的。我們衷心感謝您。</p>
<p>準備好探索 Flutter 3.22 嗎？深入查看完整的發行備註和更改日誌，啟動您的終端機，然後運行 flutter upgrade。我們迫不及待想看看您會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fbde6c164fe3" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/whats-new-in-flutter-3-22-fbde6c164fe3">Flutter 3.22 的新功能</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/9e5e250f.html" data-id="cm1ntp44f0005v517deg314fx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GPU/" rel="tag">GPU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Flutter/" style="font-size: 20px;">Flutter</a> <a href="/tags/GPU/" style="font-size: 10px;">GPU</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/archives/0.html">(no title)</a>
          </li>
        
          <li>
            <a href="/archives/430aae7c.html">【文章翻譯】What’s new in Flutter 3.24</a>
          </li>
        
          <li>
            <a href="/archives/6243ded4.html">【文章翻譯】Announcing Flutter 3.24 and Dart 3.5</a>
          </li>
        
          <li>
            <a href="/archives/8ddf18fb.html">【文章翻譯】Getting started with Flutter GPU</a>
          </li>
        
          <li>
            <a href="/archives/807a2f46.html">【文章翻譯】Getting started with Flutter GPU</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Rainvisitor<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FZZFH3T2TV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FZZFH3T2TV');
</script>
  </div>
</body>
</html>