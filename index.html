<!DOCTYPE html>
<html lang="zh-tw,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rainvisitor.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.rainvisitor.me/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-tw'
  };
</script>

  <title>RainVisitor Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RainVisitor Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">RainVisitor</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/6475a63d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/6475a63d.html" class="post-title-link" itemprop="url">【文章翻譯】Celebrating Flutter’s “Production Era”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-17 20:13:46" itemprop="dateCreated datePublished" datetime="2024-12-17T20:13:46+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 11:59:37" itemprop="dateModified" datetime="2024-12-18T11:59:37+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="慶祝-Flutter-的「生產時代」"><a href="#慶祝-Flutter-的「生產時代」" class="headerlink" title="慶祝 Flutter 的「生產時代」"></a>慶祝 Flutter 的「生產時代」</h2><p>就在六年前，我們推出了 Flutter 1.0。今天，在 <strong>#FlutterInProduction</strong> 上，我們正在慶祝我們取得的成就——從社群中 <strong>數千名貢獻者</strong> 的巨大支持，到 Flutter 作為用於建構跨平台應用程式體驗的生產級應用程式框架的 <strong>廣泛採用</strong>。</p>
<p>如果您還沒有體驗過 Flutter，我們邀請您試用一下！正如我們今天分享的那樣，您將加入一個龐大的群體：Flutter 在全球擁有 <strong>超過 100 萬月活躍開發人員</strong>，並且 <strong>為近 30% 的所有新 iOS 應用程式提供支援</strong>。超過 9 萬名開發人員積極參與了 60 多個國家的 Flutter 聚會。如果您希望在設計或建構新的成功的 Flutter 應用程式方面獲得意見，我們有一個龐大且不斷增長的 <a href="https://flutter.dev/consultants">Flutter 顧問</a> 列表，隨時準備為您提供幫助。</p>
<blockquote>
<p>“Apptopia 追蹤 Apple AppStore 和 Google Play 商店中的數百萬個應用程式，並分析和檢測用於建立應用程式的開發人員 SDK。Flutter 是我們追蹤的最受歡迎的 SDK 之一：在 Apple AppStore 中，它的使用率從 2021 年所有追蹤的免費應用程式的約 10% 穩步增長到 2024 年所有追蹤的免費應用程式的近 30%！”</p>
</blockquote>
<blockquote>
<p>— <a href="https://apptopia.com/">Apptopia Inc.</a></p>
</blockquote>
<h3 id="十年的創新，邁向生產時代"><a href="#十年的創新，邁向生產時代" class="headerlink" title="十年的創新，邁向生產時代"></a>十年的創新，邁向生產時代</h3><p>這是一段不可思議的旅程，始於 2014 年（也就是我們現在所說的實驗時代），當時它是 Google 的一個代號為「Sky」的實驗。</p>
<p>在 Flutter 出現之前，妥協是不可避免的。許多開發人員已經開始懷疑，任何框架是否都能夠真正跨多個平台提供優質的體驗。</p>
<p>隨著 2018 年 Flutter 1.0 的推出，我們有了一個明確的使命來解決這個技術困境：我們的目標是為開發人員提供終極應用程式框架，以便在所有平台上製作美觀、高效能的使用者介面。此外，還要讓開發人員能夠在客戶關心的所有平台上以高品質的應用程式接觸所有客戶，但 <em>成本更低</em>，<em>時間更短</em>。</p>
<p>即使我們增加了對行動、網頁和桌面六大主要平台的支援，並且透過豐田將 Flutter 用於資訊娛樂系統等工作 <a href="https://flutter.dev/multi-platform/embedded">繼續拓展</a>，我們的重點在 Flutter 的增長期一直保持不變。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nlSy3ZCCbdUXFRH4Q1zstg.png" />
</figure>

<p>我們現在正處於「生產時代」，我們正在用 <strong>#FlutterInProduction</strong> 慶祝這一點！此活動重點介紹了在實際應用程式中使用 Flutter 的開發人員所取得的成就。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FAEXIrThTgb0%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DAEXIrThTgb0&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FAEXIrThTgb0%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/ce33468161bcfe4ed6cff82a7a7196cf/href">https://medium.com/media/ce33468161bcfe4ed6cff82a7a7196cf/href</a></iframe>

<h3 id="與社群合作建構"><a href="#與社群合作建構" class="headerlink" title="與社群合作建構"></a>與社群合作建構</h3><p>沒有我們超過 1,400 名貢獻者、超過 10,000 名套件發佈者（編寫了超過 50,000 個套件）以及充滿熱情的 Flutter 內容創作者和愛好者的驚人社群，這一切都不可能實現。</p>
<p>我們共同建構了一個 <a href="https://github.blog/news-insights/octoverse/octoverse-2024/#the-state-of-open-source">GitHub 貢獻排名前五的開源專案</a>！</p>
<h3 id="令人驚嘆的使用者體驗"><a href="#令人驚嘆的使用者體驗" class="headerlink" title="令人驚嘆的使用者體驗"></a>令人驚嘆的使用者體驗</h3><p>這一切都始於對實現令人驚嘆的使用者體驗的關注。擺脫了典型的平台限制，Flutter 支援廣泛的設計語言——SDK 附帶了對 Material Design 和我們受 Apple 啟發的 Cupertino Widget 的支援。生態系統還提供了廣泛的設計函式庫選擇，例如 Windows 啟發的 <a href="https://pub.dev/packages/fluent_ui">fluent_ui</a>、macOS 啟發的 <a href="https://pub.dev/packages/macos_ui">macos_ui</a> 和 Ubuntu 啟發的 <a href="https://pub.dev/packages/yaru">yaru</a> Widget。</p>
<h4 id="斯堪地那維亞航空公司設計獎"><a href="#斯堪地那維亞航空公司設計獎" class="headerlink" title="斯堪地那維亞航空公司設計獎"></a>斯堪地那維亞航空公司設計獎</h4><p>使用 Flutter，您擁有實現設計團隊預想的 <em>任何設計</em> 的靈活性和能力。斯堪地那維亞航空公司就是一個很好的例子，他們在使用 Flutter 建立了新的行動應用程式後，獲得了許多著名的設計獎項，例如紅點設計獎、威比人民之聲獎和 iF 設計金獎。SAS 的執行副總裁兼首席資訊長 Charlotte Svensson <a href="https://www.sasgroup.net/newsroom/press-releases/2023/sas-wins-webby-award-for-redesigned-app/">解釋說</a>：</p>
<blockquote>
<p>“我對這個獎項感到非常自豪，它不僅僅是一個行業獎項，而是一種全球認可。這證明了當我們超越自我，專注於改善客戶體驗，以及當我們與客戶互動和共同發展時，我們能夠做到什麼。SAS 一直處於航空業創新的前沿，這個獎項也驗證了我們致力於為客戶提供卓越的數位解決方案的承諾。”</p>
</blockquote>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*3685YaIo_7soz-qF" />
<figcaption>Scandinavian Airlines design awards</figcaption>
</figure>



<h3 id="出色的效能和可靠性"><a href="#出色的效能和可靠性" class="headerlink" title="出色的效能和可靠性"></a>出色的效能和可靠性</h3><p>效能和可靠性對於積極的使用者體驗和品牌認知至關重要。速度緩慢或容易崩潰的應用程式不僅會在短期內讓使用者感到沮喪，而且還會透過負面評論和口碑在長期內損害您的品牌聲譽。</p>
<p>Flutter 從一開始就優先考慮效能和可靠性。透過選擇 Dart 程式語言，我們確保透過提前編譯為原生機器碼或 WebAssembly 來實現快速啟動時間。Dart 豐富的空安全類型系統有助於在開發過程中捕獲錯誤，從而進一步提高可靠性。此外，Flutter 的自訂 Impeller 渲染引擎專為跨平台 UI 設計，可提供流暢的動畫，並讓我們完全控制從 UI 原始碼到 GPU 的整個渲染堆疊。</p>
<h4 id="環球影城的效能和可靠性"><a href="#環球影城的效能和可靠性" class="headerlink" title="環球影城的效能和可靠性"></a>環球影城的效能和可靠性</h4><p>例如，環球目的地與體驗最近報告說，透過採用 Flutter，他們不僅減小了應用程式的大小（這對於網路連線不可靠的使用者來說是一個很大的好處），而且還大幅減少了應用程式崩潰，幾乎為零，從而降低了他們的總擁有成本。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FJTk2Exr7FO4%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DJTk2Exr7FO4&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FJTk2Exr7FO4%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/721111dda3bc3595ada438b543af64a4/href">https://medium.com/media/721111dda3bc3595ada438b543af64a4/href</a></iframe>


<h4 id="LG-電子的效能"><a href="#LG-電子的效能" class="headerlink" title="LG 電子的效能"></a>LG 電子的效能</h4><p>由於擔心傳統原生應用程式的高開發成本，LG 電子傳統上一直依賴 Web 應用程式來開發其 webOS 驅動的智慧電視。但是，他們發現 Web 應用程式的啟動速度比原生應用程式慢，而且佔用更多記憶體。透過 Flutter，LG 電子擁有一個結合了快速開發速度和出色效能的解決方案。因此，他們計劃從 2025 年開始在全球範圍內將 Flutter 用於 webOS 電視中的關鍵應用程式。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fl-J3Of7pLPw%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dl-J3Of7pLPw&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2Fl-J3Of7pLPw%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/7bb10fd5172d78f3ceec7b18b842e913/href">https://medium.com/media/7bb10fd5172d78f3ceec7b18b842e913/href</a></iframe>


<h3 id="一流的開發人員體驗和蓬勃發展的生態系統"><a href="#一流的開發人員體驗和蓬勃發展的生態系統" class="headerlink" title="一流的開發人員體驗和蓬勃發展的生態系統"></a>一流的開發人員體驗和蓬勃發展的生態系統</h3><p>Flutter 的成功深深植根於其對開發人員體驗的關注。我們使用 Stateful Hot Reload 開創了即時開發人員工作流程，並在我們的增長期增加了 Flutter <a href="https://docs.flutter.dev/tools/devtools">DevTools</a>，以顯著加快診斷和除錯工作流程。</p>
<p>Flutter 的社群提供了一個由超過 10,000 名發佈者發佈的超過 50,000 個套件組成的蓬勃發展的開放生態系統，以及強大的第三方服務和技術。此外，如果您希望在設計或建構新的成功的 Flutter 應用程式方面獲得意見，我們有一個龐大的 <a href="https://flutter.dev/consultants">Flutter 顧問</a> 列表，隨時準備為您提供幫助。</p>
<h4 id="MGM-和開發人員生產力"><a href="#MGM-和開發人員生產力" class="headerlink" title="MGM 和開發人員生產力"></a>MGM 和開發人員生產力</h4><p>應用程式代理商 <a href="https://www.superformula.com/services/flutter/">Superformula</a> 自 2020 年 8 月以來一直在使用 Flutter 進行建構。他們發現 Flutter 易於學習且文件齊全，使他們能夠讓新團隊成員快速上手並有效地做出貢獻。</p>
<p>Superformula 還使用 Flutter 為 MGM Resorts 的 400 多家餐廳 <a href="https://www.superformula.com/work/revitalizing-the-digital-dining-experience-for-mgm-resorts-400-restaurants/">重振數位用餐體驗</a>。新的基於 Flutter 的 MGM Rewards 應用程式僅在 4 個月內就重建完成，程式碼總量減少了一半，交付速度提高了 4 倍。Superformula 生產力的一個核心推動因素是能夠在行動設備、基於平板電腦的資訊站和基於 Web 的工具之間共用程式碼。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FhuzVEL676lc%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DhuzVEL676lc&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FhuzVEL676lc%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/0ef3a20b164d0ff5ac1a4bd02c687a83/href">https://medium.com/media/0ef3a20b164d0ff5ac1a4bd02c687a83/href</a></iframe>


<h4 id="GEICO-和行動開發的民主化"><a href="#GEICO-和行動開發的民主化" class="headerlink" title="GEICO 和行動開發的民主化"></a>GEICO 和行動開發的民主化</h4><p>今年早些時候，美國汽車保險公司 GEICO <a href="https://www.geico.com/techblog/flutter-as-the-multi-channel-ux-framework/">發表了一篇部落格文章</a>，詳細介紹了他們使用 Flutter 的經驗以及 Flutter 如何提高他們的生產力。他們能夠改變其組織結構，以便 UX 團隊現在 <em>跨所有管道</em> 擁有整個體驗，減少了相同功能的不同實作之間的差異。他們還將 Flutter 的開發體驗描述為 <em>“成熟的，具有豐富的工具和對軟體開發生命週期 (SDLC) 的支援”</em>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/765/0*Y65O6741pXOhM35S" />
<figcaption>GEICO user interface elements shared across web, iOS, and Android.</figcaption>
</figure>


<h3 id="未來搶先看"><a href="#未來搶先看" class="headerlink" title="未來搶先看"></a>未來搶先看</h3><p>正如我們所說，Flutter 團隊在未來幾年將承擔的一些最重要的工作是維持向全球數億使用者提供基於 Flutter 的體驗的企業所要求的支援的品質和深度。</p>
<p>為了滿足這些不斷發展的需求，我們正專注於幾個關鍵領域：</p>
<ul>
<li><strong>更深層次的 iOS 保真度：</strong> 我們將繼續透過擴展 Cupertino Widget 來提供對 Apple 設計語言的更高保真度。我們正在擁抱現代 Apple 生態系統標準，例如 Swift Package Manager。</li>
<li><strong>無縫平台整合：</strong> 我們正在研究一種新的互操作方法——直接原生互操作——我們相信這將簡化對 C、Java、Kotlin、ObjectiveC 或 Swift 中可用的平台特定 API 的存取。</li>
<li><strong>開發人員生產力增強：</strong> 我們正在繼續發展我們的開發人員工具，透過探索潛在的新的 UI 設計功能，這些功能可能會提供實時 Widget 預覽器以及實時視覺屬性編輯。</li>
<li><strong>簡潔易讀的程式碼：</strong> 為了提高開發人員的生產力，我們正在探索如何使 Flutter 程式碼更快地編寫和更容易閱讀。這包括潛在的新的語言功能，例如「主要建構函式」和「列舉簡寫」，並瀏覽 Flutter 框架以識別可能提供更簡潔的編寫常用程式碼方式的新 API。</li>
</ul>
<p>正如 Rivers 如此準確地說的那樣，事情確實 <em>“變得更流暢、更專業了一些”</em>，我們的目標是讓事情在未來繼續保持這種感覺。</p>
<h3 id="準備好在生產中使用-FlutterInProduction-了嗎？"><a href="#準備好在生產中使用-FlutterInProduction-了嗎？" class="headerlink" title="準備好在生產中使用 #FlutterInProduction 了嗎？"></a>準備好在生產中使用 #FlutterInProduction 了嗎？</h3><p>如果您最近沒有嘗試過 Flutter，那麼現在就是最佳時機！</p>
<p>想先了解別人的經驗嗎？</p>
<ul>
<li><strong>參加</strong> 2024 年 12 月 19 日的 <a href="https://flutter.dev/events/flutter-in-production#schedule">Observable Flutter 小組討論</a></li>
<li><strong>加入 Flutter 社群：</strong> 找一個當地的聚會，加入論壇，或在 Slack 上聯繫：<a href="https://flutter.dev/community">https://flutter.dev/community</a></li>
</ul>
<p>我們致力於透過始終如一地關注品質和效能來贏得您的信任。我們繼續根據使用者的需求來推動我們的路線圖。在過去 6 年的增長期中，這也發生了變化，從實驗時代的個人和業餘愛好者，到如今利用 Flutter 處理業務關鍵功能的大型企業。</p>
<p>與往常一樣，我們迫不及待地想看看您接下來會建構什麼。下次再見！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f9418261d8e1" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/flutter-in-production-f9418261d8e1">慶祝 Flutter 的「生產時代」</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/daed2484.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/daed2484.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Flutter AI Toolkit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-17 19:02:26" itemprop="dateCreated datePublished" datetime="2024-12-17T19:02:26+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 11:59:40" itemprop="dateModified" datetime="2024-12-18T11:59:40+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="宣佈-Flutter-AI-工具包"><a href="#宣佈-Flutter-AI-工具包" class="headerlink" title="宣佈 Flutter AI 工具包"></a>宣佈 Flutter AI 工具包</h2><p>Flutter AI 開發者們，歡呼吧！將 AI 支援的聊天體驗新增到您的應用程式中變得更加容易。隆重推出 <a href="https://pub.dev/packages/flutter_ai_toolkit">Flutter AI 工具包</a>，這是一組隨時可用的 AI 聊天 Widget，旨在無縫整合到您的 Flutter 專案中。無需再從頭開始構建複雜的聊天介面 - Flutter AI 工具包提供了快速輕鬆地將精密的 AI 聊天視窗新增到您的應用程式所需的一切。準備好提升跨多個平台的客戶參與度和滿意度了嗎？您已經準備好了！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/418/0*8PFN57i3DaWcEBvk" />
<figcaption><a href="https://idx.google.com/new?template=https%3A%2F%2Fgithub.com%2Fflutter%2Fai">在 Project IDX 中試用 Flutter AI 工具包！</a></figcaption>
</figure>

<h3 id="多輪聊天"><a href="#多輪聊天" class="headerlink" title="多輪聊天"></a>多輪聊天</h3><p>透過多輪聊天，您可以在同一個會話中的多個互動之間維持上下文。</p>
<p>想像一下您正在與朋友交談。他們問您是否有寵物，您告訴他們您有一個名叫 Rocky 的寵物石頭。過了一會兒，在與您聊了其他事情之後，您的朋友問：「您養 Rocky 多久了？」朋友記得您之前談話中提到的寵物石頭，即使您沒有再次提及它。</p>
<p>這基本上就是多輪聊天的作用！它可以幫助大型語言模型 (LLM) 記住正在談論的內容。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/904/1*u_atZ9LOO85MJMWdLFvxow.png" />
<figcaption>Flutter AI 工具包中的多輪聊天</figcaption>
</figure>

<h3 id="富文本顯示"><a href="#富文本顯示" class="headerlink" title="富文本顯示"></a>富文本顯示</h3><p>LLM 生成的回應支援富文本格式。LLM 不僅可以生成純文字，還可以將文字格式化，使其更有趣。例如，回應可以包含粗體文字、圖片、項目符號等等。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/920/1*m5BA-Jaa7l9uPr9NHoWjKA.png" />
<figcaption>Flutter AI 工具包中的富文本格式支援</figcaption>
</figure>

<h3 id="語音輸入"><a href="#語音輸入" class="headerlink" title="語音輸入"></a>語音輸入</h3><p>語音輸入可用於將訊息轉換為文字。此免持選項非常適合那些不喜歡打字或想要更快地撰寫訊息的人。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/768/0*KgA9lHvHX_FF3r50" />
<figcaption>Flutter AI 工具包中的語音輸入支援</figcaption>
</figure>

<h3 id="多媒體附件"><a href="#多媒體附件" class="headerlink" title="多媒體附件"></a>多媒體附件</h3><p>圖片、影片、音訊、PDF 和其他檔案可以單獨或一起新增到對話中。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/922/1*HxICVJ2oeINpsTb4DDdnqg.png" />
<figcaption>Flutter AI 工具包中的多媒體附件支援</figcaption>
</figure>

<h3 id="自訂回應-Widget"><a href="#自訂回應-Widget" class="headerlink" title="自訂回應 Widget"></a>自訂回應 Widget</h3><p>為回應設計專門的 UI 元件。例如，如果有人要求食譜，您可以顯示一個互動式食譜卡，並提供將食譜直接儲存到資料庫的選項。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/924/1*j-2lxsZJ-WEREg7X4O7Cog.png" />
<figcaption>Flutter AI 工具包中的自訂 AI 回應 Widget 支援</figcaption>
</figure>

<h3 id="自訂樣式"><a href="#自訂樣式" class="headerlink" title="自訂樣式"></a>自訂樣式</h3><p>設定聊天外觀以符合您的應用程式。變更聊天氣泡的顏色、背景、UI 字體，甚至新增 UI 圖片或動畫以反映您的品牌識別。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/722/1*ctMwVabsBVXa-ppooNwGsw.png" />
<figcaption>Flutter AI 工具包中的自訂樣式支援</figcaption>
</figure>

<h3 id="跨平台支援"><a href="#跨平台支援" class="headerlink" title="跨平台支援"></a>跨平台支援</h3><p>Flutter 支援許多平台，Flutter AI 工具包也支援。想要在 iOS、Android、Web 和 macOS 上部署使用 Flutter 製作的 AI 聊天應用程式嗎？沒問題！</p>
<h3 id="可插拔的-LLM"><a href="#可插拔的-LLM" class="headerlink" title="可插拔的 LLM"></a>可插拔的 LLM</h3><p>無論您是想使用 Google 的 Gemini 或 Vertex AI，還是其他 LLM，Flutter AI 工具包都可以輕鬆地將 AI 新增到您的應用程式中。GeminiProvider 和 VertexProvider 可用於開箱即用的整合，分別使用 <a href="https://pub.dev/packages/google_generative_ai">Google AI Dart SDK</a> 和 <a href="https://pub.dev/packages/firebase_vertexai">Firebase 中的 Vertex AI SDK</a>。我們強烈建議您將 Firebase 中的 Vertex AI SDK 用於原型設計以外的生產使用案例。此外，您可以利用 Flutter AI 工具包的 LLM 提供者介面，使用您自己的自訂程式碼插入您選擇的 LLM。</p>
<h3 id="具有多個對話的獨立聊天應用程式"><a href="#具有多個對話的獨立聊天應用程式" class="headerlink" title="具有多個對話的獨立聊天應用程式"></a>具有多個對話的獨立聊天應用程式</h3><p>構建一個功能齊全的聊天應用程式，可以儲存和管理多個對話。為了幫助您入門，Flutter AI 工具包附帶了一個範例專案，該專案利用了 <a href="https://firebase.google.com/docs/firestore">Cloud Firestore</a> 資料庫和 <a href="https://firebase.google.com/docs/vertex-ai">Firebase 中的 Vertex AI</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gAt7fwWLXUWX_nHPwzYzxg.png" />
<figcaption>Flutter AI 聊天應用程式</figcaption>
</figure>

<h3 id="立即試用-Flutter-AI-工具包"><a href="#立即試用-Flutter-AI-工具包" class="headerlink" title="立即試用 Flutter AI 工具包"></a>立即試用 Flutter AI 工具包</h3><p>要親自試用 Flutter AI 工具包，請查看 <a href="https://pub.dev/packages/flutter_ai_toolkit">pub.dev 上的 Flutter AI 工具包</a> 以及以下資源：</p>
<ul>
<li><a href="https://docs.flutter.dev/ai-toolkit/user-experience">Flutter AI 工具包文件</a></li>
<li><a href="https://flutter-ai-toolkit-examp-60bad.web.app/">Flutter AI 工具包互動式示範</a> (<a href="https://github.com/flutter/ai/blob/main/example/lib/demo/demo.dart">GitHub</a>)</li>
<li><a href="https://github.com/flutter/ai/tree/main/example/lib/recipes">食譜範例專案 (GitHub)</a></li>
<li><a href="https://github.com/csells/flutter_ai_chat/blob/main/README.md">Flutter AI 聊天範例應用程式 (GitHub)</a></li>
<li><a href="https://idx.google.com/new?template=https://github.com/flutter/ai">在瀏覽器中開始使用 (Project IDX)</a></li>
</ul>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e36b16a840d2" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/announcing-flutter-ai-toolkit-e36b16a840d2">宣佈 Flutter AI 工具包</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/fe672d55.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/fe672d55.html" class="post-title-link" itemprop="url">【文章翻譯】Video & web ad support in Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-17 19:02:25" itemprop="dateCreated datePublished" datetime="2024-12-17T19:02:25+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 11:59:43" itemprop="dateModified" datetime="2024-12-18T11:59:43+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="Flutter-的影片和網頁廣告支援"><a href="#Flutter-的影片和網頁廣告支援" class="headerlink" title="Flutter 的影片和網頁廣告支援"></a>Flutter 的影片和網頁廣告支援</h2><p>共同作者：Zoey Fan、Harold Benson、Alak Jhunjhunwala</p>
<p>將您的 Flutter 應用程式變現變得更容易，也更有價值。今天，我們很高興地宣布一套新的工具和功能更新，為開發人員提供一系列選項來將您的應用程式變現並發展您的業務。</p>
<h3 id="Flutter-開發人員現在可以使用影片廣告"><a href="#Flutter-開發人員現在可以使用影片廣告" class="headerlink" title="Flutter 開發人員現在可以使用影片廣告"></a>Flutter 開發人員現在可以使用影片廣告</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/836/0*xsAbaMexfbR30wgK" />
<figcaption>顯示範例影片廣告的動畫 gif</figcaption>
</figure>

<p>讓我們先將您的影片內容轉變為創造收入的強大引擎！</p>
<p>我們要宣布推出 <a href="https://youtu.be/U8x5n6RwZOo">Flutter 的互動式媒體廣告 (IMA) Plugin</a>。您現在可以將高品質的影片廣告無縫整合到 iOS 和 Android 上的 Flutter 應用程式中。這意味著您現在可以在影片內容播放之前（片頭廣告）、期間（中間廣告）或之後（片尾廣告）輕鬆地透過影片廣告將影片內容變現。就像 Google 行動廣告 Plugin 簡化了 Flutter 應用程式中行動廣告的顯示一樣，<a href="https://pub.dev/packages/interactive_media_ads">IMA Plugin</a> 讓您輕鬆地整合影片廣告。我們已經完成了繁重的工作，因此您可以專注於最重要的事情：創造令人驚嘆的應用程式體驗。</p>
<p><strong>輕鬆整合，最大限度地發揮影響力</strong></p>
<ul>
<li><strong>客戶端廣告插入：</strong> 廣告在單獨的影片播放器中播放，確保為您的使用者提供流暢的觀看體驗，同時讓您擁有更多控制權。</li>
<li><strong>無縫廣告處理：</strong> Plugin 請求影片廣告並處理播放。它還確保渲染跳過按鈕等 UI 元素，並觸發廣告測量訊號。</li>
<li><strong>符合產業標準：</strong> IMA 利用產業標準的影片廣告投放範本 (VAST) 規範，確保與廣告伺服器的廣泛相容性。</li>
<li><strong>存取優質廣告需求：</strong> IMA 確保您可以透過 Google 的高品質和優質影片廣告需求來將您的影片內容變現。</li>
</ul>
<p><strong>立即開始！</strong></p>
<p>您準備好使用影片廣告為您的 Flutter 應用程式增壓了嗎？前往 <a href="https://pub.dev/packages/interactive_media_ads">pub.dev&#x2F;packages&#x2F;interactive_media_ads</a> 以探索 IMA Plugin 並存取詳細的文件。您將找到開始使用所需的一切，包括程式碼範例和逐步指南。我們很期待看到您如何使用 IMA Plugin 將您的 Flutter 影片內容變現，並創造更具吸引力的應用程式體驗！</p>
<h3 id="Beta-版：使用-AdSense-廣告將您的-Flutter-網頁遊戲變現"><a href="#Beta-版：使用-AdSense-廣告將您的-Flutter-網頁遊戲變現" class="headerlink" title="Beta 版：使用 AdSense 廣告將您的 Flutter 網頁遊戲變現"></a>Beta 版：使用 AdSense 廣告將您的 Flutter 網頁遊戲變現</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*wz_WITqUIrY1dR7w" />
<figcaption>顯示遊戲中範例 AdSense 廣告的動畫 gif</figcaption>
</figure>

<p>許多 Flutter 開發人員希望像他們的行動應用程式一樣，將他們的 Flutter 網頁專案變現。我們一直在幕後忙碌地工作，並且有一些令人興奮的進展可以分享！</p>
<p>今天，我們很興奮地宣布 <strong>H5 遊戲</strong> Plugin 的 AdSense <strong>beta 計劃</strong>！透過此 Plugin，您可以輕鬆地將 AdSense <a href="https://adsense.google.com/start/h5-games-ads/">H5 遊戲廣告</a> 加入到您在 Flutter 中建立的網頁遊戲 (H5) 中，開闢新的收入來源。</p>
<p><strong>beta 計劃提供的內容：</strong></p>
<ul>
<li>成為首批整合 AdSense 的人之一：搶先體驗 Flutter AdSense Plugin，並開始試驗不同的廣告格式。</li>
<li>塑造 Plugin 的未來：提供寶貴的回饋，並幫助我們根據 Flutter 網頁開發人員的特定需求定制 Plugin。</li>
</ul>
<p>此計劃是邁向 Flutter 網頁完整廣告變現解決方案的重要一步。目前，此 Beta 計劃的重點是為 <strong>Flutter 網頁遊戲</strong> 啟用 AdSense。我們正在與 AdSense 團隊合作，為未來的 Flutter 網頁應用程式開發解決方案。</p>
<p>如果您是 Flutter 網頁 <strong>遊戲</strong> 開發人員，並且有興趣參與，請填寫 <a href="https://adsense.google.com/start/h5-beta/?src=flutter">H5 AdSense 申請表</a>。一旦您獲准加入 beta 計劃，請使用 <a href="https://pub.dev/packages/google_adsense">pub.dev&#x2F;packages&#x2F;google_adsense</a> 開始使用！</p>
<h3 id="透過深度連結提高轉換率和更好的使用者體驗"><a href="#透過深度連結提高轉換率和更好的使用者體驗" class="headerlink" title="透過深度連結提高轉換率和更好的使用者體驗"></a>透過深度連結提高轉換率和更好的使用者體驗</h3><p>加入廣告是成為成功企業的方法之一。有時您的企業需要在應用程式中銷售商品和服務。您可能已經花費了大量的時間和資源來建立簡訊&#x2F;電子郵件行銷和廣告活動，並希望這些活動能夠帶來有效的轉換。但是，如果您能透過將客戶從行銷活動直接引導到您的應用程式以及他們感興趣的特定項目，從而將您的活動提升到新的水平呢？</p>
<p>透過 Flutter 中的 <a href="https://docs.flutter.dev/ui/navigation/deep-linking">深度連結</a>，您可以做到這一點。當有人點擊您活動中的連結時，他們將被直接帶到您的應用程式以及您正在推廣的產品或服務。與連結到您的網站相比，這種無縫的轉換將 <strong>轉換的機率提高了 2.3 倍</strong>。</p>
<p>以下是深度連結對廣告商來說改變遊戲規則的原因：</p>
<ul>
<li><strong>提高轉換率：</strong> 透過將客戶直接帶到您的應用程式，您可以消除干擾，並讓他們更容易完成購買。</li>
<li><strong>個人化體驗：</strong> 深度連結允許您為每個客戶創造個人化體驗。當他們點擊連結時，他們將被帶到他們感興趣的特定產品或服務。</li>
<li><strong>追蹤活動績效：</strong> 透過深度連結，您可以追蹤活動的有效性，並查看有多少人點擊連結到您的應用程式。這些資料可以幫助您優化活動以獲得更好的結果。</li>
</ul>
<p>雖然深度連結提供了所有這些優點，但設定起來可能相當麻煩。因此，我們也讓深度連結比以往任何時候都更加穩健和可靠。透過 Flutter DevTools 中 iOS 和 Android 的完整 <a href="https://docs.flutter.dev/tools/devtools/deep-links">網頁和應用程式檢查驗證支援</a>，您可以確保您的深度連結已正確且安全地設定。您的使用者將享受網頁和應用程式內容之間的無縫轉換，增加參與度和滿意度！首先，前往 Flutter DevTools，並打開深度連結驗證標籤。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*W-CAR3hmZRMA03b20508iw.gif" />
<figcaption>顯示 Flutter DevTools 中深度連結驗證的動畫 gif</figcaption>
</figure>

<p>我們致力於為您（Flutter 開發人員）提供您成功所需的工具和資源。這些新功能證明了我們的承諾。所以，繼續，將您的 Flutter 應用程式提升到新的高度，並釋放其全部潛力！</p>
<p><strong>探索更多：</strong></p>
<ul>
<li>深入了解 Flutter 變現的世界：<a href="https://flutter.dev/monetization">flutter.dev&#x2F;monetization</a></li>
<li>掌握深度連結的藝術：<a href="https://docs.flutter.dev/development/ui/navigation/deep-linking">Flutter 文件</a></li>
<li>隨時掌握最新的 Flutter 新聞：<a href="https://medium.com/flutter">Flutter 部落格</a></li>
</ul>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f50e5a3480a8" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/video-web-ad-support-in-flutter-f50e5a3480a8">Flutter 中的影片和網頁廣告支援</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/ee34d180.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/ee34d180.html" class="post-title-link" itemprop="url">【文章翻譯】What’s new in Flutter 3.27</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-11 20:19:53" itemprop="dateCreated datePublished" datetime="2024-12-11T20:19:53+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:05:03" itemprop="dateModified" datetime="2024-12-18T12:05:03+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="使用-Impeller、Cupertino-更新等提升應用程式開發"><a href="#使用-Impeller、Cupertino-更新等提升應用程式開發" class="headerlink" title="使用 Impeller、Cupertino 更新等提升應用程式開發"></a>使用 Impeller、Cupertino 更新等提升應用程式開發</h2><h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>讓我們深入了解 Flutter 3.27！此版本充滿了增強功能和特性，著重於改進您的開發體驗並提升應用程式的效能。</p>
<p>我們在架構、引擎和生態系統方面都進行了更新，包括 Impeller 的進展和 Cupertino widget 的改進。此外，我們還在 DevTools 中引入了令人興奮的新功能，讓管理 Flutter 專案比以往任何時候都更容易。Flutter 3.27 包含來自 187 位貢獻者（包括 <strong>49 位首次貢獻者</strong>！）的超過 1,400 個提交，證明了 Flutter 社群令人難以置信的活力和合作。讓我們一起探索新功能吧！</p>
<h3 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h3><h4 id="Cupertino-更新"><a href="#Cupertino-更新" class="headerlink" title="Cupertino 更新"></a>Cupertino 更新</h4><p>此版本包含對 <code>CupertinoCheckbox</code> 和 <code>CupertinoRadio</code> 的高保真度更新，其中包括對大小、顏色、筆劃寬度和按下時的行為的更新。<code>CupertinoRadio</code>、<code>CupertinoCheckbox</code> 和 <code>CupertinoSwitch</code> 也進行了大量的可自訂性更新，加入了滑鼠游標、語義標籤、縮圖和填充顏色等屬性。某些屬性（例如 <code>CupertinoCheckbox</code> 的非活動顏色）已被棄用，而其他屬性（例如 <code>CupertinoSwitch</code> 的軌跡顏色）則已重新命名。這些變更使這些 widget 與其 Material 對應項的功能齊平。</p>
<p><code>CupertinoSlidingSegmentedControl</code> 的拇指半徑、分隔線高度、填充、陰影和拇指縮放對齊方式也進行了一些保真度更新。它現在還支援停用個別區段，以及根據區段內容進行比例佈局。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/454/0*Nr0WuNhNxjlI1Pqg" />
</figure>

<p>感謝社群成員 <a href="https://github.com/veloce">@veloce</a> 的出色貢獻，<code>CupertinoNavigationBar</code> 和 <code>CupertinoSliverNavigationBar</code> 的背景現在是透明的，直到內容在其下方捲動。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*dngArPlUvp4pVA-R" />
</figure>

<p>這使得 sliver 導航欄在其展開狀態下可以擁有與其背景相同的顏色，但在其摺疊狀態下可以擁有不同的可自訂顏色（並且能夠在捲動時在這兩種顏色之間進行插值）。</p>
<p>感謝社群成員 <a href="http://github.com/kerberjg">@kerberjg</a> 的出色貢獻，您現在可以使用 <code>CupertinoButton</code> 中新的 <code>sizeStyle</code> 屬性，透過新的 <code>CupertinoButtonSize</code> 列舉來應用 iOS 15+ 按鈕樣式。使用新的 <code>CupertinoButton.tinted</code> 建構函式來製作具有半透明背景的按鈕。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*vdSn5c7uavWstNO5" />
</figure>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ZPrThBB6ZN8DEtUq" />
</figure>

<p><code>CupertinoButton</code> 還有一個新的 <code>onLongPress</code> 處理程式，並且允許透過鍵盤快捷鍵執行操作。</p>
<p><code>CupertinoPicker</code> 和 <code>CupertinoDatePicker</code> 現在將捲動到點擊的項目。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*XUtBHK9h0zbWrKUF" />
</figure>

<p><code>CupertinoAlertDialog</code> 現在支援點擊滑動手勢。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*JYBUuzXHcYTCD4i5" />
</figure>

<p><code>CupertinoActionSheet</code> 進行了一些高保真度更新，包括在所有系統文字大小設定中調整填充和字體大小，以及在滑過按鈕時支援觸覺回饋。</p>
<p>其他變更包括：<code>CupertinoContextMenu</code> 現在支援捲動（如果其動作超出螢幕範圍），<code>CupertinoDatePicker</code> 不再裁剪其欄中的長內容，以及 <code>CupertinoMagnifier</code> 透過提供放大比例來支援縮放效果。</p>
<h4 id="標準化-Material-主題"><a href="#標準化-Material-主題" class="headerlink" title="標準化 Material 主題"></a>標準化 Material 主題</h4><p>在此版本中，<code>CardTheme</code>、<code>DialogTheme</code> 和 <code>TabBarTheme</code> 已經過重構，以使其符合 Flutter 的元件主題規範。加入了 <code>CardThemeData</code>、<code>DialogThemeData</code> 和 <code>TabBarThemeData</code> 來定義元件視覺屬性預設值的覆蓋。未來的版本將繼續標準化像這樣的元件主題，以便在 Material 函式庫中提供更一致的主題體驗。</p>
<h4 id="CarouselView-的更多功能"><a href="#CarouselView-的更多功能" class="headerlink" title="CarouselView 的更多功能"></a>CarouselView 的更多功能</h4><p>此版本引入了 <code>CarouselView.weighted</code>，可以在 Carousel 中啟用更動態的佈局。透過調整建構函式中的 <code>flexWeights</code> 參數，您可以實現各種項目佈局。例如，<code>[3, 2, 1]</code> 建立 <a href="https://m3.material.io/components/carousel/specs#3c9dc903-2f88-4b27-84e3-213c50674632">多瀏覽</a> 佈局，<code>[7, 1]</code> 建立 <a href="https://m3.material.io/components/carousel/specs#66eb8746-70f0-4bad-b940-8e1028268d65">英雄</a> 佈局，而 <code>[1, 7, 1]</code> 建立 <a href="https://m3.material.io/components/carousel/specs#92c779ce-de8b-4dee-8201-95d3e429204f">居中英雄</a> 佈局。這些值表示每個項目在 Carousel 視圖中佔據的相對權重，並且可以自訂以滿足使用者的特定需求。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*EUjz8K6BQZX2uumi" />
</figure>

<h4 id="Material-中的更多內容"><a href="#Material-中的更多內容" class="headerlink" title="Material 中的更多內容"></a>Material 中的更多內容</h4><p>此版本包含許多小的功能增強和錯誤修復。一些增強功能範例：</p>
<ul>
<li><code>SegmentedButton</code> 現在有一個 <code>direction</code> 屬性，因此項目可以垂直對齊。</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/186/0*ECVkEydB6YuBSGs_" />
</figure>

<ul>
<li><code>ButtonStyleButton</code> 類別（<code>ElevatedButton</code>、<code>FilledButton</code>、<code>OutlinedButton</code>、<code>TextButton</code>、<code>MenuItemButton</code> 和 <code>SubmenuButton</code>）的 <code>styleFrom</code> 方法中加入了更多與圖示相關的屬性，以允許更多自訂。</li>
</ul>
<p>一些錯誤修復範例：</p>
<ul>
<li><code>ButtonStyleButton</code> 類別的圖示大小和顏色預設值與 Material 3 規範一致。</li>
<li><code>AppBar</code> 的捲動下行為現在可以在導航抽屜打開時正確保留，與原生 Android 體驗相符。</li>
<li><code>MenuAnchor</code> 透過焦點修復得到了進一步改進，並且解決了幾個 <code>DropdownMenu</code> 問題，包括巢狀捲動元件中的捲動問題和過濾機制行為。</li>
</ul>
<h4 id="混合路由轉場"><a href="#混合路由轉場" class="headerlink" title="混合路由轉場"></a>混合路由轉場</h4><p>當先前的路由和新的路由具有不同的頁面轉場時，<a href="https://api.flutter.dev/flutter/widgets/ModalRoute-class.html">ModalRoutes</a> 現在更加靈活。當新的路由進入螢幕時，有時它們需要先前的現有路由播放特定轉場以與新路由的進入轉場同步。現在，<code>ModalRoutes</code> 可以互相提供退出轉場建構函式，以便進入和退出轉場始終同步。這允許頁面使用 Flutter 的 <code>Navigator</code> 和 <code>Router</code> 在一個頁面上具有多個路由轉場選項。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/231/0*vyFYrAWVig8f8WGl" />
</figure>


<h4 id="文字選取改進"><a href="#文字選取改進" class="headerlink" title="文字選取改進"></a>文字選取改進</h4><p>Flutter 的 <code>SelectionArea</code> 現在支援在 Linux、macOS 和 Windows 上使用 Shift + 點擊手勢將選取範圍的末尾移動到點擊位置。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/824/0*QwWCiz-DAHklZZAi" />
</figure>


<p>您現在還可以透過 <a href="https://api.flutter.dev/flutter/widgets/SelectableRegionState-class.html">SelectableRegionState</a> 上的 <a href="https://main-api.flutter.dev/flutter/widgets/SelectableRegionState/clearSelection.html"><code>clearSelection</code></a> 方法清除 <code>SelectionArea</code> 和 <code>SelectableRegion</code> 下的選取範圍。現在還可以透過提供 <code>GlobalKey</code> 並存取其 <a href="https://main-api.flutter.dev/flutter/material/SelectionAreaState/selectableRegion.html">SelectionAreaState.selectableRegion</a> 來透過 <code>SelectionArea</code> 存取 <code>SelectableRegionState</code>。</p>
<p>我們還解決了 <code>RenderParagraph</code> 的一些問題，因此在調整 <a href="https://github.com/flutter/flutter/pull/155719">視窗大小</a> 後，以及在點擊或 <a href="https://github.com/flutter/flutter/pull/155892">點擊</a>實際文字 [之外] 時，在 <code>SelectionArea</code> 或 <code>SelectableRegion</code> 下選取文字仍然可以按預期工作。</p>
<h4 id="Row-和-Column-間距"><a href="#Row-和-Column-間距" class="headerlink" title="Row 和 Column 間距"></a>Row 和 Column 間距</h4><p>此版本還提供了一個使用 <code>Row</code> 和 <code>Column</code> 的新便利方法：<code>spacing</code>！此雙精度參數將應用固定數量的像素來偏移 <code>Row</code> 和 <code>Column</code> 的子項之間的距離，從而減少先前執行此操作所需的程式碼量。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*85CZePbMbJ99B5-hPvwpKQ.png" />
</figure>

<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><h4 id="Android-上的-Impeller"><a href="#Android-上的-Impeller" class="headerlink" title="Android 上的 Impeller"></a>Android 上的 Impeller</h4><p>我們很高興地宣布，Impeller 現在是現代 Android 設備上的預設渲染引擎。雖然自 Flutter 3.16 穩定版本於 2023 年 11 月發佈以來，這些設備上的 Impeller 一直處於預覽階段，但從那時起，我們根據使用者回饋對效能和保真度都進行了重大改進。</p>
<p>在較舊的 Android 設備和不支援 Vulkan 的設備上，仍然會像以前一樣使用 Skia 渲染引擎。雖然我們相信 Impeller 的效能和保真度都非常高，但使用者可以選擇退出並返回到傳統的 Skia 渲染器，方法是將 <code>--no-enable-impeller</code> 傳遞給 <code>flutter</code> 命令列工具，或者將以下內容放入您的 <code>AndroidManifest.xml</code> 檔案中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">&quot;io.flutter.embedding.android.EnableImpeller&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下來，我們將繼續改進 Impeller 在 Android 上的效能和保真度。此外，我們打算讓 Impeller 的 OpenGL 後端做好生產準備，以移除 Skia 後備。</p>
<p>如同在預覽期間一樣，我們請求 Flutter 開發人員升級到最新的穩定版本，並提交在啟用 Impeller 時發現的任何缺點的錯誤。回饋對於確保 Impeller 在 Android 上取得成功仍然至關重要。Android 硬體生態系統比 iOS 生態系統更加多元。因此，關於 Impeller 最有用的回饋應包括有關發生問題的特定設備和 Android 版本的詳細資訊。</p>
<h3 id="iOS-設備的改進"><a href="#iOS-設備的改進" class="headerlink" title="iOS 設備的改進"></a>iOS 設備的改進</h3><p>在以前的 Flutter 版本中，使用者可能會遇到 <a href="https://github.com/flutter/flutter/issues/134959">一個問題</a>，即 iOS 設備上的應用程式在合成器反壓下每幀等待幾毫秒。這種反壓將被視為柵格工作負載開始時的延遲。在許多情況下，這種延遲會導致畫面丟失和卡頓。這種效應在具有較小畫面時間預算的高畫面播放速率設備上尤為明顯。</p>
<p>在此版本中，開源貢獻者 <a href="https://github.com/knopp">@knopp</a> 加入了一個 <a href="https://github.com/flutter/engine/pull/48226">新的實作</a> Metal 渲染表面，允許柵格工作負載在 UI 工作負載完成後更一致地開始。這意味著使用者將觀察到整體畫面時間更加穩定，因為在 iOS 系統合成器上的等待時間更少。特別是，Flutter 現在將在高畫面播放速率設備上更一致地達到 120Hz。在我們的基準測試中，我們觀察到在許多情況下平均畫面柵格化時間都大幅減少了。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*wsAPbKV2yW8tLXNb" />
<figcaption><em>此圖表顯示在 iPhone 11 設備上運行的許多不同基準測試中，平均畫面柵格化時間（以毫秒為單位）全面下降。</em></figcaption>
</figure>

<h4 id="架構廣色域顏色"><a href="#架構廣色域顏色" class="headerlink" title="架構廣色域顏色"></a>架構廣色域顏色</h4><p>Flutter 現在支援使用 DisplayP3 色彩空間中的顏色來定義 UI，以充分利用 iOS 設備上的顯示器。它還具有更寬的位元深度，以支援 sRGB 和 DisplayP3 色彩空間中的更多顏色。此變更導致一些 <code>Color</code> 方法被棄用；更多資訊可以在 <a href="https://docs.flutter.dev/release/breaking-changes/wide-gamut-framework">重大變更通知</a> 中找到。</p>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="Web-改進"><a href="#Web-改進" class="headerlink" title="Web 改進"></a>Web 改進</h4><p>此版本為 Flutter Web 帶來各種改進，著重於效能、效率和輔助功能：</p>
<ul>
<li>現在，Safari 和 Firefox 中的圖像解碼使用 <code>&lt;img&gt;</code> 元素完成，而不是對所有靜態圖像使用 WebAssembly 編解碼器。這消除了與圖像解碼相關的卡頓，並減少了 WASM 記憶體使用量。</li>
<li>平台視圖經過優化，以減少畫布覆蓋層的數量，從而提高渲染效率。</li>
<li>Flutter 團隊開發的所有插件和套件現在都與 WebAssembly 相容。</li>
<li>對標題、對話框、密碼、iOS 鍵盤、連結和捲動元件實作了多項輔助功能修復。</li>
<li>在 CanvasKit 和 Skwasm 渲染器中修復了許多渲染錯誤，包括圖像濾鏡、裁剪和 <code>Paint</code> 物件的記憶體使用量。</li>
<li>改進了多視圖模式下的拖動捲動。</li>
</ul>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><h4 id="Swift-Package-Manager"><a href="#Swift-Package-Manager" class="headerlink" title="Swift Package Manager"></a>Swift Package Manager</h4><p>Flutter 正在遷移到 Swift Package Manager。這帶來了許多好處：</p>
<ol>
<li><strong>存取 Swift 套件生態系統</strong>。Flutter 插件將能夠利用不斷發展的 <a href="https://swiftpackageindex.com/">Swift 套件</a> 生態系統！</li>
<li><strong>簡化 Flutter 安裝</strong>。Swift Package Manager 與 Xcode 捆綁在一起。未來，您將不再需要安裝 Ruby 和 CocoaPods 來為 Apple 平台使用 Flutter。</li>
</ol>
<p>以前，Swift Package Manager 支援僅在 Flutter 的「main」頻道上可用。我們很高興地宣布，Swift Package Manager 功能現在也在「beta」和「stable」頻道上可用！目前，Swift Package Manager 功能預設為關閉，因為我們正在解決一些問題。</p>
<p>鼓勵插件作者將 <a href="https://docs.flutter.dev/packages-and-plugins/swift-package-manager/for-plugin-authors#how-to-add-swift-package-manager-support-to-an-existing-flutter-plugin">Swift Package Manager 支援加入到您的插件中</a>。許多流行的插件——包括 <a href="https://github.com/firebase/flutterfire/issues/13205">Firebase</a>、<a href="https://github.com/fluttercommunity/plus_plugins/issues/3152">plus 插件</a> 和 <a href="https://pub.dev/packages?q=is:swiftpm-plugin">更多</a>——已經遷移到 Swift Package Manager！</p>
<p>Pub.dev 現在會檢查插件的 Swift Package Manager 相容性。未來，不相容的套件將不會獲得完整的套件評分。</p>
<p>如果您對 Flutter 對 Swift Package Manager 的支援有任何回饋，請 <a href="https://github.com/flutter/flutter/issues/new/choose">提交問題</a>。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="邊緣到邊緣"><a href="#邊緣到邊緣" class="headerlink" title="邊緣到邊緣"></a>邊緣到邊緣</h4><p>在運行 Android 15+ 的設備上，您的應用程式預設將使用邊緣到邊緣模式並以全螢幕運行！有關此變更以及如何選擇退出此行為的詳細資訊，請參閱<a href="https://docs.flutter.dev/release/breaking-changes/default-systemuimode-edge-to-edge">指南</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/648/0*CNcQF3yqFwc0IGNc" />
</figure>

<h4 id="支援-Freeform"><a href="#支援-Freeform" class="headerlink" title="支援 Freeform"></a>支援 Freeform</h4><p><a href="https://android-developers.googleblog.com/2024/09/developer-preview-desktop-windowing-on-android-tablets.html">Android Freeform</a> 允許使用者調整應用程式視窗的大小，並且一直作為開發人員選項提供。Flutter 的 <code>SafeArea</code> 和 <code>MediaQuery</code> 已更新，以便在 freeform 視窗移動到硬體缺口時處理硬體缺口。</p>
<h4 id="Kotlin-建置腳本支援和宣告式插件遷移"><a href="#Kotlin-建置腳本支援和宣告式插件遷移" class="headerlink" title="Kotlin 建置腳本支援和宣告式插件遷移"></a>Kotlin 建置腳本支援和宣告式插件遷移</h4><p>開發人員現在可以使用 <code>build.gradle.kts</code> 檔案。Flutter 工具現在支援 Kotlin 建置檔案。如果您遇到我們不支援 Kotlin 的地方，請<a href="https://github.com/flutter/flutter/issues/new/choose">提交錯誤</a>。Groovy 仍然是支援的 Gradle 語言。</p>
<p>Flutter 3.27 是最後一個支援 <a href="https://docs.gradle.org/8.5/userguide/plugins.html#sec:script_plugins">Gradle 的傳統 <code>apply</code> 腳本方法</a> 的版本。請參閱<a href="https://docs.flutter.dev/release/breaking-changes/flutter-gradle-plugin-apply">遷移文件</a>。</p>
<p><strong>注意：大多數應用程式需要手動遷移。新建立的應用程式將</strong> <a href="https://github.com/flutter/flutter/pull/157195">使用 kotlin 建置檔案</a>。</p>
<p>遷移到 Flutter Gradle 插件的宣告式包含有助於 Flutter 遷移到 Kotlin 建置檔案，從而提高類型安全性，並更容易維護建置程式碼的單元測試。這也是在 Android 工具版本之間帶來更多穩定性的一項更廣泛工作的一部分。</p>
<h3 id="生態系統"><a href="#生態系統" class="headerlink" title="生態系統"></a>生態系統</h3><h4 id="Flutter-和-Dart-套件生態系統峰會美國-2024"><a href="#Flutter-和-Dart-套件生態系統峰會美國-2024" class="headerlink" title="Flutter 和 Dart 套件生態系統峰會美國 2024"></a>Flutter 和 Dart 套件生態系統峰會美國 2024</h4><p>作為 2024 年 9 月 Fluttercon USA 的一部分，我們舉辦了 Flutter 和 Dart 套件生態系統峰會。這是我們的第二次現場峰會，繼 2024 年 7 月 Fluttercon Europe 的峰會和我們於 2023 年 8 月舉辦的第一屆虛擬峰會之後。請參閱此處的討論會重點摘要 <a href="https://docs.google.com/document/d/e/2PACX-1vRjPlBNo13I9P5UXpehKagVq8e8n7ppNz169HbKSgK4iTmCrbk5rzh-RN6ULpVJ3AkPnnCSI_VCMdYW/pub">連結</a>。</p>
<p>峰會匯集了套件作者和維護者，進行了以下主題的非會議式會議：</p>
<ul>
<li>會議 1 - 加入對 Swift Package Manager 的支援</li>
<li>會議 2 - 原生互操作的過去、現在和未來</li>
<li>會議 3 - 可持續的套件維護模型</li>
</ul>
<p>我們期待與社群合作，在未來舉辦更多此類峰會。</p>
<h4 id="pub-dev-上的套件下載次數"><a href="#pub-dev-上的套件下載次數" class="headerlink" title="pub.dev 上的套件下載次數"></a>pub.dev 上的套件下載次數</h4><p>我們在 pub.dev 上推出了下載次數指標！</p>
<p>在 <a href="https://pub.dev/">pub.dev</a> 上提供更精確的受歡迎程度指標一直是該網站問題追蹤器中 <a href="https://github.com/dart-lang/pub-dev/issues/2714">請求最多的</a> 功能。</p>
<p>現在，當您查看套件頁面時，您將看到一個 30 天下載次數，取代了以前的「受歡迎程度分數」。</p>
<p>此外，我們還加入了一個互動式折線圖，顯示隨著時間推移的每週下載活動。此圖表可幫助開發人員和套件作者發現套件使用趨勢。例如，它可能表明新版本導致使用量激增，或者套件正在變得越來越流行或越來越不受歡迎。</p>
<p>每次從 pub.dev 下載套件時都會註冊下載次數。例如，當您運行 <code>flutter pub get</code> 且套件尚未在您的 pub 快取中時。</p>
<p>顯示的下載次數是原始下載次數，反映了來自 CI 系統、套件分析、人工 pub 用戶端使用者等的使用情況。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tIfxBdBCHFzYhStI" />
</figure>

<h4 id="Pub-工作區"><a href="#Pub-工作區" class="headerlink" title="Pub 工作區"></a>Pub 工作區</h4><p>我們將在 Dart 3.6 中推出 <a href="https://dart.dev/go/pub-workspaces">Pub 工作區</a>，以支援在一個 monorepo 中開發多個相關套件。</p>
<p>透過定義引用儲存庫中其他套件的根 pubspec，在儲存庫中的任何位置運行 <code>pub get</code> 將會為所有套件產生共用解析。這可確保所有套件都使用一組一致的相依開發。</p>
<p>分析器也會選取共用解析，現在分析器只需追蹤整個工作區的單個分析上下文，從而可能在 IDE 中打開整個儲存庫時顯著減少記憶體使用量。</p>
<h4 id="從-GitHub-自動發佈-Flutter-套件"><a href="#從-GitHub-自動發佈-Flutter-套件" class="headerlink" title="從 GitHub 自動發佈 Flutter 套件"></a>從 GitHub 自動發佈 Flutter 套件</h4><p>我們擴展了 <code>setup-dart</code> <a href="https://github.com/dart-lang/setup-dart/blob/main/.github/workflows/publish.yml">發佈</a> Github Actions 工作流程，還允許將 Flutter 套件 <a href="https://dart.dev/tools/pub/automated-publishing#configuring-automated-publishing-from-github-actions-on-pub-dev">自動發佈</a> 到 pub.dev，從而更容易以可驗證的方式為 Pub 生態系統做出貢獻。</p>
<h4 id="推出互動式媒體廣告插件"><a href="#推出互動式媒體廣告插件" class="headerlink" title="推出互動式媒體廣告插件"></a>推出互動式媒體廣告插件</h4><p>我們推出了 <a href="https://pub.dev/packages/interactive_media_ads">互動式媒體廣告 (IMA) Flutter 插件</a>，可以輕鬆地將多媒體廣告整合到使用 Flutter 建置的 iOS 和 Android 應用程式中。IMA 插件可以從任何符合 VAST 標準的廣告伺服器請求廣告，並在您的應用程式中管理廣告播放。廣告在位於應用程式內容影片播放器頂部的單獨影片播放器中播放。目前支援的功能包括：</p>
<ul>
<li>線性串流影片廣告請求的用戶端 API</li>
<li>VAST 和 VMAP</li>
<li>單個和 Podded 請求</li>
<li>可跳過廣告</li>
</ul>
<h4 id="應用程式內購買-iOS-和-macOS-插件更新"><a href="#應用程式內購買-iOS-和-macOS-插件更新" class="headerlink" title="應用程式內購買 iOS 和 macOS 插件更新"></a>應用程式內購買 iOS 和 macOS 插件更新</h4><p>我們已將 <a href="https://developer.apple.com/storekit/">StoreKit 2</a> 支援加入到 <code>in_app_purchase_storekit</code> 套件中，以從 iOS 18 中棄用的 StoreKit 1 API 遷移。這使我們能夠在未來加入新的 StoreKit 2 功能，例如更好的訂閱管理。敬請期待即將推出的遷移指南，以説明您轉換到新的 StoreKit 2 功能。這是一個非重大變更，因此您可以隨時遷移。</p>
<h3 id="DevTools-和-IDE"><a href="#DevTools-和-IDE" class="headerlink" title="DevTools 和 IDE"></a>DevTools 和 IDE</h3><h4 id="Flutter-DevTools-更新"><a href="#Flutter-DevTools-更新" class="headerlink" title="Flutter DevTools 更新"></a>Flutter DevTools 更新</h4><p>此版本包含新功能、整體穩健性和完善性改進，以及一些令人興奮的新的實驗性功能，您可以從 DevTools 中啟用這些功能。有關這些功能的更多資訊，請參閱下面的「預覽和實驗性功能」部分。</p>
<p>首先，我們在 Flutter Deep Links 工具中加入了對驗證 iOS 深度連結設定的支援。您現在可以驗證 Android 和 iOS 的深度連結。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*WO_tOgbNKHtMAJ4h" />
<figcaption><em>DevTools Deep Links 工具中的 iOS 深度連結驗證。</em></figcaption>
</figure>

<p>接下來，我們對使用「離線」資料的工作流程進行了一些改進。有時需要將您在 DevTools 中查看的資料匯出以供將來使用或載入到其他工具中。此版本加入了將網路資料匯出為 .har 檔案的支援，以及將記憶體快照載入到 DevTools 中以便在 DevTools 未連線到正在運行的應用程式時查看的支援。</p>
<p>此外，如果您曾經在使用 DevTools 除錯記憶體問題時因為應用程式崩潰（可能是由於您正在嘗試除錯的 OOM 問題）而丟失了記憶體工具資料，我們感同身受！我們已透過允許您即使在應用程式斷開連線後仍然可以在 DevTools 中繼續查看最新的記憶體工具資料來修復此使用者體驗痛點。</p>
<p>這些只是此版本中的一些重點。若要進一步了解 Flutter 3.27 中包含的所有更新，請查看 DevTools 的發行說明 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.38.0">2.38.0</a>、<a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.39.0">2.39.0</a> 和 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.40.1">2.40.1</a>。</p>
<h3 id="預覽和實驗性功能"><a href="#預覽和實驗性功能" class="headerlink" title="預覽和實驗性功能"></a>預覽和實驗性功能</h3><h4 id="Flutter-DevTools-新的-Flutter-Inspector"><a href="#Flutter-DevTools-新的-Flutter-Inspector" class="headerlink" title="Flutter DevTools - 新的 Flutter Inspector"></a>Flutter DevTools - 新的 Flutter Inspector</h4><p>Flutter Inspector 已經過一些重大變更，以提高可用性並增強您的 UI 除錯體驗。透過切換「新的 Inspector」設定來啟用新的 Inspector。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/914/0*DdHEiQ7FUmFVIMGz" />
<figcaption><em>DevTools 中的新 Flutter Inspector。</em></figcaption>
</figure>

<p>一些變更包括：</p>
<ul>
<li>簡潔的 Widget 樹，可以更輕鬆地查看深度巢狀的 Flutter widget 樹。當從 IDE 中使用 Flutter Inspector 時，這尤其有用，因為水平螢幕空間有限。</li>
<li>一個選項，用於切換是否應在 widget 樹中包含實作 widget。實作 widget 是您未在應用程式程式碼中包含的 widget，而是由 Flutter 架構或其他套件加入到 widget 樹中的。</li>
<li>選定 widget 的詳細資訊視圖，顯示內聯佈局查看器、widget 和渲染物件屬性，以及 Flex widget 及其子項的 Flex 佈局資源管理器。</li>
</ul>
<p>新的 Inspector 很快就會有更多改進，但這些變更已經可以試用了！請提交您遇到的任何 <a href="https://github.com/flutter/devtools/issues">問題</a>，以便我們在預設啟用新的 Inspector 之前修復它們。</p>
<h4 id="Flutter-DevTools-使用-WebAssembly-進行嘗試"><a href="#Flutter-DevTools-使用-WebAssembly-進行嘗試" class="headerlink" title="Flutter DevTools - 使用 WebAssembly 進行嘗試"></a>Flutter DevTools - 使用 WebAssembly 進行嘗試</h4><p>在 DevTools 設定中啟用 WebAssembly 功能，以載入 WASM 編譯的 DevTools Web 應用程式。</p>
<p>這應該比預設的 JS 編譯版本的 DevTools 產生更好的效能。此功能是實驗性的，因此請提交您在 WASM 建置中遇到的任何 <a href="https://github.com/flutter/devtools/issues">問題</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/565/0*J2ur0Z_wJsdbAUt8" />
<figcaption><em>DevTools 設定，用於使用 WebAssembly 建置而不是 Javascript 建置。</em></figcaption>
</figure>

<h3 id="重大變更和棄用"><a href="#重大變更和棄用" class="headerlink" title="重大變更和棄用"></a>重大變更和棄用</h3><h4 id="Material-Design-3-標記"><a href="#Material-Design-3-標記" class="headerlink" title="Material Design 3 標記"></a>Material Design 3 標記</h4><p>最新的 Material Design 3 標記 (v6.1) 已應用於 Flutter Material 函式庫。Material Design 標記更新了僅在亮模式下 4 種顏色角色的映射，以在保持可存取對比度的同時更具視覺吸引力。我們在測試此變更時沒有發現任何損壞，此變更應用於以下顏色屬性：</p>
<ul>
<li>主要容器上（Primary10 到 Primary30）</li>
<li>次要容器上（Secondary10 到 Secondary30）</li>
<li>三級容器上（Tertiary10 到 Tertiary30）</li>
<li>錯誤容器上（Error10 到 Error30）</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/266/0*_uQf9sIr4M1EC34y" />
</figure>

<p>這會影響使用這些角色作為其預設值的 Widget。</p>
<p>晶片（<code>Chip</code>、<code>ActionChip</code>、<code>ChoiceChip</code>、<code>FilterChip</code> 和 <code>InputChip</code>）的邊框顏色已從 <code>ColorScheme.outline</code> 更新為 <code>ColorScheme.outlineVariant</code>。這改善了晶片和按鈕之間的視覺層次結構。</p>
<h4 id="Objective-C-iOS-專案"><a href="#Objective-C-iOS-專案" class="headerlink" title="Objective-C iOS 專案"></a>Objective-C iOS 專案</h4><p>自 2019 年 Flutter 1.9.1 發佈以來，新的 iOS 專案預設使用 Swift。建立 <a href="https://github.com/flutter/flutter/issues/148586">新的 Objective-C iOS 專案現在已被棄用</a>，並且 <code>flutter create --ios-language objc</code> 標誌將在 Flutter 的未來版本中移除。您仍然可以打開 Xcode 專案並加入 Objective-C 檔案，包括插件的檔案。Java 繼續透過 <code>flutter create --android-language java</code> 標誌支援 Android 應用程式。</p>
<h4 id="深度連結預設標誌"><a href="#深度連結預設標誌" class="headerlink" title="深度連結預設標誌"></a>深度連結預設標誌</h4><p>Flutter 的深度連結標誌的預設值已從 <strong>false</strong> 變更為 <strong>true</strong>，這意味著深度連結現在預設為選擇加入。如果您使用 Flutter 的預設深度連結設定，則不再需要手動將標誌設定為 <strong>true</strong>。</p>
<p>但是，如果您使用協力廠商插件進行深度連結，例如：</p>
<ul>
<li><a href="https://firebase.google.com/docs/dynamic-links">firebase 動態連結</a></li>
<li><a href="https://pub.dev/packages/uni_links">uni_link</a></li>
<li><a href="https://pub.dev/packages/app_links">app_links</a></li>
</ul>
<p>此更新將引入重大變更。在這種情況下，您需要手動將 Flutter 深度連結標誌重置為 <strong>false</strong>。</p>
<p>有關更多詳細資訊，請參閱設計文件：<a href="http://flutter.dev/go/deep-link-flag-migration">flutter.dev&#x2F;go&#x2F;deep-link-flag-migration</a></p>
<h4 id="在-IDE-中棄用對較舊-SDK-的支援"><a href="#在-IDE-中棄用對較舊-SDK-的支援" class="headerlink" title="在 IDE 中棄用對較舊 SDK 的支援"></a>在 IDE 中棄用對較舊 SDK 的支援</h4><p>為了確保我們能夠繼續提供高品質的開發人員體驗，我們正在對 IDE 插件支援進行變更。隨著 VS Code 和 IntelliJ 的 Dart 和 Flutter 插件的發展，支援較舊的 Dart SDK 版本變得越來越具有挑戰性。</p>
<p>從 Dart 3.6 發佈開始，我們將棄用對早於 3.0（於 2023 年 5 月發佈）的 Dart SDK 版本的支援。這意味著雖然這些工具可能仍然可以使用較舊的 SDK，但我們將不再為特定於這些版本的問題提供官方支援或修復。</p>
<p>隨著 Dart 3.7（預計在 2025 年第一季度）的發佈，我們將完全移除對這些較舊 SDK 版本的支援。這些插件的未來版本可能與這些版本不相容。</p>
<p><strong>這對您意味著什麼？</strong></p>
<ul>
<li>如果您使用的是較舊的 Dart SDK，我們鼓勵您升級到 3.0 或更高版本，以繼續接收支援和更新。</li>
<li>此變更影響不到我們 1% 的使用者，它將使我們能夠專注於為絕大多數開發人員提供最佳的體驗。</li>
</ul>
<h4 id="結束語"><a href="#結束語" class="headerlink" title="結束語"></a>結束語</h4><p>有關此版本中的所有重大變更，請參閱 <a href="https://docs.flutter.dev/release/breaking-changes">重大變更頁面</a> 上的完整遷移指南列表。</p>
<p>與往常一樣，非常感謝社群為 <a href="https://github.com/flutter/tests/blob/master/README.md">貢獻測試</a>——這些測試幫助我們識別重大變更。若要進一步了解，請查看 <a href="https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes">Flutter 的重大變更政策</a>。</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>非常感謝整個 Flutter 社群使此版本成為可能！您的貢獻、回饋和熱情是推動 Flutter 向前發展的動力。我們對 Flutter 的未來感到無比興奮，並迫不及待地想看到您使用 Flutter 3.27 建置的出色應用程式。</p>
<p>有關所有變更的完整概要，請查看詳細的 <a href="https://docs.flutter.dev/release/release-notes">發行說明和變更日誌</a>。準備好體驗最新最好的功能了嗎？只需運行 <code>flutter upgrade</code> 並開始建置！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=28341129570c" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/whats-new-in-flutter-3-27-28341129570c">Flutter 3.27 的新功能</a> 最初發佈在 Medium 上的 <a href="https://medium.com/flutter">Flutter</a> 中，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/6a2d80d6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/6a2d80d6.html" class="post-title-link" itemprop="url">【文章翻譯】Tune in for #FlutterInProduction — coming soon to a screen near you!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-03 19:01:01" itemprop="dateCreated datePublished" datetime="2024-12-03T19:01:01+08:00">2024-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-12 11:13:06" itemprop="dateModified" datetime="2024-12-12T11:13:06+08:00">2024-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="收看-FlutterInProduction-即將在您附近的螢幕上播出！"><a href="#收看-FlutterInProduction-即將在您附近的螢幕上播出！" class="headerlink" title="收看 #FlutterInProduction - 即將在您附近的螢幕上播出！"></a>收看 #FlutterInProduction - 即將在您附近的螢幕上播出！</h2><p>在您的日曆上標記，並務必在 <strong>2024 年 12 月 17 日</strong> 太平洋時間上午 11:00 &#x2F; 東部時間下午 2:00 &#x2F; 中歐時間晚上 8:00 收看 <strong>#FlutterInProduction</strong>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/1*SSIgDyW3jMaOF5nxH5D9lw.gif" />
</figure>

<p>這個在 <a href="https://www.youtube.com/@flutterdev">Flutter YouTube 頻道</a> 上舉辦的線上活動與我們之前的活動略有不同。我們不僅會深入探討最新版本（儘管我們一定會這樣做！）：#FlutterInProduction 還將慶祝我們作為一個社群共同走過的不可思議的旅程，使 Flutter 成為今天這個強大的、可投入生產的框架。</p>
<h3 id="預期內容"><a href="#預期內容" class="headerlink" title="預期內容"></a>預期內容</h3><ul>
<li><strong>#FlutterInProduction：</strong>無論您是經驗豐富的專業人士還是剛剛起步，您都將從 Flutter 使用者故事中獲得新的見解和靈感，從 Flutter 技術負責人那裡了解更多關於最新功能的資訊，並在此多環節線上活動中了解 Flutter 應用程式開發的未來。</li>
<li><strong>#AskFlutter 線上問答：</strong>從 Flutter 團隊負責人那裡獲得您的問題的解答。請持續關注我們在社群媒體上的徵集問題！</li>
<li><strong>Observable Flutter：</strong>對在企業開發環境中使用 Flutter 構建有什麼疑問嗎？從在生產中使用 Flutter 的公司的技術負責人那裡獲得這些問題的解答。</li>
</ul>
<h3 id="保持關注"><a href="#保持關注" class="headerlink" title="保持關注"></a>保持關注</h3><p>我們將會有一些驚喜和公告，因此請務必採取以下步驟以保持了解最新資訊。</p>
<ol>
<li>在您的日曆上或在 <a href="https://www.youtube.com/@flutterdev">YouTube</a> 上 <a href="https://calndr.link/event/jqZQr0d7nH">設定提醒</a>，了解活動時間。</li>
<li>在 <a href="https://www.youtube.com/redirect?event=channel_description&redir_token=QUFFLUhqbkRYNDVxWGRFUUZYNVdmMlg4QTB4akhOeXNVd3xBQ3Jtc0trWWpSSHo0Tnh3QjlKdF81Z0lsSkQzQWdxVEpBNVdOSVE5Q01tUUltMUFvV2k5Z1RfUzVtc0JET0pFejVRLTl1UUdPNG9DMHk3ZWpUcGtRVGVtUk1yUzA3SEx4STVpM09Kd0dSczVxOGhyQkxRb1EwNA&q=https://twitter.com/FlutterDev">Twitter</a>，<a href="https://www.linkedin.com/showcase/flutterdevofficial/">LinkedIn</a> 或此處的 Medium 上關注我們！</li>
</ol>
<p>我們迫不及待地想與您分享 #<strong>FlutterinProduction</strong>！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6bb9820d1506" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/tune-in-for-flutterinproduction-coming-soon-to-a-screen-near-you-6bb9820d1506">收看 #FlutterInProduction - 即將在您附近的螢幕上播出！</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/bf2dc4e6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/bf2dc4e6.html" class="post-title-link" itemprop="url">【文章翻譯】Prospera: using Flutter to bring AI to the frontline of sales</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-21 17:32:03" itemprop="dateCreated datePublished" datetime="2024-11-21T17:32:03+08:00">2024-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:03:54" itemprop="dateModified" datetime="2024-12-18T12:03:54+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 2.0 自動翻譯產生】</p>
<h2 id="Prospera：使用-Flutter-將-AI-帶到銷售前線"><a href="#Prospera：使用-Flutter-將-AI-帶到銷售前線" class="headerlink" title="Prospera：使用 Flutter 將 AI 帶到銷售前線"></a>Prospera：使用 Flutter 將 AI 帶到銷售前線</h2><figure>
<img alt="Gemini graphic" src="https://cdn-images-1.medium.com/max/512/1*rV1FMqYeyrHsOvtSUIOnOA.png" />
</figure>

<p>世界各地的開發人員正在使用 Google 的 Gemini 模型來應對現實世界的挑戰，而我們看到最令人興奮的應用之一就是在銷售領域。認識 Prospera，它在我們最近的 <a href="http://ai.google.dev/competition">Gemini API 開發者競賽</a> 中獲得了 <em>最佳 Flutter 應用程式</em> 和 <em>最有用的應用程式</em> 兩項大獎！Prospera 由來自德國的 Leon Kukuk 和 Max Hasenohr 共同開發，它是一款 AI 驅動的銷售教練，可在通話期間和通話後提供即時指導和回饋。這款創新的 Flutter 應用程式展示了 Gemini 如何改變銷售專業人員學習和提升技能的方式。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FZTFKbhmGcUo%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DZTFKbhmGcUo&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FZTFKbhmGcUo%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/4ae49e7b2a8ce8088799bc6c2f4f30a2/href">https://medium.com/media/4ae49e7b2a8ce8088799bc6c2f4f30a2/href</a></iframe>

<h3 id="Gemini-API-作為核心：即時分析和多模態魔法"><a href="#Gemini-API-作為核心：即時分析和多模態魔法" class="headerlink" title="Gemini API 作為核心：即時分析和多模態魔法"></a>Gemini API 作為核心：即時分析和多模態魔法</h3><p>Prospera 以真正獨特的方式利用 Gemini 的多模態功能。透過將語音對話片段直接輸入 Gemini API 的 Python SDK，該應用程式可以從經驗豐富的銷售教練的角度提供即時回饋。想像一下，在您通話期間，有一個 AI 副駕駛會提供有價值的見解和建議——這就是 Prospera 的力量。</p>
<p>但他們是如何實現這種無縫整合的呢？Prospera 的開發者 Leon 巧妙地使用了 Dart FFI（外部函數介面）和 ffigen 套件，為 PJSIP C 函式庫建立了 Dart 繫接，從而在 Flutter 中實現了無縫的電話整合，並允許透過 Gemini API 處理這些通話。這使他們能夠即時處理音訊資料，並向銷售代表提供即時回饋。</p>
<p><strong>「Gemini 對語音的細緻理解給我們留下了深刻的印象，這要歸功於其多模態音訊功能以及易於實作的特性。Flutter 使我們能夠以驚人的速度開發跨平台應用程式，同時提供了透過 FFI 和平台通道運行原生程式碼的強大機會。」——Leon</strong></p>
<h3 id="適用於所有平台的-Flutter-應用程式"><a href="#適用於所有平台的-Flutter-應用程式" class="headerlink" title="適用於所有平台的 Flutter 應用程式"></a>適用於所有平台的 Flutter 應用程式</h3><p>Prospera 使用 Flutter 構建，可以從單一程式碼庫在各種桌面平台上無縫運行。這不僅簡化了開發，還為未來擴展到行動裝置打開了大門，讓更廣泛的受眾可以使用該應用程式。開發人員還密切關注使用者體驗，使用 Material Design Widget 製作了一個設計精美的應用程式，並確保了完全的無障礙使用。</p>
<h3 id="超越銷售：展望溝通的未來"><a href="#超越銷售：展望溝通的未來" class="headerlink" title="超越銷售：展望溝通的未來"></a>超越銷售：展望溝通的未來</h3><p>透過將 Gemini 的強大功能與 Flutter 的多功能性相結合，Leon 和 Max 開發了一款有可能徹底改變我們學習、互動和在職業生涯中脫穎而出的方式的應用程式。Prospera 不僅僅是一個銷售教練；它讓我們看到了 AI 如何增強人類溝通和專業發展的未來。雖然 Prospera 專注於銷售指導，但其底層技術和方法具有更廣泛的應用。分析即時對話並提供建設性回饋的能力在各種以溝通為導向的職業中都很有價值，例如客戶服務和教育。</p>
<p><strong>想了解更多關於 Dart FFI 以及它如何增強您的 Flutter 應用程式的資訊嗎？請在 pub.dev 上查看 <a href="https://pub.dev/packages/ffigen">ffigen</a> 套件。</strong></p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=71377810fd26" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/prospera-using-flutter-to-bring-ai-to-the-frontline-of-sales-71377810fd26">Prospera：使用 Flutter 將 AI 帶到銷售前線</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/14c13b13.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/14c13b13.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Dart 3.5, and an update on the Dart roadmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-06 18:02:40" itemprop="dateCreated datePublished" datetime="2024-08-06T18:02:40+08:00">2024-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-12 11:14:10" itemprop="dateModified" datetime="2024-12-12T11:14:10+08:00">2024-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Dart-3-5-以及-Dart-路線圖更新"><a href="#宣布-Dart-3-5-以及-Dart-路線圖更新" class="headerlink" title="宣布 Dart 3.5 以及 Dart 路線圖更新"></a>宣布 Dart 3.5 以及 Dart 路線圖更新</h2><p>是時候發布我們另一個季度性的 Dart SDK 版本了。我們在互操作性方面有所改進，在 pub.dev 套件管理器中增加了新功能，並且將新的 Web 整合 API 提升到穩定版本 1.0。</p>
<p>我們的大部分時間都致力於更大的、跨越多個季度的項目，因此我們也對 Dart 路線圖進行了更新，詳細說明了我們希望在未來幾個季度取得進展的目標。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PVj9TIzP50I00tavJqAg_Q.gif" />
<figcaption>Dart 3.5 發布影像。</figcaption>
</figure>

<h3 id="Dart-3-5-中的新功能"><a href="#Dart-3-5-中的新功能" class="headerlink" title="Dart 3.5 中的新功能"></a>Dart 3.5 中的新功能</h3><p>Dart 3.5 包含許多下面討論的新功能。核心函式庫 API 也有一些較小的變更，以及大約 10 個非常小的重大變更，這些都在 <a href="https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md#350">變更日誌</a> 中說明 。</p>
<h3 id="Web-平台和-JS-互操作性"><a href="#Web-平台和-JS-互操作性" class="headerlink" title="Web 平台和 JS 互操作性"></a>Web 平台和 JS 互操作性</h3><p>在 Dart 3.4 和 Flutter 3.22 中，我們引入了對 <a href="https://docs.flutter.dev/platform-integration/web/wasm">將 Flutter Web 應用程式編譯到 WebAssembly</a> 的支援。編譯到 WebAssembly 需要使用我們新的 <a href="https://dart.dev/interop/js-interop">Dart 到 JS 互操作模型</a>，該模型之前處於預覽狀態。從 Dart 3.5 開始，它現在被視為穩定且完整，我們已將 <a href="https://pub.dev/packages/web">package:web</a>（它取代了舊的 dart:html 函式庫）中的瀏覽器 API 綁定更新到版本 1.0。</p>
<p>我們鼓勵所有 Web 套件作者 <a href="https://dart.dev/interop/js-interop/package-web">遷移到 package:web</a>。我們計劃在我們的下一個 Dart 版本中棄用舊的互操作 API（dart:html、dart:js、package:js 等），並在明年晚些時候完全停用它們。我們邀請您在 <a href="https://github.com/dart-lang/sdk/issues/56358">追蹤議題</a> 中提供您對此計劃的回饋。我們還計劃更新 pub.dev 套件管理器的 <a href="https://pub.dev/help/scoring">評分</a>，為支援新互操作模型的 Web 套件頒發積分。</p>
<p>我們還增加了一個 <a href="https://dart.dev/tools/linter-rules/invalid_runtime_check_with_js_interop_types">新的 Lint</a>，它驗證您的程式碼是否正確使用了新的 JS 互操作類型。我們建議您將此 Lint 加入到您的 analysis_options.yaml 檔案中，作為遷移您的 Web 套件的一部分。</p>
<h3 id="Dart-原生互操作性"><a href="#Dart-原生互操作性" class="headerlink" title="Dart 原生互操作性"></a>Dart 原生互操作性</h3><p>我們還對原生互操作性進行了一系列改進，這些改進支援從 Dart 直接調用 C、Java、Kotlin、Objective-C 和 Swift。</p>
<p>C 互操作性由我們的 <a href="https://dart.dev/interop/c-interop">FFI</a>（外部函數介面）函式庫啟用，我們已經支援了幾年。在 Dart 3.5 中，我們進行了增量改進，以支援將指標從 Dart TypedData 物件直接傳遞到 FFI，避免需要先將記憶體從 Dart 複製到原生（<a href="https://github.com/dart-lang/sdk/issues/44589">詳細資訊</a>）。</p>
<p>Java 和 Kotlin 互操作性由 <a href="https://pub.dev/packages/jnigen">JNIgen</a> 生成器（目前處於預覽狀態）啟用，它自動建立綁定程式碼，以便透過 Java 原生介面（<a href="https://developer.android.com/training/articles/perf-jni">JNI</a>）從 Dart 調用 Java 和 Kotlin。我們改進了效能，並增加了對 Java 異常和 Kotlin 頂級函式的支援。我們還停用了以前的 <a href="https://github.com/dart-lang/native/issues/660">基於 C 的綁定</a>，因為替代的僅 Dart 綁定現在具有相當的效能和功能，並且更易於使用。如需詳細資訊，請查看 <a href="https://pub.dev/packages/jnigen/changelog">變更日誌</a>。</p>
<p>Objective-C 互操作性建立在 FFI 和我們的 <a href="https://pub.dev/packages/ffigen">FFIgen</a> 生成器（目前處於預覽狀態）的基礎之上。我們增加了對 Objective-C 協定的支援，以及 NSString 等常見類型。如需使用 FFIgen 建立的套件的一個大型範例，請查看 <a href="https://github.com/dart-lang/http/tree/master/pkgs/cupertino_http">cupertino_http</a>，它與 Apple 的 URL 載入系統網路函式庫進行互操作。</p>
<p>在未來的版本中，我們將繼續投資於進一步的互操作性 - 既包括完成上述函式庫，也包括支援 Swift。請參閱下面的路線圖部分以獲取詳細資訊。</p>
<h3 id="pub-dev-套件儲存庫"><a href="#pub-dev-套件儲存庫" class="headerlink" title="pub.dev 套件儲存庫"></a>pub.dev 套件儲存庫</h3><p>pub.dev 是我們的套件儲存庫，社群可以在其中分享和查找具有豐富功能的套件。我們在此處進行了一些改進。首先，我們改進了對 <a href="https://dart.dev/tools/pub/pubspec#topics">主題</a> 的支援：套件作者可以使用此機制使用套件所屬的類別（例如 Widget）對其套件進行標記。我們現在 <a href="https://github.com/dart-lang/pub-dev/blob/master/doc/topics.yaml">彙整</a> 涵蓋相同類別但使用略微不同的措辭的常見主題（例如 Widget 與 Widget）。</p>
<p>其次，我們新增了一個新的 pub unpack 命令。這提供了一種在檔案系統中快速下載套件的簡單方法。例如，如果您要運行套件的範例程式並在您的本地機器上運行程式，則可以使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dart pub unpack path</span><br><span class="line">Downloading path 1.9.0 to `./path-1.9.0`...</span><br><span class="line"></span><br><span class="line">$ cd path-1.9.0/example/</span><br><span class="line"></span><br><span class="line">$ dart run example.dart</span><br><span class="line">Current path style: posix</span><br><span class="line">Current process path: /Users/mit/tmp/path-1.9.0/example</span><br></pre></td></tr></table></figure>

<p>第三，我們新增了一個新的 pub downgrade –tighten 命令。這可以用於檢查套件相依關聯中的所有版本約束。運行時，它會將下限約束更新到 pub 成功進行解析的最低版本。</p>
<h3 id="Dart-路線圖更新"><a href="#Dart-路線圖更新" class="headerlink" title="Dart 路線圖更新"></a>Dart 路線圖更新</h3><p>除了上述已完成的功能外，我們還在許多領域進行了工作，以使我們的長期路線圖取得進展。</p>
<h3 id="大型-Monorepo-的-IDE-和分析器效能"><a href="#大型-Monorepo-的-IDE-和分析器效能" class="headerlink" title="大型 Monorepo 的 IDE 和分析器效能"></a>大型 Monorepo 的 IDE 和分析器效能</h3><p>「Monorepo」是對一組相關套件和應用程式進行建構的常見方式，將所有程式碼都放在同一個儲存庫中，例如 Flutter 的 <a href="https://github.com/flutter/packages/tree/main">套件儲存庫</a>。Monorepo 不僅僅是將所有程式碼「放在一起」的便利性，而且還是確保儲存庫中單獨的套件和應用程式相互相容的關鍵工具。</p>
<p>我們從在大型 Monorepo 中工作的開發人員那裡收到了持續的回饋，表示我們的工具（特別是分析器）的效能可能存在缺陷。我們對這些問題的分析表明，根本問題在於我們最終會為每個套件及其 <strong>所有</strong> 相依關聯載入多個重疊的分析內容，導致儲存庫中每個套件的多次分析同時在記憶體中。我們認為根本的解決方案是在此類儲存庫中建立每個相依關聯版本的單一、共用解析，並且正在透過一個稱為 <a href="https://github.com/dart-lang/sdk/issues/53875">工作區</a> 的新 pub 功能來實現此功能。我們將在下一個 Dart 版本中分享更多關於此功能的資訊，但現在您可以先看看它是如何 <a href="https://github.com/flutter/engine/pull/54157/files">最近應用於 Flutter 引擎儲存庫的</a>。</p>
<h3 id="pub-dev-套件儲存庫-1"><a href="#pub-dev-套件儲存庫-1" class="headerlink" title="pub.dev 套件儲存庫"></a>pub.dev 套件儲存庫</h3><p>pub.dev 套件儲存庫的使用者長期以來一直要求改進 <a href="https://github.com/dart-lang/pub-dev/issues/2714">每個套件的使用次數&#x2F;下載次數</a> 指標。這對於套件作者來說很有幫助，可以作為他們的工作產生多少使用者效益的信號，對於套件使用者來說也有幫助，可以作為其他開發人員在使用哪些套件的信號。我們很高興地分享我們在這個功能方面取得了良好的進展，並且希望在年底前提供預覽版本。</p>
<h3 id="Dart-原生互操作性-1"><a href="#Dart-原生互操作性-1" class="headerlink" title="Dart 原生互操作性"></a>Dart 原生互操作性</h3><p>對於使用 JNIgen 的 Java 和 Kotlin 互操作性，我們預計在未來的兩個季度內完成核心支援，並從實驗性版本升級到穩定版本 1.0。如需詳細資訊，請參閱 <a href="https://github.com/orgs/dart-lang/projects/69/">JNIgen 追蹤器</a>。對於 ObjectiveC 互操作性，我們也有類似的目標；請參閱 <a href="https://github.com/orgs/dart-lang/projects/87/">Objective-C 追蹤器</a>。</p>
<p>接下來，我們將調查與 Swift 程式碼的直接互操作性。初步實驗看起來很有前景，我們希望在明年年初新增實驗性支援。</p>
<h3 id="原生互操作性和原生原始碼的捆綁"><a href="#原生互操作性和原生原始碼的捆綁" class="headerlink" title="原生互操作性和原生原始碼的捆綁"></a>原生互操作性和原生原始碼的捆綁</h3><p>在許多情況下，直接互操作性用於調用存在於作業系統中的 API，這意味著這些 API 始終在這些主機平台上可用。但是，在某些情況下，Dart 正在與其進行互操作的程式碼是原生 <em>原始碼</em>，而不是直接包含在主機上，這對使用此互操作性的套件作者來說是一個實際挑戰：如何將這些原生原始碼捆綁和構建，而無需將大量手動步驟推送到套件的使用者？為了支援這一點，我們正在探索一個 <a href="https://github.com/dart-lang/sdk/issues/50565">原生資產系統</a>，它可以支援發佈包含原生原始碼的 Dart 套件，以及一個標準化協定，允許 dart 和 flutter CLI 工具自動化這些原始碼的構建和捆綁。我們設想這將啟用一組新的互操作性用例，同時為使用依賴於原生原始碼的套件的開發人員提供簡化的使用者體驗。</p>
<h3 id="Dart-語言和宏"><a href="#Dart-語言和宏" class="headerlink" title="Dart 語言和宏"></a>Dart 語言和宏</h3><p>Dart 語言和編譯器團隊目前的大部分時間都花在了非常大型的語言功能宏的進展上，我們在 <a href="https://medium.com/dartlang/dart-3-4-bd8d23b4462a">Dart 3.4 部落格文章</a> 中介紹了這個功能。正如我們當時所說，這是一項巨大的工作，有可能會導致我們的一些核心用例（例如熱重載）出現回歸，因此我們正在採取徹底的方法，並且可能需要幾個季度的進一步工作才能分享下一步的詳細資訊。</p>
<p>除了宏之外，我們還同時探索了許多其他的較小的語言功能，如 <a href="https://github.com/orgs/dart-lang/projects/90/views/1">Dart 語言漏斗</a> 中所記錄的那樣。</p>
<p>從去年秋天開始，我們一直在重寫 Dart 格式化程式。舊的設計在過去的幾年裡運行良好，但是隨著 Flutter 的成功，我們希望遷移到 <a href="https://github.com/dart-lang/dart_style/issues/1253">一種新的風格</a>，以便更好地適應 Flutter 使用者經常編寫的聲明式程式碼類型。舊的格式化程式無法產生那種輸出。重寫工作即將完成，並且很快就會發佈。如果您想嘗試一下，請使用 experiment 標誌 tall-style（<a href="https://dart.dev/tools/experiment-flags">標誌說明</a>）。如果您看到奇怪的輸出，歡迎您 <a href="https://github.com/dart-lang/dart_style/issues">提供回饋</a>。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>這就是我們今天要分享的內容。我們歡迎您提供回饋，無論是關於討論的路線圖項目，還是關於 Dart 3.5 中的新功能，這些功能可以在 <a href="https://dart.dev/get-dart">Dart.dev</a> 上獲得，或者捆綁在今天的 <a href="https://medium.com/flutter/whats-new-in-flutter-3-24-6c040f87d1e4">Flutter 3.24 版本</a> 中。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6ca36259fa2f" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/dart-3-5-6ca36259fa2f">宣布 Dart 3.5 以及 Dart 路線圖更新</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>
<p>undefined</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/8ddf18fb.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/8ddf18fb.html" class="post-title-link" itemprop="url">【文章翻譯】Getting started with Flutter GPU</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-06 18:02:39" itemprop="dateCreated datePublished" datetime="2024-08-06T18:02:39+08:00">2024-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 01:40:49" itemprop="dateModified" datetime="2024-09-30T01:40:49+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="在-Flutter-中建立自訂渲染器並渲染-3D-場景。"><a href="#在-Flutter-中建立自訂渲染器並渲染-3D-場景。" class="headerlink" title="在 Flutter 中建立自訂渲染器並渲染 3D 場景。"></a>在 Flutter 中建立自訂渲染器並渲染 3D 場景。</h2><p>Flutter 3.24 版本引進了一個新的低階圖形 API，稱為 <a href="https://github.com/flutter/engine/blob/main/docs/impeller/Flutter-GPU.md">Flutter GPU</a>。還有一個由 Flutter GPU 支援的 3D 渲染函式庫，稱為 <a href="https://pub.dev/packages/flutter_scene">Flutter Scene</a>（套件：flutter_scene）。Flutter GPU 和 Flutter Scene 目前都處於預覽階段，僅在 Flutter 的 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a> 上可用（由於依賴實驗性功能），需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>，並且可能偶爾會引入重大變更。</p>
<p>本文包含這兩個套件的兩個「入門」指南：</p>
<ol>
<li>🔺 <strong>進階：</strong><a href="#d558">使用 Flutter GPU 入門</a><br>如果您是經驗豐富的圖形程式設計師，或者您對低階圖形感興趣，並想在 Flutter 中從頭開始建立渲染器，那麼本指南將幫助您開始使用 Flutter GPU。您將從頭開始繪製第一個三角形… 在 Flutter 中！</li>
<li>💚 <strong>中級：</strong><a href="#6b35">使用 Flutter Scene 進行 3D 渲染</a><br>如果您是想要將 3D 功能添加到應用程式中的 Flutter 開發人員，或者您想要使用 Dart 和 Flutter 建立 3D 遊戲，那麼本指南適合您！您將設定一個專案，在 Flutter 中匯入和渲染 3D 資產。</li>
</ol>
<h3 id="使用-Flutter-GPU-入門"><a href="#使用-Flutter-GPU-入門" class="headerlink" title="使用 Flutter GPU 入門"></a>使用 Flutter GPU 入門</h3><p>⚠️ 警告！⚠️ Flutter GPU 最終是一個低階 API。絕大多數將從 Flutter GPU 的存在中受益的 Flutter 開發人員很可能會透過使用在 pub.dev 上發佈的更高階渲染函式庫來做到這一點，例如 Flutter Scene 渲染套件。如果您對 Flutter GPU API 本身不感興趣，而只是對 3D 渲染感興趣，請跳到 <a href="#6b35">使用 Flutter Scene 進行 3D 渲染</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/900/0*hAqIOVkaI1IWnOHE" />
<figcaption>哦，真閃亮。這是一個射線行進的符號距離場。您可以使用 Flutter GPU 渲染它，但使用 [自訂片段著色器](https://docs.flutter.dev/ui/design/graphics/fragment-shaders) 也完全有可能。 </figcaption>
</figure>

<h3 id="使用-Flutter-GPU-入門-1"><a href="#使用-Flutter-GPU-入門-1" class="headerlink" title="使用 Flutter GPU 入門"></a>使用 Flutter GPU 入門</h3><p>Flutter GPU 是 Flutter 內建的低階圖形 API。它允許您透過撰寫 Dart 程式碼和 GLSL 著色器在 Flutter 中建立和整合自訂渲染器。不需要原生平台程式碼。</p>
<p>目前，Flutter GPU 處於早期預覽階段，並提供基本的柵格化 API，但隨著 API 逐漸穩定，將會繼續新增和改進更多功能。</p>
<p>Flutter GPU 還需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。這表示它只能在 Impeller 支援的平台上使用。在撰寫本文時，Impeller 支援：</p>
<ul>
<li>iOS（預設啟用）</li>
<li>macOS（選擇性預覽）</li>
<li>Android（選擇性預覽）</li>
</ul>
<p>我們對 Flutter GPU 的目標是最終支援所有 Flutter 的平台目標。最終目標是促進 Flutter 中跨平台渲染解決方案的生態系統，這些解決方案對於套件作者來說易於維護，對於使用者來說易於安裝。</p>
<p>3D 渲染只是一個可能的用例。Flutter GPU 也可以用於建立專用的 2D 渲染器，或者執行更非正統的操作，例如渲染 4D 空間的 3D 切片，或投影非歐幾里德空間。</p>
<p>由 Flutter GPU 支援的自訂 2D 渲染器的絕佳用例範例將是依賴骨骼網格變形的 2D 角色動畫格式。Spine 2D 就是一個很好的例子。這種骨骼網格解決方案通常具有動畫剪輯，這些剪輯會操縱層次結構中骨骼的平移、旋轉和縮放屬性，並且每個頂點都具有一些關聯的「骨骼權重」，這些權重決定哪些骨骼應該影響頂點，以及影響程度。</p>
<p>使用像 drawVertices 這樣的 Canvas 解決方案，需要在 CPU 上對每個頂點應用骨骼權重轉換。使用 Flutter GPU，骨骼轉換可以以統一陣列或甚至紋理取樣器的形式傳遞到頂點著色器，允許根據骨骼狀態和每個頂點的骨骼權重在 GPU 上並行計算每個頂點的最終位置。</p>
<p>說到此，讓我們透過一個溫和的介紹來開始使用 Flutter GPU：繪製您的第一個三角形！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JEI3fLDGcRHWKruT" />
</figure>

<h3 id="將-Flutter-GPU-加入您的專案"><a href="#將-Flutter-GPU-加入您的專案" class="headerlink" title="將 Flutter GPU 加入您的專案"></a>將 Flutter GPU 加入您的專案</h3><p>首先，請注意 Flutter GPU 目前處於早期預覽狀態，可能會發生 API 斷裂。目前 API 已經可以實現很多功能，但是有經驗的圖形工程師可能會注意到一些缺失的常見功能。Flutter GPU 在接下來的幾個月裡將會新增許多功能。</p>
<p>基於這些原因，強烈建議您在針對 Flutter GPU 開發套件時，暫時使用 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a> 的頂端。如果您遇到任何意外行為、錯誤或有功能請求，請使用標準的 <a href="https://github.com/flutter/flutter/issues/new/choose">Flutter 問題範本</a> 在 GitHub 上提交問題。與 Flutter GPU 相關的所有追蹤問題都標記為 <a href="https://github.com/flutter/flutter/labels/flutter-gpu">flutter-gpu 標籤</a>。</p>
<p>因此，在試驗 Flutter GPU 之前，請透過執行以下命令將 Flutter 切換到 main channel。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>現在建立一個新的 Flutter 專案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_cool_renderer</span><br><span class="line">cd my_cool_renderer</span><br></pre></td></tr></table></figure>

<p>接下來，將 flutter_gpu SDK 套件加入到您的 pubspec 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu --sdk=flutter</span><br></pre></td></tr></table></figure>

<h3 id="建立和匯入著色器捆綁包。"><a href="#建立和匯入著色器捆綁包。" class="headerlink" title="建立和匯入著色器捆綁包。"></a>建立和匯入著色器捆綁包。</h3><p>為了使用 Flutter GPU 渲染任何東西，您需要撰寫一些 GLSL 著色器。Flutter GPU 的著色器與 Flutter 的 <a href="https://docs.flutter.dev/ui/design/graphics/fragment-shaders">片段著色器</a> 功能所使用的著色器具有不同的語義，特別是在統一繫結方面。您還需要定義一個頂點著色器，與片段著色器一起使用。</p>
<p>從定義最簡單的著色器開始。您可以將著色器放置在專案中的任何位置，但是對於此範例，請建立一個 shaders 目錄，並使用兩個著色器填充它：simple.vert 和 simple.frag。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：shaders/simple.vert</span><br><span class="line"></span><br><span class="line">in vec2 position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_Position = vec4(position, 0.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在繪製三角形時，您將擁有一個定義每個頂點的資料列表。在本例中，它僅列出 2D 位置。對於這些頂點中的每一個，簡單的頂點著色器都會將這些 2D 位置分配給剪輯空間輸出內在 gl_Position。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：shaders/simple.frag</span><br><span class="line"></span><br><span class="line">out vec4 frag_color;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  frag_color = vec4(0, 1, 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段著色器甚至更簡單；它輸出一個 RGBA 顏色，範圍為 (0, 0, 0, 0) 到 (1, 1, 1, 1)。因此，所有內容都將被著色為綠色。</p>
<p>好的，現在您有了著色器，請使用 Flutter 的提前編譯 (AOT) 著色器編譯器將它們編譯。為了為著色器捆綁包設定自動化的建置，我們建議您使用 <a href="https://pub.dev/packages/flutter_gpu_shaders">flutter_gpu_shaders</a> 套件。</p>
<p>使用 pub 將 flutter_gpu_shaders 作為專案中的常規相依性加入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu_shaders</span><br></pre></td></tr></table></figure>

<p>Flutter GPU 著色器捆綁到 .shaderbundle 檔案中，可以作為常規資產添加到專案的資產捆綁包中。著色器捆綁包包含針對平台目標的編譯著色器來源。</p>
<p>接下來，建立一個著色器捆綁包宣告檔案，描述著色器捆綁包的內容。將以下內容添加到專案根目錄中的 my_renderer.shaderbundle.json。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;SimpleVertex&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;vertex&quot;,</span><br><span class="line">        &quot;file&quot;: &quot;shaders/simple.vert&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;SimpleFragment&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;fragment&quot;,</span><br><span class="line">        &quot;file&quot;: &quot;shaders/simple.frag&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>著色器捆綁包中的每個條目都可以具有任意名稱。在本例中，名稱是「SimpleVertex」和「SimpleFragment」。這些名稱用於在您的應用程式中查找著色器。</p>
<p>接下來，使用 flutter_gpu_shaders 套件建置 shaderbundle。您可以透過啟用實驗性的「原生資產」功能來新增一個掛鉤，該掛鉤會自動觸發建置。使用以下命令來啟用原生資產並安裝 native_assets_cli 套件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>

<p>啟用原生資產功能後，在掛鉤目錄下新增一個 build.dart 脚本，它將自動觸發建置著色器捆綁包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：hook/build.dart</span><br><span class="line"></span><br><span class="line">import &#x27;package:native_assets_cli/native_assets_cli.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_gpu_shaders/build.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) async &#123;</span><br><span class="line">  await build(args, (config, output) async &#123;</span><br><span class="line">    await buildShaderBundleJson(</span><br><span class="line">        buildConfig: config,</span><br><span class="line">        buildOutput: output,</span><br><span class="line">        manifestFileName: &#x27;my_renderer.shaderbundle.json&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>進行此更改後，當 Flutter 工具建置專案時，buildShaderBundleJson 將建置著色器捆綁包，並將結果輸出到套件根目錄下的 build&#x2F;shaderbundles&#x2F;my_renderer.shaderbundle。</p>
<p>著色器捆綁包格式本身與您使用的 Flutter 特定版本綁定，並且可能會隨著時間推移而改變。如果您正在撰寫一個建置著色器捆綁包的套件，請不要將生成的 .shaderbundle 檔案檢查到您的原始碼樹中。相反，請使用建置掛鉤來自動化建置流程（如前所述）。</p>
<p>這樣一來，使用您函式庫的開發人員將始終使用正確格式建置新的著色器捆綁包！</p>
<p>現在，您已經自動化了著色器捆綁包的建置，請像常規資產一樣匯入它。將資產條目添加到專案的 pubspec.yaml 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  assets:</span><br><span class="line">    - build/shaderbundles/</span><br></pre></td></tr></table></figure>

<p>在未來，原生資產功能將允許建置掛鉤將資料資產附加到捆綁包中。一旦發生這種情況，就不需要再在建置掛鉤旁邊新增資 * * * * *產匯入規則了。</p>
<p>接下來，新增一些程式碼，在執行時載入著色器。建立 lib&#x2F;shaders.dart 並新增以下程式碼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：lib/shaders.dart</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter_gpu/gpu.dart&#x27; as gpu;</span><br><span class="line"></span><br><span class="line">const String _kShaderBundlePath =</span><br><span class="line">    &#x27;build/shaderbundles/my_renderer.shaderbundle&#x27;;</span><br><span class="line">// 注意：如果您正在建立函式庫，則路徑必須以套件名稱為前綴</span><br><span class="line">//      例如：</span><br><span class="line">//      &#x27;packages/my_cool_renderer/build/shaderbundles/my_renderer.shaderbundle&#x27;</span><br><span class="line"></span><br><span class="line">gpu.ShaderLibrary? _shaderLibrary;</span><br><span class="line">gpu.ShaderLibrary get shaderLibrary &#123;</span><br><span class="line">  if (_shaderLibrary != null) &#123;</span><br><span class="line">    return _shaderLibrary!;</span><br><span class="line">  &#125;</span><br><span class="line">  _shaderLibrary = gpu.ShaderLibrary.fromAsset(_kShaderBundlePath);</span><br><span class="line">  if (_shaderLibrary != null) &#123;</span><br><span class="line">    return _shaderLibrary!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  throw Exception(&quot;Failed to load shader bundle! ($_kShaderBundlePath)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼為 Flutter GPU 著色器執行時函式庫建立一個單例 getter。第一次訪問 shaderLibrary 時，會使用 gpu.ShaderLibrary.fromAsset(shader_bundle_path) 使用建置的資產捆綁包初始化執行時著色器函式庫。</p>
<p>專案現在已經設定好使用 Flutter GPU 著色器。是時候渲染那個三角形了！</p>
<h3 id="绘制您的第一個三角形"><a href="#绘制您的第一個三角形" class="headerlink" title="绘制您的第一個三角形"></a>绘制您的第一個三角形</h3><p>對於本指南，您將建立一個 RGBA Flutter GPU 紋理和一個 RenderPass，將紋理作為顏色輸出附加到它。然後，您將使用 <a href="https://api.flutter.dev/flutter/dart-ui/Canvas/drawImage.html">Canvas.drawImage</a> 在 Widget 中渲染紋理。</p>
<p>為了簡潔起見，您將放棄最佳實務，只會為每一幀重新建置所有資源。</p>
<p>只要您在分配紋理時將其標記為「著色器可讀取」，您就可以將其轉換為 dart:ui.Image。若要將渲染結果顯示在 Widget 樹中，請將其繪製到 dart:ui.Canvas 上！</p>
<p>您可以透過使用自訂畫家為 Widget 樹架設腳手架來存取 Canvas。將 lib&#x2F;main.dart 的內容替換為以下內容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:typed_data&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_gpu/gpu.dart&#x27; as gpu;</span><br><span class="line"></span><br><span class="line">// 注意：我們之前在設定著色器捆綁包匯入時建立了它!</span><br><span class="line">import &#x27;shaders.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &#x27;Flutter GPU Triangle Example&#x27;,</span><br><span class="line">      home: CustomPaint(</span><br><span class="line">        painter: TrianglePainter(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrianglePainter extends CustomPainter &#123;</span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    // 嘗試存取 `gpu.gpuContext`。</span><br><span class="line">    // 如果 Flutter GPU 不受支援，將會拋出異常。</span><br><span class="line">    print(&#x27;Default color format: &#x27; +</span><br><span class="line">        gpu.gpuContext.defaultColorFormat.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在，執行應用程式。提醒一下，Flutter GPU 目前需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。因此，您必須使用 Impeller 支援的平台。對於本指南，我將以 macOS 為目標。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*lKTtaX2ih6dFpSMQ" />
</figure>

<p>如果 Flutter GPU 正常工作，那麼您應該會看到預設顏色格式被列印到主控台中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter: Default color format: PixelFormat.b8g8r8a8UNormInt</span><br></pre></td></tr></table></figure>

<p>如果 Impeller 未啟用，則在嘗試存取 gpu.gpuContext 時會拋出異常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception: Flutter GPU requires the Impeller rendering backend to be enabled.</span><br><span class="line"></span><br><span class="line">The relevant error-causing widget was:</span><br><span class="line">  CustomPaint</span><br></pre></td></tr></table></figure>

<p>為了簡便起見，您只會從這裡開始修改 paint 方法。</p>
<p>首先，建立一個 Flutter GPU 紋理，清除它，然後透過將其繪製到 Canvas 上來顯示它。</p>
<p>建立一個與 Canvas 大小相同的紋理。必須選擇一個 <code>StorageMode</code>。在本例中，您將紋理標記為 devicePrivate，因為您將只使用從設備 (GPU) 存取紋理記憶體的指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final texture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate,</span><br><span class="line">    size.width.toInt(), size.height.toInt())!;</span><br></pre></td></tr></table></figure>

<p>如果透過從主機 (CPU) 上傳資料來覆蓋紋理的資料，則使用 <code>StorageMode.hostVisible</code>。</p>
<p>第三個可用的選項是 <code>StorageMode.deviceTransient</code>，它對於不需要超過單個 RenderPass 壽命的附件很有用（因此它們可以只存在於瓦片記憶體中，並且不需要由 VRAM 分配支援）。通常，深度&#x2F;模板紋理符合此標準。</p>
<p>接下來，定義一個 <code>RenderTarget</code>。渲染目標包含一組「附件」，描述每個片段的記憶體佈局及其在 RenderPass 開始和結束時的設定&#x2F;拆卸行為。</p>
<p>本質上，RenderTarget 是 RenderPass 的可重複使用描述器。</p>
<p>現在，定義一個非常簡單的 <code>RenderTarget</code>，它只包含一個顏色附件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final renderTarget = gpu.RenderTarget.singleColor(</span><br><span class="line">gpu.ColorAttachment(texture: texture, clearValue: Colors.lightBlue));</span><br></pre></td></tr></table></figure>

<p>請注意，此程式碼將 clearValue 設定為淡藍色。每個附件都具有 <code>LoadAction</code> 和 <code>StoreAction</code>，它們分別確定在傳遞的開始和結束時應該對附件的臨時瓦片記憶體執行什麼操作。</p>
<p>預設情況下，顏色附件被設定為 <code>LoadAction.clear</code>（它將瓦片記憶體初始化為給定的顏色）和 <code>StoreAction.store</code>（它將結果儲存到附加的紋理的 VRAM 分配中）。</p>
<p>現在，建立一個 <code>CommandBuffer</code>，使用前面的 RenderTarget 從其中產生一個 RenderPass，然後立即提交 CommandBuffer 以清除紋理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final commandBuffer = gpu.gpuContext.createCommandBuffer();</span><br><span class="line">final renderPass = commandBuffer.createRenderPass(renderTarget);</span><br><span class="line">// ... 繪製調用將放在這裡!</span><br><span class="line">commandBuffer.submit();</span><br></pre></td></tr></table></figure>

<p>剩下的就是將初始化的紋理繪製到 Canvas 上！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final image = texture.asImage();</span><br><span class="line">canvas.drawImage(image, Offset.zero, Paint());</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ebUDtzQOuIGmdlop" />
</figure>

<p>現在您有了連接到螢幕顯示結果的 RenderPass，您就可以開始繪製三角形了。若要執行此操作，請設定以下內容：</p>
<ol>
<li>從著色器建立的 RenderPipeline，以及</li>
<li>包含幾何形狀的 GPU 可存取緩衝區（三個頂點位置）。</li>
</ol>
<p>建立 RenderPipeline 很容易。您只需將函式庫中的頂點和片段著色器組合在一起。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final vert = shaderLibrary[&#x27;SimpleVertex&#x27;]!;</span><br><span class="line">final frag = shaderLibrary[&#x27;SimpleFragment&#x27;]!;</span><br><span class="line">final pipeline = gpu.gpuContext.createRenderPipeline(vert, frag);</span><br></pre></td></tr></table></figure>

<p>現在是幾何形狀。回想一下，「SimpleVertex」著色器只有一個輸入：<code>in vec2 position</code>。因此，若要繪製三個頂點，您需要三組兩個浮點數。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final vertices = Float32List.fromList([</span><br><span class="line">  -0.5, -0.5, // 第一個頂點</span><br><span class="line">   0.5, -0.5, // 第二個頂點</span><br><span class="line">   0.0,  0.5, // 第三個頂點</span><br><span class="line">]);</span><br><span class="line">final verticesDeviceBuffer = gpu.gpuContext</span><br><span class="line">    .createDeviceBufferWithCopy(ByteData.sublistView(vertices))!;</span><br></pre></td></tr></table></figure>

<p>剩下的就是繫結新的資源，並呼叫 renderPass.draw() 以完成記錄繪製調用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renderPass.bindPipeline(pipeline);</span><br><span class="line"></span><br><span class="line">final verticesView = gpu.BufferView(</span><br><span class="line">  verticesDeviceBuffer,</span><br><span class="line">  offsetInBytes: 0,</span><br><span class="line">  lengthInBytes: verticesDeviceBuffer.sizeInBytes,</span><br><span class="line">);</span><br><span class="line">renderPass.bindVertexBuffer(verticesView, 3);</span><br><span class="line"></span><br><span class="line">renderPass.draw();</span><br></pre></td></tr></table></figure>

<p>如果您啟動應用程式，您現在應該會看到一個綠色的三角形！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LWnGU5WPT_Eom0wJ" />
</figure>

<p>太棒了，您使用 Flutter、Dart 和一點 GLSL 從頭開始建立了一個渲染器！</p>
<p>無論這是否是您第一次渲染三角形，或者您是經驗豐富的圖形專家，我都希望您能繼續使用 Flutter GPU，並查看我們正在開發的套件，例如 Flutter Scene。</p>
<p>在未來，我們希望發佈友好的初學者程式碼實驗室，深入探討 Flutter GPU 的預設行為和最佳實務。我們還沒討論頂點屬性佈局、紋理繫結、統一和對齊要求、管道混合、深度和模板附件、透視校正等等！</p>
<p>在那之前，我建議您探索 <a href="https://github.com/bdero/flutter_scene">Flutter Scene</a> 作為如何使用 Flutter GPU 的更全面的範例。</p>
<h3 id="使用-Flutter-Scene-進行-3D-渲染"><a href="#使用-Flutter-Scene-進行-3D-渲染" class="headerlink" title="使用 Flutter Scene 進行 3D 渲染"></a>使用 Flutter Scene 進行 3D 渲染</h3><p>Flutter Scene（套件 flutter_scene）是一個新的 3D 場景圖套件，由 Flutter GPU 支援，它使 Flutter 開發人員能夠匯入動畫 glTF 模型並渲染即時 3D 場景。</p>
<p>目的是提供一個套件，讓在 Flutter 中輕鬆建立互動式 3D 應用程式和遊戲。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tC68CbPLef2rJp1e" />
</figure>

<p>該套件最初是作為一個 dart:ui 擴展，用於用 C++ 編寫的 3D 渲染器，並直接建置到 Flutter 的原生執行時中，但它已經使用更靈活的介面針對 Flutter GPU 重新撰寫。</p>
<p>與 Flutter GPU API 本身一樣，Flutter Scene 目前處於早期預覽狀態，需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。Flutter Scene 通常與 Flutter GPU API 的重大變更保持同步，因此強烈建議您在試驗 Flutter Scene 時使用 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a>。</p>
<p>接下來，使用 Flutter Scene 建立一個應用程式！</p>
<h3 id="設定-Flutter-Scene-專案"><a href="#設定-Flutter-Scene-專案" class="headerlink" title="設定 Flutter Scene 專案"></a>設定 Flutter Scene 專案</h3><p>由於強烈建議您針對 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a> 使用 Flutter Scene，請從切換到主頻道開始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>接下來，建立一個新的 Flutter 專案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_3d_app</span><br><span class="line">cd my_3d_app</span><br></pre></td></tr></table></figure>

<p>Flutter Scene 依靠實驗性的「原生資產」功能來自動化著色器的建置。您將在稍後使用原生資產來設定自動匯入 Flutter Scene 的 3D 模型。</p>
<p>使用以下命令啟用原生資產。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br></pre></td></tr></table></figure>

<p>最後，將 Flutter Scene 添加為專案相依性。</p>
<p>您還需要在與 Flutter Scene 的 API 互動時使用一些 vector_math 構造，因此也添加 vector_math 套件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene vector_math</span><br></pre></td></tr></table></figure>

<p>接下來，匯入一個 3D 模型！</p>
<h3 id="匯入-3D-模型"><a href="#匯入-3D-模型" class="headerlink" title="匯入 3D 模型"></a>匯入 3D 模型</h3><p>首先，您需要一個要渲染的 3D 模型。對於本指南，您將使用常見的 <a href="https://en.wikipedia.org/wiki/GlTF">glTF</a> 樣本資產： <a href="https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/DamagedHelmet">DamagedHelmet.glb</a>。以下是它的樣子。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/912/0*vVWRLxJ348tCxv7T" />
<figcaption>原始的 Damaged Helmet 模型由 theblueturtle_ 在 2016 年建立（授權： [CC BY-NC 4.0 國際](https://creativecommons.org/licenses/by-nc/4.0/legalcode)）。轉換後的 glTF 版本由 ctxwing 在 2018 年建立（授權： [CC BY 4.0 國際](https://creativecommons.org/licenses/by/4.0/legalcode)）。 </figcaption>
</figure>

<p>您可以從 GitHub 上託管的 <a href="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/DamagedHelmet/glTF-Binary/DamagedHelmet.glb">glTF 樣本資產儲存庫</a> 中獲取它。將 DamagedHelmet.glb 放置在您的專案根目錄中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/main/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb</span><br></pre></td></tr></table></figure>

<p>像大多數即時 3D 渲染器一樣，Flutter Scene 在內部使用專用的 3D 模型格式。您可以使用 Flutter Scene 的離線匯入器工具將標準 glTF 二進制檔案（.glb 檔案）轉換為此格式。</p>
<p>將 flutter_scene_importer 套件作為常規相依性添加到專案中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene_importer</span><br></pre></td></tr></table></figure>

<p>添加此套件可以使用 dart run 手動呼叫匯入器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dart --enable-experiment=native-assets \</span><br><span class="line">     run flutter_scene_importer:import \</span><br><span class="line">     --input &quot;path/to/my/source_model.glb&quot; \</span><br><span class="line">     --output &quot;path/to/my/imported_model.model&quot;</span><br></pre></td></tr></table></figure>

<p>您可以透過使用原生資產建置掛鉤來自動執行匯入器。若要執行此操作，請先將 native_assets_cli 作為常規專案相依性安裝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>

<p>現在您可以撰寫建置掛鉤了。使用以下內容建立 hook&#x2F;build.dart。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:native_assets_cli/native_assets_cli.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene_importer/build_hooks.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) &#123;</span><br><span class="line">  build(args, (config, output) async &#123;</span><br><span class="line">    buildModels(buildConfig: config, inputFilePaths: [</span><br><span class="line">      &#x27;DamagedHelmet.glb&#x27;,</span><br><span class="line">    ]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 flutter_scene_importer 中的 buildModels 公用程式，提供要建置的模型列表。路徑相對於專案的建置根目錄。</p>
<p>當 Flutter 工具建置專案時，buildModels 現在將建置著色器捆綁包，並將結果輸出到套件根目錄下的 build&#x2F;models&#x2F;DamagedModel.model。</p>
<p>匯入的模型格式本身與您使用的 Flutter Scene 特定版本綁定，並且會隨著時間推移而改變。在撰寫使用 Flutter Scene 的應用程式或函式庫時，請勿將生成的 .model 檔案檢查到您的原始碼樹中。相反，請使用建置掛鉤從您的原始模型中生成它們（如前所述）。</p>
<p>這樣一來，隨著時間推移升級 Flutter Scene 時，您將始終使用正確格式建置新的 .model 檔案！</p>
<p>接下來，像常規資產一樣匯入模型。將資產條目添加到專案的 pubspec.yaml 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  assets:</span><br><span class="line">    - build/models/</span><br></pre></td></tr></table></figure>

<p>在未來，原生資產功能將允許建置掛鉤將資料資產附加到捆綁包中。一旦發生這種情況，就不需要再在建置掛鉤旁邊新增資產匯入規則了。</p>
<h3 id="渲染-3D-場景"><a href="#渲染-3D-場景" class="headerlink" title="渲染 3D 場景"></a>渲染 3D 場景</h3><p>現在是應用程式的程式碼了。</p>
<p>首先，建立一個有狀態的 Widget，用於在多個幀中保留 Scene。</p>
<p>您將根據時間進行動畫處理，因此將 SingleTickerProviderStateMixin 添加到狀態，以及一個 elapsedSeconds 成員。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter/scheduler.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/camera.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/node.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/scene.dart&#x27;;</span><br><span class="line">import &#x27;package:vector_math/vector_math.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget&#123;</span><br><span class="line">  const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  MyAppState createState() =&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line">  double elapsedSeconds = 0;</span><br><span class="line">  Scene scene = Scene();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &#x27;My 3D app&#x27;,</span><br><span class="line">      home: Placeholder(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行應用程式作為冒煙測試，以確保沒有錯誤。請記住要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/912/0*74qs6ytcTjyVHwML" />
</figure>

<p>在繼續之前，請為動畫設定計時器。覆蓋 MyAppState 中的 initState 以呼叫 createTicker。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  createTicker((elapsed) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).start();</span><br><span class="line">  </span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要 Widget 可見，計時器回呼就會為每一幀被呼叫。呼叫 setState 會觸發此 Widget 在每一幀重建。</p>
<p>接下來，載入之前放置在專案中的 3D 模型，並將其添加到 Scene 中。</p>
<p>使用 Node.fromAsset 從資產捆綁包中載入模型。將以下程式碼放置在 initState 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">  model.name = &#x27;Helmet&#x27;;</span><br><span class="line">  scene.add(model);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Node.fromAsset 會異步地從資產捆綁包中反序列化模型，並在模型準備好添加到場景中時解析返回的 Future<Node>。</p>
<p>現在，MyAppState.initState 應該如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  createTicker((elapsed) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).start();</span><br><span class="line">  </span><br><span class="line">  Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">    model.name = &#x27;Helmet&#x27;;</span><br><span class="line">    scene.add(model);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，您仍然沒有實際渲染 3D Scene！若要執行此操作，請使用 <code>Scene.render</code>，它需要 UI Canvas、Flutter Scene Camera 和一個大小。</p>
<p>存取 Canvas 的一種方法是建立一個 CustomPainter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line">  ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line">  Scene scene;</span><br><span class="line">  Camera camera;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘記將 shouldRepaint 覆蓋設置為返回 true，以便在每次重建發生時自訂畫家都會重新繪畫。</p>
<p>最後，將 CustomPainter 添加到源樹中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  final painter = ScenePainter(</span><br><span class="line">    scene: scene,</span><br><span class="line">    camera: PerspectiveCamera(</span><br><span class="line">      position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line">      target: Vector3(0, 0, 0),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return MaterialApp(</span><br><span class="line">    title: &#x27;My 3D app&#x27;,</span><br><span class="line">    home: CustomPaint(painter: painter),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼指示相機沿著一個連續的圓圈移動，但始終面向原點。</p>
<p>最後，啟動應用程式！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/796/0*_-OFc0vhBHAhrPrO" />
</figure>

<p>以下是我們組合的完整源程式碼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/camera.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/node.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/scene.dart&#x27;;</span><br><span class="line">import &#x27;package:vector_math/vector_math.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget &#123;</span><br><span class="line">  const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  MyAppState createState() =&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line">  double elapsedSeconds = 0;</span><br><span class="line">  Scene scene = Scene();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    createTicker((elapsed) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">      model.name = &#x27;Helmet&#x27;;</span><br><span class="line">      scene.add(model);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    super.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final painter = ScenePainter(</span><br><span class="line">      scene: scene,</span><br><span class="line">      camera: PerspectiveCamera(</span><br><span class="line">        position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line">        target: Vector3(0, 0, 0),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &#x27;My 3D app&#x27;,</span><br><span class="line">      home: CustomPaint(painter: painter),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line">  ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line">  Scene scene;</span><br><span class="line">  Camera camera;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Flutter-光明的未來"><a href="#Flutter-光明的未來" class="headerlink" title="Flutter 光明的未來"></a>Flutter 光明的未來</h3><p>如果您能夠成功地遵循這些指南中的其中一個並讓它運行起來：太棒了，恭喜！</p>
<p>Flutter GPU 和 Flutter Scene 都非常年輕，平台支援有限。但我想總有一天，我們會懷念這些不起眼的開端。</p>
<p>隨著 Impeller 的推廣，Flutter 團隊完全掌控了渲染堆疊，因為我们需要針對 Flutter 的用例專門化渲染器。現在，我們正在開啟 Flutter 歷史上的一個新篇章。一個由您共同掌控渲染的篇章！</p>
<p>Flutter Scene 最初是 Impeller 中的 C++ 組件，與 2D Canvas 渲染器一起，帶有一個精簡的 dart:ui 擴展。在我構建它時，我已經意識到 Flutter Engine 不會是它的最終目的地。</p>
<p>3D 渲染器的架構決策海洋是廣闊</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/6243ded4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/6243ded4.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Flutter 3.24 and Dart 3.5</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-06 18:00:29" itemprop="dateCreated datePublished" datetime="2024-08-06T18:00:29+08:00">2024-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 01:38:31" itemprop="dateModified" datetime="2024-09-30T01:38:31+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Flutter-3-24-和-Dart-3-5"><a href="#宣布-Flutter-3-24-和-Dart-3-5" class="headerlink" title="宣布 Flutter 3.24 和 Dart 3.5"></a>宣布 Flutter 3.24 和 Dart 3.5</h2><p>今天，我們將揭曉 <a href="https://medium.com/p/6c040f87d1e4/edit">Flutter 3.24</a> 和 <a href="https://medium.com/dartlang/dart-3.5-6ca36259fa2f">Dart 3.5</a>，以及 <a href="https://ioconnectchina.googlecnapps.cn/">I&#x2F;O 2024 Connect 系列</a> 的最後一站，該系列將在幾個小時內在中國舉行——中國是世界上最活躍的 Flutter 社群之一，這使得這個時刻變得格外特別。</p>
<figure>
<img alt="Dash flies in and lands to the left of an outline of 3.24. She presses a button that fills the 3.24 in with Flutter blue." src="https://cdn-images-1.medium.com/max/1024/1*jzRGig761LnPlvokq2FaVA.gif" />
</figure>

<p>我們在 5 月份的 <a href="https://io.google/2024/">Google I&#x2F;O</a> 上啟動了一系列 <a href="https://medium.com/flutter/io24-5e211f708a37">令人興奮的更新</a>，包括將 WebAssembly 編譯支援升級到 stable channel，改進 Impeller，以及預覽 Dart macros 的未來。</p>
<p>Flutter 3.24 和 Dart 3.5 發佈版本在我們幫助您製作出色的高效能應用程式（這些應用程式可以透過單個共用程式碼庫到達行動、網頁和桌面上的使用者）的使命之上。它們包括對新的 Flutter GPU API 的早期預覽，對網頁上元素嵌入的改進，以及幾個針對那些想要為 iOS 生態系統構建的開發人員的令人興奮的更新，包括對 Swift Package Manager 的早期支援，以及對 Cupertino Widgets 的功能更新。</p>
<p>讓我們開始吧！</p>
<h3 id="Impeller：為跨平台圖形效能樹立新標竿"><a href="#Impeller：為跨平台圖形效能樹立新標竿" class="headerlink" title="Impeller：為跨平台圖形效能樹立新標竿"></a>Impeller：為跨平台圖形效能樹立新標竿</h3><p>從歷史上看，跨平台框架需要在視覺效果上做出妥協，因為它們依賴於底層平台提供的更高級別的抽象。Flutter 採用了不同的方法，它擁有自己的渲染層，可以在每台設備上提供硬體加速的圖形和流暢的效能。我們在 <a href="https://docs.flutter.dev/perf/impeller">Impeller</a> 和 <a href="https://docs.flutter.dev/ui/design/graphics/fragment-shaders">著色器</a> 方面取得了重大進展，為圖形（如 3D）解鎖了令人興奮的新可能性。</p>
<p>我們很興奮地分享全新的 <a href="https://github.com/flutter/engine/blob/main/docs/impeller/Flutter-GPU.md">Flutter GPU API</a> 的早期預覽，這是一個功能強大、低階的圖形 API，直接整合到 Flutter SDK 中。API 允許您定義自訂柵格管道，並將繪製調用直接提交到 GPU，從而可以建立專用的渲染器，例如 2D Canvas 的替代方案、3D 場景圖，甚至用於創造視覺上令人驚豔、高效能和沉浸式體驗的粒子系統，而無需使用通常引擎級別需要的容量。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/796/0*QC1D0LdTgLynDOnV" />
<figcaption>3D animation of a sci-fi space helmet rendered in flutter_scene.</figcaption>
</figure>

<p>考慮到 API 的低階性，我們預計對於那些沒有大量圖形開發經驗的開發人員來說，會有一段學習曲線。這就是為什麼我們正在投資渲染套件，例如新的 <code>flutter_scene</code> 套件，它利用 Flutter GPU API 允許匯入動畫 glTF 模型並構造 3D 場景，使您能夠輕鬆地在 Flutter 和 Dart 中建立 3D 應用程式和遊戲，如下所示。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FY-DFVKPikVM%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DY-DFVKPikVM&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FY-DFVKPikVM%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/21e51abf698b844782de55d81e3cd7b4/href">https://medium.com/media/21e51abf698b844782de55d81e3cd7b4/href</a></iframe>


<p>儘管 Flutter GPU API 提供了令人興奮的可能性，但它仍然處於早期預覽階段，我們可能會對 API 進行重大變更。我們建議在使用 Flutter GPU 時針對 Flutter 的主頻道進行開發。在部落格文章 <a href="https://medium.com/flutter/getting-started-with-flutter-gpu-f33d497b7c11">Introducing Flutter GPU &amp; Flutter Scene</a> 中了解更多資訊。</p>
<h3 id="為-iOS-和-macOS-打造-Flutter：讓為-Apple-生態系統交付美麗、快速的應用程式變得更加容易"><a href="#為-iOS-和-macOS-打造-Flutter：讓為-Apple-生態系統交付美麗、快速的應用程式變得更加容易" class="headerlink" title="為 iOS 和 macOS 打造 Flutter：讓為 Apple 生態系統交付美麗、快速的應用程式變得更加容易"></a>為 iOS 和 macOS 打造 Flutter：讓為 Apple 生態系統交付美麗、快速的應用程式變得更加容易</h3><p>我們的目標是讓您能夠構建出色的應用程式，這些應用程式感覺起來像原生應用程式，並能完美地執行。這項工作的一部分是優化效能，以及最大限度地提高 Flutter 與底層平台的相容性，包括存取 Apple 生態系統的全部功能。</p>
<p>在此版本中，我們引入了對 Swift Package Manager 的早期支援，解鎖了對蓬勃發展的 Swift 套件生態系統的存取，並使 Flutter 外掛能夠利用大量預先構建的功能來加速開發。一旦 Swift Package Manager (SPM) 被 Plugin 開發人員廣泛採用，它應該會簡化 Flutter 安裝過程本身，並降低新手的入門門檻，特別是那些不熟悉 iOS 生態系統的人。我們鼓勵 Plugin 作者 <a href="https://docs.flutter.dev/packages-and-plugins/swift-package-manager/for-plugin-authors#how-to-add-swift-package-manager-support-to-an-existing-flutter-plugin">嘗試將 SPM 支援添加到您的外掛中</a>，並提供您體驗的 <a href="https://github.com/flutter/flutter/issues">回饋</a>。</p>
<p>接下來，我們希望讓您始終能夠滿足設計師的要求，並在 iOS 上提供高保真度的體驗。為了實現這一點，我們開始著手現代化和擴展 Cupertino Widget，解決了  <a href="https://github.com/flutter/flutter/issues?q=is:issue+is:closed+label:%22f:+cupertino%22+sort:updated-desc+closed:2024-04-01..2024-07-01+">Cupertino 中的 15 個問題</a>，並在 <a href="https://docs.flutter.dev/ui/widgets/cupertino">Widget 目錄</a> 中加入了 37 個缺少的 Cupertino Widget。</p>
<p>最後，我們為 Flutter macOS 應用程式添加了 <a href="https://docs.flutter.dev/platform-integration/macos/platform-views"><code>platform_view</code></a> 和 <a href="https://docs.flutter.dev/platform-integration/web/web-content-in-flutter">webview</a> 支援，允許將原生 macOS UI 組件無縫整合到您的 Flutter 應用程式中，以提供更完整、更完善的使用者體驗。</p>
<p>展望未來，我們很興奮能更多地投資於其他 Cupertino Widget 的保真度，與我們的生態系統一起推出 Swift Package Manager，並提供其他調查，讓整合和與 Apple 平台的互操作變得更加容易。</p>
<h3 id="強調充滿活力的-Flutter-社群的全球影響力"><a href="#強調充滿活力的-Flutter-社群的全球影響力" class="headerlink" title="強調充滿活力的 Flutter 社群的全球影響力"></a>強調充滿活力的 Flutter 社群的全球影響力</h3><p>我們還想感謝社群的貢獻，包括您的貢獻！這組版本包含來自 167 多位獨特貢獻者的近 1,500 次提交，其中包括 49 位 <em>全新</em> 貢獻者。我們深受 Flutter 社群持續的高水準活動、承諾和增長所鼓舞，包括積極構建框架的那些人。謝謝您！</p>
<p>我們共同努力的影響力正在世界各地展現出來，創造出數百萬人每天使用的令人難以置信的應用程式和體驗。例如，以下是 <a href="http://flutter.dev/showcase/xiaomi">案例研究</a> 的搶先看，展示了中國科技公司小米的團隊如何以及為什麼使用 Flutter 為該公司備受歡迎的新型電動汽車 <a href="https://www.mi.com/global/discover/article?id=3263&amp;ref=renatomitra.com">小米 SU7</a> 開發一個配套應用程式。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FwfD7ZQhwACU%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DwfD7ZQhwACU&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FwfD7ZQhwACU%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/1e141755d6ab1cd3b7962281efd5e6d3/href">https://medium.com/media/1e141755d6ab1cd3b7962281efd5e6d3/href</a></iframe>


<p>在世界各地出現的許多其他令人興奮的 Flutter 應用程式範例：</p>
<ul>
<li><a href="http://flutter.dev/showcase/sncf-connect">SNCF Connect</a>，法國鐵路和歐洲最大的 Flutter 應用程式（擁有超過 150 個螢幕）的擁有者，與奧運會合作為 Flutter 應用程式交付了許多更新，使數百萬遊客能夠在奧運會期間穿梭於法國各地。</li>
<li><a href="http://flutter.dev/showcase/wolt">Wolt</a>，DoorDash 國際的一部分，使用 Flutter 擴展到商家零售市場。</li>
<li><a href="http://flutter.dev/showcase/whirlpool">惠而浦</a>，一家擁有全球影響力的《財富》500 強公司，正在使用 Flutter 在巴西探索新的銷售管道。</li>
<li><a href="http://flutter.dev/showcase/monta">Monta</a>，一家丹麥的電動汽車充電生態系統初創公司，在短短 3 個月內使用 Flutter 將其第一個行動應用程式推向市場，後來又成功地將其 Web 應用程式移植到 Flutter。</li>
</ul>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>以上只是這些版本中 Flutter 和 Dart 的許多新功能和更新中的一小部分，您可以在 <a href="https://medium.com/p/6c040f87d1e4/edit">Flutter 3.24 技術部落格</a> 文章和 <a href="https://medium.com/dartlang/dart-3.5-6ca36259fa2f">Dart 3.5 部落格文章</a> 中了解更多資訊。</p>
<p>展望未來，我們對 Flutter 的未來充滿期待。我們仍然致力於我們的使命，並且感謝您——無論是貢獻者、社群成員還是 Flutter 開發人員——成為這段非凡旅程的一部分。我們迫不及待想看看您接下來會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=204b7d20c45d" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/flutter-3-24-dart-3-5-204b7d20c45d">宣布 Flutter 3.24 和 Dart 3.5</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/6243ded4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/6243ded4.html" class="post-title-link" itemprop="url">【文章翻譯】What’s new in Flutter 3.24</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-06 18:00:07" itemprop="dateCreated datePublished" datetime="2024-08-06T18:00:07+08:00">2024-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 01:38:01" itemprop="dateModified" datetime="2024-09-30T01:38:01+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="解鎖-Flutter-GPU、多視圖嵌入等等"><a href="#解鎖-Flutter-GPU、多視圖嵌入等等" class="headerlink" title="解鎖 Flutter GPU、多視圖嵌入等等"></a>解鎖 Flutter GPU、多視圖嵌入等等</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EA-cAY6uwkYqYb725vnCIw.png" />
<figcaption>Flutter 3.24 on a blue background</figcaption>
</figure>

<p>歡迎來到最新的 Flutter 更新！Flutter 3.24 充滿了令人興奮的新功能和增強功能，可以提升您的應用程式開發體驗。此版本重點介紹了 Flutter GPU 的預覽版本，它可以在 Flutter 中直接啟用進階圖形和 3D 場景。Web 應用程式現在可以嵌入多個 Flutter 視圖，增強應用程式的多功能性。最後，我們加入了影片廣告支援，以幫助您最大限度地提高收入。</p>
<p>在過去的幾個月裡，Flutter 社群一直非常活躍，擁有 852 個框架提交和 615 個引擎提交。我們很興奮地歡迎 49 位新貢獻者，他們幫助實現了此版本。您的奉獻和熱情推動著 Flutter 的前進。</p>
<p>因此，深入了解 Flutter 社群帶給這個最新版本的最新功能和增強功能吧！</p>
<h3 id="Flutter-架構"><a href="#Flutter-架構" class="headerlink" title="Flutter 架構"></a>Flutter 架構</h3><h4 id="新的-Sliver"><a href="#新的-Sliver" class="headerlink" title="新的 Sliver"></a>新的 Sliver</h4><p>此版本加入了新的 Sliver，可以將它們組合在一起以實現動態 app bar 行為：</p>
<ul>
<li><a href="http://api.flutter.dev/flutter/widgets/PinnedHeaderSliver-class.html">PinnedHeaderSliver</a></li>
<li><a href="http://api.flutter.dev/flutter/widgets/SliverResizingHeader-class.html">SliverResizingHeader</a></li>
</ul>
<p>您可以使用這些新的 Sliver 來製作浮動、保持固定或在使用者捲軸時調整大小的標題。這些新的 Sliver 類似於現有的 <a href="https://api.flutter.dev/flutter/widgets/SliverPersistentHeader-class.html">SliverPersistentHeader</a> 和 <a href="http://sliverappbar/">SliverAppBar</a> Sliver，但具有更簡單的 API，可以組合在一起以實現更大的效果。</p>
<p>這些新的 Sliver 附帶了新的範例程式碼。例如，PinnedHeaderSliver 的 API 文件有一個範例，可以重新建立 iOS 設定應用程式 app bar 的效果：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*bdcb6KGonosfPZ6m" />
</figure>

<h4 id="Cupertino-函式庫中的更新"><a href="#Cupertino-函式庫中的更新" class="headerlink" title="Cupertino 函式庫中的更新"></a>Cupertino 函式庫中的更新</h4><p>在此版本中，我們改進了 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoActionSheet-class.html">CupertinoActionSheet</a> 的保真度。在動作表單的按鈕上滑動手指現在可以提供觸覺回饋。按鈕的字體大小和粗細現在與原生對應物相符。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/655/0*_o_9V0RlITOZdU4v" />
</figure>

<p>我們還為 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoButton-class.html">CupertinoButton</a> 加入了新的焦點屬性，現在您可以自訂已停用的 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoTextField-class.html">CupertinoTextField</a> 的顏色。</p>
<p>Cupertino 函式庫的更新正在進行中，請期待未來版本中的更多更新！</p>
<h4 id="TreeView"><a href="#TreeView" class="headerlink" title="TreeView"></a>TreeView</h4><p><a href="https://pub.dev/packages/two_dimensional_scrollables">two_dimensional_scrollables</a> 套件發佈了 <a href="https://pub.dev/documentation/two_dimensional_scrollables/latest/two_dimensional_scrollables/TreeView-class.html">TreeView</a> Widget，以及幾個用於建立高效能捲軸樹的配套類別，這些樹可以在樹增長時向所有方向捲軸。套件中包含的樣本應用程式也已更新，其中包含幾個使用 <a href="https://pub.dev/documentation/two_dimensional_scrollables/latest/two_dimensional_scrollables/TableView-class.html">TableView</a> 和 <a href="https://pub.dev/documentation/two_dimensional_scrollables/latest/two_dimensional_scrollables/TreeView-class.html">TreeView</a> Widget 的全新範例。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*wcmJCv-6owwsolRl" />
</figure>

<p><a href="https://api.flutter.dev/flutter/widgets/TreeSliver-class.html">TreeSliver</a> 也被加入到框架中，用於在一維捲軸中建立樹。<code>TreeView</code> 和 <code>TreeSliver</code> API 符合，使您能夠輕鬆地在適合您的使用案例之間切換。</p>
<h4 id="CarouselView"><a href="#CarouselView" class="headerlink" title="CarouselView"></a>CarouselView</h4><p>此版本包含了 <a href="https://m3.material.io/components/carousel/overview">Material Design carousel</a> Widget：<code>CarouselView</code>。CarouselView 呈現「<a href="https://m3.material.io/components/carousel/specs#477de3a1-c9df-4742-baf3-bcd5eeb3764c">Uncontained</a>」佈局：一個可捲軸的項目列表，這些項目會捲軸到 container 的邊緣，並且當開頭和末尾項目捲出視圖和捲入視圖時，它們可以動態調整大小。</p>
<figure>
<img alt="Flutter CarouselView example" src="https://cdn-images-1.medium.com/max/512/1*6ytqSvtR2TJzAE6LntHTGw.gif" />
</figure>

<h4 id="Widget提供更多功能"><a href="#Widget提供更多功能" class="headerlink" title="Widget提供更多功能"></a>Widget提供更多功能</h4><p>此版本包含將核心 Widget 邏輯從 Material 函式庫移動到 Widgets 函式庫中以便更廣泛使用，這些邏輯不是設計專用的。這包括：</p>
<ul>
<li><a href="https://github.com/flutter/flutter/pull/148523">Feedback</a> Widget，它提供輕鬆存取設備上的觸覺和音訊回饋，以點擊回應、長按等手勢。</li>
<li><a href="https://github.com/flutter/flutter/pull/148272">ToggleableStateMixin</a> 和 <a href="https://github.com/flutter/flutter/pull/148272">ToggleablePainter</a>，用於建立複選框、開關<br>和單選按鈕等切換 Widget 的基本類別。</li>
</ul>
<h4 id="為-AnimationStatus-增強列舉功能"><a href="#為-AnimationStatus-增強列舉功能" class="headerlink" title="為 AnimationStatus 增強列舉功能"></a>為 AnimationStatus 增強列舉功能</h4><p>在社群成員 <a href="https://github.com/nate-thegrate">nate-thegrate</a>  的出色 <a href="https://github.com/flutter/flutter/pull/147801">貢獻</a> 中，增強的列舉功能被加入到 <a href="https://api.flutter.dev/flutter/animation/AnimationStatus.html">AnimationStatus</a> 中，包括 getter：</p>
<ul>
<li>isDismissed</li>
<li>isCompleted</li>
<li>isRunning</li>
<li>isForwardOrCompleted</li>
</ul>
<p>其中一些 getter 已經存在於 <a href="https://api.flutter.dev/flutter/animation/Animation-class.html">Animation</a> 子類別中，例如 <a href="https://api.flutter.dev/flutter/animation/AnimationController-class.html">AnimationController</a> 和 <a href="https://api.flutter.dev/flutter/animation/CurvedAnimation-class.html">CurvedAnimation</a>。現在，所有這些狀態 getter 都可以在 Animation 子類別中使用，除了 AnimationStatus 之外。最後，一個 <a href="https://api.flutter.dev/flutter/animation/AnimationController/toggle.html"><code>toggle</code></a> 方法被加入到 AnimationController 中，用於切換動畫的方向。</p>
<h4 id="SelectionArea-中的更新"><a href="#SelectionArea-中的更新" class="headerlink" title="SelectionArea 中的更新"></a>SelectionArea 中的更新</h4><p>Flutter 的 <a href="https://api.flutter.dev/flutter/material/SelectionArea-class.html">SelectionArea</a> 現在支援使用滑鼠進行三擊和在觸控設備上雙擊的更多原生手勢。預設情況下，<a href="https://api.flutter.dev/flutter/material/SelectionArea-class.html">SelectionArea</a> 和 <a href="https://api.flutter.dev/flutter/widgets/SelectableRegion-class.html">SelectableRegion</a> Widget 使用這些新的手勢。</p>
<p>三擊</p>
<ul>
<li>三擊 + 拖動：擴展段落塊中的選取範圍。</li>
<li>三擊：選取點擊位置的段落塊。</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*_GmbsIKfnwEAW6G8" />
</figure>

<p>雙擊</p>
<ul>
<li>雙擊 + 拖動：擴展文字區塊中的選取範圍（支援原生 Android&#x2F;Fuchsia&#x2F;iOS 和 iOS 網頁）。</li>
<li>雙擊：選取點擊位置的文字（支援原生 Android&#x2F;Fuchsia&#x2F;iOS 和 Android&#x2F;Fuchsia 網頁）。</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/770/0*DwZgIybQr3FDFxXd" />
</figure>

<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><h4 id="Impeller"><a href="#Impeller" class="headerlink" title="Impeller"></a>Impeller</h4><p><strong>改善效能和保真度</strong></p>
<p>為了在即將到來的穩定版本中移除 iOS 上的 Impeller 選擇不使用設定，團隊一直在努力改進 Impeller 的效能和保真度。例如，針對文字渲染的一系列改進 <a href="https://github.com/flutter/flutter/issues/138798">大幅提高了 emoji 捲軸的效能</a>，消除了捲軸大量 emoji 時的卡頓，這對 Impeller 的文字渲染能力來說是一項極好的壓力測試。</p>
<p>此外，透過 <a href="https://github.com/flutter/engine/pull/53042">解決許多問題</a>，我們也在此版本中大幅改進了 Impeller 文字渲染的保真度。特別是，文字粗細、間距和字距調整現在都與傳統渲染器的文字保真度相符。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gIu2Wm9mpuMGb1JY" />
<figcaption>Before (Note gaps instead of proper kerning, and lighter than intended font weight.)</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tt9hlqhTbrmj4ZCt" />
<figcaption>After</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/739/0*eMboSxWLEJBS_EyL" />
<figcaption>Before (Note incorrect spacing, for example in “vergelijken”)</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/739/0*uxeGJuIKWu0dPW1d" />
<figcaption>After</figcaption>
</figure>

<p><strong>Android 預覽</strong></p>
<p>在此版本中，我們將繼續在 Android 上預覽 Impeller。我們延長了預覽期，因為 Impeller 用於 Platform Views 的 API 在 <a href="https://github.com/flutter/flutter/issues/146499#issuecomment-2082873125">Android 14 中的一個錯誤</a> 導致出現困難。這個錯誤後來被 Android 團隊修補了，但是許多已部署的設備在可預見的將來將運行未修補的 Android 版本。解決這些問題意味著需要額外的 API 遷移，因此需要額外的穩定版本週期。出於謹慎和為了確保 Flutter 應用程式可以在盡可能廣泛的設備上運行，我們將推遲將 Impeller 作為預設渲染器，直到今年晚些時候的穩定版本發佈。</p>
<p>隨著 Android 上的 Impeller 預覽繼續在 3.24 穩定版本週期中進行，我們請求 Flutter 開發人員升級到最新的穩定版本，並在啟用 Impeller 時提交有關任何發現的不足的錯誤。在此階段的回饋對確保 Impeller 在 Android 上取得成功以及我們能夠在今年晚些時候的版本中自信地將其設為預設渲染器至關重要。Android 硬體生態系統比 iOS 生態系統更加多元。因此，關於 Impeller 最有用的回饋應包括有關發生問題的特定設備和 Android 版本的詳細資訊。</p>
<h4 id="改進縮放圖片的預設值"><a href="#改進縮放圖片的預設值" class="headerlink" title="改進縮放圖片的預設值"></a>改進縮放圖片的預設值</h4><p>在此版本中，圖片的預設 <code>FilterQuality</code> 已從 <code>FilterQuality.low</code> 變更為 <code>FilterQuality.medium</code>。當一個大型圖片比其目標矩形大很多時（這是一個常見的情況），<code>FilterQuality.low</code> 會導致圖片看起來更加「像素化」，並且渲染速度比 <code>FilterQuality.medium</code> 慢。未來，團隊還將探索更適合各種 FilterQuality 級別的新名稱。</p>
<h4 id="Flutter-GPU-預覽"><a href="#Flutter-GPU-預覽" class="headerlink" title="Flutter GPU 預覽"></a>Flutter GPU 預覽</h4><p>Flutter 推出了對渲染功能的重大更新，即 Flutter GPU，可在主頻道上使用。此低階圖形 API 允許開發人員使用 Dart 程式碼和 GLSL 著色器建立自訂渲染器，而無需任何原生平台程式碼。</p>
<p>Flutter GPU 擴展了您可以在 Flutter 中直接渲染的內容，啟用進階圖形和 3D 場景。它需要 Impeller 渲染後端，目前在 iOS、macOS 和 Android 上支援。儘管處於早期預覽階段，但 Flutter GPU 的目標是最終支援所有 Flutter 平台。</p>
<p>API 允許完全控制渲染傳遞附件、頂點階段和資料上傳到 GPU。這種靈活性對於建立複雜的渲染解決方案至關重要，從 2D 角色動畫到複雜的 3D 場景。</p>
<p>開發人員可以透過切換到 main channel 並將 flutter_gpu 套件加入到他們的專案中來開始使用 Flutter GPU。接下來的幾個月將看到更多功能和穩定性方面的改進，更高階的渲染函式庫（如 flutter_scene）將簡化這些進階功能的使用。</p>
<p>若要深入了解 Flutter GPU，並了解如何在您的專案中利用它，請查看詳細的 <a href="https://medium.com/flutter/getting-started-with-flutter-gpu-f33d497b7c11">Flutter GPU 部落格文章</a>。無論您是建立遊戲還是複雜的圖形，Flutter 的全新 GPU 功能都讓它成為產品的強大選擇。</p>
<h3 id="網頁"><a href="#網頁" class="headerlink" title="網頁"></a>網頁</h3><h3 id="多視圖嵌入"><a href="#多視圖嵌入" class="headerlink" title="多視圖嵌入"></a>多視圖嵌入</h3><p>Flutter Web 應用程式現在可以利用多視圖嵌入，讓開發人員可以將內容同時渲染到多個 HTML 元素中。此功能稱為「嵌入模式」或「多視圖」，為將 Flutter 視圖整合到現有的 Web 應用程式中提供了靈活性。</p>
<p>在多視圖模式下，Flutter Web 應用程式不會在啟動時立即渲染。相反，它會等到主機應用程式使用 addView 方法加入第一個「視圖」。主機應用程式可以動態加入或移除這些視圖，Flutter 會根據需要調整其 Widget。</p>
<p>若要啟用多視圖模式，請在 <code>flutter_bootstrap.js</code> 檔案中的 <code>initializeEngine</code> 方法中設定 <code>multiViewEnabled: true</code>。然後，可以從 JavaScript 管理視圖，將它們加入到指定的 HTML 元素中，並根據需要移除它們。每次加入和移除視圖都會觸發 Flutter 中的更新，允許動態內容渲染。</p>
<p>此功能對於將 Flutter 整合到需要多個獨立 Flutter 視圖的複雜 Web 應用程式中特別有用。它還支援每個視圖的自訂初始化資料，啟用個人化的設定和互動式體驗。</p>
<p>若要深入了解如何在 Flutter 網頁應用程式中實作多視圖嵌入，請查看 <a href="https://docs.flutter.dev/platform-integration/web/embedding-flutter-web">詳細的文件</a>。</p>
<h3 id="變現"><a href="#變現" class="headerlink" title="變現"></a>變現</h3><h3 id="影片廣告變現支援"><a href="#影片廣告變現支援" class="headerlink" title="影片廣告變現支援"></a>影片廣告變現支援</h3><p>我們推出了一個新的 <a href="https://pub.dev/packages/interactive_media_ads">互動式媒體廣告 (IMA) Plugin</a>，以支援 Flutter 行動應用程式中的串流影片廣告變現。新的 IMA Plugin 為 Flutter 應用程式提供了新的廣告變現機會，這些機會建立在現有的 <a href="https://pub.dev/packages/google_mobile_ads">Google 行動廣告 (GMA) Plugin</a> 之上，該 Plugin 主要支援展示廣告格式。</p>
<p>串流影片廣告通常在影片內容播放之前（開頭廣告）、期間（中間廣告）或之後（結尾廣告）顯示給使用者。一些串流影片廣告也可以跳過。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/836/0*_c0s8KMdLNyfxOMQ" />
</figure>

<p><strong>Flutter IMA 的優點：</strong></p>
<ul>
<li>在 Flutter 應用程式中無縫變現影片播放器內容。例如，當應用程式使用者點擊影片內容上的播放時，您現在可以實作 Flutter IMA Plugin 以首先向使用者顯示一個 15 秒的廣告，然後再開始播放影片內容。</li>
<li>利用原生 IMA SDK 的相同優點，包括存取 Google 優質廣告需求和行業標準合規性（例如 <a href="https://iabtechlab.com/standards/vast/">IAB VAST</a>）。</li>
</ul>
<p>初始發佈版本目前支援 Android 和 iOS 平台上的開頭影片廣告。中間廣告支援將很快提供。我們鼓勵您開始在 Flutter 應用程式影片內容中探索新的 IMA Plugin。如果您在 <a href="https://github.com/flutter/flutter/issues?q=is:issue+is:open+label:%22p:+interactive_media_ads%22">GitHub</a> 上遇到任何問題或疑慮，請告知我們。</p>
<p>資源：<a href="https://pub.dev/packages/interactive_media_ads">Plugin 指南</a>，<a href="https://pub.dev/packages/interactive_media_ads/example">範例應用程式</a>，<a href="https://github.com/flutter/packages/tree/main/packages/interactive_media_ads">Git 儲存庫</a></p>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><h3 id="Swift-Package-Manager-初始支援"><a href="#Swift-Package-Manager-初始支援" class="headerlink" title="Swift Package Manager 初始支援"></a>Swift Package Manager 初始支援</h3><p>今天，Flutter 使用 CocoaPods 來管理原生 iOS 或 macOS 相依。</p>
<p>Flutter 3.24 加入了對 Swift Package Manager 的早期支援。這帶來了許多優點，包括：</p>
<ol>
<li><strong>存取 Swift 套件生態系統</strong>。Flutter Plugin 將能夠利用不斷發展的 <a href="https://swiftpackageindex.com/">Swift 套件</a> 生態系統！</li>
<li><strong>簡化 Flutter 安裝</strong>。Swift Package Manager 與 Xcode 捆綁在一起。未來，您將不再需要安裝 Ruby 和 CocoaPods 來為 Apple 平台使用 Flutter。</li>
</ol>
<p>我們鼓勵 Plugin 作者 <a href="https://docs.flutter.dev/packages-and-plugins/swift-package-manager/for-plugin-authors#how-to-add-swift-package-manager-support-to-an-existing-flutter-plugin">嘗試將 Swift Package Manager 支援加入到您的 Plugin 中</a>，並提供您體驗的回饋。</p>
<p>如果您對 Flutter 對 Swift Package Manager 的支援有任何回饋，請 <a href="https://github.com/flutter/flutter/issues/new/choose">提交議題</a>。</p>
<h3 id="生態系統"><a href="#生態系統" class="headerlink" title="生態系統"></a>生態系統</h3><h3 id="Shared-Preferences-設定-Plugin-更新"><a href="#Shared-Preferences-設定-Plugin-更新" class="headerlink" title="Shared Preferences 設定 Plugin 更新"></a>Shared Preferences 設定 Plugin 更新</h3><p>我們已在 <a href="https://pub.dev/packages/shared_preferences">shared_preferences</a> Plugin 中加入了兩個新的 API，SharedPreferencesAsync 和 SharedPreferencesWithCache。最重大的變化是 Android 實作使用 Preferences DataStore 而不是 Shared Preferences。</p>
<p>SharedPreferencesAsync 允許使用者直接調用平台以獲取設備上儲存的最新偏好設定，代價是異步和比使用快取版本稍微慢一些。這對於可以由其他系統或隔離區更新的偏好設定很有用，這些偏好設定會使快取過時。</p>
<p>SharedPreferencesWithCache 建立在 SharedPreferencesAsync 之上，允許使用者同步存取偏好設定的本地快取副本。這與舊的 API 相似，但現在可以透過不同的參數多次實例化。</p>
<p>這些新的 API 旨在將來替換目前的 SharedPreferences API。但是，這是生態系統中最常用的 Plugin 之一，我們知道生態系統需要時間才能轉換到新的 API。</p>
<h3 id="Flutter-和-Dart-套件生態系統峰會歐洲-2024"><a href="#Flutter-和-Dart-套件生態系統峰會歐洲-2024" class="headerlink" title="Flutter 和 Dart 套件生態系統峰會歐洲 2024"></a>Flutter 和 Dart 套件生態系統峰會歐洲 2024</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fWo9ieYzQcJjwQBi" />
</figure>

<p>作為 Fluttercon Europe 2024 的一部分，我們舉辦了首屆面對面 Flutter 和 Dart 套件生態系統峰會。這是繼我們於 2023 年 8 月舉辦的第一屆虛擬峰會之後。<a href="https://docs.google.com/document/d/e/2PACX-1vRFLdpIJYO5YPARcyUT1FYPzwkFb1hxh_agqnCXxsyirXocLZS5jobs3xFV5ZGpSQHLHZiBzqbJlXNV/pub">在此</a>查看討論會的重點摘要。</p>
<p>我們很高興地宣布，下一屆峰會將於 2024 年 9 月 20 日在紐約市舉行的 <a href="https://flutterconusa.dev/">Fluttercon USA</a> 舉行！如果您是套件作者或貢獻者，並且將參加 Fluttercon USA 2024，請 <a href="https://rsvp.withgoogle.com/events/flutter-package-ecosystem-summit-usa-2024">註冊</a> 以保留您的峰會席位。</p>
<p>峰會匯集了套件作者和維護者，進行了以下主題的 unconference-style 議程：</p>
<ul>
<li>議程 1 - 原生互操作的過去、現在和未來</li>
<li>議程 2 - 可持續的套件維護模型</li>
<li>議程 3 - 解決套件生態系統碎片化問題</li>
</ul>
<p>我們相信峰會，特別是在更通用的 Flutter 和 Dart 活動的一部分時，是社群之間公開討論的有價值的平台，用於找出關鍵挑戰和集思廣益解決方案。我們期待與社群合作，在未來舉辦更多此類峰會。</p>
<h3 id="DevTools-和-IDE"><a href="#DevTools-和-IDE" class="headerlink" title="DevTools 和 IDE"></a>DevTools 和 IDE</h3><p>此版本包含一些對 Flutter DevTools 工具套件的令人興奮的改進。</p>
<p>如果您曾經想知道您的 Flutter 應用程式是否建立了比預期更多的 Widget，那麼 <strong>DevTools 效能</strong> 工具中的一個新功能可以幫助您。使用新的 <strong>重新建立統計資料</strong> 功能，您可以捕獲有關應用程式中或甚至特定 Flutter 畫面中 Widget 建立次數的資訊。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/749/0*7LXjXlFR9w-VR6xk" />
</figure>

<p><em>DevTools 效能工具的螢幕截圖，追蹤重新建立統計資料。</em></p>
<p>我們已為 <strong>網路分析工具</strong> 和 <strong>Flutter Deep Links 工具</strong> 等工具加入了潤色和關鍵錯誤修復，並且進行了一些一般性改進，以在您從 IDE 中使用 DevTools 時為您提供更好的體驗。說到 IDE，您知道您可以在 IDE 中直接使用每個 DevTools 工具嗎？</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tdpToIuTd-mBq-_R" />
</figure>

<p><em>DevTools 螢幕在 VS Code 視窗中打開。</em></p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*QvoXCNqqfsrMn1oC" />
</figure>

<p><em>DevTools 螢幕在 Android Studio 工具視窗中打開。</em></p>
<p>此版本包含對 VS Code 中的 Flutter 側邊欄的改進，讓您更容易存取您正在尋找的工具。升級到最新版本的 VS Code 和 Flutter 和 Dart 擴展，以存取改進的側邊欄。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/318/0*BzEybhMlV-SnSZZl" />
</figure>

<p><em>Flutter 側邊欄是自適應的，可以調整大小以適合您的工作區</em></p>
<p>此版本還包含對 <a href="https://docs.flutter.dev/tools/devtools/extensions">DevTools Extensions</a> 框架的一些重大改進。您現在可以在除錯 Dart 或 Flutter 測試時使用 DevTools 擴展（由您的套件相依之一提供的工具），或者甚至在您沒有除錯任何內容時，但只是在 IDE 中撰寫程式碼時使用。因此，如果您想在這些使用者旅程中使用工具（或建立工具！），現在已經可以了。</p>
<p>若要進一步了解 Flutter 3.24 中包含的所有更新，請查看 DevTools 的發行備註 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.35.0">2.35.0</a>，<a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.36.0">2.36.0</a> 和 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.37.2">2.37.2</a>。</p>
<h3 id="重大變更和棄用"><a href="#重大變更和棄用" class="headerlink" title="重大變更和棄用"></a>重大變更和棄用</h3><p>此版本中的重大變更包括對 <a href="https://docs.flutter.dev/release/breaking-changes/navigator-and-page-api">Navigator 的頁面 API</a>、<a href="https://docs.flutter.dev/release/breaking-changes/popscope-with-result">PopScope 中的泛型</a>、<a href="https://docs.flutter.dev/platform-integration/web/renderers">Flutter 網頁的預設渲染器</a> 的變更，以及一些新的棄用。在 <a href="https://docs.flutter.dev/release/breaking-changes">重大變更頁面</a> 上查看完整的遷移指南。</p>
<p>與往常一樣，非常感謝社群為 <a href="https://github.com/flutter/tests/blob/master/README.md">貢獻測試</a> - 這些測試幫助我們識別出這些重大變更。若要進一步了解，請查看 <a href="https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes">Flutter 的重大變更政策</a>。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>Flutter 成功背後的核心是您 - 我們非凡的社群。沒有您无數的貢獻和堅定的熱情，這個版本是不可能實現的。我們衷心感谢您。</p>
<p>若要深入了解此版本中所取得的成果，我們邀請您查看 <a href="https://docs.flutter.dev/release/release-notes/release-notes-3.24.0">發行備註</a> 和 <a href="https://github.com/flutter/flutter/blob/main/CHANGELOG.md">變更日誌</a>，以獲取 Flutter 3.24 中加入的內容的完整列表。</p>
<p>Flutter 3.24 與 Dart 3.5 現在已在 stable channel 上提供。開始使用 Flutter 的最新旅程就像運行 flutter upgrade 一樣簡單。我們迫不及待想看看您會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6c040f87d1e4" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/whats-new-in-flutter-3-24-6c040f87d1e4">Flutter 3.24 的新功能</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rainvisitor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">166</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">188</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rainvisitor</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
