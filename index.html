<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>RainVisitor Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="RainVisitor Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RainVisitor Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.rainvisitor.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-flutter-3.24" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/8ddf18fb.html" class="article-date">
  <time datetime="2024-09-27T11:51:40.000Z" itemprop="datePublished">2024-09-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Flutter/">Flutter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/8ddf18fb.html">【文章翻譯】 Getting started with Flutter GPU</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<p>在 Flutter 中建立自訂渲染器並渲染 3D 場景。</p>
<p>Flutter 3.24 版本引進了新的低階圖形 API，稱為 Flutter GPU。此外，還有一個由 Flutter GPU 支援的 3D 渲染函式庫，稱為 Flutter Scene (套件：flutter_scene)。Flutter GPU 和 Flutter Scene 目前都處於預覽階段，僅在 Flutter 的主要通道上提供 (由於依賴實驗性功能)，需要啟用 Impeller，並且可能會偶爾引入重大變更。</p>
<p>本文包含這兩個套件的兩個「入門」指南：</p>
<ol>
<li><p>🔺 <strong>進階：</strong>  Flutter GPU 入門<br>如果你是經驗豐富的圖形程式設計師，或者你對低階圖形感興趣，並希望在 Flutter 中從頭開始建立渲染器，那麼本指南將幫助你開始使用 Flutter GPU。你將從頭開始繪製你的第一個三角形……在 Flutter 中！</p>
</li>
<li><p>💚 <strong>中級：</strong>  使用 Flutter Scene 進行 3D 渲染<br>如果你是一位希望將 3D 功能添加到你的應用程式中的 Flutter 開發人員，或者你希望使用 Dart 和 Flutter 建立 3D 遊戲，那麼本指南適合你！你將設定一個匯入並在 Flutter 中渲染 3D 資產的專案。</p>
</li>
</ol>
<h3 id="Flutter-GPU-入門"><a href="#Flutter-GPU-入門" class="headerlink" title="Flutter GPU 入門"></a>Flutter GPU 入門</h3><p>⚠️ 警告！⚠️  Flutter GPU 本質上是一個低階 API。絕大多數從 Flutter GPU 的存在中受益的 Flutter 開發人員，很可能會通過使用在 pub.dev 上發布的更高階渲染函式庫 (例如 Flutter Scene 渲染套件) 來實現。如果你對 Flutter GPU API 本身不感興趣，並且只對 3D 渲染感興趣，請跳轉到  使用 Flutter Scene 進行 3D 渲染。</p>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/900/0*hAqIOVkaI1IWnOHE" /><br><figcaption>閃閃發光。這是一個射線行進的帶符號距離場。你可以使用 Flutter GPU 渲染它，但使用自訂片段著色器也可以做到。 </figcaption><br></figure>


<h3 id="Flutter-GPU-入門-1"><a href="#Flutter-GPU-入門-1" class="headerlink" title="Flutter GPU 入門"></a>Flutter GPU 入門</h3><p>Flutter GPU 是 Flutter 內建的低階圖形 API。它允許你通過編寫 Dart 程式碼和 GLSL 著色器在 Flutter 中建立和整合自訂渲染器。不需要原生平台程式碼。</p>
<p>目前，Flutter GPU 處於早期預覽階段，並提供基本的柵格化 API，但隨著 API 接近穩定狀態，將會繼續添加和改進更多功能。</p>
<p>Flutter GPU 也需要啟用 Impeller。這意味著它只能在 Impeller 支援的平台上使用。在撰寫本文時，Impeller 支援：</p>
<ul>
<li>iOS (預設啟用)</li>
<li>macOS (可選預覽)</li>
<li>Android (可選預覽)</li>
</ul>
<p>我們使用 Flutter GPU 的目標是最終支援所有 Flutter 的平台目標。最終目標是在 Flutter 中培養跨平台渲染解決方案的生態系統，這些解決方案對套件作者易於維護，對使用者易於安裝。</p>
<p>3D 渲染只是一個可能的用例。Flutter GPU 還可以用於建立專門的 2D 渲染器，或者執行更為非正統的操作，例如渲染 4D 空間的 3D 切片，或者投影非歐幾里得空間。</p>
<p>一個由 Flutter GPU 支援的自訂 2D 渲染器的一個很好的用例範例是依賴骨骼網格變形的 2D 角色動畫格式。Spine 2D 就是一個很好的範例。這種骨骼網格解決方案通常具有動畫片段，這些片段可以操作層次結構中骨骼的平移、旋轉和縮放屬性，並且每個頂點都有幾個相關的「骨骼權重」，這些權重決定哪些骨骼應該影響頂點以及影響程度。</p>
<p>使用 Canvas 解決方案 (例如 drawVertices)，需要在 CPU 上為每個頂點應用骨骼權重變換。使用 Flutter GPU，骨骼變換可以以統一陣列的形式傳遞給頂點著色器，甚至可以傳遞給紋理採樣器，允許根據骨骼的狀態和每個頂點的骨骼權重，在 GPU 上並行計算每個頂點的最終位置。</p>
<p>說到這裡，讓我們通過一個溫和的入門來開始使用 Flutter GPU：繪製你的第一個三角形！</p>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JEI3fLDGcRHWKruT" /><br></figure>


<h3 id="將-Flutter-GPU-添加到你的專案中"><a href="#將-Flutter-GPU-添加到你的專案中" class="headerlink" title="將 Flutter GPU 添加到你的專案中"></a>將 Flutter GPU 添加到你的專案中</h3><p>首先，請注意，Flutter GPU 目前處於早期預覽階段，可能會出現 API 斷裂。目前 API 已經可以實現很多功能，但經驗豐富的圖形工程師可能會注意到一些缺失的通用功能。在接下來的幾個月中，Flutter GPU 將會進行很多規劃。</p>
<p>出於這些原因，強烈建議你現在針對 Flutter GPU 開發套件時，針對  主要通道  的頂端進行操作。如果你遇到任何意外行為、錯誤或功能請求，請使用標準  Flutter 錯誤範本  在 GitHub 上提交錯誤。所有與 Flutter GPU 相關的追蹤錯誤都將標記為  flutter-gpu 標籤。</p>
<p>因此，在嘗試使用 Flutter GPU 之前，請通過執行以下命令將 Flutter 切換到主要通道。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>
<p>現在建立一個新的 Flutter 專案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_cool_renderer</span><br><span class="line">cd my_cool_renderer</span><br></pre></td></tr></table></figure>
<p>接下來，將 flutter_gpu SDK 套件添加到你的 pubspec 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu --sdk&#x3D;flutter</span><br></pre></td></tr></table></figure>
<h3 id="建立和匯入著色器捆綁包。"><a href="#建立和匯入著色器捆綁包。" class="headerlink" title="建立和匯入著色器捆綁包。"></a>建立和匯入著色器捆綁包。</h3><p>為了使用 Flutter GPU 渲染任何東西，你需要編寫一些 GLSL 著色器。Flutter GPU 的著色器與 Flutter 的  片段著色器  功能所消耗的著色器具有不同的語義，特別是在統一綁定方面。你還需要定義一個頂點著色器與片段著色器一起使用。</p>
<p>從定義最簡單的著色器開始。你可以將著色器放置在專案中的任何位置，但對於本範例，請建立一個 shaders 目錄，並用兩個著色器填充它：simple.vert 和 simple.frag。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 複製到：shaders&#x2F;simple.vert</span><br><span class="line"></span><br><span class="line">in vec2 position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> gl_Position &#x3D; vec4(position, 0.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在繪製三角形時，你將擁有一份數據列表，該列表定義每個頂點。在本例中，它只列出了 2D 位置。對於這些頂點中的每一個，簡單的頂點著色器將這些 2D 位置分配給剪輯空間輸出內在 gl_Position。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 複製到：shaders&#x2F;simple.frag</span><br><span class="line"></span><br><span class="line">out vec4 frag_color;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> frag_color &#x3D; vec4(0, 1, 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>片段著色器更簡單；它輸出一個 RGBA 顏色，範圍為 (0, 0, 0, 0) 到 (1, 1, 1, 1)。因此，所有內容都將被陰影為綠色。</p>
<p>好了，現在你有了著色器，請使用 Flutter 的提前 (AOT) 著色器編譯器編譯它們。為了設定著色器捆綁包的自動化構建，我們建議使用  flutter_gpu_shaders  套件。</p>
<p>使用 pub 將 flutter_gpu_shaders 作為你的專案中的常規依賴項添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu_shaders</span><br></pre></td></tr></table></figure>
<p>Flutter GPU 著色器被捆綁到 .shaderbundle 文件中，這些文件可以作為常規資產添加到你的專案的資產捆綁包中。著色器捆綁包包含針對平台目標的編譯後的著色器源程式碼。</p>
<p>接下來，建立一個著色器捆綁包清單文件，該文件描述著色器捆綁包的內容。將以下內容添加到專案根目錄中的 my_renderer.shaderbundle.json 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;SimpleVertex&quot;: &#123;</span><br><span class="line"> &quot;type&quot;: &quot;vertex&quot;,</span><br><span class="line"> &quot;file&quot;: &quot;shaders&#x2F;simple.vert&quot;</span><br><span class="line"> &#125;,</span><br><span class="line"> &quot;SimpleFragment&quot;: &#123;</span><br><span class="line"> &quot;type&quot;: &quot;fragment&quot;,</span><br><span class="line"> &quot;file&quot;: &quot;shaders&#x2F;simple.frag&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>著色器捆綁包中的每個條目都可以具有任意的名稱。在本例中，名稱為「SimpleVertex」和「SimpleFragment」。這些名稱用於在你的應用程式中查找著色器。</p>
<p>接下來，使用 flutter_gpu_shaders 套件構建 shaderbundle。你可以通過啟用實驗性的「原生資產」功能來添加一個自動觸發構建的鉤子。使用以下命令來啟用原生資產並安裝 native_assets_cli 套件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>
<p>啟用原生資產功能後，在 hook 目錄下添加一個 build.dart 腳本，它將自動觸發構建著色器捆綁包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 複製到：hook&#x2F;build.dart</span><br><span class="line"></span><br><span class="line">import &#39;package:native_assets_cli&#x2F;native_assets_cli.dart&#39;;</span><br><span class="line">import &#39;package:flutter_gpu_shaders&#x2F;build.dart&#39;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) async &#123;</span><br><span class="line"> await build(args, (config, output) async &#123;</span><br><span class="line"> await buildShaderBundleJson(</span><br><span class="line"> buildConfig: config,</span><br><span class="line"> buildOutput: output,</span><br><span class="line"> manifestFileName: &#39;my_renderer.shaderbundle.json&#39;</span><br><span class="line"> );</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>進行此更改後，當 Flutter 工具構建專案時，buildShaderBundleJson 將構建著色器捆綁包，並將結果輸出到套件根目錄下的 build/shaderbundles/my_renderer.shaderbundle。</p>
<p>著色器捆綁包格式本身與你使用的 Flutter 特定版本相關聯，並且可能會隨著時間的推移而更改。如果你正在編寫一個構建著色器捆綁包的套件，請不要將生成的 .shaderbundle 文件檢查到你的源程式碼樹中。相反，請使用構建鉤子自動化構建過程 (如前所述)。</p>
<p>這樣一來，使用你的函式庫的開發人員將始終使用正確格式構建新的著色器捆綁包！</p>
<p>現在你已經自動構建了著色器捆綁包，請像匯入常規資產一樣匯入它。在你的專案的 pubspec.yaml 中添加一個資產條目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"> assets:</span><br><span class="line"> - build&#x2F;shaderbundles&#x2F;</span><br></pre></td></tr></table></figure>
<p>將來，原生資產功能將允許構建鉤子將數據資產附加到捆綁包中。一旦發生這種情況，就不再需要添加資產匯入規則以及構建鉤子。</p>
<p>接下來，添加一些程式碼在執行時載入著色器。建立 lib/shaders.dart 並添加以下程式碼。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 複製到：lib&#x2F;shaders.dart</span><br><span class="line"></span><br><span class="line">import &#39;package:flutter_gpu&#x2F;gpu.dart&#39; as gpu;</span><br><span class="line"></span><br><span class="line">const String _kShaderBundlePath &#x3D;</span><br><span class="line"> &#39;build&#x2F;shaderbundles&#x2F;my_renderer.shaderbundle&#39;;</span><br><span class="line">&#x2F;&#x2F; 注意：如果你正在構建一個函式庫，則路徑必須以套件名稱為前綴。例如：</span><br><span class="line">&#x2F;&#x2F; &#39;packages&#x2F;my_cool_renderer&#x2F;build&#x2F;shaderbundles&#x2F;my_renderer.shaderbundle&#39;</span><br><span class="line"></span><br><span class="line">gpu.ShaderLibrary? _shaderLibrary;</span><br><span class="line">gpu.ShaderLibrary get shaderLibrary &#123;</span><br><span class="line"> if (_shaderLibrary !&#x3D; null) &#123;</span><br><span class="line"> return _shaderLibrary!;</span><br><span class="line"> &#125;</span><br><span class="line"> _shaderLibrary &#x3D; gpu.ShaderLibrary.fromAsset(_kShaderBundlePath);</span><br><span class="line"> if (_shaderLibrary !&#x3D; null) &#123;</span><br><span class="line"> return _shaderLibrary!;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> throw Exception(&quot;Failed to load shader bundle! ($_kShaderBundlePath)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這段程式碼為 Flutter GPU 著色器執行時函式庫建立了一個單例獲取器。第一次訪問 shaderLibrary 時，將使用 gpu.ShaderLibrary.fromAsset(shader_bundle_path) 使用構建的資產捆綁包初始化執行時著色器函式庫。</p>
<p>現在專案已經設定好了，可以使用 Flutter GPU 著色器。是時候渲染那個三角形了！</p>
<h3 id="繪製你的第一個三角形"><a href="#繪製你的第一個三角形" class="headerlink" title="繪製你的第一個三角形"></a>繪製你的第一個三角形</h3><p>在本指南中，你將建立一個 RGBA Flutter GPU 紋理和一個渲染通道，將紋理附加為顏色輸出。然後，你將使用  Canvas.drawImage  在小部件中渲染紋理。</p>
<p>為了簡潔起見，你將放棄最佳實踐，並僅為每個幀重建所有資源。</p>
<p>只要在分配紋理時將其標記為「著色器可讀」，你就可以將其轉換為 dart:ui.Image。要將渲染結果顯示在小部件樹中，請將其繪製到 dart:ui.Canvas 中！</p>
<p>你可以通過使用自訂繪製器搭建小部件樹來訪問 Canvas。將 lib/main.dart 的內容替換為以下內容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:typed_data&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br><span class="line">import &#39;package:flutter_gpu&#x2F;gpu.dart&#39; as gpu;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 注意：我們之前在設定著色器捆綁包匯入時創建了這個！</span><br><span class="line">import &#39;shaders.dart&#39;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line"> const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line"> return MaterialApp(</span><br><span class="line"> title: &#39;Flutter GPU Triangle Example&#39;,</span><br><span class="line"> home: CustomPaint(</span><br><span class="line"> painter: TrianglePainter(),</span><br><span class="line"> ),</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrianglePainter extends CustomPainter &#123;</span><br><span class="line"> @override</span><br><span class="line"> void paint(Canvas canvas, Size size) &#123;</span><br><span class="line"> &#x2F;&#x2F; 嘗試訪問 &#96;gpu.gpuContext&#96;。</span><br><span class="line"> &#x2F;&#x2F; 如果 Flutter GPU 不受支援，則將拋出異常。</span><br><span class="line"> print(&#39;Default color format: &#39; +</span><br><span class="line"> gpu.gpuContext.defaultColorFormat.toString());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> bool shouldRepaint(covariant CustomPainter oldDelegate) &#x3D;&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>現在，執行應用程式。請提醒一下，Flutter GPU 目前需要啟用 Impeller。因此你必須使用 Impeller 支援的平台。在本指南中，我將針對 macOS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*lKTtaX2ih6dFpSMQ" /><br></figure>

<p>如果 Flutter GPU 正在運作，那麼你應該會看到預設顏色格式被列印到控制台中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter: Default color format: PixelFormat.b8g8r8a8UNormInt</span><br></pre></td></tr></table></figure>
<p>如果 Impeller 未啟用，則在嘗試訪問 gpu.gpuContext 時將拋出異常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception: Flutter GPU requires the Impeller rendering backend to be enabled.</span><br><span class="line"></span><br><span class="line">The relevant error-causing widget was:</span><br><span class="line"> CustomPaint</span><br></pre></td></tr></table></figure>
<p>為了簡單起見，你只會從這裡開始修改 paint 方法。</p>
<p>首先，建立一個 Flutter GPU 紋理，清除它，然後通過將其繪製到 Canvas 中來顯示它。</p>
<p>建立一個與 Canvas 大小相同的紋理。必須選擇一個儲存模式。在本例中，你將紋理標記為 devicePrivate，因為你只會使用從裝置 (GPU) 訪問紋理記憶體的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final texture &#x3D; gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate,</span><br><span class="line"> size.width.toInt(), size.height.toInt())!;</span><br></pre></td></tr></table></figure>
<p>如果通過從主機 (CPU) 上載紋理的數據來覆蓋紋理的數據，那麼請改用 StorageMode.hostVisible。</p>
<p>第三個可用的選項是 StorageMode.deviceTransient，它適用於不需要超過單個渲染通道的壽命的附件 (因此它們可以只存在於磁磚記憶體中，並且不需要由 VRAM 分配支援)。很多時候，深度/模板紋理符合這個標準。</p>
<p>接下來，定義一個 RenderTarget。渲染目標包含一個「附件」集合，這些附件描述了每個片段記憶體佈局及其在渲染通道開始和結束時的設置/拆卸行為。</p>
<p>本質上，渲染目標是渲染通道的可重複使用描述符。</p>
<p>現在，定義一個由一個顏色附件組成的非常簡單的渲染目標。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final renderTarget &#x3D; gpu.RenderTarget.singleColor(</span><br><span class="line"> gpu.ColorAttachment(texture: texture, clearValue: Colors.lightBlue));</span><br></pre></td></tr></table></figure>
<p>請注意，這段程式碼將 clearValue 設置為淺藍色。每個附件都有一個 LoadAction 和一個 StoreAction，它們分別決定在通道開始和結束時應該對附件的臨時磁磚記憶體執行什麼操作。</p>
<p>預設情況下，顏色附件被設置為 LoadAction.clear (它將磁磚記憶體初始化為給定的顏色)，以及 StoreAction.store (它將結果保存到附加的紋理的 VRAM 分配中)。</p>
<p>現在，建立一個命令緩衝區，使用前面的渲染目標從中生成一個渲染通道，然後立即提交命令緩衝區以清除紋理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final commandBuffer &#x3D; gpu.gpuContext.createCommandBuffer();</span><br><span class="line">final renderPass &#x3D; commandBuffer.createRenderPass(renderTarget);</span><br><span class="line">&#x2F;&#x2F; ... 繪製呼叫將在這裡執行！</span><br><span class="line">commandBuffer.submit();</span><br></pre></td></tr></table></figure>
<p>剩下的就是將初始化的紋理繪製到 Canvas 中！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final image &#x3D; texture.asImage();</span><br><span class="line">canvas.drawImage(image, Offset.zero, Paint());</span><br></pre></td></tr></table></figure>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ebUDtzQOuIGmdlop" /><br></figure>

<p>現在你已經將一個渲染通道與顯示到螢幕上的結果連接起來了，你就可以開始繪製三角形了。為此，請設置以下內容：</p>
<ol>
<li>從我們的著色器建立的渲染管道，以及</li>
<li>一個包含我們幾何體的 GPU 可訪問緩衝區 (三個頂點位置)。</li>
</ol>
<p>建立渲染管道很容易。你只需要將你的函式庫中的頂點著色器和片段著色器組合起來。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final vert &#x3D; shaderLibrary[&#39;SimpleVertex&#39;]!;</span><br><span class="line">final frag &#x3D; shaderLibrary[&#39;SimpleFragment&#39;]!;</span><br><span class="line">final pipeline &#x3D; gpu.gpuContext.createRenderPipeline(vert, frag);</span><br></pre></td></tr></table></figure>
<p>現在是幾何體。回想一下，「SimpleVertex」著色器只有一個輸入：in vec2 position。因此，要繪製三個頂點，你需要三組兩個浮點數。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final vertices &#x3D; Float32List.fromList([</span><br><span class="line"> -0.5, -0.5, &#x2F;&#x2F; 第一個頂點</span><br><span class="line"> 0.5, -0.5, &#x2F;&#x2F; 第二個頂點</span><br><span class="line"> 0.0, 0.5, &#x2F;&#x2F; 第三個頂點</span><br><span class="line">]);</span><br><span class="line">final verticesDeviceBuffer &#x3D; gpu.gpuContext</span><br><span class="line"> .createDeviceBufferWithCopy(ByteData.sublistView(vertices))!;</span><br></pre></td></tr></table></figure>
<p>剩下的就是綁定新的資源並呼叫 renderPass.draw() 來完成記錄繪製呼叫。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renderPass.bindPipeline(pipeline);</span><br><span class="line"></span><br><span class="line">final verticesView &#x3D; gpu.BufferView(</span><br><span class="line"> verticesDeviceBuffer,</span><br><span class="line"> offsetInBytes: 0,</span><br><span class="line"> lengthInBytes: verticesDeviceBuffer.sizeInBytes,</span><br><span class="line">);</span><br><span class="line">renderPass.bindVertexBuffer(verticesView, 3);</span><br><span class="line"></span><br><span class="line">renderPass.draw();</span><br></pre></td></tr></table></figure>
<p>如果你啟動應用程式，你現在應該會看到一個綠色的三角形！</p>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LWnGU5WPT_Eom0wJ" /><br></figure>

<p>太棒了，你使用 Flutter、Dart 和一些 GLSL 從頭開始建立了一個渲染器！</p>
<p>無論這是否是你第一次渲染三角形，或者你是一位經驗豐富的圖形專家，我都希望你繼續使用 Flutter GPU 並查看我們正在開發的套件，例如 Flutter Scene。</p>
<p>將來，我們希望發布友好的入門程式碼實驗室，深入探討 Flutter GPU 的預設行為和最佳實踐。我們還沒有討論頂點屬性佈局、紋理綁定、統一和對齊要求、管道混合、深度和模板附件、透視校正等等！</p>
<p>在那之前，我建議你探索  Flutter Scene  ，作為如何使用 Flutter GPU 的一個更全面的範例。</p>
<h3 id="使用-Flutter-Scene-進行-3D-渲染"><a href="#使用-Flutter-Scene-進行-3D-渲染" class="headerlink" title="使用 Flutter Scene 進行 3D 渲染"></a>使用 Flutter Scene 進行 3D 渲染</h3><p>Flutter Scene (套件 flutter_scene) 是一個新的由 Flutter GPU 支援的 3D 場景圖套件，它使 Flutter 開發人員能夠匯入動畫 glTF 模型並渲染實時 3D 場景。</p>
<p>我們的目標是提供一個套件，讓使用 Flutter 建立互動式 3D 應用程式和遊戲變得容易。</p>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tC68CbPLef2rJp1e" /><br></figure>

<p>這個套件最初是一個使用 C++ 編寫的 3D 渲染器的 dart:ui 擴展，並直接構建到 Flutter 的原生執行時中，但它已針對 Flutter GPU 重新編寫，並具有更靈活的介面。</p>
<p>與 Flutter GPU API 本身一樣，Flutter Scene 目前處於早期預覽階段，需要啟用 Impeller。Flutter Scene 通常與 Flutter GPU API 的重大變更保持同步，因此強烈建議你在嘗試使用 Flutter Scene 時使用  主要通道。</p>
<p>接下來，使用 Flutter Scene 建立一個應用程式！</p>
<h3 id="設定一個-Flutter-Scene-專案"><a href="#設定一個-Flutter-Scene-專案" class="headerlink" title="設定一個 Flutter Scene 專案"></a>設定一個 Flutter Scene 專案</h3><p>由於強烈建議你針對  主要通道  使用 Flutter Scene，因此請從切換到主要通道開始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>
<p>接下來，建立一個新的 Flutter 專案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_3d_app</span><br><span class="line">cd my_3d_app</span><br></pre></td></tr></table></figure>
<p>Flutter Scene 依賴於實驗性的「原生資產」功能，以自動構建著色器。你將在稍後使用原生資產來設置 Flutter Scene 的 3D 模型的自動匯入。</p>
<p>使用以下命令啟用原生資產。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br></pre></td></tr></table></figure>
<p>最後，將 Flutter Scene 作為專案依賴項添加。</p>
<p>你還需要在與 Flutter Scene 的 API 互動時使用幾個 vector_math 構造，因此也添加 vector_math 套件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene vector_math</span><br></pre></td></tr></table></figure>
<p>接下來，匯入一個 3D 模型！</p>
<h3 id="匯入一個-3D-模型"><a href="#匯入一個-3D-模型" class="headerlink" title="匯入一個 3D 模型"></a>匯入一個 3D 模型</h3><p>首先，你需要一個要渲染的 3D 模型。在本指南中，你將使用一個通用的  glTF  樣本資產：  DamagedHelmet.glb。以下是它的樣子。</p>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/912/0*vVWRLxJ348tCxv7T" /><br><figcaption>原始的 Damaged Helmet 模型是由 theblueturtle_ 在 2016 年創建的 (許可證：  CC BY-NC 4.0 國際許可證)。轉換後的 glTF 版本是由 ctxwing 在 2018 年創建的 (許可證：  CC BY 4.0 國際許可證)</figcaption><br></figure>

<p>你可以從  GitHub 上託管的 glTF 樣本資產庫  中獲取它。將 DamagedHelmet.glb 放置在你的專案根目錄中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;KhronosGroup&#x2F;glTF-Sample-Models&#x2F;main&#x2F;2.0&#x2F;DamagedHelmet&#x2F;glTF-Binary&#x2F;DamagedHelmet.glb</span><br></pre></td></tr></table></figure>
<p>與大多數實時 3D 渲染器一樣，Flutter Scene 在內部使用專用的 3D 模型格式。你可以使用 Flutter Scene 的離線匯入工具將標準 glTF 二進制文件 (.glb 文件) 轉換為這種格式。</p>
<p>將 flutter_scene_importer 套件作為常規依賴項添加到專案中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene_importer</span><br></pre></td></tr></table></figure>
<p>添加這個套件後，可以使用 dart run 手動呼叫匯入器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dart --enable-experiment&#x3D;native-assets \</span><br><span class="line"> run flutter_scene_importer:import \</span><br><span class="line"> --input &quot;path&#x2F;to&#x2F;my&#x2F;source_model.glb&quot; \</span><br><span class="line"> --output &quot;path&#x2F;to&#x2F;my&#x2F;imported_model.model&quot;</span><br></pre></td></tr></table></figure>
<p>你可以通過使用原生資產構建鉤子來自動執行匯入器。為此，首先將 native_assets_cli 作為常規專案依賴項安裝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>
<p>現在你可以編寫構建鉤子了。使用以下內容建立 hook/build.dart。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#39;package:native_assets_cli&#x2F;native_assets_cli.dart&#39;;</span><br><span class="line">import &#39;package:flutter_scene_importer&#x2F;build_hooks.dart&#39;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) &#123;</span><br><span class="line"> build(args, (config, output) async &#123;</span><br><span class="line"> buildModels(buildConfig: config, inputFilePaths: [</span><br><span class="line"> &#39;DamagedHelmet.glb&#39;,</span><br><span class="line"> ]);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 flutter_scene_importer 中的 buildModels 工具，提供要構建的模型列表。這些路徑相對於專案的構建根目錄。</p>
<p>當 Flutter 工具構建專案時，buildModels 現在將構建著色器捆綁包，並將結果輸出到套件根目錄下的 build/models/DamagedModel.model。</p>
<p>匯入的模型格式本身與你使用的 Flutter Scene 特定版本相關聯，並且會隨著時間的推移而更改。在編寫使用 Flutter Scene 的應用程式或函式庫時，請不要將生成的 .model 文件檢查到你的源程式碼樹中。相反，請使用構建鉤子從你的源模型生成它們 (如前所述)。</p>
<p>這樣一來，隨著你升級 Flutter Scene，你將始終使用正確格式構建新的 .model 文件！</p>
<p>接下來，像匯入常規資產一樣匯入模型。在你的專案的 pubspec.yaml 中添加一個資產條目。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line"> assets:</span><br><span class="line"> - build&#x2F;models&#x2F;</span><br></pre></td></tr></table></figure>
<p>將來，原生資產功能將允許構建鉤子將數據資產附加到捆綁包中。一旦發生這種情況，就不再需要添加資產匯入規則以及構建鉤子。</p>
<h3 id="渲染一個-3D-場景"><a href="#渲染一個-3D-場景" class="headerlink" title="渲染一個 3D 場景"></a>渲染一個 3D 場景</h3><p>現在是應用程式的程式碼。</p>
<p>首先，建立一個有狀態的小部件來跨幀持久化場景。</p>
<p>你將根據時間進行動畫處理，因此將 SingleTickerProviderStateMixin 添加到狀態以及 elapsedSeconds 成員。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br><span class="line">import &#39;package:flutter&#x2F;scheduler.dart&#39;;</span><br><span class="line">import &#39;package:flutter_scene&#x2F;camera.dart&#39;;</span><br><span class="line">import &#39;package:flutter_scene&#x2F;node.dart&#39;;</span><br><span class="line">import &#39;package:flutter_scene&#x2F;scene.dart&#39;;</span><br><span class="line">import &#39;package:vector_math&#x2F;vector_math.dart&#39;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget&#123;</span><br><span class="line"> const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> MyAppState createState() &#x3D;&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line"> double elapsedSeconds &#x3D; 0;</span><br><span class="line"> Scene scene &#x3D; Scene();</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line"> return MaterialApp(</span><br><span class="line"> title: &#39;My 3D app&#39;,</span><br><span class="line"> home: Placeholder(),</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>執行應用程式作為煙霧測試，以確保沒有錯誤。請記住啟用 Impeller！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/912/0*74qs6ytcTjyVHwML" /><br></figure>

<p>在繼續之前，請為動畫設置計時器。覆蓋 MyAppState 中的 initState 以呼叫 createTicker。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">createTicker((elapsed) &#123;</span><br><span class="line">setState(() &#123;</span><br><span class="line">elapsedSeconds &#x3D; elapsed.inMilliseconds.toDouble() &#x2F; 1000;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要小部件可見，計時器回呼就會為每一幀呼叫。呼叫 setState 將觸發這個小部件在每一幀重新構建。</p>
<p>接下來，載入你之前放置在專案中的 3D 模型，並將其添加到場景中。</p>
<p>使用 Node.fromAsset 從資產捆綁包中載入模型。將以下程式碼放在 initState 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node.fromAsset(&#39;build&#x2F;models&#x2F;DamagedHelmet.model&#39;).then((model) &#123;</span><br><span class="line">model.name &#x3D; &#39;Helmet&#39;;</span><br><span class="line">scene.add(model);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Node.fromAsset 異步地從資產捆綁包中反序列化模型，並在模型準備好添加到場景中時解析返回的 Future<Node>。</p>
<p>現在 MyAppState.initState 應該如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">createTicker((elapsed) &#123;</span><br><span class="line">setState(() &#123;</span><br><span class="line">elapsedSeconds &#x3D; elapsed.inMilliseconds.toDouble() &#x2F; 1000;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Node.fromAsset(&#39;build&#x2F;models&#x2F;DamagedHelmet.model&#39;).then((model) &#123;</span><br><span class="line">model.name &#x3D; &#39;Helmet&#39;;</span><br><span class="line">scene.add(model);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，你仍然沒有實際渲染 3D 場景！為此，請使用 Scene.render，它接受一個 UI Canvas、一個 Flutter Scene 相機和一個大小。</p>
<p>訪問 Canvas 的一種方法是建立一個自訂繪製器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line"> ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line"> Scene scene;</span><br><span class="line"> Camera camera;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> void paint(Canvas canvas, Size size) &#123;</span><br><span class="line"> scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> bool shouldRepaint(covariant CustomPainter oldDelegate) &#x3D;&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要忘記將 shouldRepaint 覆蓋設置為返回 true，這樣自訂繪製器就會在每次重建時重新繪製。</p>
<p>最後，將自訂繪製器添加到源程式碼樹中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">final painter &#x3D; ScenePainter(</span><br><span class="line">scene: scene,</span><br><span class="line">camera: PerspectiveCamera(</span><br><span class="line">position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line">target: Vector3(0, 0, 0),</span><br><span class="line">),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">return MaterialApp(</span><br><span class="line">title: &#39;My 3D app&#39;,</span><br><span class="line">home: CustomPaint(painter: painter),</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這段程式碼指示相機以連續的圓圈移動，但始終面向原點。</p>
<p>最後，啟動應用程式！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/796/0*_-OFc0vhBHAhrPrO" /><br></figure>

<p>以下是我們整理的完整源程式碼。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:math&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;;</span><br><span class="line">import &#39;package:flutter_scene&#x2F;camera.dart&#39;;</span><br><span class="line">import &#39;package:flutter_scene&#x2F;node.dart&#39;;</span><br><span class="line">import &#39;package:flutter_scene&#x2F;scene.dart&#39;;</span><br><span class="line">import &#39;package:vector_math&#x2F;vector_math.dart&#39;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line"> runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget &#123;</span><br><span class="line"> const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> MyAppState createState() &#x3D;&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line"> double elapsedSeconds &#x3D; 0;</span><br><span class="line"> Scene scene &#x3D; Scene();</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> void initState() &#123;</span><br><span class="line"> createTicker((elapsed) &#123;</span><br><span class="line"> setState(() &#123;</span><br><span class="line"> elapsedSeconds &#x3D; elapsed.inMilliseconds.toDouble() &#x2F; 1000;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;).start();</span><br><span class="line"></span><br><span class="line"> Node.fromAsset(&#39;build&#x2F;models&#x2F;DamagedHelmet.model&#39;).then((model) &#123;</span><br><span class="line"> model.name &#x3D; &#39;Helmet&#39;;</span><br><span class="line"> scene.add(model);</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> super.initState();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> Widget build(BuildContext context) &#123;</span><br><span class="line"> final painter &#x3D; ScenePainter(</span><br><span class="line"> scene: scene,</span><br><span class="line"> camera: PerspectiveCamera(</span><br><span class="line"> position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line"> target: Vector3(0, 0, 0),</span><br><span class="line"> ),</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"> return MaterialApp(</span><br><span class="line"> title: &#39;My 3D app&#39;,</span><br><span class="line"> home: CustomPaint(painter: painter),</span><br><span class="line"> );</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line"> ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line"> Scene scene;</span><br><span class="line"> Camera camera;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> void paint(Canvas canvas, Size size) &#123;</span><br><span class="line"> scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @override</span><br><span class="line"> bool shouldRepaint(covariant CustomPainter oldDelegate) &#x3D;&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Flutter-光明的未來"><a href="#Flutter-光明的未來" class="headerlink" title="Flutter 光明的未來"></a>Flutter 光明的未來</h3><p>如果你能夠成功地遵循其中一個指南並讓它運行起來：哇，恭喜！</p>
<p>Flutter GPU 和 Flutter Scene 都非常年輕，平台支援有限。但我認為有一天我們會懷念這些不起眼的開端。</p>
<p>憑藉 Impeller 的努力，Flutter 團隊完全擁有了渲染堆棧，因為我們需要將渲染器專門用於 Flutter 的用例。現在，我們正在開啟 Flutter 歷史的新篇章。一個由你共同控制渲染的篇章！</p>
<p>Flutter Scene 最初是 Impeller 中的一個 C++ 組件，與 2D Canvas 渲染器以及一個精簡的 dart:ui 擴展一起。在我構建它時，我已經意識到 Flutter 引擎不會是它的最終目的地。</p>
<p>3D 渲染器的架構決策的海洋是浩瀚無垠的，沒有哪一種通用的 3D 渲染器能夠很好地解決所有用例。「通用」和「高性能」通常是相互矛盾的目標。</p>
<p>充其量，在所有方面都達到足夠的水準，幾乎等於在所有方面都無法達到卓越。</p>
<p>在渲染性能的世界裡，情況更加糟糕。專門針對某一個用例，往往意味著降低另一個用例的性能。</p>
<p>簡而言之，不可能發布一個通用的 3D 渲染器，能夠為所有人解決所有用例。但是，通過公開構建自己的解決方案所需的低階 API (Flutter GPU)，以及在它的基礎上構建一個有用的通用 3D 渲染器，這個渲染器易於 Flutter 社區檢查和修改 (Flutter Scene)，我們正在為 Flutter 開發人員創造一個空間，讓他們可以享受低風險的過時風險和高回報。</p>
<figure><br><img alt="" src="https://cdn-images-1.medium.com/max/506/1*jfeUgpEP9AgAz94yVxVW1g.gif" /><br></figure>

<p>我迫不及待地想看看你會用這些新功能做些什麼。敬請期待 Flutter Scene 的未來版本。有很多東西正在路上。</p>
<p>同時，我要回到工作崗位了。</p>
<p>很快就會見到你。:)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/8ddf18fb.html" data-id="cm1kbl91d0000fx17bgtwb2at" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GPU/" rel="tag">GPU</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-flutter-3-24-news" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/430aae7c.html" class="article-date">
  <time datetime="2024-09-27T08:40:30.000Z" itemprop="datePublished">2024-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/430aae7c.html">flutter-3-24-news</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>解鎖 Flutter GPU、多視圖嵌入等等</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*EA-cAY6uwkYqYb725vnCIw.png" />
<figcaption>Flutter 3.24 on a blue background</figcaption>
</figure>


<p>歡迎來到最新的 Flutter 更新！Flutter 3.24 充滿了令人興奮的新功能和增強功能，可以提升您的應用程式開發體驗。此版本重點介紹了 Flutter GPU 的預覽，它可以在 Flutter 中直接啟用進階圖形和 3D 場景。Web 應用程式現在可以嵌入多個 Flutter 視圖，增強應用程式的多功能性。最後，我們添加了影片廣告變現支援，以幫助您最大限度地提高收入。</p>
<p>在過去的幾個月裡，Flutter 社區一直非常活躍，擁有 852 個框架提交和 615 個引擎提交。我們很興奮地歡迎 49 位新貢獻者，他們幫助實現了此版本。您的奉獻和熱情推動著 Flutter 的前進。</p>
<p>因此，深入了解 Flutter 社區帶給這個最新版本的最新功能和增強功能吧！</p>
<p>Flutter 架構<br>新的 Sliver</p>
<p>此版本添加了新的 Sliver，可以將它們組合在一起以實現動態應用程式列行為：</p>
<p>PinnedHeaderSliver</p>
<p>SliverResizingHeader</p>
<p>您可以使用這些新的 Sliver 來製作浮動、保持固定或在使用者捲動時調整大小的標題。這些新的 Sliver 類似於現有的 SliverPersistentHeader 和 SliverAppBar Sliver，但具有更簡單的 API，可以組合在一起以實現更大的效果。</p>
<p>這些新的 Sliver 附帶了新的樣本程式碼。例如，PinnedHeaderSliver 的 API 文件有一個範例，可以重新建立 iOS 設定應用程式應用程式列的效果：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*bdcb6KGonosfPZ6m" />
</figure>

<p>Cupertino 庫中的更新</p>
<p>在此版本中，我們改進了 CupertinoActionSheet 的保真度。在動作表單的按鈕上滑動手指現在可以提供觸覺回饋。按鈕的字體大小和粗細現在與原生對應物相符。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/655/0*_o_9V0RlITOZdU4v" />
</figure>


<p>我們還為 CupertinoButton 添加了新的焦點屬性，現在您可以自訂已停用的 CupertinoTextField 的顏色。</p>
<p>Cupertino 庫的更新正在進行中，請期待未來版本中的更多更新！</p>
<p>TreeView</p>
<p>two_dimensional_scrollables 套件發佈了 TreeView 小部件，以及幾個用於建立高性能捲動樹的配套類別，這些樹可以在樹增長時向所有方向捲動。套件中包含的樣本應用程式也已更新，其中包含幾個使用 TableView 和 TreeView 小部件的全新範例。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*wcmJCv-6owwsolRl" />
</figure>


<p>TreeSliver 也被添加到框架中，用於在一維捲動中建立樹。TreeView 和 TreeSliver API 相符，使您能夠輕鬆地在適合您的用例的那個之間切換。</p>
<p>CarouselView</p>
<p>此版本包含了 Material Design 輪播 小部件：CarouselView。CarouselView 呈現「未包含」佈局：一個可捲動的項目列表，這些項目會捲動到容器的邊緣，並且當領先和尾隨項目捲出視圖和捲入視圖時，它們可以動態調整大小。</p>
<figure>
<img alt="Flutter CarouselView example" src="https://cdn-images-1.medium.com/max/512/1*6ytqSvtR2TJzAE6LntHTGw.gif" />
</figure>

<p>小部件提供更多功能</p>
<p>此版本包含將核心小部件邏輯從 Material 庫重新定位到 Widgets 庫中以便更廣泛使用的部分工作，這些邏輯不是設計專用的。這包括：</p>
<p>Feedback 小部件，它提供輕鬆訪問設備上的觸覺和音訊回饋，以響應點擊、長按等手勢。</p>
<p>ToggleableStateMixin 和 ToggleablePainter，用於建立複選框、開關和單選按鈕等切換小部件的基類。</p>
<p>為 AnimationStatus 增強枚舉功能</p>
<p>在社群成員 nate-thegrate 的出色 貢獻 中，增強的枚舉功能被添加到 AnimationStatus 中，包括 getter：</p>
<p>isDismissed</p>
<p>isCompleted</p>
<p>isRunning</p>
<p>isForwardOrCompleted</p>
<p>其中一些 getter 已經存在於 Animation 子類別中，例如 AnimationController 和 CurvedAnimation。現在，所有這些狀態 getter 都可以在 Animation 子類別中使用，除了 AnimationStatus 之外。最後，一個 toggle 方法被添加到 AnimationController 中，用於切換動畫的方向。</p>
<p>SelectionArea 中的更新</p>
<p>Flutter 的 SelectionArea 現在支援使用滑鼠進行三擊和在觸控設備上雙擊的更多原生手勢。預設情況下，SelectionArea 和 SelectableRegion 小部件使用這些新的手勢。</p>
<p>三擊</p>
<p>三擊 + 拖動：擴展段落塊中的選取範圍。</p>
<p>三擊：選取點擊位置的段落塊。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*_GmbsIKfnwEAW6G8" />
</figure>


<p>雙擊</p>
<p>雙擊 + 拖動：擴展字詞塊中的選取範圍（支援原生 Android&#x2F;Fuchsia&#x2F;iOS 和 iOS 網頁）。</p>
<p>雙擊：選取點擊位置的字詞（支援原生 Android&#x2F;Fuchsia&#x2F;iOS 和 Android&#x2F;Fuchsia 網頁）。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/770/0*DwZgIybQr3FDFxXd" />
</figure>

<p>引擎<br>Impeller</p>
<p>改善性能和保真度</p>
<p>為了在即將到來的穩定版本中移除 iOS 上的 Impeller 選擇退出，團隊一直在努力改進 Impeller 的性能和保真度。例如，針對文字渲染的一系列改進 大幅提高了 emoji 捲動的性能，消除了捲動大量 emoji 時的卡頓，這對 Impeller 的文字渲染能力來說是一項極好的壓力測試。</p>
<p>此外，透過 解決許多問題，我們也在此版本中大幅改進了 Impeller 文字渲染的保真度。特別是，文字粗細、間距和字距調整現在都與傳統渲染器的文字保真度相符。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gIu2Wm9mpuMGb1JY" />
<figcaption>Before (Note gaps instead of proper kerning, and lighter than intended font weight.)</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tt9hlqhTbrmj4ZCt" />
<figcaption>After</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/739/0*eMboSxWLEJBS_EyL" />
<figcaption>Before (Note incorrect spacing, for example in “vergelijken”)</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/739/0*uxeGJuIKWu0dPW1d" />
<figcaption>After</figcaption>
</figure>


<p>Android 預覽</p>
<p>在此版本中，我們將繼續在 Android 上預覽 Impeller。我們延長了預覽期，因為 Impeller 用於平台視圖的 API 在 Android 14 中的一個錯誤 導致出現困難。這個錯誤後來被 Android 團隊修補了，但是許多已部署的設備在可預見的將來將運行未修補的 Android 版本。解決這些問題意味著需要額外的 API 遷移，因此需要額外的穩定版本週期。出於謹慎和為了確保 Flutter 應用程式可以在盡可能廣泛的設備上運行，我們將推遲將 Impeller 作為預設渲染器，直到今年晚些時候的穩定版本發佈。</p>
<p>隨著 Android 上的 Impeller 預覽繼續在 3.24 穩定版本週期中進行，我們請求 Flutter 開發人員升級到最新的穩定版本，並在啟用 Impeller 時提交有關任何發現的不足的錯誤。在此階段的回饋對確保 Impeller 在 Android 上取得成功以及我們能夠在今年晚些時候的版本中自信地將其設為預設渲染器至關重要。Android 硬體生態系統比 iOS 生態系統更加多元。因此，關於 Impeller 最有用的回饋應包括有關發生問題的特定設備和 Android 版本的詳細資訊。</p>
<p>改進縮放圖片的預設值</p>
<p>在此版本中，圖片的預設 FilterQuality 已從 FilterQuality.low 變更為 FilterQuality.medium。當一個大型圖片比其目標矩形大很多時（這是一個常見的情況），FilterQuality.low 會導致圖片看起來更加「像素化」，並且渲染速度比 FilterQuality.medium 慢。未來，團隊還將探索更適合各種 FilterQuality 級別的新名稱。</p>
<p>Flutter GPU 預覽</p>
<p>Flutter 推出了對渲染功能的重大更新，即 Flutter GPU，可在主頻道上使用。此低階圖形 API 允許開發人員使用 Dart 程式碼和 GLSL 著色器建立自訂渲染器，而無需任何原生平台程式碼。</p>
<p>Flutter GPU 擴展了您可以在 Flutter 中直接渲染的內容，啟用進階圖形和 3D 場景。它需要 Impeller 渲染後端，目前在 iOS、macOS 和 Android 上受支持。儘管處於早期預覽階段，但 Flutter GPU 的目標是最終支援所有 Flutter 平台。</p>
<p>API 允許完全控制渲染傳遞附件、頂點階段和數據上傳到 GPU。這種靈活性對於建立複雜的渲染解決方案至關重要，從 2D 角色動畫到複雜的 3D 場景。</p>
<p>開發人員可以透過切換到主頻道並將 flutter_gpu 套件添加到他們的專案中來開始使用 Flutter GPU。接下來的幾個月將看到更多功能和穩定性方面的改進，更高階的渲染庫（如 flutter_scene）將簡化這些進階功能的使用。</p>
<p>若要深入了解 Flutter GPU，並了解如何在您的專案中利用它，請查看詳細的 Flutter GPU 部落格文章。無論您是建立遊戲還是複雜的圖形，Flutter 的全新 GPU 功能都讓它成為產品的強大選擇。</p>
<p>網頁<br>多視圖嵌入</p>
<p>Flutter 網頁應用程式現在可以利用多視圖嵌入，讓開發人員可以將內容同時渲染到多個 HTML 元素中。此功能稱為「嵌入模式」或「多視圖」，為將 Flutter 視圖整合到現有的 Web 應用程式中提供了靈活性。</p>
<p>在多視圖模式下，Flutter 網頁應用程式不會在啟動時立即渲染。相反，它會等到主機應用程式使用 addView 方法添加第一個「視圖」。主機應用程式可以動態添加或移除這些視圖，Flutter 會根據需要調整其小部件。</p>
<p>若要啟用多視圖模式，請在 flutter_bootstrap.js 檔案中的 initializeEngine 方法中設定 multiViewEnabled: true。然後，可以從 JavaScript 管理視圖，將它們添加到指定的 HTML 元素中，並根據需要移除它們。每次添加和移除視圖都會觸發 Flutter 中的更新，允許動態內容渲染。</p>
<p>此功能對於將 Flutter 整合到需要多個獨立 Flutter 視圖的複雜 Web 應用程式中特別有用。它還支援每個視圖的自訂初始化數據，啟用個人化的設定和互動式體驗。</p>
<p>若要深入了解如何在 Flutter 網頁應用程式中實作多視圖嵌入，請查看 詳細的文件。</p>
<p>變現<br>影片廣告變現支援</p>
<p>我們推出了一個新的 互動式媒體廣告 (IMA) 外掛，以支援 Flutter 行動應用程式中的串流影片廣告變現。新的 IMA 外掛為 Flutter 應用程式提供了新的廣告變現機會，這些機會建立在現有的 Google 行動廣告 (GMA) 外掛 之上，該外掛主要支援展示廣告格式。</p>
<p>串流影片廣告通常在影片內容播放之前（開頭廣告）、期間（中間廣告）或之後（結尾廣告）顯示給使用者。一些串流影片廣告也可以跳過。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/836/0*_c0s8KMdLNyfxOMQ" />
</figure>


<p>Flutter IMA 的優點：</p>
<p>在 Flutter 應用程式中無縫變現影片播放器內容。例如，當應用程式使用者點擊影片內容上的播放時，您現在可以實作 Flutter IMA 外掛以首先向使用者顯示一個 15 秒的廣告，然後再開始播放影片內容。</p>
<p>利用原生 IMA SDK 的相同優點，包括訪問 Google 優質廣告需求和行業標準合規性（例如 IAB VAST）。</p>
<p>初始發佈版本目前支援 Android 和 iOS 平台上的開頭影片廣告。中間廣告支援將很快提供。我們鼓勵您開始在 Flutter 應用程式影片內容中探索新的 IMA 外掛。如果您在 GitHub 上遇到任何問題或疑慮，請告知我們。</p>
<p>資源：外掛指南，樣本應用程式，Git 儲存庫</p>
<p>iOS<br>Swift 套件管理器初始支援</p>
<p>今天，Flutter 使用 CocoaPods 來管理原生 iOS 或 macOS 依賴項。</p>
<p>Flutter 3.24 添加了對 Swift 套件管理器的早期支援。這帶來了許多優點，包括：</p>
<p>訪問 Swift 套件生態系統。Flutter 外掛將能夠利用不斷發展的 Swift 套件 生態系統！<br>2. 簡化 Flutter 安裝。Swift 套件管理器與 Xcode 捆綁在一起。未來，您將不再需要安裝 Ruby 和 CocoaPods 來為 Apple 平台使用 Flutter。</p>
<p>我們鼓勵外掛作者 嘗試將 Swift 套件管理器支援添加到您的外掛中，並提供您體驗的回饋。</p>
<p>如果您對 Flutter 對 Swift 套件管理器的支援有任何回饋，請 提交錯誤。</p>
<p>生態系統<br>共享偏好設定外掛更新</p>
<p>我們已在 shared_preferences 外掛中添加了兩個新的 API，SharedPreferencesAsync 和 SharedPreferencesWithCache。最重大的變化是 Android 實作使用 Preferences DataStore 而不是 Shared Preferences。</p>
<p>SharedPreferencesAsync 允許使用者直接調用平台以獲取設備上保存的最新偏好設定，代價是異步和比使用快取版本稍微慢一些。這對於可以由其他系統或隔離區更新的偏好設定很有用，這些偏好設定會使快取過時。</p>
<p>SharedPreferencesWithCache 建立在 SharedPreferencesAsync 之上，允許使用者同步訪問偏好設定的本地快取副本。這與舊的 API 相似，但現在可以透過不同的參數多次實例化。</p>
<p>這些新的 API 旨在將來替換目前的 SharedPreferences API。但是，這是生態系統中最常用的外掛之一，我們知道生態系統需要時間才能轉換到新的 API。</p>
<p>Flutter 和 Dart 套件生態系統峰會歐洲 2024</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fWo9ieYzQcJjwQBi" />
</figure>


<p>作為 Fluttercon 歐洲 2024 的一部分，我們舉辦了首屆面對面 Flutter 和 Dart 套件生態系統峰會。這是繼我們於 2023 年 8 月舉辦的第一屆虛擬峰會之後。在此查看討論會的重點摘要。</p>
<p>我們很高興地宣布，下一屆峰會將於 2024 年 9 月 20 日在紐約市舉行的 Fluttercon USA 舉行！如果您是套件作者或貢獻者，並且將參加 Fluttercon USA 2024，請 註冊 以保留您的峰會席位。</p>
<p>峰會匯集了套件作者和維護者，進行了以下主題的非正式會議：</p>
<p>會議 1 - 原生互操作的過去、現在和未來</p>
<p>會議 2 - 可持續的套件維護模型</p>
<p>會議 3 - 解決套件生態系統碎片化問題</p>
<p>我們相信峰會，特別是在更通用的 Flutter 和 Dart 活動的一部分時，是社群之間公開討論的有價值的平台，用於找出關鍵挑戰和集思廣益解決方案。我們期待與社群合作，在未來舉辦更多此類峰會。</p>
<p>DevTools 和 IDE</p>
<p>此版本包含一些對 Flutter DevTools 工具套件的令人興奮的改進。</p>
<p>如果您曾經想知道您的 Flutter 應用程式是否建立了比預期更多的 Widget，那麼 DevTools 性能 工具中的一個新功能可以幫助您。使用新的 重新建立統計數據 功能，您可以捕獲有關應用程式中或甚至特定 Flutter 畫面中 Widget 建立次數的資訊。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/749/0*7LXjXlFR9w-VR6xk" />
</figure>


<p>DevTools 性能工具的螢幕截圖，跟踪重新建立統計數據。</p>
<p>我們已為 網路效能分析器 和 Flutter 深層連結工具 等工具添加了潤色和關鍵錯誤修復，並且進行了一些一般性改進，以在您從 IDE 中使用 DevTools 時為您提供更好的體驗。說到 IDE，您知道您可以在 IDE 中直接使用每個 DevTools 工具嗎？</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tdpToIuTd-mBq-_R" />
</figure>


<p>DevTools 螢幕在 VS Code 視窗中打開。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*QvoXCNqqfsrMn1oC" />
</figure>


<p>DevTools 螢幕在 Android Studio 工具視窗中打開。</p>
<p>此版本包含對 VS Code 中的 Flutter 側邊欄的改進，讓您更容易訪問您正在尋找的工具。升級到最新版本的 VS Code 和 Flutter 和 Dart 擴展，以訪問改進的側邊欄。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/318/0*BzEybhMlV-SnSZZl" />
</figure>


<p>Flutter 側邊欄是自適應的，可以調整大小以適合您的工作區</p>
<p>此版本還包含對 DevTools 擴展 框架的一些重大改進。您現在可以在調試 Dart 或 Flutter 測試時使用 DevTools 擴展（由您的套件依賴項之一提供的工具），或者甚至在您沒有調試任何內容時，但只是在 IDE 中撰寫程式碼時使用。因此，如果您想在這些使用者旅程中使用工具（或建立工具！），現在已經可以了。</p>
<p>若要進一步了解 Flutter 3.24 中包含的所有更新，請查看 DevTools 的發佈說明 2.35.0，2.36.0 和 2.37.2。</p>
<p>重大變更和棄用</p>
<p>此版本中的重大變更包括對 Navigator 的頁面 API、PopScope 中的泛型、Flutter 網頁的預設渲染器 的變更，以及一些新的棄用。在 重大變更頁面 上查看完整的遷移指南。</p>
<p>與往常一樣，非常感謝社群為 貢獻測試 - 這些測試幫助我們識別出這些重大變更。若要進一步了解，請查看 Flutter 的重大變更政策。</p>
<p>結語</p>
<p>Flutter 成功背後的核心是您 - 我們非凡的社群。沒有您無數的貢獻和堅定的熱情，這個版本是不可能實現的。我們衷心感謝您。</p>
<p>若要深入了解此版本中所取得的成果，我們邀請您查看 發佈說明 和 變更日誌，以獲取 Flutter 3.24 中添加的內容的完整列表。</p>
<p>Flutter 3.24 與 Dart 3.5 現在已在穩定版本通道上提供。開始使用 Flutter 的最新旅程就像運行 flutter upgrade 一樣簡單。我們迫不及待想看看您會建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6c040f87d1e4" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/whats-new-in-flutter-3-24-6c040f87d1e4">Flutter 3.24 的新功能</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/430aae7c.html" data-id="cm1kh4c1p0000gp17fag117fe" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-android-app-store-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/4254a2e9.html" class="article-date">
  <time datetime="2020-10-25T11:51:40.000Z" itemprop="datePublished">2020-10-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Flutter/">Flutter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/4254a2e9.html">Android app 上架流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章主要介紹在2020年 Goolge 改版後的 Play Store Console 如何上架 Android App</p>
<p>首先到 <a href="https://play.google.com/console/u/0/developers/" target="_blank" rel="noopener">Play Store Console</a> 右邊點擊新增應用程式</p>
<p><img src="../images/android-app-deploy/img1.png" alt=""></p>
<p>填寫以下應用程式詳細資訊</p>
<ul>
<li>應用程式名稱：會顯示在商店的App名稱</li>
<li>預設語言：預設App使用的語言，作為商店一開始提供的預設語言</li>
<li>應用程式類型：分類只有遊戲與應用程式，目的是要把遊戲區分出來，日後可更改</li>
<li>是否收費：設定App是否下載時需要費用，勾選收費後，需要至 <code>付費應用程式</code> 修改設定</li>
</ul>
<p>最後同意 <code>開發人員計畫政策</code> 及 <code>美國出口法律</code> 後，即可完成初始設定</p>
<p><img src="../images/android-app-deploy/img2.png" alt=""></p>
<p><img src="../images/android-app-deploy/img3.png" alt=""></p>
<p>接著進入到 <code>資訊主頁</code></p>
<p><img src="../images/android-app-deploy/img4.png" alt=""></p>
<p>第一次設定時會出現 <code>初始設定</code> 提示，可依序點擊設定，該步驟都是必須完成的步驟，否則無法完成審查上架</p>
<p><img src="../images/android-app-deploy/img5.png" alt=""></p>
<h1 id="應用程式存取權"><a href="#應用程式存取權" class="headerlink" title="應用程式存取權"></a>應用程式存取權</h1><p>設定 App 是否開放給全部使用者</p>
<p><img src="../images/android-app-deploy/img6.png" alt=""></p>
<p>或是部分功能有使用限制，需設定：</p>
<ul>
<li>名稱</li>
<li>使用者名稱/電話號碼</li>
<li>密碼</li>
<li>任何操作說明</li>
</ul>
<p>透過此可限制使用者下載應用程式</p>
<p><img src="../images/android-app-deploy/img7.png" alt=""></p>
<p><img src="../images/android-app-deploy/img8.png" alt=""></p>
<h1 id="廣告"><a href="#廣告" class="headerlink" title="廣告"></a>廣告</h1><p>設定App中是否有廣告，若有勾選廣告則會在Play商店上顯示 <code>含廣告內容</code> 的標籤</p>
<p><img src="../images/android-app-deploy/img10.png" alt=""></p>
<h1 id="內容分級"><a href="#內容分級" class="headerlink" title="內容分級"></a>內容分級</h1><p>根據國際年齡分級聯盟（英語：International Age Rating Coalition，縮寫IARC）設計的簡化各國分級的內容分級問卷，降低產品評比的過程，<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E5%B9%B4%E9%BD%A1%E5%88%86%E7%B4%9A%E8%81%AF%E7%9B%9F" target="_blank" rel="noopener">參考資料</a></p>
<p>填寫內容分級問卷，讓使用者了解App的分類，及是否會有不宜兒童的內容</p>
<p><img src="../images/android-app-deploy/img11.png" alt=""></p>
<p>首先填寫電子郵件，問卷完成會寄送一份結果至該信箱</p>
<p><img src="../images/android-app-deploy/img13.png" alt=""></p>
<p>選擇 App 的類別，以 <a href="https://play.google.com/store/apps/details?id=com.wtuc.ap" target="_blank" rel="noopener">文藻校務通</a> 為例，選擇 <code>參考資訊、新聞或教育內容</code></p>
<p><img src="../images/android-app-deploy/img12.png" alt=""></p>
<p>根據選擇的類型，需填寫相關內容是否有未成年暴力色情訊息</p>
<p><img src="../images/android-app-deploy/img14.png" alt=""></p>
<p>完成後會顯示基本的報表，點擊右下角提交完成問卷</p>
<p><img src="../images/android-app-deploy/img15.png" alt=""></p>
<p>完成後，若日後想在修改問卷內容，需至右上角 點擊 <code>Start new questionaire</code> 重新提交問卷</p>
<p><img src="../images/android-app-deploy/img16.png" alt=""></p>
<h1 id="目標對象"><a href="#目標對象" class="headerlink" title="目標對象"></a>目標對象</h1><p>填寫詳細的App發布目標對象</p>
<p>首先點選 <code>目標年齡層</code>，主要是確認目標對象是不是兒童，若對象未滿13歲則需要新增隱私權政策</p>
<p><img src="../images/android-app-deploy/img18.png" alt=""></p>
<p>勾選 <code>是否會引起兒童興趣</code>，若上者點擊13歲以下，可勾選 <code>是</code> 宣稱適合兒童</p>
<p><img src="../images/android-app-deploy/img19.png" alt=""></p>
<p>最後點擊 <code>儲存</code> 完成目標對象和內容</p>
<p><img src="../images/android-app-deploy/img20.png" alt=""></p>
<p>接著就完成一半了～～</p>
<p><img src="../images/android-app-deploy/img21.png" alt=""></p>
<h1 id="應用程式類別及詳細資料"><a href="#應用程式類別及詳細資料" class="headerlink" title="應用程式類別及詳細資料"></a>應用程式類別及詳細資料</h1><p>應用程式分類，區分應用程式或遊戲的類別，在Play 商店中，也會有類別排名</p>
<p><img src="../images/android-app-deploy/img22.png" alt=""></p>
<p>接著設定商店的聯絡詳細資訊，分別為</p>
<ul>
<li>電子郵件地址 (必填)</li>
<li>電話號碼</li>
<li>網站</li>
</ul>
<p><strong>以上訊息皆會在Play商店上顯示</strong></p>
<p><img src="../images/android-app-deploy/img23.png" alt=""></p>
<p>並勾選是否要在Play商店外行銷，讓外部網站可搜尋到你的App</p>
<p><img src="../images/android-app-deploy/img24.png" alt=""></p>
<p>完成後就只剩下最後一個步驟</p>
<p><img src="../images/android-app-deploy/img25.png" alt=""></p>
<h1 id="商店資訊"><a href="#商店資訊" class="headerlink" title="商店資訊"></a>商店資訊</h1><p>首先會根據一開始設定的<code>主要語言</code>，設定 App 在 Play 商店的資訊，可根據不同語言，設定不同的商店資訊，可點擊 <code>管理其他語言版本的翻譯內容</code> 管理其他語言的內容</p>
<h2 id="應用程式詳細資料"><a href="#應用程式詳細資料" class="headerlink" title="應用程式詳細資料"></a>應用程式詳細資料</h2><p>首先可設定</p>
<ul>
<li>應用程式名稱：App名稱，作為可供搜尋的關鍵字，上限50字</li>
<li>簡短說明：可在App頁面首要看到簡短說明，上限80字</li>
<li>完整說明：在點擊<code>關於這個應用程式</code>後顯示的完整說明</li>
</ul>
<p><img src="../images/android-app-deploy/img26.png" alt=""></p>
<p>可參照 Play 商店對應位置</p>
<p><img src="../images/android-app-deploy/img26-1.jpg" alt=""></p>
<p><img src="../images/android-app-deploy/img26-2.jpg" alt=""></p>
<p>接著設定 <code>應用程式圖示</code> 會顯示在 Play 商店的圖示，<strong>限定尺寸為 <code>512*512</code> 的解析度</strong>，上傳後都會以橢圓裁剪顯示</p>
<p><img src="../images/android-app-deploy/img27.png" alt=""></p>
<p>主要圖片顯示於商店資訊的最頂端，可用於宣傳應用程式，<strong>大小限制 <code>1024*500</code> 解析度的圖片</strong></p>
<p><img src="../images/android-app-deploy/img29.png" alt=""></p>
<p>螢幕截圖主要分為</p>
<ul>
<li>手機</li>
<li>七吋平板電腦</li>
<li>十吋平板電腦</li>
</ul>
<p>基本上，對應類型的裝置截圖都適用，也可自行製作符合規定的尺寸的圖片，<strong>皆為使用 JPEG 或 24 位元 PNG 圖片，長寬比建議16:9</strong></p>
<p><img src="../images/android-app-deploy/img30.png" alt=""></p>
<p><img src="../images/android-app-deploy/img31.png" alt=""></p>
<p>加入影片也會顯示於商店上</p>
<p><img src="../images/android-app-deploy/img32.png" alt=""></p>
<p>商店資訊設定完成後，若未來要修改都可直接修改，但修改後都需要等商店部署時間，通常都會為半天左右時間</p>
<h1 id="上傳App至商店"><a href="#上傳App至商店" class="headerlink" title="上傳App至商店"></a>上傳App至商店</h1><p>到 <code>發佈</code> 的目錄下，選擇App目前要發布的方式，有分成</p>
<ul>
<li>正式版：會發布給商店中所有設置的地區</li>
<li>公開測試：任何使用者可至 Play 商店點擊測試計畫，即可使用此版本</li>
<li>封閉測試：由開發人員建立電子郵件清單，或是可透過連結加入測試計畫 <a href="https://play.google.com/apps/testing/{app" target="_blank" rel="noopener">https://play.google.com/apps/testing/{app</a> id}</li>
<li>內部測試：由開發人員建立電子郵件清單，或是可透過內部邀請測試連結：<a href="https://play.google.com/apps/internaltest/{test" target="_blank" rel="noopener">https://play.google.com/apps/internaltest/{test</a> group id} 加入</li>
<li>搶先註冊：若還沒發佈正式版時，可利用此功能，在Play商店中顯示搶先體驗的字樣，並提供測試人員特殊獎勵</li>
</ul>
<p>不管利用哪種測試方式，接下來上傳App的方式都會相同，例如選擇 <code>正式版</code> 發布，並點擊右上方的 <code>建立新版本</code></p>
<p><img src="../images/android-app-deploy/img33.png" alt=""></p>
<p>接著第一次上架時需點擊 同意使用 <code>Google Play 應用程式簽署</code>，Google 會管理你簽署所使用的金鑰，並且該金鑰只能提供給該 App 使用</p>
<p>若今天金鑰遺失，可請帳戶擁有者聯絡<a href="https://support.google.com/googleplay/android-developer/contact/otherbugs" target="_blank" rel="noopener">支援小組</a>重新上傳金鑰</p>
<p>將利用 <code>Android Studio</code> 等等的 Android 編譯工具，將原生Android 的 <code>Apk</code> 或是 <code>App Bundle</code> 上傳至此頁面</p>
<p><strong>每次新上傳的 <code>版本號碼(version code)</code> 皆需大於先前上傳的</strong></p>
<p>關於金鑰使用詳細 <a href="https://support.google.com/googleplay/android-developer/answer/7384423" target="_blank" rel="noopener">可參考</a></p>
<p><img src="../images/android-app-deploy/img35.png" alt=""></p>
<h2 id="版本詳細資訊"><a href="#版本詳細資訊" class="headerlink" title="版本詳細資訊"></a>版本詳細資訊</h2><p>版本名稱會根據上傳的 <code>Apk</code> 或 <code>App Bundle</code> 命名</p>
<p>版本資訊會根據商店可提供的語言，以 <code>XML</code> 格式撰寫，將這次更新內容寫至 <code>語言碼(language code)</code> 中</p>
<p><img src="../images/android-app-deploy/img36.png" alt=""></p>
<p>完成後點擊儲存，並點擊檢查版本</p>
<p><img src="../images/android-app-deploy/img37.png" alt=""></p>
<p>接著會發現沒有設定提供地區</p>
<p><img src="../images/android-app-deploy/img38.png" alt=""></p>
<p>返回至上一頁的最上方，選擇 <code>國家與地區</code> 編輯針對正式版的發布國家/地區</p>
<p><img src="../images/android-app-deploy/img39.png" alt=""></p>
<p>若沒勾選，Play商店就不會發佈至此國家/地區</p>
<p><img src="../images/android-app-deploy/img40.png" alt=""></p>
<p>接著回到剛剛編輯的版本資訊，點擊 <code>開始發布(正式版)</code></p>
<p><img src="../images/android-app-deploy/img41.png" alt=""></p>
<p>最後會跳回正式版的頁面，並顯示審查中</p>
<p><img src="../images/android-app-deploy/img42.png" alt=""></p>
<p>自 2019 年開始，Play 商店在第一次審查時，最久大約會至七天，爾後提交大約都是一下子就完成審查，並都是半天會完全部署至商店(所有使用者都可以看到更新)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/4254a2e9.html" data-id="ckrhj405y0000gxb30xskeeey" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ios-app-store-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/dc2c1f00.html" class="article-date">
  <time datetime="2020-10-24T12:27:58.000Z" itemprop="datePublished">2020-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Flutter/">Flutter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/dc2c1f00.html">iOS app 上架流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章主要介紹在2020年 Apple 改版後的 App Store Connect 如何上架 iOS App</p>
<h1 id="新增-App"><a href="#新增-App" class="headerlink" title="新增 App"></a>新增 App</h1><p>到 <a href="https://appstoreconnect.apple.com/" target="_blank" rel="noopener">App Store Connect</a> 點擊 <code>我的App</code></p>
<p><img src="../images/ios-app-deploy/img1.png" alt=""></p>
<p>點擊 App 旁邊邊的 + 選擇 <code>新的 App</code></p>
<p><img src="../images/ios-app-deploy/img2.png" alt=""></p>
<h1 id="註冊Identifier"><a href="#註冊Identifier" class="headerlink" title="註冊Identifier"></a>註冊Identifier</h1><p>到 <a href="https://developer.apple.com/account/resources/identifiers/list" target="_blank" rel="noopener">憑證、識別碼及描述檔</a> 註冊App的 <code>Identifier</code></p>
<p><img src="../images/ios-app-deploy/img4-0.png" alt=""></p>
<p>選擇 <code>App IDs</code></p>
<p><img src="../images/ios-app-deploy/img4-1.png" alt=""></p>
<p>選擇 <code>App</code></p>
<p><img src="../images/ios-app-deploy/img4-2.png" alt=""></p>
<p><strong>Discription</strong> 填寫可以識別的名稱</p>
<p><strong>App ID Prefix</strong> 選擇 <code>Explicit</code> 並填上與 Xcode 中的 <code>Bundle Indentifier</code> 相同的 ID</p>
<p><strong>App ID Prefix 的 Bundle ID 上架後就不可修改</strong></p>
<p>最後點擊 <code>Continue</code> 然後 <code>Register</code> 完成註冊</p>
<p><img src="../images/ios-app-deploy/img4-3.png" alt=""></p>
<p>或是</p>
<p>懶人方法</p>
<p>使用 <code>Xcode</code> 在 <code>Target</code> 中的 <code>Runner</code> 選擇 <code>Signing &amp; Capabilities</code></p>
<p>選擇想要上架的Apple開發者帳號</p>
<p><img src="../images/ios-app-deploy/img3.png" alt=""></p>
<p>並點擊 <code>+ Capability</code> 隨意新增一個 Capability</p>
<p>此動作 <code>Xcode</code> 會自動註冊 <code>Indentifier</code> 至 App Store Connect</p>
<p>完成後再將其取消 </p>
<p>沒取消的話審查時會納入審查範圍 要特別注意</p>
<p><img src="../images/ios-app-deploy/img4-4.png" alt=""></p>
<p>接著填寫App基本資訊</p>
<ul>
<li>平台：選擇你的App會在哪些平台提供，若沒勾選可事後新增</li>
<li>名稱：在Apple Store的名稱，無法跟已上架App相同，命名上需要先搶先贏，除非對方把App刪除或修改名稱，也是使用者搜尋時能找到你的App的首要途徑</li>
<li>主要語言：首先可在商店提供的語言，若有發佈不同國家語系，可事後新增</li>
<li>套件識別碼：選擇剛才新增的 <code>Indentifier</code>，選擇後就不能修改，對應到原生的 <code>Bundle Indentifier</code></li>
<li>SKU：App ID 為獨一無二，可任意命名，填寫後不能修改，但不會公開顯示</li>
</ul>
<p><img src="../images/ios-app-deploy/img4-5.png" alt=""></p>
<h1 id="App-資訊"><a href="#App-資訊" class="headerlink" title="App 資訊"></a>App 資訊</h1><p>新增 App 後，可先來 一般資訊 -&gt; App 資訊，填寫 App 基本資訊，這邊會分兩個區塊，一個是可本地化資訊及一般資訊</p>
<h3 id="可本地化資訊"><a href="#可本地化資訊" class="headerlink" title="可本地化資訊"></a>可本地化資訊</h3><ul>
<li>名稱：必填，為一開始輸入的 App 名稱</li>
<li>副標題：必填，商店中會位於 App 名稱下方，建議使用簡短語句說明 App</li>
<li>隱私權政策：必填，聲明你的 App 隱私權政策的網址，不限制格式</li>
</ul>
<p><img src="../images/ios-app-deploy/img16.png" alt=""></p>
<h3 id="一般資訊"><a href="#一般資訊" class="headerlink" title="一般資訊"></a>一般資訊</h3><ul>
<li>Apple ID：由 Apple 產生，作為網頁上的編號，可至 <a href="https://apps.apple.com/tw/app/id`${你的" target="_blank" rel="noopener">https://apps.apple.com/tw/app/id`${你的</a> Apple ID}`，找到你的App</li>
<li>內容版權：聲明你的 App 是否有第三方內容，像是以校務通來說，資料來源於學校，就可以視為第三方內容 </li>
<li>年齡分級：必填，根據填寫 <a href="#/年齡分級問卷">年齡分級問卷</a> 的結果</li>
<li>許可協議：必填，預設使用 <a href="https://www.apple.com/legal/internet-services/itunes/dev/stdeula/" target="_blank" rel="noopener">《Apple 標準終端使用者許可協議》(EULA)</a>，可點擊自訂許可協議</li>
<li>類別：必填，在商店的分類，可選擇兩個，也作為與同類型App排名的分類</li>
</ul>
<p><img src="../images/ios-app-deploy/img17.png" alt=""></p>
<h1 id="定價與供應狀況"><a href="#定價與供應狀況" class="headerlink" title="定價與供應狀況"></a>定價與供應狀況</h1><ul>
<li>價格排程：選擇你的App定價方式，最低免費到最高 32900元，使用者付費購買後90天內都可以反悔</li>
<li>預定：第一次上架前會顯示，自訂日期在App成功發布後，會通知預定的使用者</li>
<li>供應狀況：需先填寫<code>供應國家與地區</code>，若選擇停止供應，會從商店下架，直到重新供應為止</li>
<li>Mac 上的 iOS App：如果你的iOS App有使用到 <a href="https://developer.apple.com/mac-catalyst/" target="_blank" rel="noopener">Mac Catalyst
</a>(Flutter 目前不支援)，會將你的iOS App發佈至 Mac App Store，若有發佈macOS App，則優先發布 macOS App</li>
<li>App發布方式：根據你的開發者帳號，若個人開發者帳號只能選擇公開在Apple Store，若是企業開發者帳號，則可以發布到私人的商店發布</li>
</ul>
<p><img src="../images/ios-app-deploy/img18.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img18-1.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img26.png" alt=""></p>
<h1 id="App版本資訊"><a href="#App版本資訊" class="headerlink" title="App版本資訊"></a>App版本資訊</h1><p>進入 App <code>版本資訊</code> 後</p>
<p>首先設定 <code>App預覽與截圖</code> 可參考以下規格 <strong><code>每個至少三張</code></strong></p>
<p>12.9 吋 iPad Pro 第三代 及 第二代 尺寸是可以相容的 故截圖第三代 可直接上傳到第二代</p>
<p>建議使用模擬器截圖 上傳完可用滑鼠拖曳改變顯示順序</p>
<table>
<thead>
<tr>
<th style="text-align:center">螢幕尺寸說明</th>
<th style="text-align:center">平台</th>
<th style="text-align:center">截圖尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 6.5 吋</td>
<td style="text-align:center">iPhone 11 Pro Max、iPhone 11、iPhone X S Max、iPhone XR</td>
<td style="text-align:center">1242 x 2688 像素（直向） 2688 x 1242 像素（橫向）</td>
</tr>
<tr>
<td style="text-align:center">iPhone 5.5 吋</td>
<td style="text-align:center">iPhone 8 Plus、iPhone 7 Plus、iPhone 6s Plus</td>
<td style="text-align:center">1242 x 2208 像素（直向） 2208 x 1242 像素（橫向）</td>
</tr>
<tr>
<td style="text-align:center">12.9 吋 iPad Pro（第三代）</td>
<td style="text-align:center">iPad Pro 2018、iPad Pro 2020</td>
<td style="text-align:center">2048 x 2732 像素（直向） 2732 x 2048 像素（橫向）</td>
</tr>
<tr>
<td style="text-align:center">12.9 吋 iPad Pro（第二代）</td>
<td style="text-align:center">iPad Pro 2017</td>
<td style="text-align:center">2048 x 2732 像素（直向） 2732 x 2048 像素（橫向）</td>
</tr>
</tbody>
</table>
<p>更多詳細資訊 <a href="https://help.apple.com/app-store-connect/#/devd274dd925" target="_blank" rel="noopener">可參考</a></p>
<p><img src="../images/ios-app-deploy/img5.png" alt=""></p>
<p>接著填寫</p>
<ul>
<li>行銷宣傳文字：作為 App 行銷宣傳標語，建議簡短的文字，也要符合App的性質</li>
<li>關鍵字：在商店搜尋時，透過關鍵字加強找到App，並使用逗點隔開</li>
<li>描述：詳細介紹App的功能與特色</li>
<li>支援URL：對應商店開發者網頁</li>
<li>行銷URL：待補充</li>
<li>版本：可參考 <a href="https://semver.org/lang/zh-TW/" target="_blank" rel="noopener">語意化版本</a>，不限定兩碼或三碼，不能與先前定義的相同</li>
<li>版權：宣告App版權的註解</li>
<li>年齡分級：根據填寫 <a href="#/年齡分級問卷">年齡分級問卷</a> 的結果（需點擊編輯填寫）</li>
</ul>
<p><img src="../images/ios-app-deploy/img6.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img7.png" alt=""></p>
<p>對應在商店的位置可參考</p>
<p><img src="../images/ios-app-deploy/img6-1.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img6-2.png" alt=""></p>
<h2 id="年齡分級問卷"><a href="#年齡分級問卷" class="headerlink" title="年齡分級問卷"></a>年齡分級問卷</h2><p>針對App的內容填寫是否有兒童不宜的</p>
<p><img src="../images/ios-app-deploy/img9.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img10.png" alt=""></p>
<h2 id="App審查資訊"><a href="#App審查資訊" class="headerlink" title="App審查資訊"></a>App審查資訊</h2><p>蘋果在審查時都是採用 <code>人工審查</code>，審查過程都須填寫完整的資料</p>
<ul>
<li>登入資訊：若你的App有設計登入功能，需提供測試帳號給審查人員</li>
<li>聯絡人資訊：當審查有問題時的聯絡人資訊，電話號碼需要加入國際冠碼</li>
<li>備註：資訊則提供其他資訊供審查人員了解你的App，像是之前就被問過這幾個問題，爾後我都在新的App加入這些回答<ul>
<li>Who is the target audience?</li>
<li>How do users obtain an account?</li>
<li>Is this app meant for internal distribution in your own company, in the company of one target client, or in multiple target clients’ companies?</li>
<li>In which countries will this app primarily be distributed?</li>
<li>If this app is meant for internal distribution, will the app be accessible by both internal and external partners? Or will it be exclusive to in-house employees?<ul>
<li>附件：可附上App操作影片，若你的App無法提供帳號測試，或是有些功能需要提供範例影片操作(ex.何時會使用到讀取wifi連線資訊的功能)，都需要附上影片</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="../images/ios-app-deploy/img8.png" alt=""></p>
<h3 id="建制版本"><a href="#建制版本" class="headerlink" title="建制版本"></a>建制版本</h3><p>接著選擇要送至審查的App版本，需先透過Xcode <code>Archive</code> 後上傳至App Store Connect，點擊藍色按鈕</p>
<p><img src="../images/ios-app-deploy/img11.png" alt=""></p>
<p>選擇對應想提交的版本，通常上傳完會需要一段時間處理，當完成處理都會email通知</p>
<p><img src="../images/ios-app-deploy/img11-1.png" alt=""></p>
<p>屆時才會出現在這邊</p>
<p><img src="../images/ios-app-deploy/img12.png" alt=""></p>
<p>接著選擇這次提交的出口合規資訊，點擊是否有使用加密功能，若點擊是的話，需要另外填寫出口法律資訊</p>
<p><img src="../images/ios-app-deploy/img13.png" alt=""></p>
<h3 id="廣告識別碼"><a href="#廣告識別碼" class="headerlink" title="廣告識別碼"></a>廣告識別碼</h3><p>最後是填寫是否有使用到 <code>廣告識別碼</code>，像是 Firebase Analytics 或是 Ad Mod 等第三方的廣告或分析工具，就需要聲明有使用到，若審查後發現錯誤，則需要重新上傳新的App版本</p>
<p><img src="../images/ios-app-deploy/img14.png" alt=""></p>
<p><strong>最後回到最上方點擊完成，並點擊審查，結著就會進入正在等待審查</strong></p>
<p><img src="../images/ios-app-deploy/img20.png" alt=""></p>
<p>通常審查時間已台灣都是晚上開始到半夜，對應到美國的白天時間，第一次審查都會比較久，大約2~3天，要耐心等待</p>
<p>但有時候會審查失敗，也會寄送 email 通知，可至連結查詢問題，並回覆審查人員</p>
<p>iOS Resolve Center : <a href="">https://appstoreconnect.apple.com/apps/<code>{apple id}</code>/appstore/platform/ios/resolutioncenter?m=</a></p>
<p>macOS Resolve Center : <a href="">https://appstoreconnect.apple.com/apps/<code>{apple id}</code>/appstore/platform/osx/resolutioncenter?m=</a></p>
<p><img src="../images/ios-app-deploy/img21.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img21-1.png" alt=""></p>
<p>若審查成功，則會通知 <code>Ready for Sale</code>，完成這次版本審查</p>
<p><img src="../images/ios-app-deploy/img22.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/dc2c1f00.html" data-id="ckrhj40630001gxb3dhr7cdg2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-window-10-安裝-docker-無法開啟-問題" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/b0c060c4.html" class="article-date">
  <time datetime="2018-08-27T08:21:28.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/b0c060c4.html">window 10 安裝 docker 無法開啟 問題</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>若開啟docker後，vmware無法執行須關閉docker使用的hyper-v兩者會相衝，只能同時開其一<br><a href="https://stackoverflow.com/questions/48066994/docker-no-matching-manifest-for-windows-amd64-in-the-manifest-list-entries" target="_blank" rel="noopener">https://stackoverflow.com/questions/48066994/docker-no-matching-manifest-for-windows-amd64-in-the-manifest-list-entries</a></p>
<p>關閉系統hyper-v<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype off</span><br></pre></td></tr></table></figure></p>
<p>重新打開<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure></p>
<p>上述兩指令 執行完都須重新開機</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/b0c060c4.html" data-id="ckrhj406a0004gxb35iri385y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GPU/" rel="tag">GPU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Flutter/" style="font-size: 20px;">Flutter</a> <a href="/tags/GPU/" style="font-size: 10px;">GPU</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/archives/8ddf18fb.html">【文章翻譯】 Getting started with Flutter GPU</a>
          </li>
        
          <li>
            <a href="/archives/430aae7c.html">flutter-3-24-news</a>
          </li>
        
          <li>
            <a href="/archives/4254a2e9.html">Android app 上架流程</a>
          </li>
        
          <li>
            <a href="/archives/dc2c1f00.html">iOS app 上架流程</a>
          </li>
        
          <li>
            <a href="/archives/b0c060c4.html">window 10 安裝 docker 無法開啟 問題</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Rainvisitor<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FZZFH3T2TV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FZZFH3T2TV');
</script>
  </div>
</body>
</html>