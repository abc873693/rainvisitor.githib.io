<!DOCTYPE html>
<html lang="zh-tw,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rainvisitor.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.rainvisitor.me/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-tw'
  };
</script>

  <title>RainVisitor Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RainVisitor Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">RainVisitor</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/6475a63d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/6475a63d.html" class="post-title-link" itemprop="url">【文章翻譯】Celebrating Flutter’s “Production Era”</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-17 20:13:46" itemprop="dateCreated datePublished" datetime="2024-12-17T20:13:46+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:06:10" itemprop="dateModified" datetime="2024-12-18T12:06:10+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="慶祝-Flutter-的「生產時代」"><a href="#慶祝-Flutter-的「生產時代」" class="headerlink" title="慶祝 Flutter 的「生產時代」"></a>慶祝 Flutter 的「生產時代」</h2><p>就在六年前，我們推出了 Flutter 1.0。今天，在 <strong>#FlutterInProduction</strong> 上，我們正在慶祝我們取得的成就——從社群中 <strong>數千名貢獻者</strong> 的巨大支持，到 Flutter 作為用於建構跨平台應用程式體驗的生產級應用程式框架的 <strong>廣泛採用</strong>。</p>
<p>如果您還沒有體驗過 Flutter，我們邀請您試用一下！正如我們今天分享的那樣，您將加入一個龐大的群體：Flutter 在全球擁有 <strong>超過 100 萬月活躍開發人員</strong>，並且 <strong>為近 30% 的所有新 iOS 應用程式提供支援</strong>。超過 9 萬名開發人員積極參與了 60 多個國家的 Flutter 聚會。如果您希望在設計或建構新的成功的 Flutter 應用程式方面獲得意見，我們有一個龐大且不斷增長的 <a href="https://flutter.dev/consultants">Flutter 顧問</a> 列表，隨時準備為您提供幫助。</p>
<blockquote>
<p>“Apptopia 追蹤 Apple AppStore 和 Google Play 商店中的數百萬個應用程式，並分析和檢測用於建立應用程式的開發人員 SDK。Flutter 是我們追蹤的最受歡迎的 SDK 之一：在 Apple AppStore 中，它的使用率從 2021 年所有追蹤的免費應用程式的約 10% 穩步增長到 2024 年所有追蹤的免費應用程式的近 30%！”</p>
</blockquote>
<blockquote>
<p>— <a href="https://apptopia.com/">Apptopia Inc.</a></p>
</blockquote>
<h3 id="十年的創新，邁向生產時代"><a href="#十年的創新，邁向生產時代" class="headerlink" title="十年的創新，邁向生產時代"></a>十年的創新，邁向生產時代</h3><p>這是一段不可思議的旅程，始於 2014 年（也就是我們現在所說的實驗時代），當時它是 Google 的一個代號為「Sky」的實驗。</p>
<p>在 Flutter 出現之前，妥協是不可避免的。許多開發人員已經開始懷疑，任何框架是否都能夠真正跨多個平台提供優質的體驗。</p>
<p>隨著 2018 年 Flutter 1.0 的推出，我們有了一個明確的使命來解決這個技術困境：我們的目標是為開發人員提供終極應用程式框架，以便在所有平台上製作美觀、高效能的使用者介面。此外，還要讓開發人員能夠在客戶關心的所有平台上以高品質的應用程式接觸所有客戶，但 <em>成本更低</em>，<em>時間更短</em>。</p>
<p>即使我們增加了對行動、網頁和桌面六大主要平台的支援，並且透過豐田將 Flutter 用於資訊娛樂系統等工作 <a href="https://flutter.dev/multi-platform/embedded">繼續拓展</a>，我們的重點在 Flutter 的增長期一直保持不變。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nlSy3ZCCbdUXFRH4Q1zstg.png" />
</figure>

<p>我們現在正處於「生產時代」，我們正在用 <strong>#FlutterInProduction</strong> 慶祝這一點！此活動重點介紹了在實際應用程式中使用 Flutter 的開發人員所取得的成就。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FAEXIrThTgb0%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DAEXIrThTgb0&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FAEXIrThTgb0%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/ce33468161bcfe4ed6cff82a7a7196cf/href">https://medium.com/media/ce33468161bcfe4ed6cff82a7a7196cf/href</a></iframe>

<h3 id="與社群合作建構"><a href="#與社群合作建構" class="headerlink" title="與社群合作建構"></a>與社群合作建構</h3><p>沒有我們超過 1,400 名貢獻者、超過 10,000 名套件發佈者（編寫了超過 50,000 個套件）以及充滿熱情的 Flutter 內容創作者和愛好者的驚人社群，這一切都不可能實現。</p>
<p>我們共同建構了一個 <a href="https://github.blog/news-insights/octoverse/octoverse-2024/#the-state-of-open-source">GitHub 貢獻排名前五的開源專案</a>！</p>
<h3 id="令人驚嘆的使用者體驗"><a href="#令人驚嘆的使用者體驗" class="headerlink" title="令人驚嘆的使用者體驗"></a>令人驚嘆的使用者體驗</h3><p>這一切都始於對實現令人驚嘆的使用者體驗的關注。擺脫了典型的平台限制，Flutter 支援廣泛的設計語言——SDK 附帶了對 Material Design 和我們受 Apple 啟發的 Cupertino Widget 的支援。生態系統還提供了廣泛的設計函式庫選擇，例如 Windows 啟發的 <a href="https://pub.dev/packages/fluent_ui">fluent_ui</a>、macOS 啟發的 <a href="https://pub.dev/packages/macos_ui">macos_ui</a> 和 Ubuntu 啟發的 <a href="https://pub.dev/packages/yaru">yaru</a> Widget。</p>
<h4 id="斯堪地那維亞航空公司設計獎"><a href="#斯堪地那維亞航空公司設計獎" class="headerlink" title="斯堪地那維亞航空公司設計獎"></a>斯堪地那維亞航空公司設計獎</h4><p>使用 Flutter，您擁有實現設計團隊預想的 <em>任何設計</em> 的靈活性和能力。斯堪地那維亞航空公司就是一個很好的例子，他們在使用 Flutter 建立了新的行動應用程式後，獲得了許多著名的設計獎項，例如紅點設計獎、威比人民之聲獎和 iF 設計金獎。SAS 的執行副總裁兼首席資訊長 Charlotte Svensson <a href="https://www.sasgroup.net/newsroom/press-releases/2023/sas-wins-webby-award-for-redesigned-app/">解釋說</a>：</p>
<blockquote>
<p>“我對這個獎項感到非常自豪，它不僅僅是一個行業獎項，而是一種全球認可。這證明了當我們超越自我，專注於改善客戶體驗，以及當我們與客戶互動和共同發展時，我們能夠做到什麼。SAS 一直處於航空業創新的前沿，這個獎項也驗證了我們致力於為客戶提供卓越的數位解決方案的承諾。”</p>
</blockquote>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*3685YaIo_7soz-qF" />
<figcaption>Scandinavian Airlines design awards</figcaption>
</figure>



<h3 id="出色的效能和可靠性"><a href="#出色的效能和可靠性" class="headerlink" title="出色的效能和可靠性"></a>出色的效能和可靠性</h3><p>效能和可靠性對於積極的使用者體驗和品牌認知至關重要。速度緩慢或容易崩潰的應用程式不僅會在短期內讓使用者感到沮喪，而且還會透過負面評論和口碑在長期內損害您的品牌聲譽。</p>
<p>Flutter 從一開始就優先考慮效能和可靠性。透過選擇 Dart 程式語言，我們確保透過提前編譯為原生機器碼或 WebAssembly 來實現快速啟動時間。Dart 豐富的空安全類型系統有助於在開發過程中捕獲錯誤，從而進一步提高可靠性。此外，Flutter 的自訂 Impeller 渲染引擎專為跨平台 UI 設計，可提供流暢的動畫，並讓我們完全控制從 UI 原始碼到 GPU 的整個渲染堆疊。</p>
<h4 id="環球影城的效能和可靠性"><a href="#環球影城的效能和可靠性" class="headerlink" title="環球影城的效能和可靠性"></a>環球影城的效能和可靠性</h4><p>例如，環球目的地與體驗最近報告說，透過採用 Flutter，他們不僅減小了應用程式的大小（這對於網路連線不可靠的使用者來說是一個很大的好處），而且還大幅減少了應用程式崩潰，幾乎為零，從而降低了他們的總擁有成本。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FJTk2Exr7FO4%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DJTk2Exr7FO4&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FJTk2Exr7FO4%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/721111dda3bc3595ada438b543af64a4/href">https://medium.com/media/721111dda3bc3595ada438b543af64a4/href</a></iframe>


<h4 id="LG-電子的效能"><a href="#LG-電子的效能" class="headerlink" title="LG 電子的效能"></a>LG 電子的效能</h4><p>由於擔心傳統原生應用程式的高開發成本，LG 電子傳統上一直依賴 Web 應用程式來開發其 webOS 驅動的智慧電視。但是，他們發現 Web 應用程式的啟動速度比原生應用程式慢，而且佔用更多記憶體。透過 Flutter，LG 電子擁有一個結合了快速開發速度和出色效能的解決方案。因此，他們計劃從 2025 年開始在全球範圍內將 Flutter 用於 webOS 電視中的關鍵應用程式。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fl-J3Of7pLPw%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dl-J3Of7pLPw&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2Fl-J3Of7pLPw%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/7bb10fd5172d78f3ceec7b18b842e913/href">https://medium.com/media/7bb10fd5172d78f3ceec7b18b842e913/href</a></iframe>


<h3 id="一流的開發人員體驗和蓬勃發展的生態系統"><a href="#一流的開發人員體驗和蓬勃發展的生態系統" class="headerlink" title="一流的開發人員體驗和蓬勃發展的生態系統"></a>一流的開發人員體驗和蓬勃發展的生態系統</h3><p>Flutter 的成功深深植根於其對開發人員體驗的關注。我們使用 Stateful Hot Reload 開創了即時開發人員工作流程，並在我們的增長期增加了 Flutter <a href="https://docs.flutter.dev/tools/devtools">DevTools</a>，以顯著加快診斷和除錯工作流程。</p>
<p>Flutter 的社群提供了一個由超過 10,000 名發佈者發佈的超過 50,000 個套件組成的蓬勃發展的開放生態系統，以及強大的第三方服務和技術。此外，如果您希望在設計或建構新的成功的 Flutter 應用程式方面獲得意見，我們有一個龐大的 <a href="https://flutter.dev/consultants">Flutter 顧問</a> 列表，隨時準備為您提供幫助。</p>
<h4 id="MGM-和開發人員生產力"><a href="#MGM-和開發人員生產力" class="headerlink" title="MGM 和開發人員生產力"></a>MGM 和開發人員生產力</h4><p>應用程式代理商 <a href="https://www.superformula.com/services/flutter/">Superformula</a> 自 2020 年 8 月以來一直在使用 Flutter 進行建構。他們發現 Flutter 易於學習且文件齊全，使他們能夠讓新團隊成員快速上手並有效地做出貢獻。</p>
<p>Superformula 還使用 Flutter 為 MGM Resorts 的 400 多家餐廳 <a href="https://www.superformula.com/work/revitalizing-the-digital-dining-experience-for-mgm-resorts-400-restaurants/">重振數位用餐體驗</a>。新的基於 Flutter 的 MGM Rewards 應用程式僅在 4 個月內就重建完成，程式碼總量減少了一半，交付速度提高了 4 倍。Superformula 生產力的一個核心推動因素是能夠在行動設備、基於平板電腦的資訊站和基於 Web 的工具之間共用程式碼。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FhuzVEL676lc%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DhuzVEL676lc&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FhuzVEL676lc%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/0ef3a20b164d0ff5ac1a4bd02c687a83/href">https://medium.com/media/0ef3a20b164d0ff5ac1a4bd02c687a83/href</a></iframe>


<h4 id="GEICO-和行動開發的民主化"><a href="#GEICO-和行動開發的民主化" class="headerlink" title="GEICO 和行動開發的民主化"></a>GEICO 和行動開發的民主化</h4><p>今年早些時候，美國汽車保險公司 GEICO <a href="https://www.geico.com/techblog/flutter-as-the-multi-channel-ux-framework/">發表了一篇部落格文章</a>，詳細介紹了他們使用 Flutter 的經驗以及 Flutter 如何提高他們的生產力。他們能夠改變其組織結構，以便 UX 團隊現在 <em>跨所有管道</em> 擁有整個體驗，減少了相同功能的不同實作之間的差異。他們還將 Flutter 的開發體驗描述為 <em>“成熟的，具有豐富的工具和對軟體開發生命週期 (SDLC) 的支援”</em>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/765/0*Y65O6741pXOhM35S" />
<figcaption>GEICO user interface elements shared across web, iOS, and Android.</figcaption>
</figure>


<h3 id="未來搶先看"><a href="#未來搶先看" class="headerlink" title="未來搶先看"></a>未來搶先看</h3><p>正如我們所說，Flutter 團隊在未來幾年將承擔的一些最重要的工作是維持向全球數億使用者提供基於 Flutter 的體驗的企業所要求的支援的品質和深度。</p>
<p>為了滿足這些不斷發展的需求，我們正專注於幾個關鍵領域：</p>
<ul>
<li><strong>更深層次的 iOS 保真度：</strong> 我們將繼續透過擴展 Cupertino Widget 來提供對 Apple 設計語言的更高保真度。我們正在擁抱現代 Apple 生態系統標準，例如 Swift Package Manager。</li>
<li><strong>無縫平台整合：</strong> 我們正在研究一種新的互操作方法——直接原生互操作——我們相信這將簡化對 C、Java、Kotlin、ObjectiveC 或 Swift 中可用的平台特定 API 的存取。</li>
<li><strong>開發人員生產力增強：</strong> 我們正在繼續發展我們的開發人員工具，透過探索潛在的新的 UI 設計功能，這些功能可能會提供實時 Widget 預覽器以及實時視覺屬性編輯。</li>
<li><strong>簡潔易讀的程式碼：</strong> 為了提高開發人員的生產力，我們正在探索如何使 Flutter 程式碼更快地編寫和更容易閱讀。這包括潛在的新的語言功能，例如「主要建構函式」和「列舉簡寫」，並瀏覽 Flutter 框架以識別可能提供更簡潔的編寫常用程式碼方式的新 API。</li>
</ul>
<p>正如 Rivers 如此準確地說的那樣，事情確實 <em>“變得更流暢、更專業了一些”</em>，我們的目標是讓事情在未來繼續保持這種感覺。</p>
<h3 id="準備好在生產中使用-FlutterInProduction-了嗎？"><a href="#準備好在生產中使用-FlutterInProduction-了嗎？" class="headerlink" title="準備好在生產中使用 #FlutterInProduction 了嗎？"></a>準備好在生產中使用 #FlutterInProduction 了嗎？</h3><p>如果您最近沒有嘗試過 Flutter，那麼現在就是最佳時機！</p>
<p>想先了解別人的經驗嗎？</p>
<ul>
<li><strong>參加</strong> 2024 年 12 月 19 日的 <a href="https://flutter.dev/events/flutter-in-production#schedule">Observable Flutter 小組討論</a></li>
<li><strong>加入 Flutter 社群：</strong> 找一個當地的聚會，加入論壇，或在 Slack 上聯繫：<a href="https://flutter.dev/community">https://flutter.dev/community</a></li>
</ul>
<p>我們致力於透過始終如一地關注品質和效能來贏得您的信任。我們繼續根據使用者的需求來推動我們的路線圖。在過去 6 年的增長期中，這也發生了變化，從實驗時代的個人和業餘愛好者，到如今利用 Flutter 處理業務關鍵功能的大型企業。</p>
<p>與往常一樣，我們迫不及待地想看看您接下來會建構什麼。下次再見！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f9418261d8e1" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/flutter-in-production-f9418261d8e1">慶祝 Flutter 的「生產時代」</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/daed2484.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/daed2484.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Flutter AI Toolkit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-17 19:02:26" itemprop="dateCreated datePublished" datetime="2024-12-17T19:02:26+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:06:10" itemprop="dateModified" datetime="2024-12-18T12:06:10+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="宣佈-Flutter-AI-工具包"><a href="#宣佈-Flutter-AI-工具包" class="headerlink" title="宣佈 Flutter AI 工具包"></a>宣佈 Flutter AI 工具包</h2><p>Flutter AI 開發者們，歡呼吧！將 AI 支援的聊天體驗新增到您的應用程式中變得更加容易。隆重推出 <a href="https://pub.dev/packages/flutter_ai_toolkit">Flutter AI 工具包</a>，這是一組隨時可用的 AI 聊天 Widget，旨在無縫整合到您的 Flutter 專案中。無需再從頭開始構建複雜的聊天介面 - Flutter AI 工具包提供了快速輕鬆地將精密的 AI 聊天視窗新增到您的應用程式所需的一切。準備好提升跨多個平台的客戶參與度和滿意度了嗎？您已經準備好了！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/418/0*8PFN57i3DaWcEBvk" />
<figcaption><a href="https://idx.google.com/new?template=https%3A%2F%2Fgithub.com%2Fflutter%2Fai">在 Project IDX 中試用 Flutter AI 工具包！</a></figcaption>
</figure>

<h3 id="多輪聊天"><a href="#多輪聊天" class="headerlink" title="多輪聊天"></a>多輪聊天</h3><p>透過多輪聊天，您可以在同一個會話中的多個互動之間維持上下文。</p>
<p>想像一下您正在與朋友交談。他們問您是否有寵物，您告訴他們您有一個名叫 Rocky 的寵物石頭。過了一會兒，在與您聊了其他事情之後，您的朋友問：「您養 Rocky 多久了？」朋友記得您之前談話中提到的寵物石頭，即使您沒有再次提及它。</p>
<p>這基本上就是多輪聊天的作用！它可以幫助大型語言模型 (LLM) 記住正在談論的內容。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/904/1*u_atZ9LOO85MJMWdLFvxow.png" />
<figcaption>Flutter AI 工具包中的多輪聊天</figcaption>
</figure>

<h3 id="富文本顯示"><a href="#富文本顯示" class="headerlink" title="富文本顯示"></a>富文本顯示</h3><p>LLM 生成的回應支援富文本格式。LLM 不僅可以生成純文字，還可以將文字格式化，使其更有趣。例如，回應可以包含粗體文字、圖片、項目符號等等。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/920/1*m5BA-Jaa7l9uPr9NHoWjKA.png" />
<figcaption>Flutter AI 工具包中的富文本格式支援</figcaption>
</figure>

<h3 id="語音輸入"><a href="#語音輸入" class="headerlink" title="語音輸入"></a>語音輸入</h3><p>語音輸入可用於將訊息轉換為文字。此免持選項非常適合那些不喜歡打字或想要更快地撰寫訊息的人。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/768/0*KgA9lHvHX_FF3r50" />
<figcaption>Flutter AI 工具包中的語音輸入支援</figcaption>
</figure>

<h3 id="多媒體附件"><a href="#多媒體附件" class="headerlink" title="多媒體附件"></a>多媒體附件</h3><p>圖片、影片、音訊、PDF 和其他檔案可以單獨或一起新增到對話中。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/922/1*HxICVJ2oeINpsTb4DDdnqg.png" />
<figcaption>Flutter AI 工具包中的多媒體附件支援</figcaption>
</figure>

<h3 id="自訂回應-Widget"><a href="#自訂回應-Widget" class="headerlink" title="自訂回應 Widget"></a>自訂回應 Widget</h3><p>為回應設計專門的 UI 元件。例如，如果有人要求食譜，您可以顯示一個互動式食譜卡，並提供將食譜直接儲存到資料庫的選項。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/924/1*j-2lxsZJ-WEREg7X4O7Cog.png" />
<figcaption>Flutter AI 工具包中的自訂 AI 回應 Widget 支援</figcaption>
</figure>

<h3 id="自訂樣式"><a href="#自訂樣式" class="headerlink" title="自訂樣式"></a>自訂樣式</h3><p>設定聊天外觀以符合您的應用程式。變更聊天氣泡的顏色、背景、UI 字體，甚至新增 UI 圖片或動畫以反映您的品牌識別。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/722/1*ctMwVabsBVXa-ppooNwGsw.png" />
<figcaption>Flutter AI 工具包中的自訂樣式支援</figcaption>
</figure>

<h3 id="跨平台支援"><a href="#跨平台支援" class="headerlink" title="跨平台支援"></a>跨平台支援</h3><p>Flutter 支援許多平台，Flutter AI 工具包也支援。想要在 iOS、Android、Web 和 macOS 上部署使用 Flutter 製作的 AI 聊天應用程式嗎？沒問題！</p>
<h3 id="可插拔的-LLM"><a href="#可插拔的-LLM" class="headerlink" title="可插拔的 LLM"></a>可插拔的 LLM</h3><p>無論您是想使用 Google 的 Gemini 或 Vertex AI，還是其他 LLM，Flutter AI 工具包都可以輕鬆地將 AI 新增到您的應用程式中。GeminiProvider 和 VertexProvider 可用於開箱即用的整合，分別使用 <a href="https://pub.dev/packages/google_generative_ai">Google AI Dart SDK</a> 和 <a href="https://pub.dev/packages/firebase_vertexai">Firebase 中的 Vertex AI SDK</a>。我們強烈建議您將 Firebase 中的 Vertex AI SDK 用於原型設計以外的生產使用案例。此外，您可以利用 Flutter AI 工具包的 LLM 提供者介面，使用您自己的自訂程式碼插入您選擇的 LLM。</p>
<h3 id="具有多個對話的獨立聊天應用程式"><a href="#具有多個對話的獨立聊天應用程式" class="headerlink" title="具有多個對話的獨立聊天應用程式"></a>具有多個對話的獨立聊天應用程式</h3><p>構建一個功能齊全的聊天應用程式，可以儲存和管理多個對話。為了幫助您入門，Flutter AI 工具包附帶了一個範例專案，該專案利用了 <a href="https://firebase.google.com/docs/firestore">Cloud Firestore</a> 資料庫和 <a href="https://firebase.google.com/docs/vertex-ai">Firebase 中的 Vertex AI</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*gAt7fwWLXUWX_nHPwzYzxg.png" />
<figcaption>Flutter AI 聊天應用程式</figcaption>
</figure>

<h3 id="立即試用-Flutter-AI-工具包"><a href="#立即試用-Flutter-AI-工具包" class="headerlink" title="立即試用 Flutter AI 工具包"></a>立即試用 Flutter AI 工具包</h3><p>要親自試用 Flutter AI 工具包，請查看 <a href="https://pub.dev/packages/flutter_ai_toolkit">pub.dev 上的 Flutter AI 工具包</a> 以及以下資源：</p>
<ul>
<li><a href="https://docs.flutter.dev/ai-toolkit/user-experience">Flutter AI 工具包文件</a></li>
<li><a href="https://flutter-ai-toolkit-examp-60bad.web.app/">Flutter AI 工具包互動式示範</a> (<a href="https://github.com/flutter/ai/blob/main/example/lib/demo/demo.dart">GitHub</a>)</li>
<li><a href="https://github.com/flutter/ai/tree/main/example/lib/recipes">食譜範例專案 (GitHub)</a></li>
<li><a href="https://github.com/csells/flutter_ai_chat/blob/main/README.md">Flutter AI 聊天範例應用程式 (GitHub)</a></li>
<li><a href="https://idx.google.com/new?template=https://github.com/flutter/ai">在瀏覽器中開始使用 (Project IDX)</a></li>
</ul>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e36b16a840d2" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/announcing-flutter-ai-toolkit-e36b16a840d2">宣佈 Flutter AI 工具包</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/fe672d55.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/fe672d55.html" class="post-title-link" itemprop="url">【文章翻譯】Video & web ad support in Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-17 19:02:25" itemprop="dateCreated datePublished" datetime="2024-12-17T19:02:25+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:06:10" itemprop="dateModified" datetime="2024-12-18T12:06:10+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="Flutter-的影片和網頁廣告支援"><a href="#Flutter-的影片和網頁廣告支援" class="headerlink" title="Flutter 的影片和網頁廣告支援"></a>Flutter 的影片和網頁廣告支援</h2><p>共同作者：Zoey Fan、Harold Benson、Alak Jhunjhunwala</p>
<p>將您的 Flutter 應用程式變現變得更容易，也更有價值。今天，我們很高興地宣布一套新的工具和功能更新，為開發人員提供一系列選項來將您的應用程式變現並發展您的業務。</p>
<h3 id="Flutter-開發人員現在可以使用影片廣告"><a href="#Flutter-開發人員現在可以使用影片廣告" class="headerlink" title="Flutter 開發人員現在可以使用影片廣告"></a>Flutter 開發人員現在可以使用影片廣告</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/836/0*xsAbaMexfbR30wgK" />
<figcaption>顯示範例影片廣告的動畫 gif</figcaption>
</figure>

<p>讓我們先將您的影片內容轉變為創造收入的強大引擎！</p>
<p>我們要宣布推出 <a href="https://youtu.be/U8x5n6RwZOo">Flutter 的互動式媒體廣告 (IMA) Plugin</a>。您現在可以將高品質的影片廣告無縫整合到 iOS 和 Android 上的 Flutter 應用程式中。這意味著您現在可以在影片內容播放之前（片頭廣告）、期間（中間廣告）或之後（片尾廣告）輕鬆地透過影片廣告將影片內容變現。就像 Google 行動廣告 Plugin 簡化了 Flutter 應用程式中行動廣告的顯示一樣，<a href="https://pub.dev/packages/interactive_media_ads">IMA Plugin</a> 讓您輕鬆地整合影片廣告。我們已經完成了繁重的工作，因此您可以專注於最重要的事情：創造令人驚嘆的應用程式體驗。</p>
<p><strong>輕鬆整合，最大限度地發揮影響力</strong></p>
<ul>
<li><strong>客戶端廣告插入：</strong> 廣告在單獨的影片播放器中播放，確保為您的使用者提供流暢的觀看體驗，同時讓您擁有更多控制權。</li>
<li><strong>無縫廣告處理：</strong> Plugin 請求影片廣告並處理播放。它還確保渲染跳過按鈕等 UI 元素，並觸發廣告測量訊號。</li>
<li><strong>符合產業標準：</strong> IMA 利用產業標準的影片廣告投放範本 (VAST) 規範，確保與廣告伺服器的廣泛相容性。</li>
<li><strong>存取優質廣告需求：</strong> IMA 確保您可以透過 Google 的高品質和優質影片廣告需求來將您的影片內容變現。</li>
</ul>
<p><strong>立即開始！</strong></p>
<p>您準備好使用影片廣告為您的 Flutter 應用程式增壓了嗎？前往 <a href="https://pub.dev/packages/interactive_media_ads">pub.dev&#x2F;packages&#x2F;interactive_media_ads</a> 以探索 IMA Plugin 並存取詳細的文件。您將找到開始使用所需的一切，包括程式碼範例和逐步指南。我們很期待看到您如何使用 IMA Plugin 將您的 Flutter 影片內容變現，並創造更具吸引力的應用程式體驗！</p>
<h3 id="Beta-版：使用-AdSense-廣告將您的-Flutter-網頁遊戲變現"><a href="#Beta-版：使用-AdSense-廣告將您的-Flutter-網頁遊戲變現" class="headerlink" title="Beta 版：使用 AdSense 廣告將您的 Flutter 網頁遊戲變現"></a>Beta 版：使用 AdSense 廣告將您的 Flutter 網頁遊戲變現</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*wz_WITqUIrY1dR7w" />
<figcaption>顯示遊戲中範例 AdSense 廣告的動畫 gif</figcaption>
</figure>

<p>許多 Flutter 開發人員希望像他們的行動應用程式一樣，將他們的 Flutter 網頁專案變現。我們一直在幕後忙碌地工作，並且有一些令人興奮的進展可以分享！</p>
<p>今天，我們很興奮地宣布 <strong>H5 遊戲</strong> Plugin 的 AdSense <strong>beta 計劃</strong>！透過此 Plugin，您可以輕鬆地將 AdSense <a href="https://adsense.google.com/start/h5-games-ads/">H5 遊戲廣告</a> 加入到您在 Flutter 中建立的網頁遊戲 (H5) 中，開闢新的收入來源。</p>
<p><strong>beta 計劃提供的內容：</strong></p>
<ul>
<li>成為首批整合 AdSense 的人之一：搶先體驗 Flutter AdSense Plugin，並開始試驗不同的廣告格式。</li>
<li>塑造 Plugin 的未來：提供寶貴的回饋，並幫助我們根據 Flutter 網頁開發人員的特定需求定制 Plugin。</li>
</ul>
<p>此計劃是邁向 Flutter 網頁完整廣告變現解決方案的重要一步。目前，此 Beta 計劃的重點是為 <strong>Flutter 網頁遊戲</strong> 啟用 AdSense。我們正在與 AdSense 團隊合作，為未來的 Flutter 網頁應用程式開發解決方案。</p>
<p>如果您是 Flutter 網頁 <strong>遊戲</strong> 開發人員，並且有興趣參與，請填寫 <a href="https://adsense.google.com/start/h5-beta/?src=flutter">H5 AdSense 申請表</a>。一旦您獲准加入 beta 計劃，請使用 <a href="https://pub.dev/packages/google_adsense">pub.dev&#x2F;packages&#x2F;google_adsense</a> 開始使用！</p>
<h3 id="透過深度連結提高轉換率和更好的使用者體驗"><a href="#透過深度連結提高轉換率和更好的使用者體驗" class="headerlink" title="透過深度連結提高轉換率和更好的使用者體驗"></a>透過深度連結提高轉換率和更好的使用者體驗</h3><p>加入廣告是成為成功企業的方法之一。有時您的企業需要在應用程式中銷售商品和服務。您可能已經花費了大量的時間和資源來建立簡訊&#x2F;電子郵件行銷和廣告活動，並希望這些活動能夠帶來有效的轉換。但是，如果您能透過將客戶從行銷活動直接引導到您的應用程式以及他們感興趣的特定項目，從而將您的活動提升到新的水平呢？</p>
<p>透過 Flutter 中的 <a href="https://docs.flutter.dev/ui/navigation/deep-linking">深度連結</a>，您可以做到這一點。當有人點擊您活動中的連結時，他們將被直接帶到您的應用程式以及您正在推廣的產品或服務。與連結到您的網站相比，這種無縫的轉換將 <strong>轉換的機率提高了 2.3 倍</strong>。</p>
<p>以下是深度連結對廣告商來說改變遊戲規則的原因：</p>
<ul>
<li><strong>提高轉換率：</strong> 透過將客戶直接帶到您的應用程式，您可以消除干擾，並讓他們更容易完成購買。</li>
<li><strong>個人化體驗：</strong> 深度連結允許您為每個客戶創造個人化體驗。當他們點擊連結時，他們將被帶到他們感興趣的特定產品或服務。</li>
<li><strong>追蹤活動績效：</strong> 透過深度連結，您可以追蹤活動的有效性，並查看有多少人點擊連結到您的應用程式。這些資料可以幫助您優化活動以獲得更好的結果。</li>
</ul>
<p>雖然深度連結提供了所有這些優點，但設定起來可能相當麻煩。因此，我們也讓深度連結比以往任何時候都更加穩健和可靠。透過 Flutter DevTools 中 iOS 和 Android 的完整 <a href="https://docs.flutter.dev/tools/devtools/deep-links">網頁和應用程式檢查驗證支援</a>，您可以確保您的深度連結已正確且安全地設定。您的使用者將享受網頁和應用程式內容之間的無縫轉換，增加參與度和滿意度！首先，前往 Flutter DevTools，並打開深度連結驗證標籤。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*W-CAR3hmZRMA03b20508iw.gif" />
<figcaption>顯示 Flutter DevTools 中深度連結驗證的動畫 gif</figcaption>
</figure>

<p>我們致力於為您（Flutter 開發人員）提供您成功所需的工具和資源。這些新功能證明了我們的承諾。所以，繼續，將您的 Flutter 應用程式提升到新的高度，並釋放其全部潛力！</p>
<p><strong>探索更多：</strong></p>
<ul>
<li>深入了解 Flutter 變現的世界：<a href="https://flutter.dev/monetization">flutter.dev&#x2F;monetization</a></li>
<li>掌握深度連結的藝術：<a href="https://docs.flutter.dev/development/ui/navigation/deep-linking">Flutter 文件</a></li>
<li>隨時掌握最新的 Flutter 新聞：<a href="https://medium.com/flutter">Flutter 部落格</a></li>
</ul>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f50e5a3480a8" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/video-web-ad-support-in-flutter-f50e5a3480a8">Flutter 中的影片和網頁廣告支援</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/6b11f1c7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/6b11f1c7.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Dart 3.6</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-11 20:20:13" itemprop="dateCreated datePublished" datetime="2024-12-11T20:20:13+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:28:53" itemprop="dateModified" datetime="2024-12-18T12:28:53+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 2.0 自動翻譯產生】</p>
<h2 id="宣佈-Dart-3-6"><a href="#宣佈-Dart-3-6" class="headerlink" title="宣佈 Dart 3.6"></a>宣佈 Dart 3.6</h2><p>歡迎來到 Dart 3.6！今天，我們發佈了今年的最後一個版本，與 <a href="https://medium.com/flutter/whats-new-in-flutter-3-27-28341129570c">Flutter 3.27</a> 一起推出。我們很高興在語言中分享一個新功能：<em>數字分隔符</em>。我們在 pub 生態系統中也有一些新功能：<em>pub 下載次數</em> 以及備受期待的 <em>pub 工作區</em>！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*pojZOcfCeFztkEzK" />
<figcaption>Dart 3.6</figcaption>
</figure>


<h3 id="Pub-工作區"><a href="#Pub-工作區" class="headerlink" title="Pub 工作區"></a>Pub 工作區</h3><p>Pub 現在支援在 monorepo 或工作區中的套件之間共用解析。工作區是一組緊密相關的套件，它們一起開發、解析和發佈。</p>
<p>pub 工作區功能可確保 monorepo 中的套件共用一組一致的相依性。這會強制您 <em>在出現時</em> 解決分組套件之間的相依性衝突，而不是在開始使用套件時才面對混亂。</p>
<p>Flutter 分析器會在單個分析上下文中處理 pub 工作區中的所有套件，這與以前每個套件單獨使用一個上下文的行為不同。對於大型儲存庫，這可以顯著減少 Dart 語言伺服器消耗的記憶體量，從而提高 IDE 效能。</p>
<p>要定義 pub 工作區，請在根 pubspec.yaml 檔案中加入 <code>workspace</code> 欄位，並列出相關套件，如下例所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">_</span></span><br><span class="line"><span class="attr">publish_to:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">sdk:</span> <span class="string">^3.6.0</span></span><br><span class="line"><span class="attr">workspace:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">packages/helper</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">packages/client_package</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">packages/server_package</span></span><br></pre></td></tr></table></figure>


<p>然後在儲存庫中的任何位置執行 <code>pub get</code> 以完成映射和剩餘的檔案管理。</p>
<p>要使用 pub 工作區，所有工作區套件（但非相依性）必須具有 ^3.6.0 或更高版本的 SDK 版本約束。</p>
<p>有關更多資訊，包括完整的詳細說明和邊緣案例涵蓋範圍，請查看 <a href="https://dart.dev/go/pub-workspaces">Pub 工作區（monorepo 支援）</a> 頁面。</p>
<h3 id="Pub-下載次數"><a href="#Pub-下載次數" class="headerlink" title="Pub 下載次數"></a>Pub 下載次數</h3><p>我們聽取了您對 pub.dev 上更精確指標的 <a href="https://github.com/dart-lang/pub-dev/issues/2714">請求</a>，現在下載次數就在這裡！下載次數取代了單個套件頁面上之前的「人氣分數」。除了新的指標之外，您還將在每個頁面上找到一個迷你圖表，顯示每週的下載次數。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*KJoC5ioNl7lXms0P" />
<figcaption>螢幕截圖突出了 pub.dev 上新的下載次數和迷你圖表</figcaption>
</figure>


<p>您可以在 <a href="https://pub.dev/help/scoring">pub.dev 評分文件</a> 中了解更多關於下載次數的資訊。</p>
<h3 id="數字分隔符"><a href="#數字分隔符" class="headerlink" title="數字分隔符"></a>數字分隔符</h3><p>Dart 語言現在允許使用底線 (_) 作為數字分隔符，這有助於提高長數字字面量的可讀性。多個連續的底線表示更高級別的分組。以下是一些 Dart 中有效使用數字分隔符的範例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>__000_000__000_000__000_000</span><br><span class="line"><span class="number">0x4000</span>_0000_0000_0000</span><br><span class="line"><span class="number">0.000</span>_000_000_01</span><br><span class="line"><span class="number">0x00</span>_14_22_01_23_45</span><br></pre></td></tr></table></figure>


<p>請記住，數字分隔符僅在數字 <em>之間</em> 有效，因此不允許使用 100_、0._000_1 或 1.2e_3 之類的字面量。始終如一地使用數字分隔符也很重要，因此請確保數字組在每個級別的組之間大小相同。</p>
<p>要使用數字分隔符，您需要將套件中的最低 SDK 提升至 3.6.0 或更高版本。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>今天就到這裡。有關 Dart 團隊在本季度所做工作的完整故事，請查看 <a href="https://github.com/dart-lang/sdk/blob/main/CHANGELOG.md#360">3.6.0 的變更日誌</a>。別忘了查看 <a href="https://medium.com/flutter/whats-new-in-flutter-3-27-28341129570c">Flutter 3.27 版本部落格</a> 文章以獲取更多更新。明年見！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=778dd7a80983" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/announcing-dart-3-6-778dd7a80983">宣佈 Dart 3.6</a> 最初發佈在 Medium 的 <a href="https://medium.com/dartlang">Dart</a> 上，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/ee34d180.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/ee34d180.html" class="post-title-link" itemprop="url">【文章翻譯】What’s new in Flutter 3.27</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-11 20:19:53" itemprop="dateCreated datePublished" datetime="2024-12-11T20:19:53+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:05:03" itemprop="dateModified" datetime="2024-12-18T12:05:03+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="使用-Impeller、Cupertino-更新等提升應用程式開發"><a href="#使用-Impeller、Cupertino-更新等提升應用程式開發" class="headerlink" title="使用 Impeller、Cupertino 更新等提升應用程式開發"></a>使用 Impeller、Cupertino 更新等提升應用程式開發</h2><h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>讓我們深入了解 Flutter 3.27！此版本充滿了增強功能和特性，著重於改進您的開發體驗並提升應用程式的效能。</p>
<p>我們在架構、引擎和生態系統方面都進行了更新，包括 Impeller 的進展和 Cupertino widget 的改進。此外，我們還在 DevTools 中引入了令人興奮的新功能，讓管理 Flutter 專案比以往任何時候都更容易。Flutter 3.27 包含來自 187 位貢獻者（包括 <strong>49 位首次貢獻者</strong>！）的超過 1,400 個提交，證明了 Flutter 社群令人難以置信的活力和合作。讓我們一起探索新功能吧！</p>
<h3 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h3><h4 id="Cupertino-更新"><a href="#Cupertino-更新" class="headerlink" title="Cupertino 更新"></a>Cupertino 更新</h4><p>此版本包含對 <code>CupertinoCheckbox</code> 和 <code>CupertinoRadio</code> 的高保真度更新，其中包括對大小、顏色、筆劃寬度和按下時的行為的更新。<code>CupertinoRadio</code>、<code>CupertinoCheckbox</code> 和 <code>CupertinoSwitch</code> 也進行了大量的可自訂性更新，加入了滑鼠游標、語義標籤、縮圖和填充顏色等屬性。某些屬性（例如 <code>CupertinoCheckbox</code> 的非活動顏色）已被棄用，而其他屬性（例如 <code>CupertinoSwitch</code> 的軌跡顏色）則已重新命名。這些變更使這些 widget 與其 Material 對應項的功能齊平。</p>
<p><code>CupertinoSlidingSegmentedControl</code> 的拇指半徑、分隔線高度、填充、陰影和拇指縮放對齊方式也進行了一些保真度更新。它現在還支援停用個別區段，以及根據區段內容進行比例佈局。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/454/0*Nr0WuNhNxjlI1Pqg" />
</figure>

<p>感謝社群成員 <a href="https://github.com/veloce">@veloce</a> 的出色貢獻，<code>CupertinoNavigationBar</code> 和 <code>CupertinoSliverNavigationBar</code> 的背景現在是透明的，直到內容在其下方捲動。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*dngArPlUvp4pVA-R" />
</figure>

<p>這使得 sliver 導航欄在其展開狀態下可以擁有與其背景相同的顏色，但在其摺疊狀態下可以擁有不同的可自訂顏色（並且能夠在捲動時在這兩種顏色之間進行插值）。</p>
<p>感謝社群成員 <a href="http://github.com/kerberjg">@kerberjg</a> 的出色貢獻，您現在可以使用 <code>CupertinoButton</code> 中新的 <code>sizeStyle</code> 屬性，透過新的 <code>CupertinoButtonSize</code> 列舉來應用 iOS 15+ 按鈕樣式。使用新的 <code>CupertinoButton.tinted</code> 建構函式來製作具有半透明背景的按鈕。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*vdSn5c7uavWstNO5" />
</figure>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ZPrThBB6ZN8DEtUq" />
</figure>

<p><code>CupertinoButton</code> 還有一個新的 <code>onLongPress</code> 處理程式，並且允許透過鍵盤快捷鍵執行操作。</p>
<p><code>CupertinoPicker</code> 和 <code>CupertinoDatePicker</code> 現在將捲動到點擊的項目。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*XUtBHK9h0zbWrKUF" />
</figure>

<p><code>CupertinoAlertDialog</code> 現在支援點擊滑動手勢。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*JYBUuzXHcYTCD4i5" />
</figure>

<p><code>CupertinoActionSheet</code> 進行了一些高保真度更新，包括在所有系統文字大小設定中調整填充和字體大小，以及在滑過按鈕時支援觸覺回饋。</p>
<p>其他變更包括：<code>CupertinoContextMenu</code> 現在支援捲動（如果其動作超出螢幕範圍），<code>CupertinoDatePicker</code> 不再裁剪其欄中的長內容，以及 <code>CupertinoMagnifier</code> 透過提供放大比例來支援縮放效果。</p>
<h4 id="標準化-Material-主題"><a href="#標準化-Material-主題" class="headerlink" title="標準化 Material 主題"></a>標準化 Material 主題</h4><p>在此版本中，<code>CardTheme</code>、<code>DialogTheme</code> 和 <code>TabBarTheme</code> 已經過重構，以使其符合 Flutter 的元件主題規範。加入了 <code>CardThemeData</code>、<code>DialogThemeData</code> 和 <code>TabBarThemeData</code> 來定義元件視覺屬性預設值的覆蓋。未來的版本將繼續標準化像這樣的元件主題，以便在 Material 函式庫中提供更一致的主題體驗。</p>
<h4 id="CarouselView-的更多功能"><a href="#CarouselView-的更多功能" class="headerlink" title="CarouselView 的更多功能"></a>CarouselView 的更多功能</h4><p>此版本引入了 <code>CarouselView.weighted</code>，可以在 Carousel 中啟用更動態的佈局。透過調整建構函式中的 <code>flexWeights</code> 參數，您可以實現各種項目佈局。例如，<code>[3, 2, 1]</code> 建立 <a href="https://m3.material.io/components/carousel/specs#3c9dc903-2f88-4b27-84e3-213c50674632">多瀏覽</a> 佈局，<code>[7, 1]</code> 建立 <a href="https://m3.material.io/components/carousel/specs#66eb8746-70f0-4bad-b940-8e1028268d65">英雄</a> 佈局，而 <code>[1, 7, 1]</code> 建立 <a href="https://m3.material.io/components/carousel/specs#92c779ce-de8b-4dee-8201-95d3e429204f">居中英雄</a> 佈局。這些值表示每個項目在 Carousel 視圖中佔據的相對權重，並且可以自訂以滿足使用者的特定需求。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*EUjz8K6BQZX2uumi" />
</figure>

<h4 id="Material-中的更多內容"><a href="#Material-中的更多內容" class="headerlink" title="Material 中的更多內容"></a>Material 中的更多內容</h4><p>此版本包含許多小的功能增強和錯誤修復。一些增強功能範例：</p>
<ul>
<li><code>SegmentedButton</code> 現在有一個 <code>direction</code> 屬性，因此項目可以垂直對齊。</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/186/0*ECVkEydB6YuBSGs_" />
</figure>

<ul>
<li><code>ButtonStyleButton</code> 類別（<code>ElevatedButton</code>、<code>FilledButton</code>、<code>OutlinedButton</code>、<code>TextButton</code>、<code>MenuItemButton</code> 和 <code>SubmenuButton</code>）的 <code>styleFrom</code> 方法中加入了更多與圖示相關的屬性，以允許更多自訂。</li>
</ul>
<p>一些錯誤修復範例：</p>
<ul>
<li><code>ButtonStyleButton</code> 類別的圖示大小和顏色預設值與 Material 3 規範一致。</li>
<li><code>AppBar</code> 的捲動下行為現在可以在導航抽屜打開時正確保留，與原生 Android 體驗相符。</li>
<li><code>MenuAnchor</code> 透過焦點修復得到了進一步改進，並且解決了幾個 <code>DropdownMenu</code> 問題，包括巢狀捲動元件中的捲動問題和過濾機制行為。</li>
</ul>
<h4 id="混合路由轉場"><a href="#混合路由轉場" class="headerlink" title="混合路由轉場"></a>混合路由轉場</h4><p>當先前的路由和新的路由具有不同的頁面轉場時，<a href="https://api.flutter.dev/flutter/widgets/ModalRoute-class.html">ModalRoutes</a> 現在更加靈活。當新的路由進入螢幕時，有時它們需要先前的現有路由播放特定轉場以與新路由的進入轉場同步。現在，<code>ModalRoutes</code> 可以互相提供退出轉場建構函式，以便進入和退出轉場始終同步。這允許頁面使用 Flutter 的 <code>Navigator</code> 和 <code>Router</code> 在一個頁面上具有多個路由轉場選項。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/231/0*vyFYrAWVig8f8WGl" />
</figure>


<h4 id="文字選取改進"><a href="#文字選取改進" class="headerlink" title="文字選取改進"></a>文字選取改進</h4><p>Flutter 的 <code>SelectionArea</code> 現在支援在 Linux、macOS 和 Windows 上使用 Shift + 點擊手勢將選取範圍的末尾移動到點擊位置。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/824/0*QwWCiz-DAHklZZAi" />
</figure>


<p>您現在還可以透過 <a href="https://api.flutter.dev/flutter/widgets/SelectableRegionState-class.html">SelectableRegionState</a> 上的 <a href="https://main-api.flutter.dev/flutter/widgets/SelectableRegionState/clearSelection.html"><code>clearSelection</code></a> 方法清除 <code>SelectionArea</code> 和 <code>SelectableRegion</code> 下的選取範圍。現在還可以透過提供 <code>GlobalKey</code> 並存取其 <a href="https://main-api.flutter.dev/flutter/material/SelectionAreaState/selectableRegion.html">SelectionAreaState.selectableRegion</a> 來透過 <code>SelectionArea</code> 存取 <code>SelectableRegionState</code>。</p>
<p>我們還解決了 <code>RenderParagraph</code> 的一些問題，因此在調整 <a href="https://github.com/flutter/flutter/pull/155719">視窗大小</a> 後，以及在點擊或 <a href="https://github.com/flutter/flutter/pull/155892">點擊</a>實際文字 [之外] 時，在 <code>SelectionArea</code> 或 <code>SelectableRegion</code> 下選取文字仍然可以按預期工作。</p>
<h4 id="Row-和-Column-間距"><a href="#Row-和-Column-間距" class="headerlink" title="Row 和 Column 間距"></a>Row 和 Column 間距</h4><p>此版本還提供了一個使用 <code>Row</code> 和 <code>Column</code> 的新便利方法：<code>spacing</code>！此雙精度參數將應用固定數量的像素來偏移 <code>Row</code> 和 <code>Column</code> 的子項之間的距離，從而減少先前執行此操作所需的程式碼量。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*85CZePbMbJ99B5-hPvwpKQ.png" />
</figure>

<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><h4 id="Android-上的-Impeller"><a href="#Android-上的-Impeller" class="headerlink" title="Android 上的 Impeller"></a>Android 上的 Impeller</h4><p>我們很高興地宣布，Impeller 現在是現代 Android 設備上的預設渲染引擎。雖然自 Flutter 3.16 穩定版本於 2023 年 11 月發佈以來，這些設備上的 Impeller 一直處於預覽階段，但從那時起，我們根據使用者回饋對效能和保真度都進行了重大改進。</p>
<p>在較舊的 Android 設備和不支援 Vulkan 的設備上，仍然會像以前一樣使用 Skia 渲染引擎。雖然我們相信 Impeller 的效能和保真度都非常高，但使用者可以選擇退出並返回到傳統的 Skia 渲染器，方法是將 <code>--no-enable-impeller</code> 傳遞給 <code>flutter</code> 命令列工具，或者將以下內容放入您的 <code>AndroidManifest.xml</code> 檔案中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:name</span>=<span class="string">&quot;io.flutter.embedding.android.EnableImpeller&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>接下來，我們將繼續改進 Impeller 在 Android 上的效能和保真度。此外，我們打算讓 Impeller 的 OpenGL 後端做好生產準備，以移除 Skia 後備。</p>
<p>如同在預覽期間一樣，我們請求 Flutter 開發人員升級到最新的穩定版本，並提交在啟用 Impeller 時發現的任何缺點的錯誤。回饋對於確保 Impeller 在 Android 上取得成功仍然至關重要。Android 硬體生態系統比 iOS 生態系統更加多元。因此，關於 Impeller 最有用的回饋應包括有關發生問題的特定設備和 Android 版本的詳細資訊。</p>
<h3 id="iOS-設備的改進"><a href="#iOS-設備的改進" class="headerlink" title="iOS 設備的改進"></a>iOS 設備的改進</h3><p>在以前的 Flutter 版本中，使用者可能會遇到 <a href="https://github.com/flutter/flutter/issues/134959">一個問題</a>，即 iOS 設備上的應用程式在合成器反壓下每幀等待幾毫秒。這種反壓將被視為柵格工作負載開始時的延遲。在許多情況下，這種延遲會導致畫面丟失和卡頓。這種效應在具有較小畫面時間預算的高畫面播放速率設備上尤為明顯。</p>
<p>在此版本中，開源貢獻者 <a href="https://github.com/knopp">@knopp</a> 加入了一個 <a href="https://github.com/flutter/engine/pull/48226">新的實作</a> Metal 渲染表面，允許柵格工作負載在 UI 工作負載完成後更一致地開始。這意味著使用者將觀察到整體畫面時間更加穩定，因為在 iOS 系統合成器上的等待時間更少。特別是，Flutter 現在將在高畫面播放速率設備上更一致地達到 120Hz。在我們的基準測試中，我們觀察到在許多情況下平均畫面柵格化時間都大幅減少了。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*wsAPbKV2yW8tLXNb" />
<figcaption><em>此圖表顯示在 iPhone 11 設備上運行的許多不同基準測試中，平均畫面柵格化時間（以毫秒為單位）全面下降。</em></figcaption>
</figure>

<h4 id="架構廣色域顏色"><a href="#架構廣色域顏色" class="headerlink" title="架構廣色域顏色"></a>架構廣色域顏色</h4><p>Flutter 現在支援使用 DisplayP3 色彩空間中的顏色來定義 UI，以充分利用 iOS 設備上的顯示器。它還具有更寬的位元深度，以支援 sRGB 和 DisplayP3 色彩空間中的更多顏色。此變更導致一些 <code>Color</code> 方法被棄用；更多資訊可以在 <a href="https://docs.flutter.dev/release/breaking-changes/wide-gamut-framework">重大變更通知</a> 中找到。</p>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="Web-改進"><a href="#Web-改進" class="headerlink" title="Web 改進"></a>Web 改進</h4><p>此版本為 Flutter Web 帶來各種改進，著重於效能、效率和輔助功能：</p>
<ul>
<li>現在，Safari 和 Firefox 中的圖像解碼使用 <code>&lt;img&gt;</code> 元素完成，而不是對所有靜態圖像使用 WebAssembly 編解碼器。這消除了與圖像解碼相關的卡頓，並減少了 WASM 記憶體使用量。</li>
<li>平台視圖經過優化，以減少畫布覆蓋層的數量，從而提高渲染效率。</li>
<li>Flutter 團隊開發的所有插件和套件現在都與 WebAssembly 相容。</li>
<li>對標題、對話框、密碼、iOS 鍵盤、連結和捲動元件實作了多項輔助功能修復。</li>
<li>在 CanvasKit 和 Skwasm 渲染器中修復了許多渲染錯誤，包括圖像濾鏡、裁剪和 <code>Paint</code> 物件的記憶體使用量。</li>
<li>改進了多視圖模式下的拖動捲動。</li>
</ul>
<h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><h4 id="Swift-Package-Manager"><a href="#Swift-Package-Manager" class="headerlink" title="Swift Package Manager"></a>Swift Package Manager</h4><p>Flutter 正在遷移到 Swift Package Manager。這帶來了許多好處：</p>
<ol>
<li><strong>存取 Swift 套件生態系統</strong>。Flutter 插件將能夠利用不斷發展的 <a href="https://swiftpackageindex.com/">Swift 套件</a> 生態系統！</li>
<li><strong>簡化 Flutter 安裝</strong>。Swift Package Manager 與 Xcode 捆綁在一起。未來，您將不再需要安裝 Ruby 和 CocoaPods 來為 Apple 平台使用 Flutter。</li>
</ol>
<p>以前，Swift Package Manager 支援僅在 Flutter 的「main」頻道上可用。我們很高興地宣布，Swift Package Manager 功能現在也在「beta」和「stable」頻道上可用！目前，Swift Package Manager 功能預設為關閉，因為我們正在解決一些問題。</p>
<p>鼓勵插件作者將 <a href="https://docs.flutter.dev/packages-and-plugins/swift-package-manager/for-plugin-authors#how-to-add-swift-package-manager-support-to-an-existing-flutter-plugin">Swift Package Manager 支援加入到您的插件中</a>。許多流行的插件——包括 <a href="https://github.com/firebase/flutterfire/issues/13205">Firebase</a>、<a href="https://github.com/fluttercommunity/plus_plugins/issues/3152">plus 插件</a> 和 <a href="https://pub.dev/packages?q=is:swiftpm-plugin">更多</a>——已經遷移到 Swift Package Manager！</p>
<p>Pub.dev 現在會檢查插件的 Swift Package Manager 相容性。未來，不相容的套件將不會獲得完整的套件評分。</p>
<p>如果您對 Flutter 對 Swift Package Manager 的支援有任何回饋，請 <a href="https://github.com/flutter/flutter/issues/new/choose">提交問題</a>。</p>
<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="邊緣到邊緣"><a href="#邊緣到邊緣" class="headerlink" title="邊緣到邊緣"></a>邊緣到邊緣</h4><p>在運行 Android 15+ 的設備上，您的應用程式預設將使用邊緣到邊緣模式並以全螢幕運行！有關此變更以及如何選擇退出此行為的詳細資訊，請參閱<a href="https://docs.flutter.dev/release/breaking-changes/default-systemuimode-edge-to-edge">指南</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/648/0*CNcQF3yqFwc0IGNc" />
</figure>

<h4 id="支援-Freeform"><a href="#支援-Freeform" class="headerlink" title="支援 Freeform"></a>支援 Freeform</h4><p><a href="https://android-developers.googleblog.com/2024/09/developer-preview-desktop-windowing-on-android-tablets.html">Android Freeform</a> 允許使用者調整應用程式視窗的大小，並且一直作為開發人員選項提供。Flutter 的 <code>SafeArea</code> 和 <code>MediaQuery</code> 已更新，以便在 freeform 視窗移動到硬體缺口時處理硬體缺口。</p>
<h4 id="Kotlin-建置腳本支援和宣告式插件遷移"><a href="#Kotlin-建置腳本支援和宣告式插件遷移" class="headerlink" title="Kotlin 建置腳本支援和宣告式插件遷移"></a>Kotlin 建置腳本支援和宣告式插件遷移</h4><p>開發人員現在可以使用 <code>build.gradle.kts</code> 檔案。Flutter 工具現在支援 Kotlin 建置檔案。如果您遇到我們不支援 Kotlin 的地方，請<a href="https://github.com/flutter/flutter/issues/new/choose">提交錯誤</a>。Groovy 仍然是支援的 Gradle 語言。</p>
<p>Flutter 3.27 是最後一個支援 <a href="https://docs.gradle.org/8.5/userguide/plugins.html#sec:script_plugins">Gradle 的傳統 <code>apply</code> 腳本方法</a> 的版本。請參閱<a href="https://docs.flutter.dev/release/breaking-changes/flutter-gradle-plugin-apply">遷移文件</a>。</p>
<p><strong>注意：大多數應用程式需要手動遷移。新建立的應用程式將</strong> <a href="https://github.com/flutter/flutter/pull/157195">使用 kotlin 建置檔案</a>。</p>
<p>遷移到 Flutter Gradle 插件的宣告式包含有助於 Flutter 遷移到 Kotlin 建置檔案，從而提高類型安全性，並更容易維護建置程式碼的單元測試。這也是在 Android 工具版本之間帶來更多穩定性的一項更廣泛工作的一部分。</p>
<h3 id="生態系統"><a href="#生態系統" class="headerlink" title="生態系統"></a>生態系統</h3><h4 id="Flutter-和-Dart-套件生態系統峰會美國-2024"><a href="#Flutter-和-Dart-套件生態系統峰會美國-2024" class="headerlink" title="Flutter 和 Dart 套件生態系統峰會美國 2024"></a>Flutter 和 Dart 套件生態系統峰會美國 2024</h4><p>作為 2024 年 9 月 Fluttercon USA 的一部分，我們舉辦了 Flutter 和 Dart 套件生態系統峰會。這是我們的第二次現場峰會，繼 2024 年 7 月 Fluttercon Europe 的峰會和我們於 2023 年 8 月舉辦的第一屆虛擬峰會之後。請參閱此處的討論會重點摘要 <a href="https://docs.google.com/document/d/e/2PACX-1vRjPlBNo13I9P5UXpehKagVq8e8n7ppNz169HbKSgK4iTmCrbk5rzh-RN6ULpVJ3AkPnnCSI_VCMdYW/pub">連結</a>。</p>
<p>峰會匯集了套件作者和維護者，進行了以下主題的非會議式會議：</p>
<ul>
<li>會議 1 - 加入對 Swift Package Manager 的支援</li>
<li>會議 2 - 原生互操作的過去、現在和未來</li>
<li>會議 3 - 可持續的套件維護模型</li>
</ul>
<p>我們期待與社群合作，在未來舉辦更多此類峰會。</p>
<h4 id="pub-dev-上的套件下載次數"><a href="#pub-dev-上的套件下載次數" class="headerlink" title="pub.dev 上的套件下載次數"></a>pub.dev 上的套件下載次數</h4><p>我們在 pub.dev 上推出了下載次數指標！</p>
<p>在 <a href="https://pub.dev/">pub.dev</a> 上提供更精確的受歡迎程度指標一直是該網站問題追蹤器中 <a href="https://github.com/dart-lang/pub-dev/issues/2714">請求最多的</a> 功能。</p>
<p>現在，當您查看套件頁面時，您將看到一個 30 天下載次數，取代了以前的「受歡迎程度分數」。</p>
<p>此外，我們還加入了一個互動式折線圖，顯示隨著時間推移的每週下載活動。此圖表可幫助開發人員和套件作者發現套件使用趨勢。例如，它可能表明新版本導致使用量激增，或者套件正在變得越來越流行或越來越不受歡迎。</p>
<p>每次從 pub.dev 下載套件時都會註冊下載次數。例如，當您運行 <code>flutter pub get</code> 且套件尚未在您的 pub 快取中時。</p>
<p>顯示的下載次數是原始下載次數，反映了來自 CI 系統、套件分析、人工 pub 用戶端使用者等的使用情況。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tIfxBdBCHFzYhStI" />
</figure>

<h4 id="Pub-工作區"><a href="#Pub-工作區" class="headerlink" title="Pub 工作區"></a>Pub 工作區</h4><p>我們將在 Dart 3.6 中推出 <a href="https://dart.dev/go/pub-workspaces">Pub 工作區</a>，以支援在一個 monorepo 中開發多個相關套件。</p>
<p>透過定義引用儲存庫中其他套件的根 pubspec，在儲存庫中的任何位置運行 <code>pub get</code> 將會為所有套件產生共用解析。這可確保所有套件都使用一組一致的相依開發。</p>
<p>分析器也會選取共用解析，現在分析器只需追蹤整個工作區的單個分析上下文，從而可能在 IDE 中打開整個儲存庫時顯著減少記憶體使用量。</p>
<h4 id="從-GitHub-自動發佈-Flutter-套件"><a href="#從-GitHub-自動發佈-Flutter-套件" class="headerlink" title="從 GitHub 自動發佈 Flutter 套件"></a>從 GitHub 自動發佈 Flutter 套件</h4><p>我們擴展了 <code>setup-dart</code> <a href="https://github.com/dart-lang/setup-dart/blob/main/.github/workflows/publish.yml">發佈</a> Github Actions 工作流程，還允許將 Flutter 套件 <a href="https://dart.dev/tools/pub/automated-publishing#configuring-automated-publishing-from-github-actions-on-pub-dev">自動發佈</a> 到 pub.dev，從而更容易以可驗證的方式為 Pub 生態系統做出貢獻。</p>
<h4 id="推出互動式媒體廣告插件"><a href="#推出互動式媒體廣告插件" class="headerlink" title="推出互動式媒體廣告插件"></a>推出互動式媒體廣告插件</h4><p>我們推出了 <a href="https://pub.dev/packages/interactive_media_ads">互動式媒體廣告 (IMA) Flutter 插件</a>，可以輕鬆地將多媒體廣告整合到使用 Flutter 建置的 iOS 和 Android 應用程式中。IMA 插件可以從任何符合 VAST 標準的廣告伺服器請求廣告，並在您的應用程式中管理廣告播放。廣告在位於應用程式內容影片播放器頂部的單獨影片播放器中播放。目前支援的功能包括：</p>
<ul>
<li>線性串流影片廣告請求的用戶端 API</li>
<li>VAST 和 VMAP</li>
<li>單個和 Podded 請求</li>
<li>可跳過廣告</li>
</ul>
<h4 id="應用程式內購買-iOS-和-macOS-插件更新"><a href="#應用程式內購買-iOS-和-macOS-插件更新" class="headerlink" title="應用程式內購買 iOS 和 macOS 插件更新"></a>應用程式內購買 iOS 和 macOS 插件更新</h4><p>我們已將 <a href="https://developer.apple.com/storekit/">StoreKit 2</a> 支援加入到 <code>in_app_purchase_storekit</code> 套件中，以從 iOS 18 中棄用的 StoreKit 1 API 遷移。這使我們能夠在未來加入新的 StoreKit 2 功能，例如更好的訂閱管理。敬請期待即將推出的遷移指南，以説明您轉換到新的 StoreKit 2 功能。這是一個非重大變更，因此您可以隨時遷移。</p>
<h3 id="DevTools-和-IDE"><a href="#DevTools-和-IDE" class="headerlink" title="DevTools 和 IDE"></a>DevTools 和 IDE</h3><h4 id="Flutter-DevTools-更新"><a href="#Flutter-DevTools-更新" class="headerlink" title="Flutter DevTools 更新"></a>Flutter DevTools 更新</h4><p>此版本包含新功能、整體穩健性和完善性改進，以及一些令人興奮的新的實驗性功能，您可以從 DevTools 中啟用這些功能。有關這些功能的更多資訊，請參閱下面的「預覽和實驗性功能」部分。</p>
<p>首先，我們在 Flutter Deep Links 工具中加入了對驗證 iOS 深度連結設定的支援。您現在可以驗證 Android 和 iOS 的深度連結。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*WO_tOgbNKHtMAJ4h" />
<figcaption><em>DevTools Deep Links 工具中的 iOS 深度連結驗證。</em></figcaption>
</figure>

<p>接下來，我們對使用「離線」資料的工作流程進行了一些改進。有時需要將您在 DevTools 中查看的資料匯出以供將來使用或載入到其他工具中。此版本加入了將網路資料匯出為 .har 檔案的支援，以及將記憶體快照載入到 DevTools 中以便在 DevTools 未連線到正在運行的應用程式時查看的支援。</p>
<p>此外，如果您曾經在使用 DevTools 除錯記憶體問題時因為應用程式崩潰（可能是由於您正在嘗試除錯的 OOM 問題）而丟失了記憶體工具資料，我們感同身受！我們已透過允許您即使在應用程式斷開連線後仍然可以在 DevTools 中繼續查看最新的記憶體工具資料來修復此使用者體驗痛點。</p>
<p>這些只是此版本中的一些重點。若要進一步了解 Flutter 3.27 中包含的所有更新，請查看 DevTools 的發行說明 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.38.0">2.38.0</a>、<a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.39.0">2.39.0</a> 和 <a href="https://docs.flutter.dev/tools/devtools/release-notes/release-notes-2.40.1">2.40.1</a>。</p>
<h3 id="預覽和實驗性功能"><a href="#預覽和實驗性功能" class="headerlink" title="預覽和實驗性功能"></a>預覽和實驗性功能</h3><h4 id="Flutter-DevTools-新的-Flutter-Inspector"><a href="#Flutter-DevTools-新的-Flutter-Inspector" class="headerlink" title="Flutter DevTools - 新的 Flutter Inspector"></a>Flutter DevTools - 新的 Flutter Inspector</h4><p>Flutter Inspector 已經過一些重大變更，以提高可用性並增強您的 UI 除錯體驗。透過切換「新的 Inspector」設定來啟用新的 Inspector。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/914/0*DdHEiQ7FUmFVIMGz" />
<figcaption><em>DevTools 中的新 Flutter Inspector。</em></figcaption>
</figure>

<p>一些變更包括：</p>
<ul>
<li>簡潔的 Widget 樹，可以更輕鬆地查看深度巢狀的 Flutter widget 樹。當從 IDE 中使用 Flutter Inspector 時，這尤其有用，因為水平螢幕空間有限。</li>
<li>一個選項，用於切換是否應在 widget 樹中包含實作 widget。實作 widget 是您未在應用程式程式碼中包含的 widget，而是由 Flutter 架構或其他套件加入到 widget 樹中的。</li>
<li>選定 widget 的詳細資訊視圖，顯示內聯佈局查看器、widget 和渲染物件屬性，以及 Flex widget 及其子項的 Flex 佈局資源管理器。</li>
</ul>
<p>新的 Inspector 很快就會有更多改進，但這些變更已經可以試用了！請提交您遇到的任何 <a href="https://github.com/flutter/devtools/issues">問題</a>，以便我們在預設啟用新的 Inspector 之前修復它們。</p>
<h4 id="Flutter-DevTools-使用-WebAssembly-進行嘗試"><a href="#Flutter-DevTools-使用-WebAssembly-進行嘗試" class="headerlink" title="Flutter DevTools - 使用 WebAssembly 進行嘗試"></a>Flutter DevTools - 使用 WebAssembly 進行嘗試</h4><p>在 DevTools 設定中啟用 WebAssembly 功能，以載入 WASM 編譯的 DevTools Web 應用程式。</p>
<p>這應該比預設的 JS 編譯版本的 DevTools 產生更好的效能。此功能是實驗性的，因此請提交您在 WASM 建置中遇到的任何 <a href="https://github.com/flutter/devtools/issues">問題</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/565/0*J2ur0Z_wJsdbAUt8" />
<figcaption><em>DevTools 設定，用於使用 WebAssembly 建置而不是 Javascript 建置。</em></figcaption>
</figure>

<h3 id="重大變更和棄用"><a href="#重大變更和棄用" class="headerlink" title="重大變更和棄用"></a>重大變更和棄用</h3><h4 id="Material-Design-3-標記"><a href="#Material-Design-3-標記" class="headerlink" title="Material Design 3 標記"></a>Material Design 3 標記</h4><p>最新的 Material Design 3 標記 (v6.1) 已應用於 Flutter Material 函式庫。Material Design 標記更新了僅在亮模式下 4 種顏色角色的映射，以在保持可存取對比度的同時更具視覺吸引力。我們在測試此變更時沒有發現任何損壞，此變更應用於以下顏色屬性：</p>
<ul>
<li>主要容器上（Primary10 到 Primary30）</li>
<li>次要容器上（Secondary10 到 Secondary30）</li>
<li>三級容器上（Tertiary10 到 Tertiary30）</li>
<li>錯誤容器上（Error10 到 Error30）</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/266/0*_uQf9sIr4M1EC34y" />
</figure>

<p>這會影響使用這些角色作為其預設值的 Widget。</p>
<p>晶片（<code>Chip</code>、<code>ActionChip</code>、<code>ChoiceChip</code>、<code>FilterChip</code> 和 <code>InputChip</code>）的邊框顏色已從 <code>ColorScheme.outline</code> 更新為 <code>ColorScheme.outlineVariant</code>。這改善了晶片和按鈕之間的視覺層次結構。</p>
<h4 id="Objective-C-iOS-專案"><a href="#Objective-C-iOS-專案" class="headerlink" title="Objective-C iOS 專案"></a>Objective-C iOS 專案</h4><p>自 2019 年 Flutter 1.9.1 發佈以來，新的 iOS 專案預設使用 Swift。建立 <a href="https://github.com/flutter/flutter/issues/148586">新的 Objective-C iOS 專案現在已被棄用</a>，並且 <code>flutter create --ios-language objc</code> 標誌將在 Flutter 的未來版本中移除。您仍然可以打開 Xcode 專案並加入 Objective-C 檔案，包括插件的檔案。Java 繼續透過 <code>flutter create --android-language java</code> 標誌支援 Android 應用程式。</p>
<h4 id="深度連結預設標誌"><a href="#深度連結預設標誌" class="headerlink" title="深度連結預設標誌"></a>深度連結預設標誌</h4><p>Flutter 的深度連結標誌的預設值已從 <strong>false</strong> 變更為 <strong>true</strong>，這意味著深度連結現在預設為選擇加入。如果您使用 Flutter 的預設深度連結設定，則不再需要手動將標誌設定為 <strong>true</strong>。</p>
<p>但是，如果您使用協力廠商插件進行深度連結，例如：</p>
<ul>
<li><a href="https://firebase.google.com/docs/dynamic-links">firebase 動態連結</a></li>
<li><a href="https://pub.dev/packages/uni_links">uni_link</a></li>
<li><a href="https://pub.dev/packages/app_links">app_links</a></li>
</ul>
<p>此更新將引入重大變更。在這種情況下，您需要手動將 Flutter 深度連結標誌重置為 <strong>false</strong>。</p>
<p>有關更多詳細資訊，請參閱設計文件：<a href="http://flutter.dev/go/deep-link-flag-migration">flutter.dev&#x2F;go&#x2F;deep-link-flag-migration</a></p>
<h4 id="在-IDE-中棄用對較舊-SDK-的支援"><a href="#在-IDE-中棄用對較舊-SDK-的支援" class="headerlink" title="在 IDE 中棄用對較舊 SDK 的支援"></a>在 IDE 中棄用對較舊 SDK 的支援</h4><p>為了確保我們能夠繼續提供高品質的開發人員體驗，我們正在對 IDE 插件支援進行變更。隨著 VS Code 和 IntelliJ 的 Dart 和 Flutter 插件的發展，支援較舊的 Dart SDK 版本變得越來越具有挑戰性。</p>
<p>從 Dart 3.6 發佈開始，我們將棄用對早於 3.0（於 2023 年 5 月發佈）的 Dart SDK 版本的支援。這意味著雖然這些工具可能仍然可以使用較舊的 SDK，但我們將不再為特定於這些版本的問題提供官方支援或修復。</p>
<p>隨著 Dart 3.7（預計在 2025 年第一季度）的發佈，我們將完全移除對這些較舊 SDK 版本的支援。這些插件的未來版本可能與這些版本不相容。</p>
<p><strong>這對您意味著什麼？</strong></p>
<ul>
<li>如果您使用的是較舊的 Dart SDK，我們鼓勵您升級到 3.0 或更高版本，以繼續接收支援和更新。</li>
<li>此變更影響不到我們 1% 的使用者，它將使我們能夠專注於為絕大多數開發人員提供最佳的體驗。</li>
</ul>
<h4 id="結束語"><a href="#結束語" class="headerlink" title="結束語"></a>結束語</h4><p>有關此版本中的所有重大變更，請參閱 <a href="https://docs.flutter.dev/release/breaking-changes">重大變更頁面</a> 上的完整遷移指南列表。</p>
<p>與往常一樣，非常感謝社群為 <a href="https://github.com/flutter/tests/blob/master/README.md">貢獻測試</a>——這些測試幫助我們識別重大變更。若要進一步了解，請查看 <a href="https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes">Flutter 的重大變更政策</a>。</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>非常感謝整個 Flutter 社群使此版本成為可能！您的貢獻、回饋和熱情是推動 Flutter 向前發展的動力。我們對 Flutter 的未來感到無比興奮，並迫不及待地想看到您使用 Flutter 3.27 建置的出色應用程式。</p>
<p>有關所有變更的完整概要，請查看詳細的 <a href="https://docs.flutter.dev/release/release-notes">發行說明和變更日誌</a>。準備好體驗最新最好的功能了嗎？只需運行 <code>flutter upgrade</code> 並開始建置！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=28341129570c" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/whats-new-in-flutter-3-27-28341129570c">Flutter 3.27 的新功能</a> 最初發佈在 Medium 上的 <a href="https://medium.com/flutter">Flutter</a> 中，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/6a2d80d6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/6a2d80d6.html" class="post-title-link" itemprop="url">【文章翻譯】Tune in for #FlutterInProduction — coming soon to a screen near you!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-12-03 19:01:01" itemprop="dateCreated datePublished" datetime="2024-12-03T19:01:01+08:00">2024-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-12 11:13:06" itemprop="dateModified" datetime="2024-12-12T11:13:06+08:00">2024-12-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="收看-FlutterInProduction-即將在您附近的螢幕上播出！"><a href="#收看-FlutterInProduction-即將在您附近的螢幕上播出！" class="headerlink" title="收看 #FlutterInProduction - 即將在您附近的螢幕上播出！"></a>收看 #FlutterInProduction - 即將在您附近的螢幕上播出！</h2><p>在您的日曆上標記，並務必在 <strong>2024 年 12 月 17 日</strong> 太平洋時間上午 11:00 &#x2F; 東部時間下午 2:00 &#x2F; 中歐時間晚上 8:00 收看 <strong>#FlutterInProduction</strong>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/1*SSIgDyW3jMaOF5nxH5D9lw.gif" />
</figure>

<p>這個在 <a href="https://www.youtube.com/@flutterdev">Flutter YouTube 頻道</a> 上舉辦的線上活動與我們之前的活動略有不同。我們不僅會深入探討最新版本（儘管我們一定會這樣做！）：#FlutterInProduction 還將慶祝我們作為一個社群共同走過的不可思議的旅程，使 Flutter 成為今天這個強大的、可投入生產的框架。</p>
<h3 id="預期內容"><a href="#預期內容" class="headerlink" title="預期內容"></a>預期內容</h3><ul>
<li><strong>#FlutterInProduction：</strong>無論您是經驗豐富的專業人士還是剛剛起步，您都將從 Flutter 使用者故事中獲得新的見解和靈感，從 Flutter 技術負責人那裡了解更多關於最新功能的資訊，並在此多環節線上活動中了解 Flutter 應用程式開發的未來。</li>
<li><strong>#AskFlutter 線上問答：</strong>從 Flutter 團隊負責人那裡獲得您的問題的解答。請持續關注我們在社群媒體上的徵集問題！</li>
<li><strong>Observable Flutter：</strong>對在企業開發環境中使用 Flutter 構建有什麼疑問嗎？從在生產中使用 Flutter 的公司的技術負責人那裡獲得這些問題的解答。</li>
</ul>
<h3 id="保持關注"><a href="#保持關注" class="headerlink" title="保持關注"></a>保持關注</h3><p>我們將會有一些驚喜和公告，因此請務必採取以下步驟以保持了解最新資訊。</p>
<ol>
<li>在您的日曆上或在 <a href="https://www.youtube.com/@flutterdev">YouTube</a> 上 <a href="https://calndr.link/event/jqZQr0d7nH">設定提醒</a>，了解活動時間。</li>
<li>在 <a href="https://www.youtube.com/redirect?event=channel_description&redir_token=QUFFLUhqbkRYNDVxWGRFUUZYNVdmMlg4QTB4akhOeXNVd3xBQ3Jtc0trWWpSSHo0Tnh3QjlKdF81Z0lsSkQzQWdxVEpBNVdOSVE5Q01tUUltMUFvV2k5Z1RfUzVtc0JET0pFejVRLTl1UUdPNG9DMHk3ZWpUcGtRVGVtUk1yUzA3SEx4STVpM09Kd0dSczVxOGhyQkxRb1EwNA&q=https://twitter.com/FlutterDev">Twitter</a>，<a href="https://www.linkedin.com/showcase/flutterdevofficial/">LinkedIn</a> 或此處的 Medium 上關注我們！</li>
</ol>
<p>我們迫不及待地想與您分享 #<strong>FlutterinProduction</strong>！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6bb9820d1506" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/tune-in-for-flutterinproduction-coming-soon-to-a-screen-near-you-6bb9820d1506">收看 #FlutterInProduction - 即將在您附近的螢幕上播出！</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/bf2dc4e6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/bf2dc4e6.html" class="post-title-link" itemprop="url">【文章翻譯】Prospera: using Flutter to bring AI to the frontline of sales</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-21 17:32:03" itemprop="dateCreated datePublished" datetime="2024-11-21T17:32:03+08:00">2024-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:06:10" itemprop="dateModified" datetime="2024-12-18T12:06:10+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 2.0 自動翻譯產生】</p>
<h2 id="Prospera：使用-Flutter-將-AI-帶到銷售前線"><a href="#Prospera：使用-Flutter-將-AI-帶到銷售前線" class="headerlink" title="Prospera：使用 Flutter 將 AI 帶到銷售前線"></a>Prospera：使用 Flutter 將 AI 帶到銷售前線</h2><figure>
<img alt="Gemini graphic" src="https://cdn-images-1.medium.com/max/512/1*rV1FMqYeyrHsOvtSUIOnOA.png" />
</figure>

<p>世界各地的開發人員正在使用 Google 的 Gemini 模型來應對現實世界的挑戰，而我們看到最令人興奮的應用之一就是在銷售領域。認識 Prospera，它在我們最近的 <a href="http://ai.google.dev/competition">Gemini API 開發者競賽</a> 中獲得了 <em>最佳 Flutter 應用程式</em> 和 <em>最有用的應用程式</em> 兩項大獎！Prospera 由來自德國的 Leon Kukuk 和 Max Hasenohr 共同開發，它是一款 AI 驅動的銷售教練，可在通話期間和通話後提供即時指導和回饋。這款創新的 Flutter 應用程式展示了 Gemini 如何改變銷售專業人員學習和提升技能的方式。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FZTFKbhmGcUo%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DZTFKbhmGcUo&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FZTFKbhmGcUo%2Fhqdefault.jpg&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/4ae49e7b2a8ce8088799bc6c2f4f30a2/href">https://medium.com/media/4ae49e7b2a8ce8088799bc6c2f4f30a2/href</a></iframe>

<h3 id="Gemini-API-作為核心：即時分析和多模態魔法"><a href="#Gemini-API-作為核心：即時分析和多模態魔法" class="headerlink" title="Gemini API 作為核心：即時分析和多模態魔法"></a>Gemini API 作為核心：即時分析和多模態魔法</h3><p>Prospera 以真正獨特的方式利用 Gemini 的多模態功能。透過將語音對話片段直接輸入 Gemini API 的 Python SDK，該應用程式可以從經驗豐富的銷售教練的角度提供即時回饋。想像一下，在您通話期間，有一個 AI 副駕駛會提供有價值的見解和建議——這就是 Prospera 的力量。</p>
<p>但他們是如何實現這種無縫整合的呢？Prospera 的開發者 Leon 巧妙地使用了 Dart FFI（外部函數介面）和 ffigen 套件，為 PJSIP C 函式庫建立了 Dart 繫接，從而在 Flutter 中實現了無縫的電話整合，並允許透過 Gemini API 處理這些通話。這使他們能夠即時處理音訊資料，並向銷售代表提供即時回饋。</p>
<p><strong>「Gemini 對語音的細緻理解給我們留下了深刻的印象，這要歸功於其多模態音訊功能以及易於實作的特性。Flutter 使我們能夠以驚人的速度開發跨平台應用程式，同時提供了透過 FFI 和平台通道運行原生程式碼的強大機會。」——Leon</strong></p>
<h3 id="適用於所有平台的-Flutter-應用程式"><a href="#適用於所有平台的-Flutter-應用程式" class="headerlink" title="適用於所有平台的 Flutter 應用程式"></a>適用於所有平台的 Flutter 應用程式</h3><p>Prospera 使用 Flutter 構建，可以從單一程式碼庫在各種桌面平台上無縫運行。這不僅簡化了開發，還為未來擴展到行動裝置打開了大門，讓更廣泛的受眾可以使用該應用程式。開發人員還密切關注使用者體驗，使用 Material Design Widget 製作了一個設計精美的應用程式，並確保了完全的無障礙使用。</p>
<h3 id="超越銷售：展望溝通的未來"><a href="#超越銷售：展望溝通的未來" class="headerlink" title="超越銷售：展望溝通的未來"></a>超越銷售：展望溝通的未來</h3><p>透過將 Gemini 的強大功能與 Flutter 的多功能性相結合，Leon 和 Max 開發了一款有可能徹底改變我們學習、互動和在職業生涯中脫穎而出的方式的應用程式。Prospera 不僅僅是一個銷售教練；它讓我們看到了 AI 如何增強人類溝通和專業發展的未來。雖然 Prospera 專注於銷售指導，但其底層技術和方法具有更廣泛的應用。分析即時對話並提供建設性回饋的能力在各種以溝通為導向的職業中都很有價值，例如客戶服務和教育。</p>
<p><strong>想了解更多關於 Dart FFI 以及它如何增強您的 Flutter 應用程式的資訊嗎？請在 pub.dev 上查看 <a href="https://pub.dev/packages/ffigen">ffigen</a> 套件。</strong></p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=71377810fd26" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/prospera-using-flutter-to-bring-ai-to-the-frontline-of-sales-71377810fd26">Prospera：使用 Flutter 將 AI 帶到銷售前線</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/4fcc687c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/4fcc687c.html" class="post-title-link" itemprop="url">【文章翻譯】Google Summer of Code 2024 Results</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-10-14 17:23:41" itemprop="dateCreated datePublished" datetime="2024-10-14T17:23:41+08:00">2024-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:35:35" itemprop="dateModified" datetime="2024-12-18T12:35:35+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 2.0 自動翻譯產生】</p>
<h2 id="Google-暑期程式碼計劃-2024-成果"><a href="#Google-暑期程式碼計劃-2024-成果" class="headerlink" title="Google 暑期程式碼計劃 2024 成果"></a>Google 暑期程式碼計劃 2024 成果</h2><p><a href="https://summerofcode.withgoogle.com/">Google 暑期程式碼計劃</a> (GSoC) 的重點是讓全球新的開發人員參與開源軟體開發。Google 贊助貢獻者在夏季與輔導開源組織合作進行為期 12 週的程式設計專案。在過去的 19 年裡，已有超過 20,000 名貢獻者參與了 Google 暑期程式碼計劃。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/674/0*vm7AfKyip_pXJGCd" />
</figure>

<p>2024 年，Dart 連續第五年作為輔導組織參與 Google 暑期程式碼計劃。今年，我們收到了來自世界各地潛在參與者的 50 份專案提案。今天，我們重點介紹了今年夏天我們輔導的一些專案。貢獻者在此文章中描述了他們的專案。</p>
<h3 id="使用-OkHttp-的-JNI-綁定的-HTTP-客戶端"><a href="#使用-OkHttp-的-JNI-綁定的-HTTP-客戶端" class="headerlink" title="使用 OkHttp 的 JNI 綁定的 HTTP 客戶端"></a>使用 OkHttp 的 JNI 綁定的 HTTP 客戶端</h3><p><em>作者：Anikate De</em></p>
<p>現有的 Dart HTTP 客戶端無法與原生 Android API 互動，限制了對 KeyStore 私鑰、系統代理和使用者安裝憑證的支援（所有這些都是 Dart 使用者強烈要求的功能）。</p>
<p>開源專案 <a href="https://square.github.io/okhttp/">OkHttp</a> 是 Android 上網路密集型應用程式的熱門選擇，它擁有的 API 可以無縫地實作上述功能。因此，OkHttp 被選為此專案的起點。使用 GSoC 2022 專案，<a href="https://pub.dev/packages/jnigen">package:jnigen</a>，為多個 OkHttp API 生成了 Dart 的 JNI 綁定。OkHttpClient 與現有的 HTTP 客戶端完全相容，允許從任何替代方案無縫過渡到使用 OkHttpClient。</p>
<p>除了非同步 HTTP 請求之外，<a href="https://pub.dev/packages/ok_http">package:ok_http</a> 還支援 WebSockets，這需要通過 package:web_socket_conformance_test 中的所有測試。這允許從任何 WebSocket 替代方案平穩過渡。使用 package:ok_http 基準測試的 Flutter 應用程式報告了所有其他 Dart 提供的 HTTP 客戶端中最小的 APK 大小。</p>
<p>在您的 Flutter 專案中利用 OkHttpClient 的優點就像匯入它一樣簡單，並編輯您目前的 Client 物件！</p>
<p>在 <a href="https://github.com/Anikate-De/gsoc-2024-project-report">GSoC 貢獻者報告</a> 中閱讀更多關於專案的詳細資訊。</p>
<h3 id="Swift2ObjC：ObjC-包裝器產生器"><a href="#Swift2ObjC：ObjC-包裝器產生器" class="headerlink" title="Swift2ObjC：ObjC 包裝器產生器"></a>Swift2ObjC：ObjC 包裝器產生器</h3><p><em>作者：Mohammad Eid</em></p>
<p>Dart 可以（間接）與 Swift 程式碼通訊。這是透過 ObjC 完成的，因為 Dart 可以使用 <a href="https://dart.dev/interop/c-interop">ffi</a> 套件與基於 C 語言（如 ObjC）通訊。Swift API 可以使用 <code>@objc</code> 註釋，以請求編譯器為它們產生 ObjC 標頭。使用 <a href="https://pub.dev/packages/ffigen">ffigen</a> 自動為 Dart 產生 ffi 綁定。對於 Swift，您需要手動註釋您想要與之通訊的 API。</p>
<p>註釋 Swift API 可能比加入 <code>@objc</code> 註釋更複雜。如果您不擁有該模組怎麼辦？如果您無法編輯它，您必須建立一個自訂包裝器來鏡像 API，以便您可以註釋方法。此外，由於 Swift 是一種現代語言，而 ObjC 不是，您可能會遇到一些 API，這些 API 無法直接在 ObjC 中表示，因此您也必須解決這些情況。</p>
<p>Swift2ObjC 為您處理這些事情：它為 Swift 模組產生包裝器，並使用 <code>@objc</code> 註釋它們，同時確保所有 API 都可以在 ObjC 中表示 - 否則 Swift 模組將無法編譯。我在 Medium 上的這篇文章 (<a href="https://medium.com/@mohammad.mossad.eid/swift2objc-more-convenient-swift-dart-interoperability-b152dd5bed13">文章連結</a>) 中解釋了實作細節（如果您正在考慮為該工具做出貢獻，可以參考這篇文章，因為它仍在積極開發中）。您還可以在 GitHub 上的 <a href="https://github.com/dart-lang/native/tree/cf13658c3bc92e62893ec15659dc1370a7d07e8a/pkgs/swift2objc">swift2objc 儲存庫</a> 中深入研究原始碼。</p>
<h3 id="使用-dartdoc-test-測試文件註釋"><a href="#使用-dartdoc-test-測試文件註釋" class="headerlink" title="使用 dartdoc_test 測試文件註釋"></a>使用 dartdoc_test 測試文件註釋</h3><p><em>作者：Takuma Ichikawa</em></p>
<p>Dart 允許在文件註釋中嵌入程式碼範例。這是一個有益的做法，因為它也會作為 API 文件發佈，並以套件使用者和開發人員都容易理解的方式展示如何使用套件。但是，文件註釋中的程式碼範例不會被分析或測試，因此很難發現錯誤，並且難以維護。隨著專案和文件的增長，這個問題變得更加嚴重。</p>
<p>因此，對於 GSOC，我開發了 <a href="https://pub.dev/packages/dartdoc_test">dartdoc_test</a> 套件來解決此類問題。dartdoc_test 工具可以提取和分析文件註釋中的程式碼範例，以發現潛在的錯誤。透過將套件加入到您的專案中，並從命令列運行它，您可以發現所有程式碼範例中的錯誤。您還可以在運行 <code>dart test</code> 命令時，透過加入 <code>dartdoc_test</code> 測試檔案來執行程式碼範例的靜態分析。</p>
<p>透過運行以下兩個命令，您可以輕鬆地在 Dart 專案中試用 dartdoc_test。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dart pub add dev:dartdoc_test</span><br><span class="line">dart run dartdoc_test</span><br></pre></td></tr></table></figure>

<p>要了解更多資訊，請在 pub.dev 上查看 <a href="https://pub.dev/packages/dartdoc_test">dartdoc_test</a>。</p>
<h3 id="使用-FFIgenPad-在-Web-上使用-WASM-產生-dart-ffi-綁定"><a href="#使用-FFIgenPad-在-Web-上使用-WASM-產生-dart-ffi-綁定" class="headerlink" title="使用 FFIgenPad 在 Web 上使用 WASM 產生 dart:ffi 綁定"></a>使用 FFIgenPad 在 Web 上使用 WASM 產生 dart:ffi 綁定</h3><p><em>作者：TheComputerM</em></p>
<p>Dart 作為一種可以編譯成各種目標的語言，包含了促進與原生二進位制檔案通訊的功能。您可以使用 <a href="https://dart.dev/interop/c-interop">dart:ffi</a> 等套件與 C API 互動，並使用 <a href="https://pub.dev/packages/jni">package:jni</a> 與 Java 程式碼互動。您只需編寫一些黏合程式碼來指定您正在呼叫的原生函數的類型簽章。</p>
<p>當您使用一個具有許多匯出的函式庫時，問題就出現了，手動編寫太多匯出。這個問題可以使用 <a href="https://pub.dev/packages/ffigen">ffigen</a>（一個先前的 GSoC 專案）來解決，這是一個僅使用函式庫的標頭檔來產生綁定的工具。要做到這一點，您必須安裝 ffigen，設定所有正確的依賴項和需求，然後（可能）一次又一次地迭代。這並不是無縫且簡單的定義。因此，FFIgenPad 誕生了。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*sB2hJW3ZkMCeF9Mp" />
</figure>

<p>該專案的另一個目標是測試 dart2wasm 編譯器（您可以在 <a href="https://thecomputerm.hashnode.dev/dirty-deeds-done-dart-cheap-experiments-with-dart2wasm">此部落格文章</a> 中找到我的實驗）。當然，我們可以在伺服器上運行 ffigen，並在其上放置一個 UI。相反，我透過將 libclang 和 ffigen 都編譯成 WebAssembly 來確保 FFIgenPad 完全在瀏覽器上運行（當您可以使用客戶端的系統時，為什麼還要使用伺服器進行計算）。</p>
<p>在 <a href="https://ffigenpad.surge.sh/">https://ffigenpad.surge.sh/</a> 查看演示，並在 GitHub 上的 <a href="https://github.com/TheComputerM/dart-native/tree/ffigenpad">我的分支</a> 中查看原始程式碼。我要感謝我的導師 Prerak Mann、Daco Harkes 和 Jackson Gardner，感謝他們在我請求幫助時隨時提供協助。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ae925357d2d7" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/google-summer-of-code-2024-results-ae925357d2d7">Google 暑期程式碼計劃 2024 成果</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/14c13b13.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/14c13b13.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Dart 3.5, and an update on the Dart roadmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-06 18:02:40" itemprop="dateCreated datePublished" datetime="2024-08-06T18:02:40+08:00">2024-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-18 12:36:40" itemprop="dateModified" datetime="2024-12-18T12:36:40+08:00">2024-12-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 2.0 自動翻譯產生】</p>
<h2 id="宣布-Dart-3-5-和-Dart-路線圖更新"><a href="#宣布-Dart-3-5-和-Dart-路線圖更新" class="headerlink" title="宣布 Dart 3.5 和 Dart 路線圖更新"></a>宣布 Dart 3.5 和 Dart 路線圖更新</h2><p>我們又到了季度 Dart SDK 發佈的時間。我們在互操作性方面進行了改進，在我們的 pub.dev 套件管理器中加入了新功能，並且我們已將新的 Web 整合 API 升級到穩定版和 1.0 版。</p>
<p>我們的大部分時間都花在更大、跨多個季度的努力上，因此我們也更新了 Dart 路線圖，詳細說明了我們希望在未來幾個季度取得的進展。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PVj9TIzP50I00tavJqAg_Q.gif" />
<figcaption>Dart 3.5 發佈圖片。</figcaption>
</figure>

<h3 id="Dart-3-5-的新功能"><a href="#Dart-3-5-的新功能" class="headerlink" title="Dart 3.5 的新功能"></a>Dart 3.5 的新功能</h3><p>Dart 3.5 具有以下討論的許多新功能。核心函式庫 API 也有一些較小的變更，以及大約 10 個非常小的重大變更，這些變更涵蓋在 <a href="https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md#350">變更日誌</a> 中。</p>
<h3 id="Web-平台和-JS-互操作性"><a href="#Web-平台和-JS-互操作性" class="headerlink" title="Web 平台和 JS 互操作性"></a>Web 平台和 JS 互操作性</h3><p>在 Dart 3.4 和 Flutter 3.22 中，我們引入了對 <a href="https://docs.flutter.dev/platform-integration/web/wasm">將 Flutter Web 應用程式編譯為 WebAssembly</a> 的支援。編譯為 WebAssembly 需要使用我們新的 <a href="https://dart.dev/interop/js-interop">Dart 到 JS 互操作模型</a>，該模型之前處於預覽階段。從 Dart 3.5 開始，它現在被認為是穩定且完整的，我們已將 <a href="https://pub.dev/packages/web">package:web</a>（它取代了舊的 dart:html 函式庫）中的瀏覽器 API 繫結更新到 1.0 版。</p>
<p>我們鼓勵所有 Web 套件作者 <a href="https://dart.dev/interop/js-interop/package-web">遷移到 package:web</a>。我們計劃在下一個 Dart 版本中棄用舊的互操作 API（dart:html、dart:js、package:js 等），並在明年晚些時候完全停止使用它們。我們邀請您在 <a href="https://github.com/dart-lang/sdk/issues/56358">追蹤議題</a> 中就此計劃提供回饋。我們還計劃更新 pub.dev 套件管理器上的 <a href="https://pub.dev/help/scoring">評分</a>，以獎勵支援新互操作模型的 Web 套件。</p>
<p>我們還加入了 <a href="https://dart.dev/tools/linter-rules/invalid_runtime_check_with_js_interop_types">一個新的 lint</a>，它驗證您的程式碼是否正確使用了新的 JS 互操作類型。我們建議您在遷移 Web 套件時將此 lint 加入到您的 analysis_options.yaml 檔案中。</p>
<h3 id="Dart-原生互操作性"><a href="#Dart-原生互操作性" class="headerlink" title="Dart 原生互操作性"></a>Dart 原生互操作性</h3><p>我們還對原生互操作性進行了一系列改進，它支援從 Dart 直接調用到 C、Java、Kotlin、Objective-C 和 Swift。</p>
<p>C 互操作由我們的 <a href="https://dart.dev/interop/c-interop">FFI</a>（外部函式介面）函式庫啟用，我們已經支援了幾年。在 Dart 3.5 中，我們進行了漸進式改進，以支援將 Dart TypedData 物件的指標直接傳遞給 FFI，避免必須先將記憶體從 Dart 複製到原生（<a href="https://github.com/dart-lang/sdk/issues/44589">詳細資訊</a>）。</p>
<p>Java 和 Kotlin 互操作由 <a href="https://pub.dev/packages/jnigen">JNIgen</a> 生成器（目前處於預覽階段）啟用，它自動建立繫結程式碼，以透過 Java 原生介面 (<a href="https://developer.android.com/training/articles/perf-jni">JNI</a>) 從 Dart 調用到 Java 和 Kotlin。我們改進了效能，並加入了對 Java 異常和 Kotlin 頂層函式的支援。我們還停止了以前的 <a href="https://github.com/dart-lang/native/issues/660">基於 C 的繫結</a>，因為現在替代的僅 Dart 繫結具有相當的效能和功能，並且更容易使用。有關詳細資訊，請參閱 <a href="https://pub.dev/packages/jnigen/changelog">變更日誌</a>。</p>
<p>Objective-C 互操作建立在 FFI 和我們的 <a href="https://pub.dev/packages/ffigen">FFIgen</a> 生成器（目前處於預覽階段）之上。我們加入了對 Objective-C 協議和常見類型（例如 NSString）的支援。有關使用 FFIgen 建立的套件的大型範例，請參閱 <a href="https://github.com/dart-lang/http/tree/master/pkgs/cupertino_http">cupertino_http</a>，它與 Apple 的 URL Loading System 網路函式庫互操作。</p>
<p>我們將繼續在未來的版本中進一步投資互操作性——無論是在完成上述函式庫方面，還是在支援 Swift 方面。有關詳細資訊，請參閱下面的路線圖部分。</p>
<h3 id="Pub-dev-套件儲存庫"><a href="#Pub-dev-套件儲存庫" class="headerlink" title="Pub.dev 套件儲存庫"></a>Pub.dev 套件儲存庫</h3><p>Pub.dev 是我們的套件儲存庫，社群可以在其中分享和找到具有豐富功能的套件。我們在這裡進行了一些改進。首先，我們改進了對 <a href="https://dart.dev/tools/pub/pubspec#topics">主題</a> 的支援：套件作者可以透過這種機制使用它們所屬的類別（例如 widget）來標記他們的套件。我們現在 <a href="https://github.com/dart-lang/pub-dev/blob/master/doc/topics.yaml">整合</a> 涵蓋相同類別但措辭略有不同的常見主題（例如 widgets vs widget）。</p>
<p>其次，我們加入了一個新的 <code>pub unpack</code> 命令。這提供了一種快速簡便的方法來將套件下載到您的檔案系統。例如，如果您想在本地機器上運行套件的範例程式，可以使用此命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ dart pub unpack path</span><br><span class="line">Downloading path 1.9.0 to `./path-1.9.0`...</span><br><span class="line"></span><br><span class="line">$ cd path-1.9.0/example/</span><br><span class="line"></span><br><span class="line">$ dart run example.dart</span><br><span class="line">Current path style: posix</span><br><span class="line">Current process path: /Users/mit/tmp/path-1.9.0/example</span><br></pre></td></tr></table></figure>

<p>第三，我們加入了一個新的 <code>pub downgrade --tighten</code> 命令。這可以用於檢查套件相依中的所有版本限制。運行時，它會將較低的限制更新為 pub 能夠解析的最低版本。</p>
<h3 id="Dart-路線圖更新"><a href="#Dart-路線圖更新" class="headerlink" title="Dart 路線圖更新"></a>Dart 路線圖更新</h3><p>除了上述已完成的功能外，我們還在許多領域開展了工作，以推進我們的長期路線圖。</p>
<h3 id="大型-monorepos-的-IDE-和分析器效能"><a href="#大型-monorepos-的-IDE-和分析器效能" class="headerlink" title="大型 monorepos 的 IDE 和分析器效能"></a>大型 monorepos 的 IDE 和分析器效能</h3><p>「monorepo」是一種常見的程式碼結構方式，用於將一組相關套件和應用程式的程式碼放在單個儲存庫中，例如 Flutter 的 <a href="https://github.com/flutter/packages/tree/main">套件儲存庫</a>。monorepo 不僅僅是為了方便將所有程式碼「放在一起」，而且還可以作為確保儲存庫中的各個套件和應用程式相互相容的關鍵工具。</p>
<p>我們一直收到在大型 monorepos 中工作的開發人員的回饋，認為我們的工具，尤其是分析器的效能可能不足。我們對這些問題的分析表明，根本原因是我們最終為每個套件及其所有相依載入了多個重疊的分析上下文，導致記憶體中同時存在多個套件分析副本。我們相信根本的解決方案是在此類儲存庫中建立每個相依版本的單個共用解析，並正在透過一個名為 <a href="https://github.com/dart-lang/sdk/issues/53875">workspaces</a> 的新 pub 功能來開發此功能。我們將在下一個 Dart 版本中分享更多關於此的資訊，但現在您可以先看看這是如何 <a href="https://github.com/flutter/engine/pull/54157/files">最近應用</a> 於 Flutter 引擎儲存庫的。</p>
<h3 id="Pub-dev-套件儲存庫-1"><a href="#Pub-dev-套件儲存庫-1" class="headerlink" title="Pub.dev 套件儲存庫"></a>Pub.dev 套件儲存庫</h3><p>pub.dev 套件儲存庫的使用者長期以來一直要求改進 <a href="https://github.com/dart-lang/pub-dev/issues/2714">每個套件的使用&#x2F;下載</a> 指標。這對於套件作者來說，可以作為一個指標，表明有多少使用者從他們的工作中受益；對於套件使用者來說，可以作為一個指標，表明其他開發人員正在使用哪些套件。我們很高興地與大家分享，我們在這項功能上取得了良好的進展，並希望在年底前推出預覽版。</p>
<h3 id="Dart-原生互操作"><a href="#Dart-原生互操作" class="headerlink" title="Dart 原生互操作"></a>Dart 原生互操作</h3><p>對於使用 JNIgen 的 Java 和 Kotlin 互操作，我們預計將在接下來的兩個季度內完成核心支援，並從實驗版升級到穩定版 1.0。有關詳細資訊，請參閱 <a href="https://github.com/orgs/dart-lang/projects/69/">JNIgen 追蹤器</a>。對於 ObjectiveC 互操作，我們有一個類似的目標；請參閱 <a href="https://github.com/orgs/dart-lang/projects/87">Objective-C 追蹤器</a>。</p>
<p>接下來，我們正在研究與 Swift 程式碼的直接互操作。初步實驗看起來很有希望，我們希望在明年年初加入實驗性支援。</p>
<h3 id="原生互操作和原生程式碼的捆綁"><a href="#原生互操作和原生程式碼的捆綁" class="headerlink" title="原生互操作和原生程式碼的捆綁"></a>原生互操作和原生程式碼的捆綁</h3><p>在許多情況下，直接互操作用於調用到作業系統中存在的 API，這意味著這些 API 在這些主機平台上始終可用。但是，在某些情況下，Dart 互操作的程式碼是主機上未直接包含的原生<em>程式碼</em>，這對使用此類互操作的套件作者提出了一個實際挑戰：如何在不將大量手動步驟推給套件使用者的情況下捆綁和構建該原生程式碼？為了支援這一點，我們正在探索一個 <a href="https://github.com/dart-lang/sdk/issues/50565">原生資源系統</a>，它可以支援發佈包含原生程式碼的 Dart 套件，以及一個標準化協議，以啟用 dart 和 flutter CLI 工具自動構建和捆綁該程式碼。我們預計這將啟用一組新的互操作使用案例，同時為使用依賴原生程式碼的套件的開發人員提供簡單的使用者體驗。</p>
<h3 id="Dart-語言和巨集"><a href="#Dart-語言和巨集" class="headerlink" title="Dart 語言和巨集"></a>Dart 語言和巨集</h3><p>Dart 語言和編譯器團隊目前的大部分時間都花在推進大型語言功能巨集上，我們在 <a href="https://medium.com/dartlang/dart-3-4-bd8d23b4462a">Dart 3.4 部落格文章</a> 中介紹了巨集。正如我們當時所說，這是一項巨大的任務，可能會在我們的一些核心使用案例（例如熱重載）中造成回歸，因此我們正在採取一種徹底的方法，並且在我們能夠分享下一步的詳細資訊之前，可能需要幾個季度的進一步工作。</p>
<p>除了巨集之外，我們還同時探索許多其他較小的語言功能，如 <a href="https://github.com/orgs/dart-lang/projects/90/views/1">Dart 語言漏斗</a> 中所述。</p>
<p>自去年秋季以來，我們一直在重寫 Dart 格式化程式。舊的設計在很多年裡都運行良好，但隨著 Flutter 的成功，我們希望轉向 <a href="https://github.com/dart-lang/dart_style/issues/1253">一種新風格</a>，這種風格更適合 Flutter 使用者經常撰寫的宣告式程式碼。舊的格式化程式無法產生這種輸出。重寫工作接近完成，很快就會發佈。如果您想試用它，請傳遞實驗旗標 tall-style（<a href="https://dart.dev/tools/experiment-flags">旗標說明</a>）。如果您看到奇怪的輸出，歡迎提供 <a href="https://github.com/dart-lang/dart_style/issues">回饋</a>。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>這就是我們今天要分享的全部內容。我們歡迎您提供回饋，無論是關於討論的路線圖項目，還是關於 Dart 3.5 中的新功能，這些功能可以從 <a href="https://dart.dev/get-dart">Dart.dev</a> 獲取，或捆綁在今天的 <a href="https://medium.com/flutter/whats-new-in-flutter-3-24-6c040f87d1e4">Flutter 3.24 版本</a> 中。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6ca36259fa2f" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/dart-3-5-6ca36259fa2f">宣布 Dart 3.5 和 Dart 路線圖更新</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/8ddf18fb.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/8ddf18fb.html" class="post-title-link" itemprop="url">【文章翻譯】Getting started with Flutter GPU</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-08-06 18:02:39" itemprop="dateCreated datePublished" datetime="2024-08-06T18:02:39+08:00">2024-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 01:40:49" itemprop="dateModified" datetime="2024-09-30T01:40:49+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="在-Flutter-中建立自訂渲染器並渲染-3D-場景。"><a href="#在-Flutter-中建立自訂渲染器並渲染-3D-場景。" class="headerlink" title="在 Flutter 中建立自訂渲染器並渲染 3D 場景。"></a>在 Flutter 中建立自訂渲染器並渲染 3D 場景。</h2><p>Flutter 3.24 版本引進了一個新的低階圖形 API，稱為 <a href="https://github.com/flutter/engine/blob/main/docs/impeller/Flutter-GPU.md">Flutter GPU</a>。還有一個由 Flutter GPU 支援的 3D 渲染函式庫，稱為 <a href="https://pub.dev/packages/flutter_scene">Flutter Scene</a>（套件：flutter_scene）。Flutter GPU 和 Flutter Scene 目前都處於預覽階段，僅在 Flutter 的 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a> 上可用（由於依賴實驗性功能），需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>，並且可能偶爾會引入重大變更。</p>
<p>本文包含這兩個套件的兩個「入門」指南：</p>
<ol>
<li>🔺 <strong>進階：</strong><a href="#d558">使用 Flutter GPU 入門</a><br>如果您是經驗豐富的圖形程式設計師，或者您對低階圖形感興趣，並想在 Flutter 中從頭開始建立渲染器，那麼本指南將幫助您開始使用 Flutter GPU。您將從頭開始繪製第一個三角形… 在 Flutter 中！</li>
<li>💚 <strong>中級：</strong><a href="#6b35">使用 Flutter Scene 進行 3D 渲染</a><br>如果您是想要將 3D 功能添加到應用程式中的 Flutter 開發人員，或者您想要使用 Dart 和 Flutter 建立 3D 遊戲，那麼本指南適合您！您將設定一個專案，在 Flutter 中匯入和渲染 3D 資產。</li>
</ol>
<h3 id="使用-Flutter-GPU-入門"><a href="#使用-Flutter-GPU-入門" class="headerlink" title="使用 Flutter GPU 入門"></a>使用 Flutter GPU 入門</h3><p>⚠️ 警告！⚠️ Flutter GPU 最終是一個低階 API。絕大多數將從 Flutter GPU 的存在中受益的 Flutter 開發人員很可能會透過使用在 pub.dev 上發佈的更高階渲染函式庫來做到這一點，例如 Flutter Scene 渲染套件。如果您對 Flutter GPU API 本身不感興趣，而只是對 3D 渲染感興趣，請跳到 <a href="#6b35">使用 Flutter Scene 進行 3D 渲染</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/900/0*hAqIOVkaI1IWnOHE" />
<figcaption>哦，真閃亮。這是一個射線行進的符號距離場。您可以使用 Flutter GPU 渲染它，但使用 [自訂片段著色器](https://docs.flutter.dev/ui/design/graphics/fragment-shaders) 也完全有可能。 </figcaption>
</figure>

<h3 id="使用-Flutter-GPU-入門-1"><a href="#使用-Flutter-GPU-入門-1" class="headerlink" title="使用 Flutter GPU 入門"></a>使用 Flutter GPU 入門</h3><p>Flutter GPU 是 Flutter 內建的低階圖形 API。它允許您透過撰寫 Dart 程式碼和 GLSL 著色器在 Flutter 中建立和整合自訂渲染器。不需要原生平台程式碼。</p>
<p>目前，Flutter GPU 處於早期預覽階段，並提供基本的柵格化 API，但隨著 API 逐漸穩定，將會繼續新增和改進更多功能。</p>
<p>Flutter GPU 還需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。這表示它只能在 Impeller 支援的平台上使用。在撰寫本文時，Impeller 支援：</p>
<ul>
<li>iOS（預設啟用）</li>
<li>macOS（選擇性預覽）</li>
<li>Android（選擇性預覽）</li>
</ul>
<p>我們對 Flutter GPU 的目標是最終支援所有 Flutter 的平台目標。最終目標是促進 Flutter 中跨平台渲染解決方案的生態系統，這些解決方案對於套件作者來說易於維護，對於使用者來說易於安裝。</p>
<p>3D 渲染只是一個可能的用例。Flutter GPU 也可以用於建立專用的 2D 渲染器，或者執行更非正統的操作，例如渲染 4D 空間的 3D 切片，或投影非歐幾里德空間。</p>
<p>由 Flutter GPU 支援的自訂 2D 渲染器的絕佳用例範例將是依賴骨骼網格變形的 2D 角色動畫格式。Spine 2D 就是一個很好的例子。這種骨骼網格解決方案通常具有動畫剪輯，這些剪輯會操縱層次結構中骨骼的平移、旋轉和縮放屬性，並且每個頂點都具有一些關聯的「骨骼權重」，這些權重決定哪些骨骼應該影響頂點，以及影響程度。</p>
<p>使用像 drawVertices 這樣的 Canvas 解決方案，需要在 CPU 上對每個頂點應用骨骼權重轉換。使用 Flutter GPU，骨骼轉換可以以統一陣列或甚至紋理取樣器的形式傳遞到頂點著色器，允許根據骨骼狀態和每個頂點的骨骼權重在 GPU 上並行計算每個頂點的最終位置。</p>
<p>說到此，讓我們透過一個溫和的介紹來開始使用 Flutter GPU：繪製您的第一個三角形！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JEI3fLDGcRHWKruT" />
</figure>

<h3 id="將-Flutter-GPU-加入您的專案"><a href="#將-Flutter-GPU-加入您的專案" class="headerlink" title="將 Flutter GPU 加入您的專案"></a>將 Flutter GPU 加入您的專案</h3><p>首先，請注意 Flutter GPU 目前處於早期預覽狀態，可能會發生 API 斷裂。目前 API 已經可以實現很多功能，但是有經驗的圖形工程師可能會注意到一些缺失的常見功能。Flutter GPU 在接下來的幾個月裡將會新增許多功能。</p>
<p>基於這些原因，強烈建議您在針對 Flutter GPU 開發套件時，暫時使用 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a> 的頂端。如果您遇到任何意外行為、錯誤或有功能請求，請使用標準的 <a href="https://github.com/flutter/flutter/issues/new/choose">Flutter 問題範本</a> 在 GitHub 上提交問題。與 Flutter GPU 相關的所有追蹤問題都標記為 <a href="https://github.com/flutter/flutter/labels/flutter-gpu">flutter-gpu 標籤</a>。</p>
<p>因此，在試驗 Flutter GPU 之前，請透過執行以下命令將 Flutter 切換到 main channel。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>現在建立一個新的 Flutter 專案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_cool_renderer</span><br><span class="line">cd my_cool_renderer</span><br></pre></td></tr></table></figure>

<p>接下來，將 flutter_gpu SDK 套件加入到您的 pubspec 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu --sdk=flutter</span><br></pre></td></tr></table></figure>

<h3 id="建立和匯入著色器捆綁包。"><a href="#建立和匯入著色器捆綁包。" class="headerlink" title="建立和匯入著色器捆綁包。"></a>建立和匯入著色器捆綁包。</h3><p>為了使用 Flutter GPU 渲染任何東西，您需要撰寫一些 GLSL 著色器。Flutter GPU 的著色器與 Flutter 的 <a href="https://docs.flutter.dev/ui/design/graphics/fragment-shaders">片段著色器</a> 功能所使用的著色器具有不同的語義，特別是在統一繫結方面。您還需要定義一個頂點著色器，與片段著色器一起使用。</p>
<p>從定義最簡單的著色器開始。您可以將著色器放置在專案中的任何位置，但是對於此範例，請建立一個 shaders 目錄，並使用兩個著色器填充它：simple.vert 和 simple.frag。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：shaders/simple.vert</span><br><span class="line"></span><br><span class="line">in vec2 position;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  gl_Position = vec4(position, 0.0, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在繪製三角形時，您將擁有一個定義每個頂點的資料列表。在本例中，它僅列出 2D 位置。對於這些頂點中的每一個，簡單的頂點著色器都會將這些 2D 位置分配給剪輯空間輸出內在 gl_Position。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：shaders/simple.frag</span><br><span class="line"></span><br><span class="line">out vec4 frag_color;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  frag_color = vec4(0, 1, 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片段著色器甚至更簡單；它輸出一個 RGBA 顏色，範圍為 (0, 0, 0, 0) 到 (1, 1, 1, 1)。因此，所有內容都將被著色為綠色。</p>
<p>好的，現在您有了著色器，請使用 Flutter 的提前編譯 (AOT) 著色器編譯器將它們編譯。為了為著色器捆綁包設定自動化的建置，我們建議您使用 <a href="https://pub.dev/packages/flutter_gpu_shaders">flutter_gpu_shaders</a> 套件。</p>
<p>使用 pub 將 flutter_gpu_shaders 作為專案中的常規相依性加入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_gpu_shaders</span><br></pre></td></tr></table></figure>

<p>Flutter GPU 著色器捆綁到 .shaderbundle 檔案中，可以作為常規資產添加到專案的資產捆綁包中。著色器捆綁包包含針對平台目標的編譯著色器來源。</p>
<p>接下來，建立一個著色器捆綁包宣告檔案，描述著色器捆綁包的內容。將以下內容添加到專案根目錄中的 my_renderer.shaderbundle.json。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;SimpleVertex&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;vertex&quot;,</span><br><span class="line">        &quot;file&quot;: &quot;shaders/simple.vert&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;SimpleFragment&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;fragment&quot;,</span><br><span class="line">        &quot;file&quot;: &quot;shaders/simple.frag&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>著色器捆綁包中的每個條目都可以具有任意名稱。在本例中，名稱是「SimpleVertex」和「SimpleFragment」。這些名稱用於在您的應用程式中查找著色器。</p>
<p>接下來，使用 flutter_gpu_shaders 套件建置 shaderbundle。您可以透過啟用實驗性的「原生資產」功能來新增一個掛鉤，該掛鉤會自動觸發建置。使用以下命令來啟用原生資產並安裝 native_assets_cli 套件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>

<p>啟用原生資產功能後，在掛鉤目錄下新增一個 build.dart 脚本，它將自動觸發建置著色器捆綁包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：hook/build.dart</span><br><span class="line"></span><br><span class="line">import &#x27;package:native_assets_cli/native_assets_cli.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_gpu_shaders/build.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) async &#123;</span><br><span class="line">  await build(args, (config, output) async &#123;</span><br><span class="line">    await buildShaderBundleJson(</span><br><span class="line">        buildConfig: config,</span><br><span class="line">        buildOutput: output,</span><br><span class="line">        manifestFileName: &#x27;my_renderer.shaderbundle.json&#x27;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>進行此更改後，當 Flutter 工具建置專案時，buildShaderBundleJson 將建置著色器捆綁包，並將結果輸出到套件根目錄下的 build&#x2F;shaderbundles&#x2F;my_renderer.shaderbundle。</p>
<p>著色器捆綁包格式本身與您使用的 Flutter 特定版本綁定，並且可能會隨著時間推移而改變。如果您正在撰寫一個建置著色器捆綁包的套件，請不要將生成的 .shaderbundle 檔案檢查到您的原始碼樹中。相反，請使用建置掛鉤來自動化建置流程（如前所述）。</p>
<p>這樣一來，使用您函式庫的開發人員將始終使用正確格式建置新的著色器捆綁包！</p>
<p>現在，您已經自動化了著色器捆綁包的建置，請像常規資產一樣匯入它。將資產條目添加到專案的 pubspec.yaml 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  assets:</span><br><span class="line">    - build/shaderbundles/</span><br></pre></td></tr></table></figure>

<p>在未來，原生資產功能將允許建置掛鉤將資料資產附加到捆綁包中。一旦發生這種情況，就不需要再在建置掛鉤旁邊新增資 * * * * *產匯入規則了。</p>
<p>接下來，新增一些程式碼，在執行時載入著色器。建立 lib&#x2F;shaders.dart 並新增以下程式碼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 複製到：lib/shaders.dart</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter_gpu/gpu.dart&#x27; as gpu;</span><br><span class="line"></span><br><span class="line">const String _kShaderBundlePath =</span><br><span class="line">    &#x27;build/shaderbundles/my_renderer.shaderbundle&#x27;;</span><br><span class="line">// 注意：如果您正在建立函式庫，則路徑必須以套件名稱為前綴</span><br><span class="line">//      例如：</span><br><span class="line">//      &#x27;packages/my_cool_renderer/build/shaderbundles/my_renderer.shaderbundle&#x27;</span><br><span class="line"></span><br><span class="line">gpu.ShaderLibrary? _shaderLibrary;</span><br><span class="line">gpu.ShaderLibrary get shaderLibrary &#123;</span><br><span class="line">  if (_shaderLibrary != null) &#123;</span><br><span class="line">    return _shaderLibrary!;</span><br><span class="line">  &#125;</span><br><span class="line">  _shaderLibrary = gpu.ShaderLibrary.fromAsset(_kShaderBundlePath);</span><br><span class="line">  if (_shaderLibrary != null) &#123;</span><br><span class="line">    return _shaderLibrary!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  throw Exception(&quot;Failed to load shader bundle! ($_kShaderBundlePath)&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼為 Flutter GPU 著色器執行時函式庫建立一個單例 getter。第一次訪問 shaderLibrary 時，會使用 gpu.ShaderLibrary.fromAsset(shader_bundle_path) 使用建置的資產捆綁包初始化執行時著色器函式庫。</p>
<p>專案現在已經設定好使用 Flutter GPU 著色器。是時候渲染那個三角形了！</p>
<h3 id="绘制您的第一個三角形"><a href="#绘制您的第一個三角形" class="headerlink" title="绘制您的第一個三角形"></a>绘制您的第一個三角形</h3><p>對於本指南，您將建立一個 RGBA Flutter GPU 紋理和一個 RenderPass，將紋理作為顏色輸出附加到它。然後，您將使用 <a href="https://api.flutter.dev/flutter/dart-ui/Canvas/drawImage.html">Canvas.drawImage</a> 在 Widget 中渲染紋理。</p>
<p>為了簡潔起見，您將放棄最佳實務，只會為每一幀重新建置所有資源。</p>
<p>只要您在分配紋理時將其標記為「著色器可讀取」，您就可以將其轉換為 dart:ui.Image。若要將渲染結果顯示在 Widget 樹中，請將其繪製到 dart:ui.Canvas 上！</p>
<p>您可以透過使用自訂畫家為 Widget 樹架設腳手架來存取 Canvas。將 lib&#x2F;main.dart 的內容替換為以下內容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:typed_data&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_gpu/gpu.dart&#x27; as gpu;</span><br><span class="line"></span><br><span class="line">// 注意：我們之前在設定著色器捆綁包匯入時建立了它!</span><br><span class="line">import &#x27;shaders.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &#x27;Flutter GPU Triangle Example&#x27;,</span><br><span class="line">      home: CustomPaint(</span><br><span class="line">        painter: TrianglePainter(),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrianglePainter extends CustomPainter &#123;</span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    // 嘗試存取 `gpu.gpuContext`。</span><br><span class="line">    // 如果 Flutter GPU 不受支援，將會拋出異常。</span><br><span class="line">    print(&#x27;Default color format: &#x27; +</span><br><span class="line">        gpu.gpuContext.defaultColorFormat.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在，執行應用程式。提醒一下，Flutter GPU 目前需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。因此，您必須使用 Impeller 支援的平台。對於本指南，我將以 macOS 為目標。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*lKTtaX2ih6dFpSMQ" />
</figure>

<p>如果 Flutter GPU 正常工作，那麼您應該會看到預設顏色格式被列印到主控台中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter: Default color format: PixelFormat.b8g8r8a8UNormInt</span><br></pre></td></tr></table></figure>

<p>如果 Impeller 未啟用，則在嘗試存取 gpu.gpuContext 時會拋出異常。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception: Flutter GPU requires the Impeller rendering backend to be enabled.</span><br><span class="line"></span><br><span class="line">The relevant error-causing widget was:</span><br><span class="line">  CustomPaint</span><br></pre></td></tr></table></figure>

<p>為了簡便起見，您只會從這裡開始修改 paint 方法。</p>
<p>首先，建立一個 Flutter GPU 紋理，清除它，然後透過將其繪製到 Canvas 上來顯示它。</p>
<p>建立一個與 Canvas 大小相同的紋理。必須選擇一個 <code>StorageMode</code>。在本例中，您將紋理標記為 devicePrivate，因為您將只使用從設備 (GPU) 存取紋理記憶體的指令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final texture = gpu.gpuContext.createTexture(gpu.StorageMode.devicePrivate,</span><br><span class="line">    size.width.toInt(), size.height.toInt())!;</span><br></pre></td></tr></table></figure>

<p>如果透過從主機 (CPU) 上傳資料來覆蓋紋理的資料，則使用 <code>StorageMode.hostVisible</code>。</p>
<p>第三個可用的選項是 <code>StorageMode.deviceTransient</code>，它對於不需要超過單個 RenderPass 壽命的附件很有用（因此它們可以只存在於瓦片記憶體中，並且不需要由 VRAM 分配支援）。通常，深度&#x2F;模板紋理符合此標準。</p>
<p>接下來，定義一個 <code>RenderTarget</code>。渲染目標包含一組「附件」，描述每個片段的記憶體佈局及其在 RenderPass 開始和結束時的設定&#x2F;拆卸行為。</p>
<p>本質上，RenderTarget 是 RenderPass 的可重複使用描述器。</p>
<p>現在，定義一個非常簡單的 <code>RenderTarget</code>，它只包含一個顏色附件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final renderTarget = gpu.RenderTarget.singleColor(</span><br><span class="line">gpu.ColorAttachment(texture: texture, clearValue: Colors.lightBlue));</span><br></pre></td></tr></table></figure>

<p>請注意，此程式碼將 clearValue 設定為淡藍色。每個附件都具有 <code>LoadAction</code> 和 <code>StoreAction</code>，它們分別確定在傳遞的開始和結束時應該對附件的臨時瓦片記憶體執行什麼操作。</p>
<p>預設情況下，顏色附件被設定為 <code>LoadAction.clear</code>（它將瓦片記憶體初始化為給定的顏色）和 <code>StoreAction.store</code>（它將結果儲存到附加的紋理的 VRAM 分配中）。</p>
<p>現在，建立一個 <code>CommandBuffer</code>，使用前面的 RenderTarget 從其中產生一個 RenderPass，然後立即提交 CommandBuffer 以清除紋理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final commandBuffer = gpu.gpuContext.createCommandBuffer();</span><br><span class="line">final renderPass = commandBuffer.createRenderPass(renderTarget);</span><br><span class="line">// ... 繪製調用將放在這裡!</span><br><span class="line">commandBuffer.submit();</span><br></pre></td></tr></table></figure>

<p>剩下的就是將初始化的紋理繪製到 Canvas 上！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final image = texture.asImage();</span><br><span class="line">canvas.drawImage(image, Offset.zero, Paint());</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ebUDtzQOuIGmdlop" />
</figure>

<p>現在您有了連接到螢幕顯示結果的 RenderPass，您就可以開始繪製三角形了。若要執行此操作，請設定以下內容：</p>
<ol>
<li>從著色器建立的 RenderPipeline，以及</li>
<li>包含幾何形狀的 GPU 可存取緩衝區（三個頂點位置）。</li>
</ol>
<p>建立 RenderPipeline 很容易。您只需將函式庫中的頂點和片段著色器組合在一起。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">final vert = shaderLibrary[&#x27;SimpleVertex&#x27;]!;</span><br><span class="line">final frag = shaderLibrary[&#x27;SimpleFragment&#x27;]!;</span><br><span class="line">final pipeline = gpu.gpuContext.createRenderPipeline(vert, frag);</span><br></pre></td></tr></table></figure>

<p>現在是幾何形狀。回想一下，「SimpleVertex」著色器只有一個輸入：<code>in vec2 position</code>。因此，若要繪製三個頂點，您需要三組兩個浮點數。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final vertices = Float32List.fromList([</span><br><span class="line">  -0.5, -0.5, // 第一個頂點</span><br><span class="line">   0.5, -0.5, // 第二個頂點</span><br><span class="line">   0.0,  0.5, // 第三個頂點</span><br><span class="line">]);</span><br><span class="line">final verticesDeviceBuffer = gpu.gpuContext</span><br><span class="line">    .createDeviceBufferWithCopy(ByteData.sublistView(vertices))!;</span><br></pre></td></tr></table></figure>

<p>剩下的就是繫結新的資源，並呼叫 renderPass.draw() 以完成記錄繪製調用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renderPass.bindPipeline(pipeline);</span><br><span class="line"></span><br><span class="line">final verticesView = gpu.BufferView(</span><br><span class="line">  verticesDeviceBuffer,</span><br><span class="line">  offsetInBytes: 0,</span><br><span class="line">  lengthInBytes: verticesDeviceBuffer.sizeInBytes,</span><br><span class="line">);</span><br><span class="line">renderPass.bindVertexBuffer(verticesView, 3);</span><br><span class="line"></span><br><span class="line">renderPass.draw();</span><br></pre></td></tr></table></figure>

<p>如果您啟動應用程式，您現在應該會看到一個綠色的三角形！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LWnGU5WPT_Eom0wJ" />
</figure>

<p>太棒了，您使用 Flutter、Dart 和一點 GLSL 從頭開始建立了一個渲染器！</p>
<p>無論這是否是您第一次渲染三角形，或者您是經驗豐富的圖形專家，我都希望您能繼續使用 Flutter GPU，並查看我們正在開發的套件，例如 Flutter Scene。</p>
<p>在未來，我們希望發佈友好的初學者程式碼實驗室，深入探討 Flutter GPU 的預設行為和最佳實務。我們還沒討論頂點屬性佈局、紋理繫結、統一和對齊要求、管道混合、深度和模板附件、透視校正等等！</p>
<p>在那之前，我建議您探索 <a href="https://github.com/bdero/flutter_scene">Flutter Scene</a> 作為如何使用 Flutter GPU 的更全面的範例。</p>
<h3 id="使用-Flutter-Scene-進行-3D-渲染"><a href="#使用-Flutter-Scene-進行-3D-渲染" class="headerlink" title="使用 Flutter Scene 進行 3D 渲染"></a>使用 Flutter Scene 進行 3D 渲染</h3><p>Flutter Scene（套件 flutter_scene）是一個新的 3D 場景圖套件，由 Flutter GPU 支援，它使 Flutter 開發人員能夠匯入動畫 glTF 模型並渲染即時 3D 場景。</p>
<p>目的是提供一個套件，讓在 Flutter 中輕鬆建立互動式 3D 應用程式和遊戲。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tC68CbPLef2rJp1e" />
</figure>

<p>該套件最初是作為一個 dart:ui 擴展，用於用 C++ 編寫的 3D 渲染器，並直接建置到 Flutter 的原生執行時中，但它已經使用更靈活的介面針對 Flutter GPU 重新撰寫。</p>
<p>與 Flutter GPU API 本身一樣，Flutter Scene 目前處於早期預覽狀態，需要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>。Flutter Scene 通常與 Flutter GPU API 的重大變更保持同步，因此強烈建議您在試驗 Flutter Scene 時使用 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a>。</p>
<p>接下來，使用 Flutter Scene 建立一個應用程式！</p>
<h3 id="設定-Flutter-Scene-專案"><a href="#設定-Flutter-Scene-專案" class="headerlink" title="設定 Flutter Scene 專案"></a>設定 Flutter Scene 專案</h3><p>由於強烈建議您針對 <a href="https://docs.flutter.dev/release/upgrade#other-channels">主頻道</a> 使用 Flutter Scene，請從切換到主頻道開始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel main</span><br><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure>

<p>接下來，建立一個新的 Flutter 專案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_3d_app</span><br><span class="line">cd my_3d_app</span><br></pre></td></tr></table></figure>

<p>Flutter Scene 依靠實驗性的「原生資產」功能來自動化著色器的建置。您將在稍後使用原生資產來設定自動匯入 Flutter Scene 的 3D 模型。</p>
<p>使用以下命令啟用原生資產。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter config --enable-native-assets</span><br></pre></td></tr></table></figure>

<p>最後，將 Flutter Scene 添加為專案相依性。</p>
<p>您還需要在與 Flutter Scene 的 API 互動時使用一些 vector_math 構造，因此也添加 vector_math 套件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene vector_math</span><br></pre></td></tr></table></figure>

<p>接下來，匯入一個 3D 模型！</p>
<h3 id="匯入-3D-模型"><a href="#匯入-3D-模型" class="headerlink" title="匯入 3D 模型"></a>匯入 3D 模型</h3><p>首先，您需要一個要渲染的 3D 模型。對於本指南，您將使用常見的 <a href="https://en.wikipedia.org/wiki/GlTF">glTF</a> 樣本資產： <a href="https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/DamagedHelmet">DamagedHelmet.glb</a>。以下是它的樣子。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/912/0*vVWRLxJ348tCxv7T" />
<figcaption>原始的 Damaged Helmet 模型由 theblueturtle_ 在 2016 年建立（授權： [CC BY-NC 4.0 國際](https://creativecommons.org/licenses/by-nc/4.0/legalcode)）。轉換後的 glTF 版本由 ctxwing 在 2018 年建立（授權： [CC BY 4.0 國際](https://creativecommons.org/licenses/by/4.0/legalcode)）。 </figcaption>
</figure>

<p>您可以從 GitHub 上託管的 <a href="https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Assets/main/Models/DamagedHelmet/glTF-Binary/DamagedHelmet.glb">glTF 樣本資產儲存庫</a> 中獲取它。將 DamagedHelmet.glb 放置在您的專案根目錄中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/main/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb</span><br></pre></td></tr></table></figure>

<p>像大多數即時 3D 渲染器一樣，Flutter Scene 在內部使用專用的 3D 模型格式。您可以使用 Flutter Scene 的離線匯入器工具將標準 glTF 二進制檔案（.glb 檔案）轉換為此格式。</p>
<p>將 flutter_scene_importer 套件作為常規相依性添加到專案中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add flutter_scene_importer</span><br></pre></td></tr></table></figure>

<p>添加此套件可以使用 dart run 手動呼叫匯入器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dart --enable-experiment=native-assets \</span><br><span class="line">     run flutter_scene_importer:import \</span><br><span class="line">     --input &quot;path/to/my/source_model.glb&quot; \</span><br><span class="line">     --output &quot;path/to/my/imported_model.model&quot;</span><br></pre></td></tr></table></figure>

<p>您可以透過使用原生資產建置掛鉤來自動執行匯入器。若要執行此操作，請先將 native_assets_cli 作為常規專案相依性安裝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter pub add native_assets_cli</span><br></pre></td></tr></table></figure>

<p>現在您可以撰寫建置掛鉤了。使用以下內容建立 hook&#x2F;build.dart。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:native_assets_cli/native_assets_cli.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene_importer/build_hooks.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main(List&lt;String&gt; args) &#123;</span><br><span class="line">  build(args, (config, output) async &#123;</span><br><span class="line">    buildModels(buildConfig: config, inputFilePaths: [</span><br><span class="line">      &#x27;DamagedHelmet.glb&#x27;,</span><br><span class="line">    ]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 flutter_scene_importer 中的 buildModels 公用程式，提供要建置的模型列表。路徑相對於專案的建置根目錄。</p>
<p>當 Flutter 工具建置專案時，buildModels 現在將建置著色器捆綁包，並將結果輸出到套件根目錄下的 build&#x2F;models&#x2F;DamagedModel.model。</p>
<p>匯入的模型格式本身與您使用的 Flutter Scene 特定版本綁定，並且會隨著時間推移而改變。在撰寫使用 Flutter Scene 的應用程式或函式庫時，請勿將生成的 .model 檔案檢查到您的原始碼樹中。相反，請使用建置掛鉤從您的原始模型中生成它們（如前所述）。</p>
<p>這樣一來，隨著時間推移升級 Flutter Scene 時，您將始終使用正確格式建置新的 .model 檔案！</p>
<p>接下來，像常規資產一樣匯入模型。將資產條目添加到專案的 pubspec.yaml 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flutter:</span><br><span class="line">  assets:</span><br><span class="line">    - build/models/</span><br></pre></td></tr></table></figure>

<p>在未來，原生資產功能將允許建置掛鉤將資料資產附加到捆綁包中。一旦發生這種情況，就不需要再在建置掛鉤旁邊新增資產匯入規則了。</p>
<h3 id="渲染-3D-場景"><a href="#渲染-3D-場景" class="headerlink" title="渲染 3D 場景"></a>渲染 3D 場景</h3><p>現在是應用程式的程式碼了。</p>
<p>首先，建立一個有狀態的 Widget，用於在多個幀中保留 Scene。</p>
<p>您將根據時間進行動畫處理，因此將 SingleTickerProviderStateMixin 添加到狀態，以及一個 elapsedSeconds 成員。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter/scheduler.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/camera.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/node.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/scene.dart&#x27;;</span><br><span class="line">import &#x27;package:vector_math/vector_math.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget&#123;</span><br><span class="line">  const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  MyAppState createState() =&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line">  double elapsedSeconds = 0;</span><br><span class="line">  Scene scene = Scene();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &#x27;My 3D app&#x27;,</span><br><span class="line">      home: Placeholder(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行應用程式作為冒煙測試，以確保沒有錯誤。請記住要 <a href="https://docs.flutter.dev/perf/impeller#availability">啟用 Impeller</a>！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/912/0*74qs6ytcTjyVHwML" />
</figure>

<p>在繼續之前，請為動畫設定計時器。覆蓋 MyAppState 中的 initState 以呼叫 createTicker。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  createTicker((elapsed) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).start();</span><br><span class="line">  </span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要 Widget 可見，計時器回呼就會為每一幀被呼叫。呼叫 setState 會觸發此 Widget 在每一幀重建。</p>
<p>接下來，載入之前放置在專案中的 3D 模型，並將其添加到 Scene 中。</p>
<p>使用 Node.fromAsset 從資產捆綁包中載入模型。將以下程式碼放置在 initState 中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">  model.name = &#x27;Helmet&#x27;;</span><br><span class="line">  scene.add(model);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Node.fromAsset 會異步地從資產捆綁包中反序列化模型，並在模型準備好添加到場景中時解析返回的 Future<Node>。</p>
<p>現在，MyAppState.initState 應該如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void initState() &#123;</span><br><span class="line">  createTicker((elapsed) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;).start();</span><br><span class="line">  </span><br><span class="line">  Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">    model.name = &#x27;Helmet&#x27;;</span><br><span class="line">    scene.add(model);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  super.initState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，您仍然沒有實際渲染 3D Scene！若要執行此操作，請使用 <code>Scene.render</code>，它需要 UI Canvas、Flutter Scene Camera 和一個大小。</p>
<p>存取 Canvas 的一種方法是建立一個 CustomPainter：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line">  ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line">  Scene scene;</span><br><span class="line">  Camera camera;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘記將 shouldRepaint 覆蓋設置為返回 true，以便在每次重建發生時自訂畫家都會重新繪畫。</p>
<p>最後，將 CustomPainter 添加到源樹中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  final painter = ScenePainter(</span><br><span class="line">    scene: scene,</span><br><span class="line">    camera: PerspectiveCamera(</span><br><span class="line">      position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line">      target: Vector3(0, 0, 0),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return MaterialApp(</span><br><span class="line">    title: &#x27;My 3D app&#x27;,</span><br><span class="line">    home: CustomPaint(painter: painter),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼指示相機沿著一個連續的圓圈移動，但始終面向原點。</p>
<p>最後，啟動應用程式！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run -d macos --enable-impeller</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/796/0*_-OFc0vhBHAhrPrO" />
</figure>

<p>以下是我們組合的完整源程式碼。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:math&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:flutter/material.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/camera.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/node.dart&#x27;;</span><br><span class="line">import &#x27;package:flutter_scene/scene.dart&#x27;;</span><br><span class="line">import &#x27;package:vector_math/vector_math.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(const MyApp());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyApp extends StatefulWidget &#123;</span><br><span class="line">  const MyApp(&#123;super.key&#125;);</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  MyAppState createState() =&gt; MyAppState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyAppState extends State&lt;MyApp&gt; with SingleTickerProviderStateMixin &#123;</span><br><span class="line">  double elapsedSeconds = 0;</span><br><span class="line">  Scene scene = Scene();</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void initState() &#123;</span><br><span class="line">    createTicker((elapsed) &#123;</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        elapsedSeconds = elapsed.inMilliseconds.toDouble() / 1000;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    Node.fromAsset(&#x27;build/models/DamagedHelmet.model&#x27;).then((model) &#123;</span><br><span class="line">      model.name = &#x27;Helmet&#x27;;</span><br><span class="line">      scene.add(model);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    super.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    final painter = ScenePainter(</span><br><span class="line">      scene: scene,</span><br><span class="line">      camera: PerspectiveCamera(</span><br><span class="line">        position: Vector3(sin(elapsedSeconds) * 3, 2, cos(elapsedSeconds) * 3),</span><br><span class="line">        target: Vector3(0, 0, 0),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &#x27;My 3D app&#x27;,</span><br><span class="line">      home: CustomPaint(painter: painter),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ScenePainter extends CustomPainter &#123;</span><br><span class="line">  ScenePainter(&#123;required this.scene, required this.camera&#125;);</span><br><span class="line">  Scene scene;</span><br><span class="line">  Camera camera;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  void paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    scene.render(camera, canvas, viewport: Offset.zero &amp; size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool shouldRepaint(covariant CustomPainter oldDelegate) =&gt; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Flutter-光明的未來"><a href="#Flutter-光明的未來" class="headerlink" title="Flutter 光明的未來"></a>Flutter 光明的未來</h3><p>如果您能夠成功地遵循這些指南中的其中一個並讓它運行起來：太棒了，恭喜！</p>
<p>Flutter GPU 和 Flutter Scene 都非常年輕，平台支援有限。但我想總有一天，我們會懷念這些不起眼的開端。</p>
<p>隨著 Impeller 的推廣，Flutter 團隊完全掌控了渲染堆疊，因為我们需要針對 Flutter 的用例專門化渲染器。現在，我們正在開啟 Flutter 歷史上的一個新篇章。一個由您共同掌控渲染的篇章！</p>
<p>Flutter Scene 最初是 Impeller 中的 C++ 組件，與 2D Canvas 渲染器一起，帶有一個精簡的 dart:ui 擴展。在我構建它時，我已經意識到 Flutter Engine 不會是它的最終目的地。</p>
<p>3D 渲染器的架構決策海洋是廣闊</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rainvisitor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">242</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">239</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rainvisitor</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
