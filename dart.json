{"2017-04-24T03:28:51.000Z":{"title":"An intro to immutability with Dart","link":"https://medium.com/dartlang/an-intro-to-immutability-with-dart-d4de871865c7?source=rss----23738d481ce8---4","guid":"https://medium.com/p/d4de871865c7","category":["javascript","dartlang","immutable","dart","functional-programming"],"dc:creator":"Matan Lurey","pubDate":"Mon, 24 Apr 2017 03:28:51 GMT","atom:updated":"2017-04-24T03:28:51.030Z","content:encoded":"<p>It’s impossible to deny that <a href=\"https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=2&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwiM4_LAjLzTAhWDKGMKHbnICLYQFggmMAE&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FImmutable_object&amp;usg=AFQjCNEkdj3g887nk6kENS9SYN-2xsqXpw&amp;sig2=hZqSkCh5MKP-OX2w8YyjvQ\">immutability</a> is a hot topic in programming, especially front-end programming. Libraries like <a href=\"https://facebook.github.io/immutable-js/\">Immutable.js</a> and other concepts like unidirectional data flow have argued it’s easier to reason about data when it doesn’t change underneath you:</p><blockquote>In object-oriented and functional programming, an <strong>immutable</strong> object (unchangeable object) is an object whose state cannot be modified after it is created. This is in contrast to a mutable object (changeable object), which can be modified after it is created.</blockquote><p>Well, what about Dart? We have a couple concepts that lend themselves well to immutability and immutable objects built-in, starting with the <em>const</em> modifier and <em>const</em> constructor. Not to be confused with <em>const</em> in ES6, which is merely an immutable binding:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ea74deee818166289d71ec2e853c434b/href\">https://medium.com/media/ea74deee818166289d71ec2e853c434b/href</a></iframe><p>In Dart, <em>const</em> is both an immutable binding <em>and</em> an immutable object:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b5c3e18a4ded4290dc78862cec944a62/href\">https://medium.com/media/b5c3e18a4ded4290dc78862cec944a62/href</a></iframe><p>All literals (<em>Null, String, int, double, num, bool, Map, List, Symbol</em>) are capable of being <em>const</em>, and it’s possible to create user-types with a <em>const</em> constructor:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/edfbe695485a73786e4f6746cb8ca8d2/href\">https://medium.com/media/edfbe695485a73786e4f6746cb8ca8d2/href</a></iframe><p>Let’s review — <em>const</em> instances are both immutable bindings and <em>enforced</em> at a language level to be both deeply immutable — and also are <em>canonicalized </em>at compile-time — that is, any two instances are considered equivalent, and are only represented by a single instance when running. For example, the following is rather cheap — it only allocates a single instance at runtime:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/0e956977444eba775eb2be11833f0b5c/href\">https://medium.com/media/0e956977444eba775eb2be11833f0b5c/href</a></iframe><p>Want to learn more? <a href=\"https://www.dartlang.org/guides/language/language-tour#final-and-const\">Read the Dart language tour about final and const</a>.</p><h3>Further static checking with package:meta</h3><p>Of course, <em>const</em> is a bit restrictive — you must be able to create a class at compile-time — so you couldn’t for example read a database and create <em>const</em> objects at runtime. We’ve recently introduced the “immutable” annotation with <a href=\"https://pub.dartlang.org/packages/meta\">package:meta</a>:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/41b36ef3a895268ca40ff6309867409e/href\">https://medium.com/media/41b36ef3a895268ca40ff6309867409e/href</a></iframe><p>You can use this annotation to help enforce that developers keep your classes deeply immutable. It won’t be canonicalized like <em>const</em>, but can still be quite helpful for developers.</p><p>I hope this was a nice introduction to immutability. Please let me know in the comments or on twitter if you’d like to learn more about Dart or immutability.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d4de871865c7\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/an-intro-to-immutability-with-dart-d4de871865c7\">An intro to immutability with Dart</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2017-04-19T23:26:15.000Z":{"title":"Evolving the Dart REPL PoC","link":"https://medium.com/dartlang/evolving-dart-repl-poc-233440a35e1f?source=rss----23738d481ce8---4","guid":"https://medium.com/p/233440a35e1f","category":["prototyping","software-development","programming","javascript","google"],"dc:creator":"Andreas Kirsch","pubDate":"Wed, 19 Apr 2017 23:26:15 GMT","atom:updated":"2017-04-19T23:53:14.965Z","content:encoded":"<h4>Hacking with Dart</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/400/0*VisHHMp_ARvFA08w.jpg\" /></figure><p>The <a href=\"https://github.com/BlackHC/dart_repl\">Dart REPL</a> allows you to evaluate Dart expressions and statements in an <a href=\"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop\">interactive shell</a>. It has been awhile since <a href=\"https://medium.com/dartlang/dart-repl-poc-f327e3769b6f\">my first post about the Dart REPL</a> (you don’t need to read it to enjoy this post), and lots of features are still missing. In particular, dynamic imports and support for top-level declarations would be very useful, so let’s look into how to support them.</p><p><em>Disclaimer: I do work for Google, but this post is about a personal project. I’m not on the Dart team or related. This article only contains my humble personal opinion.</em></p><p><strong>tl;dr</strong>: Code and instructions on how to run the Dart REPL can be found at <a href=\"https://github.com/BlackHC/dart_repl\">https://github.com/BlackHC/dart_repl</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/500/0*pmcEIyli_y3CLPCi.jpg\" /></figure><h3>Hot reload</h3><p>For <a href=\"https://flutter.io/\">Flutter</a>, a cool new feature has been added to the Dart VM: <a href=\"https://github.com/flutter/flutter/wiki/Hot-Reload\"><strong>hot reload</strong></a>. There is an entertaining YouTube clip from the Dart DevSummit that explains and shows it in detail:</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FiPlPk43RbpA%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DiPlPk43RbpA&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FiPlPk43RbpA%2Fhqdefault.jpg&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/824f2944e1d202f35f9a5dde00aeb762/href\">https://medium.com/media/824f2944e1d202f35f9a5dde00aeb762/href</a></iframe><p>Hot reload allows you to change your code while your program is running. The Dart VM will pick up the changes you’ve made and try to apply them while keeping everything running. And if it can’t, it will tell you why. This is very cool! In the spirit of hacking Dart to do great things, let us ponder how we can use this to implement the new features.</p><h4>Why can’t we import new libraries in the current version of the REPL?</h4><p>The REPL uses Dart’s VM service to evaluate expressions. Sadly, importing a library is not expression in Dart, so we can’t just evaluate it in that context. However, we can change the code of the REPL’s sandbox while it is running to import a new library and then we could just trigger a hot reload to update the REPL. Does this work? It actually does \\o/</p><figure><a href=\"https://asciinema.org/a/114834\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/505/1*3Zj7w3g1jNI_SXtkvM8-Lg.gif\" /></a><figcaption>Dart REPL with runtime imports</figcaption></figure><p>But wait: another thing that we can’t do by evaluating expressions via the VM service is creating new classes and functions. In fact, none of Dart’s top-level declarations can be executed by evaluating an expression for this reason.</p><h3>How can we allow top-level declarations?</h3><p>Of course, we could use the same idea described above to also add a new class or a global function. However, anyone who has used IPython or similar for a while knows that you tend to redeclare the same class or function frequently as you iterate on the code. You re-execute slightly modified versions of the same code over and over again while you play around with it.</p><p>If we were to just add these declarations to our sandbox Dart library, it would require us to keep tab of what has been declared when and where in the file in order to update the declaration when you iterate on it. This requires a lot of logic and clever code. Sadly, it would also break easily if a change to a class were to break compatibility with older code or other declarations. This would keep the REPL from hot reloading and would force the user to restart it :( This sounds complex and brittle: not a winning combination, I think!</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/500/0*JRC_8ZBdApr8CNWF.jpg\" /></figure><h4>Spike &amp; chains</h4><p>Instead, what if we could redefine the same top-level declaration multiple times without the redeclarations ever colliding? Is that even possible in Dart? You bet it is! But not within the same library :) Dart allows you to import a library and then declare a class, function or global variable that shadows an existing declaration.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2496f4846e2ec984332c0fccd753eda5/href\">https://medium.com/media/2496f4846e2ec984332c0fccd753eda5/href</a></iframe><p>In this example, there will be no complaints about b.dart’s MyClass shadowing a.dart’s version because they live in different libraries and the local declaration in b.dart has precedence over the one imported from a.dart.</p><p>In general, shadowing is what happens when you declare a variable that hides another variable from an outer scope. For example:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/53b655cff7e8341f81ba0a07a703fbb7/href\">https://medium.com/media/53b655cff7e8341f81ba0a07a703fbb7/href</a></iframe><p>Can we use this? To investigate it, I have implemented a quick spike <a href=\"https://github.com/BlackHC/dart_repl/tree/master/spikes/import_spike\">here</a>. It doesn’t generate any code. Rather, it is a very dumb example to make sure that what we think will work actually works. It would be frustrating to spend a lot of time on implementing this using code generation only to find out that it could have never worked! This is the gist of it:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5ee2c1920db51d8f94c2adc2d84e1a21/href\">https://medium.com/media/5ee2c1920db51d8f94c2adc2d84e1a21/href</a></iframe><p>This works indeed! We can create a chain of libraries that import each other (and also export each other because otherwise the symbols will not be available everywhere). Then the users can redefine symbols as often as they want. Obviously, this can result in old code referring to shadowed symbols, which might make things slightly confusing, but at least it won’t break. And anybody who has used IPython or similar has learnt to live with it, too. It can’t be that bad.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*jjpANyPKXUIge1JcUA3WSQ.png\" /></figure><p>The diagram above shows how it works: as we add new top-level declarations, new “cells” (Dart libraries) are created which import (and export) the previous cell. The final cell is imported in the sandbox library that is used as execution environment for normal Dart expressions and statements. The sandbox file is edited in-place and then reloaded using hot reload.</p><h4>A workflow vision</h4><p>Moreover, if you want to update code continuously without shadowing anything, that is still possible, too: hot reload already allows for this workflow in normal Dart programs. You can do the same in the REPL. You can edit your amazing Dart library amazing_dart_library.dart and import it into REPL, play around with it, and while you do so, you can edit the code in your editor of choice and have the REPL hot reload the code when you want by calling reload(). The best of both worlds \\o/</p><h3>How can we implement this in practice?</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/0*lKzRhG-9uyW5eLvq.jpg\" /></figure><p>Well, we are hacking Dart here, so let’s see: Hot reload is not supported by the <a href=\"https://pub.dartlang.org/packages/vm_service_client\">vm_service_client</a> yet since it is such a new feature and the <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md\">service specification</a> is not totally complete yet. I started writing <a href=\"https://github.com/dart-lang/vm_service_client/pull/14\">a pull request</a> for Natalie (the maintainer) to add support for it, but really, as my coworkers know: production quality code is not my thing, especially not in my spare time (sorry Natalie!). However, this does not block our hacking adventure.</p><p><a href=\"https://pub.dartlang.org/\">pub</a>, Dart’s package management system, not only supports automatic version constraint resolution and a centralized repository of packages, it also allows you <a href=\"https://www.dartlang.org/tools/pub/dependencies\">to use local packages or to depend directly on GitHub</a> . This is usually not advisable because you lose much of what makes pub great, but here it works: I simply forked vm_service_client into my own GitHub clone and made the necessary changes. You can find the code at <a href=\"https://github.com/BlackHC/vm_service_client/tree/reload_sources_poc\">https://github.com/BlackHC/vm_service_client/tree/reload_sources_poc</a>. Afterwards, I changed the Dart REPL’s pubspec.yaml to link to my GitHub clone instead of the official version:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/be30ddffb92ecf0d20851fbf9e1c0a15/href\">https://medium.com/media/be30ddffb92ecf0d20851fbf9e1c0a15/href</a></iframe><p>And that’s it! A simplepub getin the terminal now updates the Dart REPL to use the forked version.</p><p>This makes it really easy to experiment with anything: you can fork other packages to try things out and easily depend on them. And the cool thing is, I can publish this and when you download the REPL for yourself using pub, it will grab the code from GitHub, too. Very hackable yet shareable! (Even if it’s not advisable for production packages in general :)</p><p>The main bit of juicy logic is the cell generator that implements a very simple templating mechanism in line with what we’ve discussed above:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/879f11229a2d99bf949edafa4d499737/href\">https://medium.com/media/879f11229a2d99bf949edafa4d499737/href</a></iframe><p>The hot reload feature is called from the REPL when a new import is needed:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/f47b8fae206d6b2cb31497ab33e258d8/href\">https://medium.com/media/f47b8fae206d6b2cb31497ab33e258d8/href</a></iframe><p>And that’s pretty much it! You can have a look at all the changes in the pull request: <a href=\"https://github.com/BlackHC/dart_repl/pull/2\">https://github.com/BlackHC/dart_repl/pull/2</a>.<br>I admit the code is a bit hacky and untidy. There is also quite a bit of unrelated wrapper code for message passing between the REPL and the sandbox in the pull request. This sadly obfuscates the main changes a bit. I need to see how we can refactor all this to make it neater and tidier again… but sometimes, it’s just easier to get things running quickly than writing the best code and pull requests. Sorry about that!</p><figure><a href=\"https://asciinema.org/a/114838\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/505/1*lR3fQGmW9Bjxtcxy-mJsjg.gif\" /></a><figcaption>Dart REPL with top-level declarations</figcaption></figure><p>The Dart REPL’s source can be found at <a href=\"https://github.com/BlackHC/dart_repl\">https://github.com/BlackHC/dart_repl</a>. In addition to supporting top-level declarations, I have also added support for built-inimport, loadPackage and reload commands. (Please note: loadPackage requires the soon-to-be-released 1.24 dev builds of the Dart SDK. It’s a no-op right otherwise.) These built-in commands are all trivial extensions that use hot reload. Finally, to load new packages from your local pub cache, I’m using the excellent <a href=\"https://github.com/dart-lang/pub_cache\">pub_cache</a> package.</p><p>To give it a go (and assuming you have installed the Dart SDK), just run:</p><pre>pub global activate dart_repl<br>pub global run dart_repl</pre><p>Thanks for making it to the end of this article! Please let me know what you think :)</p><p>Cheers,<br>Andreas</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=233440a35e1f\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/evolving-dart-repl-poc-233440a35e1f\">Evolving the Dart REPL PoC</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2017-03-28T05:34:03.000Z":{"title":"Making a Dart web app offline-capable: 3 lines of code","link":"https://medium.com/dartlang/making-a-dart-web-app-offline-capable-3-lines-of-code-e980010a7815?source=rss----23738d481ce8---4","guid":"https://medium.com/p/e980010a7815","category":["offline","progressive-web-app","service-worker","dart","dartlang"],"dc:creator":"István Soós","pubDate":"Tue, 28 Mar 2017 05:34:03 GMT","atom:updated":"2017-03-28T05:34:03.042Z","content:encoded":"<p>Have you ever tried to load a web application (maybe a game or a measurement converter) and couldn’t use it because the network was down? That’s an awful experience, but luckily we have the technology to make such apps available for our users.</p><p>For most apps and games, this can be done with 3 lines of Dart code and 1 command in the terminal. In this short article I’ll guide you through the steps, and make sure that you can always play <a href=\"https://isoos.github.io/offline_pop_pop_win/\">Pop, Pop, Win!</a></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*GsjtYvVghuA63qhhRdyfPQ.png\" /><figcaption><a href=\"https://dart-lang.github.io/sample-pop_pop_win/\">Pop, Pop, Win!</a> — a <a href=\"https://github.com/dart-lang/sample-pop_pop_win\">Minesweeper implementation</a> in Dart</figcaption></figure><h3>Service workers</h3><p>A service worker is a JavaScript file that runs in the background. It can control the web page or the site it is associated with, intercepting and modifying navigation and resource requests, and caching resources in a very granular fashion.</p><p>It is a non-intrusive web technology: service workers can improve the user experience if the browser <a href=\"http://caniuse.com/#feat=serviceworkers\">supports them</a>, but the site can operate just fine in their absence (with the default web behavior). This is a useful property that enables <strong>progressive web applications (PWA)</strong>, where you can provide more advanced features to the majority of the users, while making sure that the rest aren’t locked out.</p><p>As a background processing thread, a service worker can help with:</p><ul><li>offline mode (fetching resources from cache while the network is down)</li><li>caching strategies (for near-instant cached responses that can be updated later with fresh content)</li><li>push notifications (like in a mobile app)</li><li>messaging (if the application is open on multiple tabs)</li></ul><p>The important feature for our offline gaming experience is this: we would like to play Pop, Pop, Win!, and not meet this dinosaur:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*cufcmiyxW8k4ku1-Y_zsvg.png\" /><figcaption>Fun fact: you can play with that dinosaur by pushing the up arrow key.</figcaption></figure><h3>Progressive web app with Dart</h3><p>Supporting offline mode requires roughly the following:</p><ol><li>Determining which resources to put in the cache for offline use.</li><li>Creating a service worker that prepares a cache of these resources.</li><li>Registering the service worker, so that subsequent requests can be served from the offline cache (in case the network is down).</li><li>In that service worker, pre-populating the offline cache with the URLs, and also handling the appropriate fetch request either from the cache, or from the network.</li><li>Making sure that the service worker detects changes to the app or static assets, and puts the new version in the cache.</li></ol><p>While the above list may sound a bit scary, we have a <a href=\"https://pub.dartlang.org/packages/pwa\">pwa</a> package in Dart that does most of the work for us, providing a high-level API and automating most of the work.</p><h4>Changes in your application</h4><p>Import the pwa package in your pubspec.yaml:</p><pre>dependencies:<br>  pwa: ^0.1.2</pre><p>After running pub get, add the client to your web/main.dart:</p><pre>import ‘package:pwa/client.dart’ as pwa;</pre><pre>main() {<br>  // register PWA ServiceWorker for offline caching.<br>  new pwa.Client();</pre><pre>}</pre><p>The above code handles item 3 from the above list by registering the service worker (which we will create in the following step). Right now we don’t use the Client instance for anything else, but as the pwa package gets new features, it may become useful for other purposes.</p><h4>Automatically generated progressive web application</h4><p>The pwa package provides code generation that handles items 1–2 and 4–5 from the above list. To ensure proper cache use (both populating and invalidating the cache) use the following workflow:</p><ol><li>Build your web app with all of the static resources landing in build/web:<br>pub build</li><li>Run pwa’s code generator to scan (or rescan) your offline assets:<br>pub run pwa</li><li>Build your project again, because you need to have your (new) pwa.dart file compiled:<br>pub build</li></ol><p>These steps produce a file named lib/pwa/offline_urls.g.dart that contains a list of the offline URLs to be cached. The .g.dart extension indicates that the file is generated and may be overwritten automatically by pwa’s code generator tool.</p><p>On the first run, this workflow generates the web/pwa.dart file that contains your service worker with reasonable defaults. You can modify this file (to customize the offline URLs or use the high-level APIs, for example) because the code generator won’t change or override it again.</p><h3>Caveats</h3><p>While Dartium is great for most web development, at the moment it’s hard to use with service workers. We recommend using Chrome or Firefox instead.</p><p>Cache invalidation is one of the hardest problems in computer science. The underlying <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Cache\">Web Cache API</a> provides some guarantees, and the pwa library goes to a great length to gracefully handle the edge cases, but don’t treat the cache as reliable storage for anything really important. Make use of the cache when it is available, and fail gracefully when it’s not.</p><h3>Try it out</h3><p>You can now deploy the new version of your application. Or try the <a href=\"https://isoos.github.io/offline_pop_pop_win/\">offline Pop, Pop, Win! game</a>.</p><p>After opening the game and playing one round, shut down your wi-fi or unplug the network cable, and then reload (or retype the URL). If you’re using Chrome or Firefox, your game should be up and running. Good luck, have fun!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e980010a7815\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/making-a-dart-web-app-offline-capable-3-lines-of-code-e980010a7815\">Making a Dart web app offline-capable: 3 lines of code</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2017-03-31T06:15:43.000Z":{"title":"Zero to One with Flutter, Part Two","link":"https://medium.com/dartlang/zero-to-one-with-flutter-part-two-5aa2f06655cb?source=rss----23738d481ce8---4","guid":"https://medium.com/p/5aa2f06655cb","category":["animation","data-visualization","flutter","dartlang","mobile-app-development"],"dc:creator":"Mikkel Ravn","pubDate":"Fri, 31 Mar 2017 06:15:43 GMT","atom:updated":"2017-04-06T06:47:20.755Z","content:encoded":"<p>Discovering how to animate composite graphical objects in the context of a cross-platform mobile app. Join an avid concept miner in learning how to apply the tween concept to animation of structured values, exemplified by bar charts. Full code samples, batteries included.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OSc2sFHg8KH4ZQR2ymytKg.png\" /></figure><p>How do you enter into a new field of programming? Experimentation is obviously key, as is studying and emulating programs written by more experienced peers. I personally like to complement these approaches with concept mining: Trying to work from first principles, identifying concepts, exploring their strength, deliberately seeking their guidance. It is a rationalistic approach which cannot stand on its own, but one that is intellectually stimulating and may lead you to deeper insights faster.</p><p>This is the second and final part of an introduction to Flutter and its widget and tween concepts. At the end of <a href=\"https://medium.com/dartlang/zero-to-one-with-flutter-43b13fd7b354\">part one</a>, we arrived at a widget tree containing, among various layout and state-handling widgets,</p><ul><li>a widget for painting a single Bar using custom, animation-aware drawing code,</li><li>a floating action button widget for initiating an animated change of the bar’s height.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*5ggIsPDAwb8sAgPw8vZkyw.gif\" /><figcaption>Animating bar height.</figcaption></figure><p>The animation was implemented using a BarTween, and I claimed that the tween concept would scale to handle more complex situations. Here in part two, I’ll fulfill that claim by generalizing the design to bars with more properties, and to bar charts containing multiple bars in various configurations.</p><p>Let’s start by adding color to our single bar. We add a color field next to the height field of the Bar class, and update Bar.lerp to lerp both of them. This pattern is typical:</p><p><em>Lerp between composite values by lerping corresponding components.</em></p><p>Recall from part one that “lerp” is a short form of “linearly interpolate” or “linear interpolation”.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e1113c39e49373466143181e9ea2eff2/href\">https://medium.com/media/e1113c39e49373466143181e9ea2eff2/href</a></iframe><p>Notice the utility of the static lerp method idiom here. Without Bar.lerp, lerpDouble (morally double.lerp), and Color.lerp we’d have to implement BarTween by creating a Tween&lt;double&gt; for the height and a Tween&lt;Color&gt; for the color. Those tweens would be instance fields of BarTween, initialized by its constructor, and used in its lerp method. We’d be duplicating knowledge about the properties of Bar several times over, outside the Bar class. Maintainers of our code would likely find that less than ideal.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*kCvpZWFivphnjDnOiIoaIw.gif\" /><figcaption>Animating bar height and color.</figcaption></figure><p>To make use of colored bars in our app, we’ll update BarChartPainter to get the bar color from the Bar. In main.dart, we need to be able to create an empty Bar and a random Bar. We’ll use a fully transparent color for the former, and a random color for the latter. Colors will be taken from a simple ColorPalette which we quickly introduce in a file of its own. We’ll make both Bar.empty and Bar.random factory constructors on Bar (<a href=\"https://gist.github.com/mravn-google/90bda9c82df356338b3fe3f733066f6c\">code listing</a>).</p><p>Bar charts involve multiple bars in various configurations. To introduce complexity slowly, our first implementation will be suitable for bar charts displaying numeric quantities for a fixed set of categories. Examples include visitors per weekday or sales per quarter. For such charts, changing the data set to another week or another year does not change the categories used, only the bar shown for each category.</p><p>We’ll update main.dart first this time, replacing Bar by BarChart and BarTween by BarChartTween (<a href=\"https://gist.github.com/mravn-google/029930ddb613b00b6f5df7179d76fdc4\">code listing</a>).</p><p>To make the Dart analyzer happy, we create the BarChart class in bar.dart and implement it using a fixed-length list of Bar instances. We’ll use five bars, one for each day of the workweek. We then need to move the responsibility for creating empty and random instances from Bar to BarChart. With fixed categories, an empty bar chart is reasonably taken to be a collection of empty bars. On the other hand, letting a random bar chart be a collection of random bars would make our charts rather kaleidoscopic. Instead, we’ll choose a random color for the chart and let each bar, still of random height, inherit that.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/97aa77017bd4cbc10ca6834abdb9dc61/href\">https://medium.com/media/97aa77017bd4cbc10ca6834abdb9dc61/href</a></iframe><p>The BarChartPainter distributes available width evenly among the bars and makes each bar take up 75% of the width available to it.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*aiUQNf70oukpvNf6sVw3GA.gif\" /><figcaption>Fixed-category bar chart.</figcaption></figure><p>Notice how BarChart.lerp is implemented in terms of Bar.lerp, regenerating the list structure on the fly. Fixed-category bar charts are composite values for which straightforward component-wise lerping makes sense, precisely as for single bars with multiple properties.</p><p>There is a pattern at play here. When a Dart class’s constructor takes multiple parameters, you can often lerp each parameter separately and the combination will look good, too. And you can nest this pattern arbitrarily: dashboards would be lerped by lerping their constituent bar charts, which are lerped by lerping their bars, which are lerped by lerping their height and color. And colors are lerped by lerping their RGB and alpha components. At the leaves of this recursion, we lerp numbers.</p><p>The mathematically inclined might express this by saying that lerping commutes with structure in the sense that for composite values <em>C</em>(<em>x</em>, <em>y</em>) we have</p><p><em>lerp</em>(<em>C</em>(<em>x</em>1, <em>y</em>1), <em>C</em>(<em>x</em>2, <em>y</em>2), <em>t</em>) == <em>C</em>(<em>lerp</em>(<em>x</em>1, <em>x</em>2, <em>t</em>), <em>lerp</em>(<em>y</em>1, <em>y</em>2, <em>t</em>))</p><p>As we have seen, this generalizes nicely from two components (height and color of a bar) to arbitrarily many components (the <em>n</em> bars of a fixed-category bar chart).</p><p>There are, however, situations in which this pretty picture breaks down. We may wish to animate between two values that are not composed in quite the same way. As a simple example, consider animating from a bar chart with data for the five days of the workweek to a chart including also the weekend.</p><p>You might readily come up with several different ad-hoc solutions to this problem, and might then go ask your UX designer to choose between them. That’s a valid approach, though I believe it pays to keep in mind during your discussion the fundamental structure common to those different solutions: The tween. Recall from part one:</p><p><em>Animate </em><em>Ts by tracing out a path in the space of all </em><em>Ts as the animation value runs from zero to one. Model the path with a </em><em>Tween&lt;T&gt;.</em></p><p>The central question to answer with the UX designer is this: What are the intermediate values between a chart with five bars and one with seven? An obvious choice is to have six bars, but we need more intermediate values than that to animate smoothly. We need to draw bars differently, stepping outside the realm of equal-width, uniformly spaced bars, fitted to 200 pixels. In other words, the space of T values must be generalized.</p><p><em>Lerp between values with different structure by embedding them into a space of more general values, encompassing as special cases both animation end points and all intermediate values needed.</em></p><p>We can do this in two steps. First, we generalize Bar to include its <em>x</em> coordinate and width as attributes:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/62ee88878e7322d237b1368e5e59f5fb/href\">https://medium.com/media/62ee88878e7322d237b1368e5e59f5fb/href</a></iframe><p>Second, we make BarChart support charts with different bar counts. Our new charts will be suitable for data sets where bar <em>i</em> represents the <em>i</em>th value in some series like sales on day <em>i</em> after a product launch. <a href=\"https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html\">Counting as programmers</a>, any such chart involves a bar for each integer value 0..<em>n</em>, but the bar count <em>n</em> may be different from one chart to the next.</p><p>Consider two charts with five and seven bars, respectively. The bars for their five common categories, 0..5, can be animated compositionally as we’ve seen above. The bars with index 5 and 6 have no counterpart in the other animation end point, but as we are now free to give each bar its own position and width, we can introduce two invisible bars to play that role. The visual effect is that bars 5 and 6 grow into their final appearance as the animation proceeds. Animating in the other direction, bars 5 and 6 would diminish or fade into invisibility.</p><p><em>Lerp between composite values by lerping corresponding components. Where a component is missing in one end point, use an invisible component in its place.</em></p><p>There are often several ways to choose invisible components. Let’s say our friendly UX designer has decided to use zero-width, zero-height bars with <em>x</em> coordinate and color inherited from their visible counterpart. We’ll add a method to Bar for creating such a collapsed version of a given instance.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/d85dd55de3c77897881d0445450801b2/href\">https://medium.com/media/d85dd55de3c77897881d0445450801b2/href</a></iframe><p>Integrating the above code into our app involves redefining BarChart.empty and BarChart.random for this new setting. An empty bar chart can now reasonable be taken to contain zero bars, while a random one might contain a random number of bars all of the same randomly chosen color, and each having a randomly chosen height. But since position and width are now part of the definition of Bar, we need BarChart.random to specify those attributes too. It seems reasonable to provide BarChart.random with the chart Size parameter, and then relieve BarChartPainter.paint of most of its calculations (<a href=\"https://gist.github.com/mravn-google/cac095296074b8b1b7ad6c91a21a5f1a\">code listing</a>).</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*dN9og1kRYpRsL-cFIgO23w.gif\" /><figcaption>Lerping to/from invisible bars.</figcaption></figure><p>The astute reader may have noticed a potential inefficiency in our definition of BarChart.lerp above. We are creating collapsed Bar instances only to be given as arguments to Bar.lerp, and that happens repeatedly, for every value of the animation parameter t. At 60 frames per second, that could mean a lot of Bar instances being fed to the garbage collector, even for a relatively short animation. There are alternatives:</p><ul><li>Collapsed Bar instances can be reused by being created only once in the Bar class rather than on each call to collapsed. This approach works here, but is not generally applicable.</li><li>The reuse can be handled by BarChartTween instead, by having its constructor create a list _tween of BarTween instances used during the creation of the lerped bar chart: (i) =&gt; _tweens[i].lerp(t). This approach breaks with the convention of using static lerp methods throughout. There is no object involved in the static BarChart.lerp in which to store the tween list for the duration of the animation. The BarChartTween object, by contrast, is perfectly suited for this.</li><li>A null bar can be used to represent a collapsed bar, assuming suitable conditional logic in Bar.lerp. This approach is slick and efficient, but does require some care to avoid dereferencing or misinterpreting null. It is commonly used in the Flutter SDK where static lerp methods tend to accept null as an animation end point, typically interpreting it as some sort of invisible element, like a completely transparent color or a zero-size graphical element. As the most basic example, lerpDouble treats null as zero, unless both animation end-points are null.</li></ul><p>The snippet below shows the code we would write following the null approach:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/fc7e7027b28152dda198b3c30e536e6e/href\">https://medium.com/media/fc7e7027b28152dda198b3c30e536e6e/href</a></iframe><p>I think it’s fair to say that Dart’s ? syntax is well suited to the task. But notice how the decision to use collapsed (rather than, say, transparent) bars as invisible elements is now buried in the conditional logic in Bar.lerp. That is the main reason I chose the seemingly less efficient solution earlier. As always in questions of performance vs maintainability, your choice should be based on measurements.</p><p>We have one more step to take before we can tackle bar chart animation in full generality. Consider an app using a bar chart to show sales by product category for a given year. The user can select another year, and the app should then animate to the bar chart for that year. If the product categories were the same for the two years, or happened to be the same except for some additional categories shown to the right in one of the charts, we could use our existing code above. But what if the company had product categories A, B, C, and X in 2016, but had discontinued B and introduced D in 2017? Our existing code would animate as follows:</p><pre>2016  2017<br>  A -&gt; A<br>  B -&gt; C<br>  C -&gt; D<br>  X -&gt; X</pre><p>The animation might be beautiful and silky-smooth, but it would still be confusing to the user. Why? Because it doesn’t preserve semantics. It transforms a graphical element representing product category B into one representing category C, while the one for C goes elsewhere. Just because 2016 B happens to be drawn in the same position where 2017 C later appears doesn’t imply that the former should morph into the latter. Instead, 2016 B should disappear, 2016 C should move left and morph into 2017 C, and 2017 D should appear on its right. We can implement this mingling using one of the oldest algorithms in the book: merging sorted lists.</p><p><em>Lerp between composite values by lerping semantically corresponding components. When components form sorted lists, the merge algorithm can bring such components on a par, using invisible components as needed to deal with one-sided merges.</em></p><p>All we need is to make Bar instances mutually comparable in a linear order. Then we can merge them as follows:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/163fc08e689ba1474e063e1c0657064e/href\">https://medium.com/media/163fc08e689ba1474e063e1c0657064e/href</a></iframe><p>Concretely, we’ll assign each bar a sort key in the form of an integer rank attribute. The rank can then be conveniently used also to assign each bar a color from the palette, allowing us to follow the movement of individual bars in the animation demo.</p><p>A random bar chart will now be based on a random selection of ranks to include (<a href=\"https://gist.github.com/mravn-google/4f7194e8c1f875eba189856eb40e6b1e\">code listing</a>).</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*MuSAOLktwY8bTJdPGuoNqA.gif\" /><figcaption>Arbitrary categories. Merge-based lerping.</figcaption></figure><p>This works nicely, but is perhaps not the most efficient solution. We are repeatedly executing the merge algorithm in BarChart.lerp, once for every value of t. To fix that, we’ll implement the idea mentioned earlier to store reusable information in BarChartTween.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a17319978532c6255412fdab5cfe3c2e/href\">https://medium.com/media/a17319978532c6255412fdab5cfe3c2e/href</a></iframe><p>We can now remove the static BarChart.lerp method.</p><p>Let’s summarize what we’ve learned about the tween concept so far:</p><p><em>Animate </em><em>Ts by tracing out a path in the space of all </em><em>Ts as the animation value runs from zero to one. Model the path with a </em><em>Tween&lt;T&gt;.</em></p><p><em>Generalize the </em><em>T concept as needed until it encompasses all animation end points and intermediate values.</em></p><p><em>Lerp between composite values by lerping corresponding components.</em></p><ul><li><em>The correspondence should be based on semantics, not on accidental graphical co-location.</em></li><li><em>Where a component is missing in one animation end point, use an invisible component in its place, possibly derived from the other end point.</em></li><li><em>Where components form sorted lists, use the merge algorithm to bring semantically corresponding components on a par, introducing invisible components as needed to deal with one-sided merges.</em></li></ul><p><em>Consider implementing tweens using static </em><em>Xxx.lerp methods to facilitate reuse in composite tween implementations. Where significant recomputation happens across calls to </em><em>Xxx.lerp for a single animation path, consider moving the computation to the constructor of the </em><em>XxxTween class, and let its instances host the computation outcome.</em></p><p>Armed with these insights, we are finally in position to animate more complex charts. We’ll do stacked bars, grouped bars, and stacked+grouped bars in quick succession:</p><ul><li>Stacked bars are used for data sets where categories are two-dimensional and it makes sense to add up the numerical quantity represented by bar heights. An example might be revenue per product and geographical region. Stacking by product makes it easy to compare product performance in the global market. Stacking by region shows which regions are important.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*qKUFM56S-ZonH1amVDDXTw.gif\" /><figcaption>Stacked bars.</figcaption></figure><ul><li>Grouped bars are also used for data sets with two-dimensional categories, but where it is not meaningful or desirable to stack the bars. For instance, if the numeric quantity is market share in percent per product and region, stacking by product makes no sense. Even where stacking does makes sense, grouping can be preferable as it makes it easier to do quantitative comparisons across both category dimensions at the same time.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*YiojxPiaWY7lB5v9iZVgDg.gif\" /><figcaption>Grouped bars.</figcaption></figure><ul><li>Stacked+grouped bars support three-dimensional categories, like revenue per product, geographical region, and sales channel.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*9ObVOKbos4DoQsmsqbMnRQ.gif\" /><figcaption>Stacked+grouped bars.</figcaption></figure><p>In all three variants, animation can be used to visualize data set changes, thus introducing an additional dimension (typically time) without cluttering the charts.</p><p>For the animation to be useful and not just pretty, we need to make sure that we lerp only between semantically corresponding components. So the bar segment used to represent the revenue for a particular product/region/channel in 2016 should be morphed into one representing revenue for the same product/region/channel in 2017 (if present).</p><p>The merge algorithm can be used to ensure this. As you may have guessed from the preceding discussion, merge will be put to work at multiple levels, reflecting the dimensionality of the categories. We’ll merge stacks and bars in stacked charts, groups and bars in grouped charts, and all three in stacked+grouped charts.</p><p>To accomplish that without a lot of code duplication, we’ll abstract the merge algorithm into a general utility, and put it in a file of its own, tween.dart:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/30c0ab2c4e57fb77ff3d28f2e93dc58b/href\">https://medium.com/media/30c0ab2c4e57fb77ff3d28f2e93dc58b/href</a></iframe><p>The MergeTweenable&lt;T&gt; interface captures precisely what is needed to be able to create a tween of two sorted lists of Ts by merging. We’ll instantiate the type parameter T with Bar, BarStack, and BarGroup, and make all these types implement MergeTweenable&lt;T&gt;.</p><p>The <a href=\"https://gist.github.com/mravn-google/78326296c59f0544d280a987d9ba39e2\">stacked</a>, <a href=\"https://gist.github.com/mravn-google/d3f0f2a93cb478ab3a50dab03437a5d5\">grouped</a>, and <a href=\"https://gist.github.com/mravn-google/cbd4a89e7b9e5431898a16727f7642b6\">stacked+grouped</a> implementations have been written to be directly comparable. I encourage you to play around with the code:</p><ul><li>Change the number of groups, stacks, and bars created by BarChart.random.</li><li>Change the color palettes. For stacked+grouped bars I’ve used a monochrome palette, because I think that looks nicer. You and your UX designer may disagree.</li><li>Replace BarChart.random and the floating action button with a year selector and create BarChart instances from realistic data sets.</li><li>Implement horizontal bar charts.</li><li>Implement other chart types (pie, line, stacked area). Animate them using MergeTweenable&lt;T&gt; or similar.</li><li>Add chart legends and/or labels and axes, then animate those too.</li></ul><p>The tasks of the last two bullets are quite challenging. Have fun.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5aa2f06655cb\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/zero-to-one-with-flutter-part-two-5aa2f06655cb\">Zero to One with Flutter, Part Two</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2017-02-23T10:00:31.000Z":{"title":"Google Maps with AngularDart","link":"https://medium.com/dartlang/google-maps-with-angulardart-a75f7f84f941?source=rss----23738d481ce8---4","guid":"https://medium.com/p/a75f7f84f941","category":["javascript","dart","dartlang","google-maps","web-development"],"dc:creator":"István Soós","pubDate":"Thu, 23 Feb 2017 10:00:31 GMT","atom:updated":"2017-02-23T10:00:31.388Z","content:encoded":"<p>In this article we will integrate Google Maps with an AngularDart application. The app itself will be very simple: it calculates the <a href=\"https://en.wikipedia.org/wiki/Great-circle_distance\">great circle distance</a> (the shortest distance on the surface of a sphere) between two selected markers on the map.</p><p>Along the way you will:</p><ul><li>Register your own Google Maps API key.</li><li>Create a barebones Angular web application.</li><li>Integrate Dart with the Google Maps JavaScript API, and handle the maps interaction.</li><li>Learn some polishing tips for the Angular component.</li></ul><p>This article is roughly four times longer than the code. If you want, just go look at the complete <a href=\"https://github.com/isoos/google_maps_angular_dart\"><strong>source code</strong></a> and the final <a href=\"https://isoos.github.io/google_maps_angular_dart/\"><strong>demo</strong></a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*hLce2qgbJEkxjOlOr8jn9g.png\" /><figcaption>Screenshot of the demo</figcaption></figure><h3>Google Maps JavaScript API</h3><p>The <a href=\"https://developers.google.com/maps/documentation/javascript/\">Google Maps JavaScript API</a> allows developers to embed and integrate Google Maps on their site. You can customize the displayed map’s content and handling with your own imagery, data and processing.</p><p>To start developing with the Google Maps API, you must register a free API key that allows a reasonable amount of usage. As your application gets more traction, you can upgrade it to a paid plan.</p><p>Visit the <a href=\"https://developers.google.com/maps/documentation/javascript/\">JavaScript API page</a>, and at the top of the page, click GET A KEY. Create a name for your project and click CREATE AND ENABLE API:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*cPMKvi22U5csti4Dubb-4A.png\" /></figure><p>Your key will be enabled and ready to use in a couple of seconds:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*8Opaixc6Ardgd0wYKyvKNw.png\" /></figure><p>Note your API key. We’ll use it when we fetch the Maps JavaScript library:</p><pre><a href=\"https://maps.googleapis.com/maps/api/js?key=KEY_GOES_HERE\">https://maps.googleapis.com/maps/api/js?key=<strong>KEY_GOES_HERE</strong></a></pre><p>In JavaScript, to create a map instance and place a marker on it, we’d use the following code:</p><pre>var hostElement = document.getElementById(&#39;map-id&#39;);<br>var map = new google.maps.Map(hostElement, {<br>  zoom: 2,<br>  center: {lat: 47.4979, lng: 19.0402}<br>});<br>var marker = new google.maps.Marker({<br>  position: {lat: 47.4979, lng: 19.0402},<br>  map: map,<br>  label: &#39;A&#39;<br>});</pre><p>As you will see later, the Dart code will be very similar (with all of the added benefits of Dart).</p><h3>The AngularDart Application</h3><p>The easiest way to get started with an AngularDart application is to follow the <a href=\"https://webdev.dartlang.org/guides/get-started\">Get Started</a> guide and <a href=\"https://webdev.dartlang.org/guides/get-started#4-create-and-run-a-web-app\">create a new project</a> in WebStorm or in the Community Edition of IntelliJ IDEA.</p><p>In case you are using a different editor, or you just want to follow the structure of our example code, here is the bare minimum.</p><p>In the pubspec file, pubspec.yaml:</p><pre>name: google_maps_angular_dart<br>version: 0.0.1<br>description: Angular application with Google Maps integration</pre><pre>environment:<br>  sdk: &#39;&gt;=1.19.0 &lt;2.0.0&#39;</pre><pre>dependencies:<br>  angular2: ^2.2.0</pre><pre>dev_dependencies:<br>  dart_to_js_script_rewriter: ^1.0.1</pre><pre>transformers:<br>- angular2:<br>    platform_directives:<br>      - &#39;package:angular2/common.dart#COMMON_DIRECTIVES&#39;<br>    platform_pipes:<br>      - &#39;package:angular2/common.dart#COMMON_PIPES&#39;<br>    entry_points: web/main.dart<br>- dart_to_js_script_rewriter</pre><p>In the host page, web/index.html:</p><pre>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;!-- other headers --&gt;<br>    &lt;script defer src=&quot;main.dart&quot; type=&quot;application/dart&quot;&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>   <strong>&lt;map-control&gt;&lt;/map-control&gt;</strong><br>&lt;/body&gt;<br>&lt;/html&gt;</pre><p>In the app’s entry point, web/main.dart:</p><pre>import &#39;package:angular2/platform/browser.dart&#39;;<br>import &#39;package:google_maps_angular_dart/component/map_control.dart&#39;;</pre><pre>void main() {<br>  bootstrap(MapControl);<br>}</pre><p>In the Dart file for the &lt;map-control&gt; component, lib/component/map_control.dart:</p><pre>import &#39;package:angular2/core.dart&#39;;</pre><pre><a href=\"http://twitter.com/Component\">@Component</a>(<br>  selector: &#39;map-control&#39;,<br>  template: &#39;{{distance}}&#39;,<br>)<br>class MapControl {<br>  String distance = &#39;no distance yet&#39;;<br>}</pre><p>The above code won’t do too much, but it is a start and you can run it by using pub serve and then opening the page in Dartium:</p><pre>$ pub serve<br>Loading source assets...<br>Loading angular2 and dart_to_js_script_rewriter transformers...<br>Serving google_maps_angular_dart web on <a href=\"http://localhost:8080\">http://localhost:8080</a><br>Build completed successfully</pre><h3>Google Maps integration</h3><p>To start with the Google Maps integration, put the following script tag into your web/index.html. Notice that you need to set your API key:</p><pre>&lt;script src=&quot;https://maps.googleapis.com/maps/api/js?key=<strong>[YOUR_KEY_HERE]</strong>&quot;&gt;&lt;/script&gt;</pre><p>Fortunately there is a ready-to-use Google Maps Dart package on pub. Add it to your pubspec.yaml:</p><pre>dependencies:<br>  angular2: ^2.2.0<br>  <strong>google_maps: ^3.0.0</strong></pre><p>Then run pub get to download the package.</p><p>We need to create a host element for the map area in our component template. We will start with basic styling, and use the #mapArea anchor to identify the element in the next step:</p><pre>&lt;div style=&quot;width: 300px; height: 300px&quot; #<strong>mapArea</strong>&gt;[map]&lt;/div&gt;</pre><p>In the component code, we can inject the element’s reference as follows:</p><pre>@ViewChild(&#39;mapArea&#39;)<br>ElementRef mapAreaRef;</pre><p>The element reference is not available immediately after the MapControl class has been created, so we need to hook into Angular’s lifecycle callbacks:</p><pre>class MapControl <strong>implements AfterViewInit</strong> {</pre><pre><strong>  @override<br>  void ngAfterViewInit() {</strong><br>    // mapAreaRef is available now<br>  <strong>}</strong><br>}</pre><p>Tip: use the IDE to write the method bodies for you. For example, in IntelliJ, hit CMD + N (or CTRL + N), and select the “Implement Methods…” menu item. It will allow you to select the missing methods and you need to worry only about the method body:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/634/1*V9N-6dAV8vZjuT6cI1Sftw.png\" /></figure><p>As the following code shows, the Dart API is very similar to to the JavaScript one, with the added benefit that it is type checked.</p><pre>class MapControl implements AfterViewInit {<br>  // ...</pre><pre>@override<br>  void ngAfterViewInit() {<br>    GMap map = new GMap(<br>        mapAreaRef.nativeElement,<br>        new MapOptions()<br>          ..zoom = 2<br>          ..center = new LatLng(47.4979, 19.0402)<br>                             // ^ Budapest, Hungary<br>        );<br>    new Marker(new MarkerOptions()<br>      ..map = map<br>      ..position = new LatLng(47.4979, 19.0402)<br>      ..label = &#39;A&#39;);<br>  }<br>}</pre><p>One example of the benefits of type checking is that when we listen for events, we don’t need to think about how to access properties. For example, the IDE can help us find the MouseEvent property (latLng) that holds the location of the marker.</p><p>Here is the code that reacts to dragging the marker:</p><pre>    marker.onDrag.listen((MouseEvent event) {<br>      print(&#39;New location while dragging: ${event.latLng}&#39;);<br>    });</pre><p>Capturing click events on the map is similar:</p><pre>    map.onClick.listen((MouseEvent event) {<br>      print(&#39;User clicked on position: ${event.latLng}&#39;);<br>    });</pre><h3>Putting it together</h3><p>To measure the distance between two coordinates, we will track two markers on the map. The user shall be able to drag the markers around or place them by clicking.</p><p>We need to keep track of the map and the markers as fields:</p><pre>  GMap _map;<br>  Marker _aMarker;<br>  Marker _bMarker;</pre><p>Update the initialization to store the map reference and to register a click handler. The click handler updates the marker positions and the distance:</p><pre>  @override<br>  void ngAfterViewInit() {<br>    <strong>_map</strong> = new GMap(<br>        mapAreaRef.nativeElement,<br>        new MapOptions()<br>          ..zoom = 2<br>          ..center = new LatLng(47.4979, 19.0402)<br>                             // ^ Budapest, Hungary<br>        );<br>    <strong>_map.onClick</strong>.listen((MouseEvent event) {<br><strong>      _updatePosition</strong>(event.latLng);<br>      <strong>_updateDistance</strong>();<br>    });<br>  }</pre><p>Here is the code for the first part of the click handler:</p><pre>  void _updatePosition(LatLng position) {<br>    if (_aMarker == null) {<br>      _aMarker = _createMarker(_map, &#39;A&#39;, position);<br>    } else if (_bMarker == null) {<br>      _bMarker = _createMarker(_map, &#39;B&#39;, position);<br>    } else {<br>      _aMarker.position = _bMarker.position;<br>      _bMarker.position = position;<br>    }<br>  }</pre><p>The code for marker instantiation is similar to the earlier example:</p><pre>  Marker _createMarker(GMap map, String label, LatLng position) {<br>    final Marker marker = new Marker(new MarkerOptions()<br>      ..map = map<br>      ..draggable = true<br>      ..label = label<br>      ..position = position);<br>    marker.onDrag.listen((MouseEvent event) {<br>      _updateDistance();<br>    });<br>    return marker;<br>  }</pre><p>With the help of utility functions from dart:math, we are able to crunch through the mathematics of the great circle distance calculation, and set the value in our distance field:</p><pre>  /// Radius of the earth in km.<br>  const int radiusOfEarth = 6371;</pre><pre>double _toRadian(num degree) =&gt; degree * PI / 180.0;</pre><pre>void _updateDistance() {<br>    if (_aMarker == null || _bMarker == null) return;<br>    LatLng a = _aMarker.position;<br>    LatLng b = _bMarker.position;<br>    double dLat = _toRadian(b.lat - a.lat);<br>    double sLat = pow(sin(dLat / 2), 2);<br>    double dLng = _toRadian(b.lng - a.lng);<br>    double sLng = pow(sin(dLng / 2), 2);<br>    double cosALat = cos(_toRadian(a.lat));<br>    double cosBLat = cos(_toRadian(b.lat));<br>    double x = sLat + cosALat * cosBLat * sLng;<br>    double d = 2 * atan2(sqrt(x), sqrt(1 - x)) * radiusOfEarth;<br>    distance = &#39;${d.round()} km&#39;;<br>  }</pre><p>Have you ever wondered how far do you live from a relative, a famous location or a landmark? It is time to try out the application and check it for yourself. It turns out that my home is 9815 km from Google Headquarters in Mountain View:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*AOtq_2d-f5cETtXb-ixzYA.png\" /><figcaption>The distance between Googleplex in Mountain View, California and the author’s home in Budapest, Hungary</figcaption></figure><h3>Polishing the application</h3><p>The Google Maps integration in our Angular app is complete at this point. We are listening and reacting to map events and creating objects on the map. In this last section we will implement features that add a nice finish for our demo.</p><h4>Separate template and style</h4><p>It is a good practice to put complex UI template in a separate .html file. We can do the same with CSS styles:</p><pre>@Component(<br>    selector: &#39;map-control&#39;,<br>    templateUrl: &#39;map_control.html&#39;,<br>    styleUrls: const &lt;String&gt;[&#39;map_control.css&#39;])<br>class MapControl implements AfterViewInit {</pre><p>The map element has a CSS class, map-area:</p><pre>&lt;div class=&quot;map-area&quot; #mapArea&gt;[map]&lt;/div&gt;</pre><p>Our CSS file can be as simple as this:</p><pre>.map-area {<br>  width: 500px;<br>  height: 400px;<br>  margin: 10px;<br>}</pre><h4>Handling the unit of distance</h4><p>Some people are fluent in km ⟷ miles conversions, but the rest of us would like a dropdown where we can select the distance unit. In the HTML template the dropdown can be a simple &lt;SELECT&gt; element with a model binding to the unit field.</p><pre>&lt;label&gt;Unit:&lt;/label&gt;<br>&lt;select [(ngModel)]=&quot;<strong>unit</strong>&quot;&gt;<br>  &lt;option value=&quot;km&quot;&gt;km&lt;/option&gt;<br>  &lt;option value=&quot;miles&quot;&gt;miles&lt;/option&gt;<br>&lt;/select&gt;</pre><p>In the Dart code, we want to store the unit and to update the distance whenever the unit is updated:</p><pre>String _unit = &#39;km&#39;;</pre><pre><strong>String get unit</strong> =&gt; _unit;</pre><pre><strong>set unit(String value)</strong> {<br>  _unit = value;<br>  _updateDistance();<br>}</pre><p>And don’t forget to update the previously hardcoded km in the distance calculation:</p><pre>    /// Const value to convert from km to miles.<br>    const double milesPerKm = 0.621371;</pre><pre>    // ... same code as earlier<br>    if (unit == &#39;miles&#39;) {<br>      d *= milesPerKm;<br>    }<br>    distance = &#39;${d.round()} $unit&#39;;</pre><h4>Formatting the coordinates</h4><p>What if we are interested in publishing the position of our markers? The easiest way would be to expose the position values in Dart, so we can use {{a}} and {{b}} in our template:</p><pre>  // Expose the position values.<br>  LatLng get a =&gt; _aMarker?.position;<br>  LatLng get b =&gt; _bMarker?.position;</pre><p>The template can hide the label when the marker is not initialized yet, preventing potential issues with null values:</p><pre>  &lt;div *ngIf=&quot;a != null&quot;&gt;A: {{a}}&lt;/div&gt;<br>  &lt;div *ngIf=&quot;b != null&quot;&gt;B: {{b}}&lt;/div&gt;</pre><p>However, {{a}} would translate to calling LatLng.toString(), and it would give us two really long double values, whereas a few digits would be just fine. One solution is to use pipes in the template:</p><pre>&lt;div *ngIf=&quot;a != null&quot;&gt;A: {{a.lat | number : &#39;1.4-4&#39;}}, {{a.lng | number : &#39;1.4-4&#39;}}&lt;/div&gt;<br>&lt;div *ngIf=&quot;b != null&quot;&gt;B: {{b.lat | number : &#39;1.4-4&#39;}}, {{b.lng | number : &#39;1.4-4&#39;}}&lt;/div&gt;</pre><p>The <a href=\"https://webdev.dartlang.org/angular/guide/template-syntax\">template syntax guide</a> suggests placing that logic in the controller class, for better testing:</p><pre>  /// Formatted position of the &#39;A&#39; marker.<br>  String get <strong>aPosition</strong> =&gt; _formatPosition(a);</pre><pre>  /// Formatted position of the &#39;B&#39; marker.<br>  String get <strong>bPosition</strong> =&gt; _formatPosition(b);</pre><pre>  String _formatPosition(LatLng pos) {<br>    if (pos == null) return null;<br>    return &#39;${pos.lat.toStringAsFixed(4)}, &#39; <br>        &#39;${pos.lng.toStringAsFixed(4)}&#39;;<br>  }</pre><p>With that, the template can be much simpler:</p><pre>&lt;div *ngIf=&quot;a != null&quot;&gt;A: {{<strong>aPosition</strong>}}&lt;/div&gt;<br>&lt;div *ngIf=&quot;b != null&quot;&gt;B: {{<strong>bPosition</strong>}}&lt;/div&gt;</pre><h4>Clean up the template</h4><p>As a last step, move all of the remaining code parts from the template to the controller:</p><pre>  /// Whether the &#39;A&#39; marker&#39;s positions should be shown<br>  bool get <strong>showA</strong> =&gt; a != null;</pre><pre>  /// Whether the &#39;B&#39; marker&#39;s positions should be shown<br>  bool get <strong>showB</strong> =&gt; b != null;</pre><pre>  /// Whether the &#39;distance&#39; label should be shown<br>  bool get <strong>showDistance</strong> =&gt; distance != null;</pre><p>Doing so, the template references only the getters:</p><pre>&lt;div *ngIf=&quot;<strong>showA</strong>&quot;&gt;A: {{aPosition}}&lt;/div&gt;<br>&lt;div *ngIf=&quot;<strong>showB</strong>&quot;&gt;B: {{bPosition}}&lt;/div&gt;</pre><pre>&lt;p *ngIf=&quot;<strong>showDistance</strong>&quot;&gt;<br>  Distance: {{distance}}&lt;br/&gt;<br>&lt;/p&gt;</pre><h3>Closing notes</h3><p>As you can see, implementing two-way integration with Google Maps is easy: the source code is clean and readable. With the full support of the Dart toolchain, it is easily extensible, without ever worrying about what we may break at other places.</p><p>As an exercise for the reader, you can add <a href=\"https://developers.google.com/maps/documentation/javascript/earthquakes#heatmaps\">heatmap visualization</a> to the map using the same API in Dart. Check out the <a href=\"https://pub.dartlang.org/packages/google_maps\">google_maps</a> package for all of the possibilities.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a75f7f84f941\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/google-maps-with-angulardart-a75f7f84f941\">Google Maps with AngularDart</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2017-02-22T07:02:51.000Z":{"title":"Zero to One with Flutter","link":"https://medium.com/dartlang/zero-to-one-with-flutter-43b13fd7b354?source=rss----23738d481ce8---4","guid":"https://medium.com/p/43b13fd7b354","category":["flutter","animation","dartlang","mobile-app-development"],"dc:creator":"Mikkel Ravn","pubDate":"Wed, 22 Feb 2017 07:02:51 GMT","atom:updated":"2017-04-08T14:54:46.225Z","content:encoded":"<p><em>It was late summer 2016, and my first task as a new hire at the Google office in Aarhus, Denmark was to implement animated charts in an Android/iOS app using </em><a href=\"https://flutter.io\"><em>Flutter</em></a><em> and </em><a href=\"https://www.dartlang.org\"><em>Dart</em></a><em>. Besides being a “Noogler”, I was new to Flutter, new to Dart, and new to animations. In fact, I had never done a mobile app before. My very first smartphone was just a few months old — bought in a fit of panic that I might fail the phone interview by answering the call with my old Nokia...</em></p><p><em>I did have some prior experience with charts from desktop Java, but that wasn’t animated. I felt… weird. Partly a dinosaur, partly reborn.</em></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/164/1*2t8GffL0BcNoGLU-IgHT9w.jpeg\" /></figure><p><strong>TL;DR</strong> Discovering the strength of Flutter’s widget and tween concepts by writing chart animations in Dart for an Android/iOS app.</p><p>Moving to a new development stack makes you aware of your priorities. Near the top of my list are these three:</p><ul><li><strong>Strong concepts </strong>deal effectively with complexity by providing simple, relevant ways of structuring thoughts, logic, or data.</li><li><strong>Clear code</strong> lets us express those concepts cleanly, without being distracted by language pitfalls, excessive boilerplate, or auxiliary detail.</li><li><strong>Fast iteration</strong> is key to experimentation and learning — and software development teams learn for a living: what the requirements really are, and how best to fulfill them with concepts expressed in code.</li></ul><p>Flutter is a new platform for developing Android and iOS apps from a single codebase, written in Dart. Since our requirements spoke of a fairly complex UI including animated charts, the idea of building it only once seemed very attractive. My tasks involved exercising Flutter’s CLI tools, some pre-built widgets, and its 2D rendering engine — in addition to writing a lot of plain Dart code to model and animate charts. I’ll share below some conceptual highlights of my learning experience, and provide a starting point for your own evaluation of the Flutter/Dart stack.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*OKV3RzTg89W3VxXnpAH3Eg.gif\" /><figcaption>A simple animated bar chart, captured from an iOS simulator during development</figcaption></figure><p>This is part one of a <a href=\"https://medium.com/dartlang/zero-to-one-with-flutter-part-two-5aa2f06655cb\">two-part</a> introduction to Flutter and its ‘widget’ and ‘tween’ concepts. I’ll illustrate the strength of these concepts by using them to display and animate charts like the one shown above. Full code samples should provide an impression of the level of code clarity achievable with Dart. And I’ll include enough detail that you should be able to follow along on your own laptop (and emulator or device), and experience the length of the Flutter development cycle.</p><p>The starting point is a fresh <a href=\"https://flutter.io/setup\">installation of Flutter</a>. Run</p><pre>$ flutter doctor</pre><p>to check the setup:</p><pre>$ flutter doctor<br>[✓] Flutter (on Mac OS, channel master)<br>  • Flutter at /Users/mravn/flutter<br>  • Framework revision 64bae978f1 (7 hours ago), 2017-02-18 21:00:27<br>  • Engine revision ab09530927<br>  • Tools Dart version 1.23.0-dev.0.0</pre><pre>[✓] Android toolchain - develop for Android devices<br>    (Android SDK 24.0.2)<br>  • Android SDK at /Users/mravn/Library/Android/sdk<br>  • Platform android-25, build-tools 24.0.2<br>  • Java(TM) SE Runtime Environment (build 1.8.0_101-b13)</pre><pre>[✓] iOS toolchain - develop for iOS devices (Xcode 8.2.1)<br>  • Xcode at /Applications/Xcode.app/Contents/Developer<br>  • Xcode 8.2.1, Build version 8C1002<br>  • ios-deploy 1.9.1</pre><pre>[✓] IntelliJ IDEA Community Edition (version 2016.3.4)<br>  • Dart plugin version 163.13137<br>  • Flutter plugin version 0.1.10</pre><pre>[✓] Connected devices<br>  • iPhone SE • 664A33B0-A060-4839-A933-7589EF46809B • ios •<br>    iOS 10.2 (simulator)</pre><p>With enough check marks, you can create a Flutter app. Let’s call it charts:</p><pre>$ flutter create charts</pre><p>That should give you a directory of the same name:</p><pre>charts<br>  android<br>  ios<br>  lib<br>    main.dart</pre><p>About fifty files have been generated, making up a complete sample app that can be installed on both Android and iOS. We’ll do all our coding in main.dart and sibling files, with no pressing need to touch any of the other files or directories.</p><p>You should verify that you can launch the sample app. Start an emulator or plug in a device, then execute</p><pre>$ flutter run</pre><p>in the charts directory. You should then see a simple counting app on your emulator or device. It uses Material Design widgets, which is nice, but optional. As the top-most layer of the Flutter architecture, those widgets are completely replaceable.</p><p>Let’s start by replacing the contents of main.dart with the code below, a simple starting point for playing with chart animations.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/8d5e916d43424063a8b320ea23ebe8d2/href\">https://medium.com/media/8d5e916d43424063a8b320ea23ebe8d2/href</a></iframe><p>Save the changes, then restart the app. You can do that from the terminal, by pressing R. This ‘full restart’ operation throws away the application state, then rebuilds the UI. For situations where the existing application state still makes sense after the code change, one can press r to do a ‘hot reload’, which only rebuilds the UI. There is also a Flutter plugin for IntelliJ IDEA providing the same functionality integrated with a Dart editor:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*soCdZ19Qugtv1YJewMQZGg.png\" /><figcaption>Screen shot from IntelliJ IDEA with the Flutter plug-in, showing the reload and restart buttons in the top-right corner. These buttons are enabled, if the app has been started from within the IDE.</figcaption></figure><p>Once restarted, the app shows a centered text label saying Data set: null and a floating action button to refresh the data. Yes, humble beginnings.</p><p>To get a feel for the difference between hot reload and full restart, try the following: After you’ve pressed the floating action button a few times, make a note of the current data set number, then replace Icons.refresh with Icons.add in the code, save, and do a hot reload. Observe that the button changes, but that the application state is retained; we’re still at the same place in the random stream of numbers. Now undo the icon change, save, and do a full restart. The application state has been reset, and we’re back to Data set: null.</p><p>Our simple app shows two central aspects of the Flutter widget concept in action:</p><ul><li>The user interface is defined by a tree of <strong>immutable widgets </strong>which is built via a foxtrot of constructor calls (where you get to configure widgets) and build methods (where widget implementations get to decide how their sub-trees look). The resulting tree structure for our app is shown below, with the main role of each widget in parentheses. As you can see, while the widget concept is quite broad, each concrete widget type typically has a very focused responsibility.</li></ul><pre>MaterialApp                    (navigation)<br>  ChartPage                    (state management)<br>    Scaffold                   (layout)<br>      Center                   (layout)<br>        Text                   (text)<br>      FloatingActionButton     (user interaction)<br>        Icon                   (graphics) </pre><ul><li>With an immutable tree of immutable widgets defining the user interface, the only way to change that interface is to rebuild the tree. Flutter takes care of that, when the next frame is due. All we have to do is tell Flutter that some state on which a subtree depends has changed. The root of such a <strong>state-dependent subtree</strong> must be a StatefulWidget. Like any decent widget, a StatefulWidget is not mutable, but its subtree is built by a State object which is. Flutter retains State objects across tree rebuilds and attaches each to their respective widget in the new tree during building. They then determine how that widget’s subtree is built. In our app, ChartPage is a StatefulWidget with ChartPageState as its State. Whenever the user presses the button, we execute some code to change ChartPageState. We’ve demarcated the change with setState so that Flutter can do its housekeeping and schedule the widget tree for rebuilding. When that happens, ChartPageState will build a slightly different subtree rooted at the new instance of ChartPage.</li></ul><p>Immutable widgets and state-dependent subtrees are the main tools that Flutter puts at our disposal to address the complexities of state management in elaborate UIs responding to asynchronous events such as button presses, timer ticks, or incoming data. From my desktop experience I’d say this complexity is <em>very</em> real. Assessing the strength of Flutter’s approach is — and should be — an exercise for the reader: try it out on something non-trivial.</p><p>Our charts app will stay simple in terms of widget structure, but we’ll do a bit of animated custom graphics. First step is to replace the textual representation of each data set with a very simple chart. Since a data set currently involves only a single number in the interval 0..100, the chart will be a bar chart with a single bar, whose height is determined by that number. We’ll use an initial value of 50 to avoid a null height:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b97dcebf4c1b4f627c53a2b2f1a8c6b7/href\">https://medium.com/media/b97dcebf4c1b4f627c53a2b2f1a8c6b7/href</a></iframe><p>CustomPaint is a widget that delegates painting to a CustomPainter strategy. Our implementation of that strategy draws a single bar.</p><p>Next step is to add animation. Whenever the data set changes, we want the bar to change height smoothly rather than abruptly. Flutter has an AnimationController concept for orchestrating animations, and by registering a listener, we’re told when the animation value — a double running from zero to one — changes. Whenever that happens, we can call setState as before and update ChartPageState.</p><p>For reasons of exposition, our first go at this will be ugly:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/096e58d80a92d64d7f4901e66961fab0/href\">https://medium.com/media/096e58d80a92d64d7f4901e66961fab0/href</a></iframe><p>Ouch. Complexity already rears its ugly head, and our data set is still just a single number! The code needed to set up animation control is a minor concern, as it doesn’t ramify when we get more chart data. The real problem is the variables startHeight, currentHeight, and endHeight which reflect the changes made to the data set and the animation value, and are updated in three different places.</p><p>We are in need of a concept to deal with this mess.</p><p>Enter <strong>tweens</strong>. While far from unique to Flutter, they are a delightfully simple concept for structuring animation code. Their main contribution is to replace the imperative approach above with a functional one. A tween is a <em>value</em>. It describes the path taken between two points in a space of other values, like bar charts, as the animation value runs from zero to one.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/260/1*3KpUQjhZLrvwvjF0daKg9g.jpeg\" /></figure><p>Tweens are generic in the type of these other values, and can be expressed in Dart as objects of the type Tween&lt;T&gt;:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/700759a916df107cf64bd8f067b8ebf8/href\">https://medium.com/media/700759a916df107cf64bd8f067b8ebf8/href</a></iframe><p>The jargon lerp comes from the field of computer graphics and is short for both <em>linear interpolation</em> (as a noun) and <em>linearly interpolate</em> (as a verb). The parameter t is the animation value, and a tween should thus lerp from begin (when t is zero) to end (when t is one).</p><p>The Flutter SDK’s <a href=\"https://docs.flutter.io/flutter/animation/Tween-class.html\">Tween&lt;T&gt;</a> class is very similar to the above, but is a concrete class that supports mutating begin and end. I’m not entirely sure why that choice was made, but there are probably good reasons for it in areas of the SDK’s animation support that I have yet to explore. In the following, I’ll use the Flutter Tween&lt;T&gt;, but pretend it is immutable.</p><p>We can clean up our code using a single Tween&lt;double&gt; for the bar height:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/d8f66cc086d6c12d83708f24a090b13f/href\">https://medium.com/media/d8f66cc086d6c12d83708f24a090b13f/href</a></iframe><p>We’re using Tween for packaging the bar height animation end-points in a single value. It interfaces neatly with the AnimationController and CustomPainter, avoiding widget tree rebuilds during animation as the Flutter infrastructure now marks CustomPaint for repaint at each animation tick, rather than marking the whole ChartPage subtree for rebuild, relayout, and repaint. These are definite improvements. But there’s more to the tween concept; it offers <em>structure</em> to organize our thoughts and code, and we haven’t really taken that seriously. The tween concept says,</p><p><em>Animate </em><em>Ts by tracing out a path in the space of all </em><em>Ts as the animation value runs from zero to one. Model the path with a </em><em>Tween&lt;T&gt;.</em></p><p>In the code above, T is a double, but we do not want to animate doubles, we want to animate bar charts! Well, OK, single bars for now, but the concept is strong, and it scales, if we let it.</p><p>(You may be wondering why we don’t take that argument a step further and insist on animating data sets rather than their representations as bar charts. That’s because data sets — in contrast to bar charts which are graphical objects — generally do not inhabit spaces where smooth paths exist. Data sets for bar charts typically involve numerical data mapped against discrete data categories. But without the spatial representation as bar charts, there is no reasonable notion of a smooth path between two data sets involving different categories.)</p><p>Returning to our code, we’ll need a Bar type and a BarTween to animate it. Let’s extract the bar-related classes into their own bar.dart file next to main.dart:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/731869321dcedfe09a8c84939b0ca90d/href\">https://medium.com/media/731869321dcedfe09a8c84939b0ca90d/href</a></iframe><p>I’m following a Flutter SDK convention here in defining BarTween.lerp in terms of a static method on the Bar class. This works well for simple types like Bar, Color, Rect and many others, but we’ll need to reconsider the approach for more involved chart types. There is no double.lerp in the Dart SDK, so we’re using the function lerpDouble from the dart:ui package to the same effect.</p><p>Our app can now be re-expressed in terms of bars as shown in the code below; I’ve taken the opportunity to dispense of the dataSet field.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5b33423ef85d47f1ce28e2b002792d78/href\">https://medium.com/media/5b33423ef85d47f1ce28e2b002792d78/href</a></iframe><p>The new version is longer, and the extra code should carry its weight. It will, as we tackle increased chart complexity in <a href=\"https://medium.com/@mravn/zero-to-one-with-flutter-part-two-5aa2f06655cb\">part two</a>. Our requirements speak of colored bars, multiple bars, partial data, stacked bars, grouped bars, stacked and grouped bars, … all of it animated. Stay tuned.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/372/1*n76TpChNv8Q25WrfBiuWpw.gif\" /><figcaption>A preview of one of the animations we’ll do in part two.</figcaption></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=43b13fd7b354\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/zero-to-one-with-flutter-43b13fd7b354\">Zero to One with Flutter</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2017-01-17T21:27:57.000Z":{"title":"A Dart REPL PoC","link":"https://medium.com/dartlang/dart-repl-poc-f327e3769b6f?source=rss----23738d481ce8---4","guid":"https://medium.com/p/f327e3769b6f","category":["software-development","google","programming","javascript","python"],"dc:creator":"Andreas Kirsch","pubDate":"Tue, 17 Jan 2017 21:27:57 GMT","atom:updated":"2017-01-18T11:13:10.906Z","content:encoded":"<h4>Hacking with Dart</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/proxy/0*lOBcrb2bYgKV6VYT.png\" /></figure><p><a href=\"https://www.python.org/\">Python</a>’s interactive mode is great. <a href=\"http://dartlang.org/\">Dart</a> does not have an interactive mode at the moment, but it is really good for prototyping ideas quickly, so let’s see if we can hack something together!</p><p><em>Disclaimer: I do work for Google, but this post is about a personal project. I’m not on the Dart team or related. This is just my humble opinion and my story. Come along.</em></p><p>The interactive mode in languages like Python or Ruby has helped make them very approachable for beginners. But these are not the only ones that use the concept of a <a href=\"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop\">REPL</a>. A REPL is a read-eval-print loop. Shells like BASH or zsh also employ REPLs when you interact with them in a terminal. It is also what you get when you work with notebooks in <a href=\"http://jupyter.org/\">Jupyter</a> (IPython Notebooks), <a href=\"https://www.mathworks.com/products/matlab.html\">Matlab</a>, <a href=\"https://www.wolfram.com/mathematica/\">Mathematica</a> or <a href=\"https://www.maplesoft.com/products/maple/\">Maple</a>. This way of interactive computing is very popular with researchers.</p><p>This is what Python’s interactive mode looks like:</p><figure><a href=\"https://asciinema.org/a/99317\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/866/1*sqspbSjstPhKIsIbZBDq-Q.gif\" /></a><figcaption>Good ol’ Python REPL</figcaption></figure><p>Dart does not support evaluating statements in a global scope like Python, so there is no obvious way to do it correctly. In Dart, statements have to be inside functions and the main function is the entry point of a program. Just like in C++ or C#. Personally, I prefer this as it makes it easier to figure out what is happening when a program runs. But… I’d still really want an interactive mode. It would allow me to play around with ideas and try things out even faster. So let’s see if we can create a REPL as a proof of concept!</p><h3>How can we create a REPL in dart?</h3><p>Dart is really good for prototyping. So let’s do just that and not get bogged down by language design questions :)</p><p>Now there is no eval function like in JavaScript or Python, and I don’t want to write a full blown interpreter myself to implement one. It wouldn’t be very fast and I don’t have a lot of time either. However, when you debug <a href=\"https://www.dartlang.org/tools/jetbrains-plugin\">Dart code in Intellij</a>, you can evaluate expressions while you step through your code. Evaluating expressions is very much what we’d like to do, isn’t it? Can we use this feature?</p><p>Dart’s debugging capabilities are exposed through its <a href=\"https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md\">VM service</a>. It is an JSON-RPC service provided by the <a href=\"https://www.dartlang.org/dart-vm\">Dart VM</a> that you can connect to to debug your application. <a href=\"https://medium.com/u/a81c627aeff9\">Natalie Weizenbaum</a> has published an article about the vm_service_client package that provides a very nice API to interact with the VM service: <a href=\"http://news.dartlang.org/2016/05/unboxing-packages-vmserviceclient.html\">http://news.dartlang.org/2016/05/unboxing-packages-vmserviceclient.html</a></p><p>Now what we can do is: our REPL can connect to its own VM service to evaluate expressions that it reads from the terminal! That sounds crazy…</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/552/0*wtt2rUBIRxHnPUHv.jpg\" /></figure><p>… but it works! I have written a <a href=\"https://github.com/BlackHC/dart_repl/blob/ca3518074c94f48ce5be872b15b58556133a474c/bin/repl.dart\">quick spike</a> and indeed it works. Dart supports <a href=\"https://www.dartlang.org/tutorials/language/futures\">asynchronous programming</a>, which comes in really handy as it keeps the program from blocking itself when talking to its own VM service.</p><blockquote>Spikes are a concept from test-driven development: they are quick and dirty experiments one writes to figure out some technical questions.</blockquote><p>With the question of feasibility settled, it is easy to write a proper proof of concept. To evaluate expressions that go beyond 1 + 1, we need to support variables. Now variables cannot easily be created because a variable declaration is not an expression in Dart. In Python, you can just declare a variable on the fly by assigning to it. In Dart, we can simulate dynamic fields by overloading n<a href=\"https://www.dartlang.org/articles/language/emulating-functions#interactions-with-mirrors-and-nosuchmethod\">oSuchMethod</a> to create elements in a dictionary on the fly. I call this class Scope and when we <a href=\"https://www.dartdocs.org/documentation/vm_service_client/0.2.3/vm_service_client/VMInstanceRef/evaluate.html\">evaluate expressions within an instance</a> of it, the fields can be accessed like globals.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/460/0*2PUDlyPF7rchkNmA.jpg\" /></figure><p>The code is actually more straight-forward:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/24c2ff5f3a35ac2aff25a18c34a6fa36/href\">https://medium.com/media/24c2ff5f3a35ac2aff25a18c34a6fa36/href</a></iframe><p>With this, we can already do stuff like a = 3and b = a*3:</p><figure><a href=\"https://asciinema.org/a/99312\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/866/1*2tDjwpxSxslDUfiv8enwow.gif\" /></a><figcaption>Simple expressions: DONE</figcaption></figure><p>One limitation, we quickly run into is, that we can only access symbols that have been imported in the file that declares the Scope class. import ‘…’; cannot be evaluated using the VM service. So no dart:io if we don’t import it explicitly, and no custom libraries :(</p><p>Oh wait! Dart can spawn new isolates (independent workers) using a URI with <a href=\"https://api.dartlang.org/stable/1.21.1/dart-isolate/Isolate/spawnUri.html\">Isolate.spawnUri</a>. Users could specify additional imports on the command-line, and the REPL could generate source code to include these imports and then spawn a new isolate using the generated code that has the imports available for the user.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/570/0*bgs2vFlKPkZsFbSO.jpg\" /></figure><p>And it works \\o/</p><figure><a href=\"https://asciinema.org/a/99313\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/866/1*eh9q0mNToXK0R_QiYdrylw.gif\" /></a><figcaption>Custom imports: DONE</figcaption></figure><h3>Supporting more Dart</h3><p>Now another issue is that we only can evaluate expressions. Control statements like if/else blocks or while loops are not expressions. For statements, we could wrap them in a closure and execute the closure, which is a function call expression. Thus, if (a == 1) print(&#39;a is 1!!&#39;); would become</p><pre>() { if (a == 1) print(&#39;a is 1!!&#39;); }();</pre><p>We just need to figure out if the input is an expression or a statement. This is difficult because we’d have to write a Dart parser for this. But Dart is written in Dart, and the <a href=\"https://pub.dartlang.org/packages/analyzer\">analyzer</a> package provides a parser that can parse any Dart code for free!</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/c81085d088d4d2246a4159f5d1af133b/href\">https://medium.com/media/c81085d088d4d2246a4159f5d1af133b/href</a></iframe><p>And thus, that is also solved.</p><figure><a href=\"https://asciinema.org/a/99314\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/866/1*uemGA2TzYypx2RmooQfwmg.gif\" /></a><figcaption>Statements and expressions: DONE</figcaption></figure><h3>More imports</h3><p>The last bit that keeps us from importing just any library is that by default a new Isolate only sees the packages that are mentioned in its pubspec.yaml. We want to support importing any library though. Isolate.spawnUri has a packageConfig parameter that allows us to specify a map from package name to package path. We can just use another command-line parameter to target another package and use its package config in our Isolate. Woohoo!</p><p>We quickly run into the problem that our Isolate needs to access the analyzer package (and others) that might not be loaded by whatever package you want to toy around with in your REPL session. Package <a href=\"https://pub.dartlang.org/packages/package_resolver\">package_resolver</a> to the rescue! With it, we can easily manipulate package configurations.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e22f734a0e7be08e8ee8eb506616ac2d/href\">https://medium.com/media/e22f734a0e7be08e8ee8eb506616ac2d/href</a></iframe><p>With all this, we have a full workflow implemented:</p><figure><a href=\"https://asciinema.org/a/99316\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/866/1*KKIJauKlylkVMaLvhJQq9w.gif\" /></a><figcaption>Import any library from another package: DONE</figcaption></figure><h3>What’s next?</h3><p>This was a long post… The whole proof of concept clocks in at <strong>451 lines of code</strong>, so almost as long as this post.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/625/0*Xn430bpRfeDmM9uF.jpg\" /></figure><p>The code can be found on <a href=\"https://github.com/BlackHC/dart_repl/tree/master/lib\">https://github.com/BlackHC/dart_repl</a>. You can give it a go easily if you have Dart installed:</p><pre>pub global activate dart_repl<br>pub global run dart_repl</pre><p>I really enjoyed creating this proof of concept in my spare time. All the pieces just fell into place within a couple of hours. IDE support for Dart in Intellij is excellent, and there are a ton of documentation and articles around now. Check out <a href=\"https://medium.com/u/a81c627aeff9\">Natalie Weizenbaum</a>’s Unboxing Packages series for example: <a href=\"http://news.dartlang.org/2016/04/unboxing-packages-async-part-3.html\">http://news.dartlang.org/2016/04/unboxing-packages-async-part-3.html</a> et al. Low-level hacking in Dart is fun, and there are great libraries to get creative with. <a href=\"https://github.com/dart-lang/code_builder\">code_builder</a> is looking very promising and <a href=\"https://github.com/google/built_collection.dart\">built_collection</a> is providing immutable collections. <a href=\"https://medium.com/u/7c51fc1918ba\">David Morgan</a> has also been publishing articles on <a href=\"https://medium.com/dartlang/darts-built-collection-for-immutable-collections-db662f705eff#.kj3ubd2xj\">immutable collections</a> in Dart.</p><p>For dart_repl, it would be nice to import additional libraries at runtime without restarts. The Dart team has recently added support for hot reloading to the VM. This mainly provides a better experience in <a href=\"https://flutter.io/\">Flutter</a> for mobile app developers. Maybe, this could be used for adhoc imports and for defining functions and classes in the REPL, too.</p><p>In general, Dart could be great for research and for researchers, and I would absolutely love to see Jupyter support for Dart. One would only have to implement its kernel interface to make such a Dart REPL compatible with it… :) That should be easy, right?</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/400/0*0_DI8nuDDB5VwIbc.jpg\" /></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f327e3769b6f\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart-repl-poc-f327e3769b6f\">A Dart REPL PoC</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2017-01-11T15:04:48.000Z":{"title":"Dart-on-LLVM","link":"https://medium.com/dartlang/dart-on-llvm-b82e83f99a70?source=rss----23738d481ce8---4","guid":"https://medium.com/p/b82e83f99a70","category":["dart","programming","dartlang","llvm","javascript"],"dc:creator":"Erik Corry","pubDate":"Wed, 11 Jan 2017 15:04:48 GMT","atom:updated":"2017-01-11T15:19:23.494Z","content:encoded":"<p>This is a story about an experiment to compile the <a href=\"https://www.dartlang.org/\">Dart</a> language using the <a href=\"http://llvm.org/\">LLVM</a> compiler framework. On its face this is pretty pointless, since</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/845/1*DN03P0ofCSyHM6UwB42Nyg.png\" /></figure><p>Dart already has an excellent <a href=\"https://www.dartlang.org/dart-vm/tools/dart-vm\">virtual machine</a> which uses <a href=\"https://en.wikipedia.org/wiki/Just-in-time_compilation\">just-in-time</a> compilation to get excellent performance. Since Dart is dynamically typed (more precisely, it’s <a href=\"https://www.dartlang.org/articles/language/optional-types\">optionally typed</a>), a JIT compiler is a natural fit — it can use the types available at runtime to perform optimizations that a static compiler can’t do.</p><p>Another reason Dart-on-LLVM looks like a fool’s errand is that, despite the name, LLVM is not a virtual machine, and until recently it was not suitable for languages with garbage collection. By suitable, we mean:</p><ul><li>Moving, precise (non-leaking) GC</li><li>Highly optimized</li></ul><p>This is because, once the optimizer had munged your code, you no longer had any way to find the GC-able pointers on the stack. A common strategy was to move all pointers to special memory areas, but this defeats many of the optimization strategies in a modern compiler, which relies on register allocation of local variables to work its magic. You could either have good GC or full performance, not both.</p><p>New winds are blowing in LLVM-land, though. Recently, LLVM has grown some GC support in the form of the experimental <a href=\"http://llvm.org/docs/Statepoints.html\"><em>Statepoint</em></a> feature. This has been used by various brave groups, including the people behind the <a href=\"https://github.com/ispras/llv8/wiki\">LLV8</a> experiment and <a href=\"http://llvm.org/devmtg/2015-10/slides/DasReames-LLVMForAManagedLanguage.pdf\">Azul</a>, who are using it for a new top-tier compiler for their JVM.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/845/1*g6p0yM6fD_UD3rfsOWGQ-A.png\" /></figure><p>It appears that building a real VM based on LLVM has gone from being “mission impossible” to being merely “<a href=\"https://www.youtube.com/watch?v=gJGJMi-sUS8\">mission difficult</a>”. At the same time, <a href=\"https://github.com/dart-lang/dev_compiler/blob/master/STRONG_MODE.md\">strong mode</a> makes Dart more statically typed, and less dynamic. Also, we at Google are building <a href=\"https://www.youtube.com/watch?v=Mx-AllVZ1VY&amp;t=0m29s\">Flutter</a> for iOS, where JIT compilation is banned. Both these developments align Dart better with the LLVM project’s goals and trade-offs.</p><h3>Why LLVM?</h3><p>LLVM is a modern, well maintained Open Source compiler framework, which gives us a lot of optimization and platforms “for free”. For example, there’s a complete <a href=\"http://llvm.org/docs/Passes.html#inline-function-integration-inlining\">inlining</a> pass which can inline any function into any other, and contains <a href=\"https://bugs.chromium.org/p/v8/issues/detail?id=3354\">heuristics</a> for when to do so.</p><p>It also looks like an open, welcome community, which welcomes contributions.</p><h3>Goals of the experiment</h3><ul><li>The context is Strong Mode Dart in an ahead-of-time compiled scenario</li><li>Evaluate the feasibility of using Statepoint support for precise, moving GC</li><li>Evaluate performance</li></ul><h3>Methodology</h3><p>We (<a href=\"https://medium.com/u/9fa86af2470a\">Erik Corry</a> and Dmitry Olshansky) based our experiment on the discontinued “<a href=\"https://github.com/dartino/sdk\">Dartino</a>” runtime. This was an experimental Dart runtime optimized for small devices. It had a few advantages for us over using the DartVM as a basis:</p><ul><li>There was already an experimental LLVM backend for Dartino, built by <a href=\"https://medium.com/u/191fa0fcb4fe\">Martin Kustermann</a>. This had no GC support, so it crashed when it ran out of memory.</li><li>Dartino makes use of a lot of the machinery of <a href=\"https://webdev.dartlang.org/tools/dart2js\">Dart2JS</a>, and so it doesn’t need a complete parser, front end etc. The Dartino bytecodes we use as input already have a lot of difficult Dart features lowered away. For example, closures are objects, and optional arguments have been turned into different versions of functions.</li><li>We were both already familiar with Dartino.</li><li>Dartino comes with a relatively complete runtime and is capable of running large apps, eg hosting Dart2JS. It doesn’t have a lot of Unix IO support and the threading model is different, so it is not a drop-in replacement.</li></ul><h3>Garbage Collection in Dartino</h3><p>The existing Dartino LLVM experiment was forked from Dartino a while back, when the GC was very simple (semispace <a href=\"https://en.wikipedia.org/wiki/Cheney&#39;s_algorithm\">Cheney collector</a>, no generations, big pauses, 2x memory footprint overhead). We cherry-picked changes from the main Dartino branch to get a more conventional 2-generation GC with write barriers. There are no read barriers, and collection is stop-the-world, without concurrent GC (though LLVM Statepoints do look to have support for these features, and they are almost certainly being used by Azul in their closed source VM).</p><p>We did not cherry pick the compacting old-generation support from newer Dartino versions.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/1*VqmfjhoN9cMWH0vz37zU6A.jpeg\" /></figure><h3>Architecture</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/964/1*pyM5bJo-_-i8Leum4yHPOQ.png\" /></figure><p>The above pipeline shows the path from Dart source to machine code. In a real implementation, the first parts would be replaced by something based on the ‘<a href=\"https://github.com/dart-lang/sdk/tree/master/pkg/kernel\">kernel</a>’ format (preparsed Dart source frontend).</p><h4>Translation to LLVM and high level optimization</h4><p>llvm-codegen is linked to our own copy of LLVM, and performs high level optimizations. At this stage, LLVM maintains the fiction that pointers are valid across GCs, but the pointers are marked with a non-default “address space” which prohibits LLVM from reasoning about their bit patterns in ways that would be incorrect in the presence of moving GC. Various custom LLVM intrinsics are used to mark points where GC can occur.</p><p>Because of tagged pointers, the LLVM bitcode is very ugly with lots of casts and adds. Therefore this document contains “LLVM pseudocode”, and not the true .ll file. If you are used to actual .ll files this is going to look like “Baby’s first .ll babblings”, sorry! The following represents the code for a dynamic dispatch after mem2reg, the pass that lifts local variables from the stack into <a href=\"https://en.wikipedia.org/wiki/Static_single_assignment_form\">SSA</a> registers:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2a556a8d39b25d686a2bc724b0a201cb/href\">https://medium.com/media/2a556a8d39b25d686a2bc724b0a201cb/href</a></iframe><p>After the optimizer has run, the rather laborious lookup above has been lifted out of the loop, leaving only the call instruction. This is possible because class pointers are immutable in Dart and we have attached various metadata to the load instructions (not shown), including invariant.loadand never.faults(the latter is an addition to our <a href=\"https://github.com/ErikCorryGoogle/llvm\">patched version of LLVM</a>).</p><h4>Lowering</h4><p>Once high level optimizations have been run, we lower most of the intrinsics to normal LLVM instructions. For example, the write barrier is reduced to a series of stores (Dartino uses a card marking scheme that owes a lot to <a href=\"https://medium.com/u/f4d8d5c764a8\">Urs</a>’ <a href=\"http://hoelzle.org/publications/urs-thesis.pdf\">PhD</a> section 6.2.3). After lowering, every local-variable pointer is rewritten by an opaque intrinsic at every possible GC point (every call, basically). This inhibits a lot of optimizations (which is why we had to do optimization passes before lowering), but serves two purposes:</p><ul><li>The intrinsic will later be used to generate stack maps, detailing the location of GC-able pointers on the stack.</li><li>The SSA values are broken up into before-GC and after-GC values, which makes the GC visible to the optimizer and prevents invalid codegen.</li></ul><p>The call now looks more like this (the dispatch has been hoisted out of a loop, so %code contains the code pointer — the loop is not shown)</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/706ab9a6a3bcade0d6dd9d9ebfa2b478/href\">https://medium.com/media/706ab9a6a3bcade0d6dd9d9ebfa2b478/href</a></iframe><p>The transformation is rather clumsy, creating a special token in the transformed call, and using that as an argument in the calls to gc.result and gc.relocate. The GC-able pointers are still specially marked (with a non-zero address space, not shown in the pseudo-LLVM above), which inhibits some optimizations at the next stage.</p><h4>Code generation</h4><p>The final step is code generation, performed by the LLVM program llc. This step can be done by a completely unpatched ToT LLVM with the command llc -O3. The only backend with support for the experimental GC intrinsics is currently x64, but we don’t see any fundamental barriers to adding and upstreaming ARM support. The dynamic dispatch call site now looks like:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/cd4cec4022d4c83b1a111e22469a344f/href\">https://medium.com/media/cd4cec4022d4c83b1a111e22469a344f/href</a></iframe><p>This uses the standard (mostly register-based) calling convention for x64. Before every call, a bunch of registers are spilled to the stack, where they can be moved by the GC if needed. There is no support for callee-saved GC-able values (V8 and DartVM don’t support this either).</p><h3>Performance</h3><p>Dartino byte code is optimized for simplicity and compactness in a very dynamically typed environment. For this analysis we attempt to look forward to a scenario where strong mode is used, and types are known when compiling. In this scenario, dispatch of methods and access to member variables on objects would be simpler and faster. In order to get closer to that scenario, we are making use of some whole program analyses when generating LLVM code.</p><p>The most important consequence of this is that if only a few classes have a method foo(), then we check for those classes and call the foo() method directly. Unlike some vtable-like dispatch mechanism, this lets LLVM inline the method where it makes sense. This is a huge win, especially for <a href=\"https://www.dartlang.org/resources/dart-tips/dart-tips-ep-10\">getters and setters</a>, which are a great feature of Dart.</p><p>The compiler still has to handle a lot of dynamic-language issues, which it does mostly correctly (see test status section below). In particular, integers can overflow and become real heap allocated number objects at any time. Together with the overloading of operators this makes even simple for-loops rather complicated. More static analysis can probably improve this.</p><p>One difference to the real DartVM is that we don’t check for stack overflows and we don’t check for thread interruptions on loop back edges. Based on experience from V8 we guesstimate that fixing this could cost about 10% performance.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*_B_KUgeFwaeUxC97GBIHPw.png\" /></figure><p>We compare against the regular JITing DartVM, and the new ahead-of-time support that has been added to the DartVM for <a href=\"https://flutter.io/\">Flutter</a>. Benchmarks are <a href=\"https://github.com/dartino/sdk/tree/master/benchmarks\">from Dartino</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*uB5TngqsrAvvzu_fr8KCdg.png\" /></figure><p>Running a short lived program like Hello World shows mainly the time to do startup. The JIT-based system spends time compiling code, and both the non-LLVM solutions here are deserializing a data heap on startup.</p><h3>Performance Conclusions</h3><p>We have comparable performance to Flutter’s existing ahead-of-time technology (which is a moving target — these measurements were made in late November 2016 on a beefy 64 bit Linux workstation). The JIT is still a long way ahead. The garbage collection performance of the Dartino fork we are running on, is not up to speed.<br>We also measured startup time. Dartino-LLVM generates static data for the classes, constants, and dispatch tables. These are loaded by the highly optimized <a href=\"https://www.cs.virginia.edu/~dww4s/articles/ld_linux.html\">ld.linux</a> runtime linker, and they load faster than the current Dart AOT data heap snapshot, giving very good performance for startup. For the startup tests the CPU governor was set to “performance”.</p><h3>A note on compatibility</h3><p>For this study we have not been especially focused on getting 100% Dart compatibility. It is sufficient to do the “hard things” i.e. GC and exception handling, to prove they are possible. In some cases we took a shortcut that showed a real solution was possible without wasting time on actually implementing the real solution. Here are some places we compromised:</p><ul><li>Like Dartino we don’t have infinite-precision integers. However, we do check all int operations for overflow and switch dynamically to a boxed number representation (however, the boxed representation is only 64 bit, wrapping).</li><li>On no-such-method (a failed type check, essentially), we don’t follow the full Dart semantics, which includes calling the no-such-method method and checking for a getter, that has the same name as the missing method and returns an object with a ‘call’ method. However, we do throw an exception at a safe point (a point where allocation can take place).</li><li>We don’t check for stack overflow on calls, or check for interruptions on loop back edges. LLVM does have experimental support for these. The solutions we are comparing against do support this. Experience from V8 suggests that fixing this might cause about 10% performance degradation.</li><li>Our front-end compiler is a modified Dart2JS. Since Dartino was discontinued, it has not kept up with the latest changes to the language, and so there are some tests we cannot run.</li><li>Dart exception handling is fully implemented apart from the no-such-method related exceptions. For this we used the exception handling support built into LLVM, which looks adequate for the task and well aligned to Dart’s exception model (which is at heart not so different from C++, for which LLVM was designed).</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/348/1*4bthU0tgek2j09dJuKn-aQ.png\" /></figure><p>In all, we pass almost 90% of the tests that Dartino could pass. Of the ones we fail, the biggest reasons are problems with the compiler front-end and problems handling no-such-method events.</p><p>Of the ca 11.6% tests that fail, here is a breakdown of why they fail:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/598/1*f_vtnoVYGfdXXqPUaGrOGw.png\" /></figure><h3>Conclusions</h3><p>The experimental LLVM GC support appears to be fully functional on x64.<br>Performance of the prototype was on a par with our more mature DartVM-based ahead-of-time solution.</p><p>For the performance analysis we are making no use of Dart strong mode, which can be expected to yield optimization opportunities that play to LLVM’s strengths. We are, however, making use of some closed world assumptions, which we think are realistic.</p><p>We are able to compile the last stage from LLVM bitcode to machine code using only an unpatched LLVM ToT build (marked in blue on the pipeline diagram above). The optimizations performed at this stage (-O3) did not cause any miscompilations or GC issues that we observed.</p><h3>Future</h3><p>There has been no decision on how and whether to use this approach for Dart or Flutter, but here are some random thoughts on interesting avenues that could be explored.</p><ul><li>Having a home-grown language other than C++-with-handles to write runtime routines. The back-end would be LLVM-with-Statepoints. (There is a little Forth experiment in the current branch, but something more beefy would be needed to write more than the very simplest native routines in).</li><li>What impact would wrapping 64 bit integers have?</li><li>How can we use whole-program knowledge to generate code while still allowing parallel compilation of large projects?</li></ul><h3>References</h3><p>LLVM GC support <a href=\"http://llvm.org/docs/Statepoints.html\">http://llvm.org/docs/Statepoints.html</a><br>Dartino-LLVM repository <a href=\"https://github.com/dartino/sdk/tree/llvm\">https://github.com/dartino/sdk/tree/llvm</a><br>Modified LLVM repo <a href=\"https://github.com/ErikCorryGoogle/llvm\">https://github.com/ErikCorryGoogle/llvm</a><br>Urs Hölzle PhD: <a href=\"http://hoelzle.org/publications/urs-thesis.pdf\">http://hoelzle.org/publications/urs-thesis.pdf</a><br>LLV8: <a href=\"https://github.com/ispras/llv8\">https://github.com/ispras/llv8</a></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b82e83f99a70\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart-on-llvm-b82e83f99a70\">Dart-on-LLVM</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2016-12-07T14:23:29.000Z":{"title":"Dart’s built_value for Serialization","link":"https://medium.com/dartlang/darts-built-value-for-serialization-f5db9d0f4159?source=rss----23738d481ce8---4","guid":"https://medium.com/p/f5db9d0f4159","category":["dart","programming","immutability","dartlang","json"],"dc:creator":"David Morgan","pubDate":"Wed, 07 Dec 2016 14:23:29 GMT","atom:updated":"2017-02-20T12:18:41.878Z","content:encoded":"<p>Last week I introduced <a href=\"https://medium.com/@davidmorgan_14314/darts-built-value-for-immutable-object-models-83e2497922d4\">built_value for immutable object models</a>. We saw how to define object models in built_value; they’re immutable, easy to work with, and, if you like that sort of thing, a lot of fun.</p><p>This article covers the rest of the built_value package. The biggest item is that, as you may have guessed from the title, they’re also serializable.</p><p>Here’s what built_value serialization looks like to use:</p><pre>// Value type defined using built_value.<br>abstract class Login implements Built&lt;Login, LoginBuilder&gt; {<br>  // Add serialization support by defining this static getter.<br>  static Serializer&lt;Login&gt; get serializer =&gt; _$loginSerializer;</pre><pre>  ...<br>}</pre><pre>// Once per app, define a top level &quot;Serializer&quot; to gather together<br>// all the generated serializers.<br>Serializers serializers = _$serializers;</pre><pre>// Use it!<br>var login = new Login((b) =&gt; b<br>  ..username = &#39;johnsmith&#39;<br>  ..password = &#39;123456&#39;);</pre><pre>print(JSON.encode(serializers.serialize(login)));<br>--&gt;<br>[&quot;Login&quot;, &quot;username&quot;, &quot;johnsmith&quot;, &quot;password&quot;, &quot;123456&quot;]</pre><p>Notice the “JSON.encode”? The serializer doesn’t actually go as far as serializing to a String; rather it converts to primitives that Dart’s built-in JSON serialization knows how to handle. So if you want to, you can use something other than JSON.</p><p>You probably think of serialization as something that should “just work”, but there are a few subtle trade-offs involved. Let’s dig into built_value’s serialization.</p><h3>Polymorphism</h3><p>The single most important aspect of built_value’s serialization is that it supports polymorphism. Specifically, you can have fields of <em>abstract</em> types, and</p><ul><li>any serializable implementation of that abstract type can be serialized;</li><li>enough information will be written on the wire to deserialize to the correct types.</li></ul><p>The simplest example is that it can serialize a list of Object:</p><pre>serializers.serialize(new BuiltList&lt;Object&gt;([1, &#39;two&#39;, 3]));<br>--&gt;<br>[&#39;list&#39;, [&#39;int&#39;, 1, &#39;string&#39;, &#39;two&#39;, &#39;int&#39;, 3]]</pre><p>Extra information is added on the wire only as required to disambiguate when deserializing. So if you have a field of type “BuiltList&lt;int&gt;”, it will be serialized like “[1, 2, 3]” and not like “[‘int’, 1, ‘int’, 2, ‘int’, 3]”.</p><p>The bottom line is that you can define your object model however you like, and built_value will serialize it. If you want to see this in more detail, the <a href=\"https://github.com/google/built_value.dart/blob/master/built_value/test/built_map_serializer_test.dart\">map serializer test</a> explores all the possibilities.</p><h3>Multiple Implementations</h3><p>Another problem all serialization mechanisms have to face is somehow defining the <em>universe</em> of serializable types. Here built_json does something a little unusual by allowing <em>multiple implementations</em> of one “type”.</p><p>This works because types are defined on the wire by their <em>class name only</em>. No attempt is made to disambiguate between different classes called “Login”, for example; it’s assumed that both sender and receiver have a compatible serializer for a class called “Login” available.</p><p>This adds useful flexibility. If you’re using Dart on the server and the client, for example, you have a <em>choice</em> for each class in the object model:</p><ul><li>You can use the same class on the client and server.</li><li>Or, you can use different classes. The implementations must have the same name and compatible fields.</li></ul><p>For example, you could have a “Login” class for the client that deals with rendering and parsing; and a separate “Login” class for the server that deals with authentication and databases. Of course, the server-only implementation is free to use packages like “dart:io”, and the client-only implementation packages like “dart:html”.</p><h3>Multiple Languages</h3><p>Because built_value serialization identifies types by the class name alone, the serialized data maps well onto any object oriented language. Support for Java is planned via <a href=\"https://github.com/google/auto/tree/master/value\">AutoValue</a>.</p><h3>Multiple Versions</h3><p>Serialized built_value data is backwards/forwards compatible in a very simple way: it relies on class names and field names. Class name changes and required field name changes are breaking.</p><p>Nullable fields are more flexible: on serialization, they will only be written if non-null; on deserialization, they will default to null if not found. So, nullable fields can be added, removing or renamed and this is not a breaking change.</p><p>Unrecognized fields are simply ignored.</p><h3>No Mirrors</h3><p>Finally, and crucial for performance, is that built_value doesn’t use mirrors in any shape or form. All analysis is done at codegen time, leaving you with minimal, performant serialization code.</p><p>That was serialization with built_value. You can just sit down and write an object model and it is straight away serializable for use in RPCs or for long term storage.</p><h3>EnumClass</h3><p>Finally, built_value comes with one more feature: EnumClass. Dart enums <a href=\"https://www.dartlang.org/guides/language/language-tour#enumerated-types\">aren’t classes</a>, but a powerful object model needs enums that behave like classes. The obvious pattern is to create a class with “static const” fields, and EnumClass makes this a little easier to do. It provides:</p><ul><li>Generated code for “values” and “valueOf”.</li><li>Serialization via built_value serializers.</li><li>An extra bonus for Angular or Angular2 users: the codegen can optionally produce a mixin to help you use the enum from templates.</li></ul><p>All of these features can be seen in the <a href=\"https://github.com/google/built_value.dart/blob/master/example/lib/enums.dart\">example</a>.</p><p>That’s it for this week! Having covered the basics of built_value I’m ready to dive into the chat example in detail next week. Stay tuned!</p><p>Edit: <a href=\"https://medium.com/@davidmorgan_14314/building-a-chat-app-in-dart-815fcd0e5a31#.ncnhb2fh0\">next article</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f5db9d0f4159\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/darts-built-value-for-serialization-f5db9d0f4159\">Dart’s built_value for Serialization</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2016-11-30T11:48:47.000Z":{"title":"Dart’s built_value for Immutable Object Models","link":"https://medium.com/dartlang/darts-built-value-for-immutable-object-models-83e2497922d4?source=rss----23738d481ce8---4","guid":"https://medium.com/p/83e2497922d4","category":["clean-code","programming","dart","immutability","dartlang"],"dc:creator":"David Morgan","pubDate":"Wed, 30 Nov 2016 11:48:47 GMT","atom:updated":"2017-03-29T11:24:58.187Z","content:encoded":"<p>Last week I <a href=\"https://medium.com/@davidmorgan_14314/darts-built-collection-for-immutable-collections-db662f705eff#.71roxijm3\">wrote about</a> <a href=\"https://github.com/google/built_collection.dart\">built_collection</a>. I finished by remarking that to really make use of immutable collections, you need immutable values. So here we are: <a href=\"https://github.com/google/built_value.dart\">built_value</a>. This is the second major piece behind my talk at <a href=\"https://www.youtube.com/watch?v=TMeJxWltoVo\">Dart Developer Summit (video)</a>.</p><h3>Value Types</h3><p>The built_value package is for defining your own <em>value types</em>. The term has a <a href=\"https://en.wikipedia.org/wiki/Value_type\">precise meaning</a>, but we use it informally to mean types where equality is based only on value. For example, numbers: my 3 is equal to your 3.</p><p>Not only that: my 3 will <em>always</em> equal your 3; it can’t change to be 4, or null, or a different type altogether. Value types are naturally immutable. This makes them simple to interact with and to reason about.</p><p>This all sounds terribly abstract. What are value types good for? Well, it turns out: a lot. A whole lot. Arguably — and I do argue this, often — any class that’s used to model the real world should be a value type. Observe:</p><pre>var user1 = new User(name: &quot;John Smith&quot;);<br>var user2 = new User(name: &quot;John Smith&quot;);</pre><pre>print(user1 == user2);</pre><p>What should it print? Crucially, both instances are supposed to refer to someone in the real world. Because their values are identical they must refer to the <em>same person. </em>So they must be considered equal.</p><p>What about immutability? Consider:</p><pre>user1.nickname = &#39;Joe&#39;;</pre><p>What does updating a “User” nickname mean? It could imply any number of changes; perhaps the welcome text on my web page uses the nickname, and that should be updated. I probably have some storage somewhere, so that will need updating too. I now have two major problems:</p><ul><li>I don’t know who has a reference to “user1”. The value has just changed under them; depending on how they’re using it, this could have any number of unpredictable effects.</li><li>Anyone holding “user2” or similar is now holding a value that’s out of date.</li></ul><p>Immutability can’t help with the second problem, but it does remove the first. It means there are no unpredictable updates, just explicit ones:</p><pre>var updatedUser = new User(name: &quot;John Smith&quot;, nickname: &quot;Joe&quot;);<br>saveToDatabase(updatedUser); // Database will notify frontend.</pre><p>Crucially, it means changes are <em>local until explicitly published</em>. This leads to simple code that’s easy to reason about — and to make both correct and fast.</p><h3>The Problem with Value Types</h3><p>So, the obvious question: if value types are so useful, why don’t we see them everywhere?</p><p>Unfortunately they’re extremely laborious to implement. In Dart and in most other Object Oriented languages, a large amount of <a href=\"https://en.wikipedia.org/wiki/Boilerplate_code\">boilerplate code</a> is needed. In my talk at the Dart Developer Summit I showed how a simple two-field class <a href=\"https://www.youtube.com/watch?v=TMeJxWltoVo&amp;feature=youtu.be&amp;t=369\">needs so much boilerplate it fills a whole slide (video)</a>.</p><h3>Introducing built_value</h3><p>We need either a language feature — which is exciting to discuss, but unlikely to arrive any time soon — or some form of <a href=\"https://en.wikipedia.org/wiki/Metaprogramming\">metaprogramming</a>. And what we find is that Dart already has a very nice way to do metaprogramming: <a href=\"https://github.com/dart-lang/source_gen\">source_gen</a>.</p><p>The goal is clear: make it so easy to define and use value types that we can use them wherever a value type makes sense.</p><p>First we’ll need a quick detour to look at how this problem can be approached with source_gen. The source_gen tool creates generated source in new files next to your manually maintained source, so we need to leave room for a generated implementation. That means an abstract class:</p><pre>abstract class User {<br>  String get name;<br>  <br>  @nullable<br>  String get nickname;<br>}</pre><p>That has enough information to generate an implementation. By convention generated code starts with “_$”, to mark it as private and generated. So the generated implementation will be called “_$User”. To allow it to extend “User” there will be a private constructor for this purpose called “_”:</p><pre>=== user.dart ===</pre><pre>abstract class User {<br>  String get name;</pre><pre>  @nullable<br>  String get nickname;</pre><pre>  User._();<br>  factory User() = UserImpl;<br>}</pre><pre>=== user.g.dart is generated by source_gen ===</pre><pre>class _$User extends User {<br>  String name;<br>  String nickname;</pre><pre>  _$User() : super._();<br>}</pre><p>We need to use Dart’s “part” statement to pull in the generated code:</p><pre>=== user.dart ===</pre><pre>library user;</pre><pre>part &#39;user.g.dart&#39;;</pre><pre>abstract class User {<br>  String get name;</pre><pre>  @nullable<br>  String get nickname;</pre><pre>  User._();<br>  factory User() = _$User;<br>}</pre><pre>=== user.g.dart is generated by source_gen ===</pre><pre>part of user;</pre><pre>class _$User extends User {<br>  String name;<br>  String nickname;</pre><pre>  _$User() : super._();</pre><pre>  // Generated implementation goes here.<br>}</pre><p>We’re getting somewhere! We have a way to generate code and plug it into the code we write by hand. Now back to the interesting part: what you actually have to write by hand and what built_value should generate.</p><p>We’re missing a way to actually specify values for the fields. We could think about using named optional parameters:</p><pre>factory User({String name, String nickname}) = _$User;</pre><p>But this has a couple of drawbacks: it forces you to repeat all the field names in the constructor, and it only provides a way to set all the fields in one go; what if you want to build up a value piece by piece?</p><p>Fortunately, the <a href=\"https://en.wikipedia.org/wiki/Builder_pattern\">builder pattern</a> comes to the rescue. We’ve already seen <a href=\"https://medium.com/@davidmorgan_14314/darts-built-collection-for-immutable-collections-db662f705eff#.oj7boxdoh\">how well it works</a> for collections in Dart — thanks to the cascade operator. Assuming we have a builder type, we can use that for the constructor — by asking for a function that takes a builder as a parameter:</p><pre>abstract class User {<br>  String get name;</pre><pre>  @nullable<br>  String get nickname;</pre><pre>  User._();<br>  factory User([updates(UserBuilder b)]) = _$User;<br>}</pre><p>That’s a bit surprising, but it leads to a very simple syntax for instantiation:</p><pre>var user1 = new User((b) =&gt; b<br>    ..name = &#39;John Smith&#39;<br>    ..nickname = &#39;Joe&#39;);</pre><p>What about creating new values based on old ones? The traditional builder pattern provides a “toBuilder” method to convert to a builder; you then apply your updates and call “build”. But a nicer pattern for most use cases is to have a “rebuild” method. Like the constructor, it takes a function that takes a builder, and provides for easy inline updates:</p><pre>var user2 = user.rebuild((b) =&gt; b<br>    ..nickname = &#39;Jojo&#39;);</pre><p>We do still want “toBuilder”, though, for cases when you want to keep a builder around for a little while. So we want two methods for all our value types:</p><pre>abstract class Built&lt;V, B&gt; {<br>  // Creates a new instance: this one with [updates] applied.<br>  V rebuild(updates(B builder));</pre><pre>  // Converts to a builder.<br>  B toBuilder();<br>}</pre><p>You don’t need to write the implementation for these, built_value will generate it for you. So you can just declare that you “implement Built”:</p><pre>library user;</pre><pre>import &#39;package:built_value/built_value.dart&#39;;</pre><pre>part &#39;user.g.dart&#39;;</pre><pre>abstract class User implements Built&lt;User, UserBuilder&gt; {<br>  String get name;</pre><pre>  @nullable<br>  String get nickname;</pre><pre>  User._();<br>  factory User([updates(UserBuilder b)]) = _$User;<br>}</pre><p>And that’s it! A value type defined, an implementation generated and easy to use. Of course, the generated implementation isn’t just fields: it also provides “operator==”, “hashCode”, “toString” and null checks for required fields.</p><p>I’ve skipped over one major detail, though: I said “assuming we have a builder type”. Of course, we’re generating code, so the answer is simple: we’ll generate it for you. The “UserBuilder’ referred to from “User” is created in “user.g.dart”.</p><p>…<em>unless</em> you wanted to write some code in the builder, which is a perfectly reasonable thing to want to do. If that’s what you want, you follow the same pattern for the builder. It’s declared as abstract, with a private constructor and a factory that delegates to the generated implementation:</p><pre>abstract class UserBuilder extends Builder&lt;V, B&gt; {<br>  @virtual<br>  String name;</pre><pre>  @virtual<br>  String nickname;</pre><pre>  // Parses e.g. John &quot;Joe&quot; Smith into username+nickname.<br>  void parseUser(String user) {<br>    ...<br>  }</pre><pre>  UserBuilder._();<br>  factory UserBuilder() =&gt; _$UserBuilder;<br>}</pre><p>The “@virtual” annotations come from “package:meta”, and are needed to allow the generated implementation to override the fields. Now that you’ve added utility methods to your builder you can use them inline just like you could assign to fields:</p><pre>var user = new User((b) =&gt; b..parseUser(&#39;John &quot;Joe&quot; Smith&#39;));</pre><p>The use cases for customizing a builder are relatively rare, but they can be very powerful. For example, you might want your builders to implement a common interface for setting shared fields, so they can be used interchangeably.</p><h3>Nested Builders</h3><p>There’s a major feature of built_value you haven’t seen yet: nested builders. When a built_value field holds a built_collection or another built_value, by default it’s available in the builder as a <em>nested builder</em>. This means you can update deeply nested fields <em>more easily </em>than if the whole structure was mutable:</p><pre>var structuredData = new Account((b) =&gt; b<br>    ..user.name = &#39;John Smith&#39;<br>    ..user.nickname = &#39;Joe&#39;<br>    ..credentials.email = &#39;john.smith@example.com&#39;<br>    ..credentials.phone.country = Country.us<br>    ..credentials.phone.number = &#39;555 01234 567&#39;);</pre><pre>var updatedStructuredData = structuredData.rebuild((b) =&gt; b<br>    ..credentials.phone.country = Country.switzerland<br>    ..credentials.phone.number = &#39;555 01234 555&#39;);</pre><p>Why “more easily” than if the structure was mutable?</p><p>Firstly, the “update” method provided by all builders means you can enter a new scope whenever you like, “restarting” the cascade operator and making whatever updates you want both concisely and inline:</p><pre>var updatedStructuredData = structuredData.rebuild((b) =&gt; b<br>    ..user.update((b) =&gt; b<br>        ..name = &#39;Johnathan Smith&#39;)<br>    ..credentials.phone.update((b) =&gt; b<br>        ..country = Country.switzerland<br>        ..number = &#39;555 01234 555&#39;));</pre><p>Secondly, nested builders are automatically created as needed. For example, in built_value’s benchmark code we define a type called Node:</p><pre>abstract class Node implements Built&lt;Node, NodeBuilder&gt; {<br>  @nullable<br>  String get label;<br>  @nullable<br>  Node get left; <br>  @nullable<br>  Node get right;</pre><pre>  Node._();<br>  factory Node([updates(NodeBuilder b)]) = _$Node;<br>}</pre><p>And the auto creation of builders lets us create whatever tree structure we want inline:</p><pre>var node = new Node((b) =&gt; b<br>  ..left.left.left.right.left.right.label = &#39;I’m a leaf!&#39;<br>  ..left.left.right.right.label = &#39;I’m also a leaf!&#39;);</pre><pre>var updatedNode = node.rebuild((b) =&gt; b<br>  ..left.left.right.right.label = &#39;I’m not a leaf any more!&#39;<br>  ..left.left.right.right.right.label = &#39;I’m the leaf now!&#39;);</pre><p>Did I mention a benchmark? When updating, built_value only copies the parts of the structure that need updating, reusing the rest. So it’s <em>fast — </em>and memory efficient<em>.</em></p><p>But you don’t just have to build trees. With built_value you have at your disposal fully typed immutable object models … that are as fast and powerful as efficient immutable trees. You can mix and match typed data, custom structures like the “Node” example, and collections from built_collection:</p><pre>var structuredData = new Account((b) =&gt; b<br>    ..user.update((b) =&gt; b<br>        ..name = &#39;John Smith&#39;)<br>    ..credentials.phone.update((b) =&gt; b<br>        ..country = Country.us<br>        ..number = &#39;555 01234 567&#39;)<br>    ..node.left.left.left.account.update((b) =&gt; b<br>        ..user.name = &#39;John Smith II&#39;<br>        ..user.nickname = &#39;Is lost in a tree&#39;)<br>    ..node.left.right.right.account.update((b) =&gt; b<br>        ..user.name = &#39;John Smith III&#39;));</pre><p><em>These</em> are the value types that I’m talking about when I argue most data should be value types!</p><h3>More on built_value</h3><p>I’ve covered why built_value is needed and what it looks like to use. There’s more to come: built_value also provides EnumClass, for classes that act like enums, and JSON serialization, for server/client communication and data storage. I’ll talk about those in future articles.</p><p>After that I’ll dig into the <a href=\"https://github.com/google/built_value.dart/tree/master/chat_example\">chat example</a> that uses built_value in and end to end system with server and client.</p><p>Edit: <a href=\"https://medium.com/@davidmorgan_14314/darts-built-value-for-serialization-f5db9d0f4159#.par5t1142\">next article</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=83e2497922d4\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/darts-built-value-for-immutable-object-models-83e2497922d4\">Dart’s built_value for Immutable Object Models</a> was originally published in <a href=\"https://medium.com/dartlang\">dartlang</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-03-19T19:36:19.000Z":{"title":"Making Dart a Better Language for UI","link":"https://medium.com/dartlang/making-dart-a-better-language-for-ui-f1ccaf9f546c?source=rss----23738d481ce8---4","guid":"https://medium.com/p/f1ccaf9f546c","category":["flutter","dart","ui","programming-languages","programming"],"dc:creator":"Bob Nystrom","pubDate":"Tue, 19 Mar 2019 19:36:19 GMT","atom:updated":"2019-03-19T19:36:19.738Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4PIeARfthvxtn0cvBB5MPw.jpeg\" /></figure><p>On the <a href=\"https://www.dartlang.org/\">Dart</a> team, we are busy implementing a handful of language changes that I’m really excited about. They all relate to collection literals, the built-in syntax for creating lists, maps, and sets:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/9a301b4329f5856c288f1bdf646f4dfa/href\">https://medium.com/media/9a301b4329f5856c288f1bdf646f4dfa/href</a></iframe><p>If you aren’t writing Dart code today, this may not be super relevant to you and your Life Goals, but I hope you’ll keep reading anyway. I think the features are interesting in their own right, and the execution model that underlies them might stretch your brain in useful and/or engaging ways. I always find it fun to learn about new language stuff, even in languages I don’t currently use.</p><h3>How Flutter Users Build Their UI</h3><p>If you heard anything about Dart in the past year, it was probably in the context of <a href=\"https://flutter.dev/\">Flutter</a>. If that name doesn’t ring a bell, Flutter is a UI framework for building multi-platform mobile apps. I can’t do it justice here, but click the link and it will answer every question in your heart. (Well, at least every question regarding Flutter. It won’t tell you why that high school crush never called you back.)</p><p>A key choice any UI framework makes is how the basic visual UI elements — buttons, colors, text, layout, etc. — are defined. Do you author these in some sort of separate “template” or “markup” format or right in the executable code where the UI’s behavior is defined? Every fifteen years or so, the industry flips on which answer is the right one.</p><p><a href=\"https://angular.io/\">Angular</a> and most web frameworks follow in the footsteps of HTML and use templates. <a href=\"https://reactjs.org/\">React</a> puts the UI inside your JavaScript, but also adds an embedded DSL called <a href=\"https://reactjs.org/docs/introducing-jsx.html\">JSX</a> to make it look like HTML. Trying to have its cake and eat it too, I guess, though not everyone would describe HTML as particularly dessert-like.</p><p>Flutter puts the UI right into your Dart code, using normal Dart expression syntax. Behold:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/bee5624389aa5e9587f83a4abf544f7e/href\">https://medium.com/media/bee5624389aa5e9587f83a4abf544f7e/href</a></iframe><p>Everything after that return keyword is one big nested expression that produces a chunk of user interface. Using Dart for this has a handful of material benefits:</p><ul><li><strong>There’s only one language to learn: Dart.</strong> Since Dart was designed to be familiar to people coming from other languages, that’s hopefully not too difficult.</li><li><strong>You can use all of the abstraction features of a general-purpose programming language when building your UI.</strong> Hoist pieces out into reusable functions. Give those functions parameters to vary the generated UI. Store things in local variables. You do you.</li><li><strong>You never hit an expressiveness wall and have to port to a different language.</strong> If you’ve ever used a declarative language, you’ve probably run into the situation where you hit the limit of what it can actually express. At that point, you either abandon what you were trying to do, or laboriously rewrite the whole thing in a lower level, usually imperative language. Since you’re already <em>in</em> a full-featured language with Dart, you never hit that wall and your UI code smoothly grows in sophistication.</li></ul><p>The main challenge, of course, and the reason why people make declarative languages in the first place, is that defining stuff in an imperative language can be really tedious and difficult to read.</p><p>Imagine that instead of this little bit of HTML:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/57a1716e8650bd51a1e3d9791f731b86/href\">https://medium.com/media/57a1716e8650bd51a1e3d9791f731b86/href</a></iframe><p>You had to write something like:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/15a57d48b23ef533d30f20925f396562/href\">https://medium.com/media/15a57d48b23ef533d30f20925f396562/href</a></iframe><p>Fortunately, modern languages and APIs aren’t quite <em>that</em> low level. Even though statements are imperative, <em>expressions</em> are pretty declarative. While the above code is gnarly, this one is about on par with HTML:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/f539ad3ea859d65450839a28c9af6fe4/href\">https://medium.com/media/f539ad3ea859d65450839a28c9af6fe4/href</a></iframe><p>The modern reactive paradigm where you “build” your UI by constructing it from scratch as a single expression gets you pretty far. The relevant part of the Flutter example up there is just:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/7dfbfea89e37769c90ec5f7b5af11ae1/href\">https://medium.com/media/7dfbfea89e37769c90ec5f7b5af11ae1/href</a></iframe><p>It’s got parentheses and square brackets instead of angle brackets, but is otherwise not too far from a “markup” language. It’s surprising how well this works. Dart’s syntax is based on JavaScript, which got it from Java, which got it from C. Along the way, we added the square bracket list literal syntax and named parameters, but those are fairly minor.</p><p>C was designed for implementing command-line operating systems on the PDP-11. The fact that its notation scales not <em>too </em>badly to building graphical UIs on mobile devices is either a testament to Ritchie’s design taste, or our collective Stockholm Syndrome around C syntax. Either way, it works… mostly.</p><p>In the example here, there’s no interesting runtime <em>logic</em> required to build the UI. Everything fits nicely into a single nested expression. But let’s say, for whatever reason, you don’t want to show the “This is Flutter” part of the text on Tuesdays. (Perhaps you need to make room on screen for the “Taco Tuesday!” banner.)</p><p>There are a few ways to express that, but none of them feel as nice and declarative as the above example. Here’s one:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/704cb9b46e03e2851bcbf30991ef04db/href\">https://medium.com/media/704cb9b46e03e2851bcbf30991ef04db/href</a></iframe><p>We’re a lot closer to the nasty low-level imperative code that drives people to using templates. When we looked at real Flutter code, we were sad to see a lot that looked like this. So, about a year ago, the Flutter team asked us on Dart to come up with language changes to make UI code written in Dart easier to write, read, and maintain.</p><h3>“UI as Code”</h3><p>We called this initiative “<a href=\"https://github.com/munificent/ui-as-code\">UI as code</a>”, since it’s about building your UI using code. But the ultimate goal is language features that are generally applicable to as many Dart programs, Flutter or not, as possible. (If you want a lot more background, here’s <a href=\"https://github.com/munificent/ui-as-code/blob/master/Motivation.md\">a long motivation doc</a> I wrote.)</p><p>After exploring <a href=\"https://github.com/munificent/ui-as-code/blob/master/Choices.md\">a bunch of options</a>, we decided to focus on a few targeted improvements around collection literals. This may not seem as sexy as jamming something like JSX into Dart (not that I’m entirely ruling that out), but it has the advantage of being much easier for users to incrementally take advantage of in their code.</p><p>Just making list literals groovier might seem to have, uh, limited impact. But, if you look at Flutter UI code like the above, it’s basically a big tree of constructor calls and list literals. List literals are a large fraction of the territory. (Heck, <a href=\"https://en.wikipedia.org/wiki/Lisp_(programming_language)\">entire languages</a> have been designed around them.) If you dig into examples where it feels like you should be able to write something declaratively but instead have to do a bunch of gross imperative mutation, it’s very often around lists.</p><p>If we can make collections better, we can make a <em>lot</em> of Dart code better. To that end, we’re adding three new features:</p><h3>Spreads</h3><p>Often, when you build a list of widgets, some of those widgets are already in some <em>other</em> list. Here’s a bit of Flutter code:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/aa16f0f829d91242489ca6c470b64f9e/href\">https://medium.com/media/aa16f0f829d91242489ca6c470b64f9e/href</a></iframe><p>The buildTab2Conversation() method returns a list of widgets that we want to surround with the header and footer. Having to build the resulting list imperatively is a real drag. It forces the code to read &quot;backwards&quot; where you see a bunch of stuff mucking around with the children before you get to the code to see what they are the children <em>of</em>.</p><p>Dart has this feature called <a href=\"https://news.dartlang.org/2012/02/method-cascades-in-dart-posted-by-gilad.html\">method cascades</a> that helps somewhat. Those let you stuff a mutating method call in the middle of an expression while yielding the original object. With that, you get:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/17a63c04c6c19afbf3b240059741d8d0/href\">https://medium.com/media/17a63c04c6c19afbf3b240059741d8d0/href</a></iframe><p>That’s kind of better, but it’s still pretty awkward. That trailing ..add() to append a single item is particularly egregious. You can probably guess how we fixed this since a number of other languages already have the same solution. (&gt;90% of language design is figuring out which features to borrow from other languages.) We’re adding <a href=\"https://github.com/dart-lang/language/blob/master/accepted/future-releases/spread-collections/feature-specification.md\">a new syntax called <em>spreads</em></a>.</p><p>Inside a collection literal, a spread unpacks another collection and inserts its contents directly in place. For example:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/67060f95e444412f1cd1e9e9a23dcba4/href\">https://medium.com/media/67060f95e444412f1cd1e9e9a23dcba4/href</a></iframe><p>The ... before the list element causes its elements to be interpolated into the surrounding list. This is the same syntax JavaScript uses. Python, Ruby, and a few others use a prefix * for the same thing, but we felt that didn&#39;t stand out visually enough. With this feature, the Flutter example becomes:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2b07710a5405bc337f65a570e4ef2ec1/href\">https://medium.com/media/2b07710a5405bc337f65a570e4ef2ec1/href</a></iframe><p>I believe this is a real improvement. All of the children of the list view are nestled snug in the one list literal. This looks nicer, and also plays nicer with type inference. With all of the elements inside the list, we can use all of them when inferring the list’s type.</p><p>I’m showing a Flutter example here, but I spent a lot of time combing through a huge corpus of Dart code to see where this syntax would be useful and it comes into play all over the place. In particular, code that builds lists of command line arguments for invoking other programs really benefits from spreads.</p><h3>Elements</h3><p>Before I get into the last two features, I want to dig into what a spread actually <em>is</em>. It will seem like I’m belaboring the point, but I promise being clear on this will be helpful later. Here’s a leading question: <em>is a spread an expression?</em></p><p>It seems like one, because it appears in a list literal in a place where an expression is expected:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/109f6b354713e4066c65071197624180/href\">https://medium.com/media/109f6b354713e4066c65071197624180/href</a></iframe><p>Like an expression, you evaluate it and it produces some data. Maybe it’s an expression that evaluates to an <a href=\"https://api.dartlang.org/stable/2.2.0/dart-core/Iterable-class.html\">Iterable</a> object? But, wait, that doesn’t make sense. That’s what the expression <em>inside</em> the spread does. If you just want an expression that evaluates to an Iterable, there’s no need to put the ... before it.</p><p>A spread doesn’t evaluate to a single Iterable object, it <em>unpacks</em> that object and evaluates to the <em>series</em> of objects produced by the Iterable. It wouldn’t be useful to then <em>repack</em> that back into some new object. But an expression always evaluates to a <em>single</em> object.</p><p>If a spread was an expression, what would it mean to use one in other places where an expression is allowed?</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/97f4df23240dcff5b1063ee56af6daa6/href\">https://medium.com/media/97f4df23240dcff5b1063ee56af6daa6/href</a></iframe><p>What would this do? It doesn’t make sense to store the entire Iterable as an object in wat. If you wanted that, you could just omit the ... entirely. The answer is that spreads <em>aren&#39;t</em> expressions. They are a different kind of syntactic category. Dart, like many languages, already has two big syntax groups: statements and expressions.</p><p>Statements are executed but don’t produce any result value. Instead, they are expected to have some useful side effect. They can’t be used in any context where a value is needed because it won’t give you one. That’s why, say, this is forbidden:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3966f533c5c08e16d9f3d7debe2c72a8/href\">https://medium.com/media/3966f533c5c08e16d9f3d7debe2c72a8/href</a></iframe><p>A for statement doesn&#39;t produce a value, so it doesn&#39;t make sense to stuff one in a variable initializer. There <em>are </em><a href=\"https://en.wikipedia.org/wiki/Expression-oriented_programming_language\">languages that unify expressions and statements</a> and allow code like this. They define each statement to execute in some way and <em>also</em> produce a value. But Dart isn&#39;t one of those languages.</p><p>Expressions evaluate to a single result value. You can use them in places where a value is useful. There are also “<a href=\"https://www.eskimo.com/~scs/cclass/notes/sx3a.html\">expression statements</a>” — an expression followed by a semicolon — which are statements that contain a single expression. Handy since many expressions do also happen to have side effects and are useful even when their result isn’t needed.</p><p>A spread is neither of those. A spread can evaluate to zero values (if you spread an empty collection), one value, or many. It’s its own kind of thing. A good name for this category would be “generator”. My model for this comes from <a href=\"https://en.wikipedia.org/wiki/Icon_(programming_language)#Generators\">Icon</a> where <em>every</em> expression can be a generator. But Dart already has <a href=\"https://www.dartlang.org/articles/language/beyond-async#generators\">generator functions</a> so I didn’t want to overload the term.</p><p>A spread can only appear in a place that can gracefully handle receiving zero or more values. Without completely overhauling the language’s execution model and turning it into Icon (which I find strangely appealing, but probably not practical…), there aren’t too many places that fit that constraint. Basically collection literals and maybe positional argument lists. (I wrote <a href=\"https://github.com/munificent/ui-as-code/blob/master/in-progress/parameter-freedom.md\">a proposal for the latter</a>, but it’s quite complex so we aren’t doing it, at least not right now.)</p><p>That leaves inside the body of collection literals. Based on that, I call these “elements”. An element is a piece of code that when evaluated produces zero or more values. Those values are then interpolated in place into the surrounding context where they appear. So, in a list, they become a series of elements in the new list. In a map, they become a series of key/value pairs. You get the idea.</p><p>The body of a collection literal can thus contain either expressions or elements. Allowing two categories is a little confusing, but fortunately we can simplify this by saying that a collection only contains elements. Then we define an “expression element” to be an element containing a single expression. The element always produces one result — the value of the expression. Sort of like the element equivalent of an expression statement.</p><p>Right, so that’s where we are. We’ve changed collections to contain elements instead of expressions and defined two kinds of elements, spreads and expression elements. To evaluate a collection literal, you walk the elements, evaluate each one, and concatenate (or union in the case of a set) all of the resulting objects.</p><p>With that model in mind, we can walk through the other two new features:</p><h3>Collection If</h3><p>Write any Flutter code and you pretty quickly run into cases where the tree of widgets you want to build changes based on some condition. Say we have:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/072107afe88a64be99a02468120afdef/href\">https://medium.com/media/072107afe88a64be99a02468120afdef/href</a></iframe><p>Later, we decide that we want to use a different search button on Android. You can already do that using a conditional expression:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5efc7ff8b897dd4d5b6eae7fb35a4bd3/href\">https://medium.com/media/5efc7ff8b897dd4d5b6eae7fb35a4bd3/href</a></iframe><p>This works OK, though I’ve never found C’s conditional operator very easy to read. Often, though, you don’t want to <em>swap out</em> a widget based on a condition, you want to simply <em>omit</em> one. Let’s say you don’t want to show a search box on Android at all. Today, Flutter users tend to use one of two patterns. This is one:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/39ddc8aac984d2fcd49ab5f849f0cfe5/href\">https://medium.com/media/39ddc8aac984d2fcd49ab5f849f0cfe5/href</a></iframe><p>It forces you to rearrange the entire function by hoisting the child list out and building it imperatively before you use it. The other pattern looks like:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/171e6899189aef91942841b006718783/href\">https://medium.com/media/171e6899189aef91942841b006718783/href</a></iframe><p>This uses a conditional expression which sometimes produces a null and then filters that null out of the resulting list. Props to whoever came up with this, but it&#39;s not something any user should have to write to accomplish such a simple task. Simple problems should have simple solutions, and small conceptual changes to your program shouldn&#39;t require large textual changes.</p><p>Here’s the new thing. For the first example where we want a different button on Android, it looks like this:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b1ef984cb6f93e08c355a3acf47c5fae/href\">https://medium.com/media/b1ef984cb6f93e08c355a3acf47c5fae/href</a></iframe><p>Instead of ?:, it uses the familiar if and else syntax. This is literally just a few tokens different from the existing conditional expression, so it doesn&#39;t seem to carry its weight. The more interesting case is when we want to <em>omit</em> the button on Android:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e1c9d56f9e880ad57fde781aa9f61f4f/href\">https://medium.com/media/e1c9d56f9e880ad57fde781aa9f61f4f/href</a></iframe><p>Note there’s no else clause. Both of these examples look pretty similar to languages like Ruby where if is an expression. But an expression must always evaluate to a value, even when the condition is false. In Ruby, in that case, it implicitly evaluates to nil.</p><p>But that’s <em>not</em> what you want here. You don’t want to end up with a null element in your list of child widgets. That&#39;s why the conditional expression example up there had to use the annoying where() to filter it out. Fortunately, that&#39;s not a problem here. Because if inside a collection isn&#39;t an <em>expression</em>. It&#39;s an <em>element</em>.</p><p>Now you see why I was dragging you through all that stuff with spreads. Elements give us the foundation to have an ifsyntax that lets you completely omit an element from a collection. The if element produces a single value if the condition is true, or if there is an else case. If the condition is false and there is no else clause, it simply produces no values at all.</p><p>I think this behavior is really useful, but it’s also confusing if you look at the code and expect if to act like a simple expression.</p><h3>Collection For</h3><p>The previous feature takes an existing bit of Dart statement syntax and repurposes it to do something useful in the context of a collection. Are there any other statement forms worth taking?</p><p>Most don’t make sense. Sticking a return statement in there wouldn&#39;t do anything useful since it would just exit the surrounding function. while isn&#39;t very useful either. In order to exit a while loop, the body typically contains a break, return, or some kind of side effect like an assignment. But that implies the body contains <em>statements</em>, which isn&#39;t what we want. The goal is to make collections more <em>expressive</em>, not more <em>imperative</em>.</p><p>I dug through a bunch of collection literals in existing code looking for patterns I thought could be improved by new syntax. The main one, by far, was if. But I saw a number of places that I thought could be improved by for. Here&#39;s a slightly cleaned up example of some code I found:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2264e586cab6282249bfe3edd474ddeb/href\">https://medium.com/media/2264e586cab6282249bfe3edd474ddeb/href</a></iframe><p>All of the command.add() stuff feels needlessly imperative. If we allow for loops inside a collection literal, this becomes:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/41ad41995c1a44493bd7e9f69058becb/href\">https://medium.com/media/41ad41995c1a44493bd7e9f69058becb/href</a></iframe><h3>Composing Elements</h3><p>Given that we are already adding spreads, the for syntax doesn&#39;t seem very compelling. Couldn&#39;t you accomplish the same thing using spread with some combination of higher-order methods on iterables? Yes, you can. You&#39;d get something like:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/6c4490496a96626c573526f2b047887b/href\">https://medium.com/media/6c4490496a96626c573526f2b047887b/href</a></iframe><p>This does work and is fine for some use cases. Let’s consider a slightly different example. Say we only want to include an entry point if a corresponding JSON file exists. That means we’re not doing a simple 1–1 mapping. Using only spreads, we get something like:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/6be0be5cc720b7c1efbf75d8d595cd47/href\">https://medium.com/media/6be0be5cc720b7c1efbf75d8d595cd47/href</a></iframe><p>This works too. But it starts to get harder and harder to translate the simple “if the file exists, do this” logic to a stream-based, higher-order functional style. There’s always some combination of map(), where() and maybe transform() that does the job, but it can feel like translating a haiku into Reverse Polish Notation.</p><p>There is a cleaner solution, and it involves a key question: What is the <em>body</em> of these new if and for elements? In the examples I&#39;ve shown you so far, it&#39;s always an expression. But there&#39;s no need to restrict it to just that. Instead, we allow any element to go there. In other words, all three of these new features can be composed freely. The above code can be expressed like:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3f65104085fa082afd66f79093cdf509/href\">https://medium.com/media/3f65104085fa082afd66f79093cdf509/href</a></iframe><p>A simple if inside a for, just like you&#39;d do if you were writing imperative statements. The semantics for composing elements turn out to be pretty obvious:</p><ul><li>An if element produces all of the values produced by its then clause if the condition is true, otherwise it produces all of the elements of the &quot;else&quot; clause. If there is no &quot;else&quot;, it produces no elements.</li><li>A for element produces the concatenation of all of the values produced by its body element each time the body is executed.</li></ul><p>This enables some patterns that I think are cool. An obvious problem you run into is wanting to include or omit <em>multiple </em>values based on a single condition. So, say in our previous example we wanted to skip both the title and the search box on Android. You can do that by wrapping a spread in an if:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/21a614632be7c22f8a6c05cb6347e0d5/href\">https://medium.com/media/21a614632be7c22f8a6c05cb6347e0d5/href</a></iframe><p>The spread is necessary here to unpack the inner list. Otherwise, when not on Android, you’d include the entire inner list as a single value. (We considered implicitly flattening in cases like this based on static types, but that gets really dubious when you think about how things like a List&lt;Object&gt; should behave.)</p><p>You can think of spreading a list literal as the element equivalent of a curly block for statements — it lets you put multiple elements in a place where only one is expected. (If you’re familiar with the <a href=\"https://en.wikipedia.org/wiki/Comma_operator\">comma operator</a>, that’s essentially the analogous form for expressions. Parallels everywhere.)</p><p>Using for and if in an empty collection literal gives you a syntax not too far from the special &quot;list comprehension&quot; syntax supported by some other languages like Python:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/071a6300aec81fd8cb8066169f280068/href\">https://medium.com/media/071a6300aec81fd8cb8066169f280068/href</a></iframe><p>You can even nest for:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/0d61512589198c681d9f6b6bd08a6c36/href\">https://medium.com/media/0d61512589198c681d9f6b6bd08a6c36/href</a></iframe><p>This builds a list containing the <a href=\"https://en.wikipedia.org/wiki/Cartesian_product\">Cartesian product</a> of all of the points in the given hor and vert rectangle.</p><p>Also, these new features compose across collection types. I’ve been using lists as the example because they come up most often, but all of these features work inside maps and sets too. The only difference is that with sets, duplicates get implicitly discarded. And in maps, instead of having primitive expression elements, the basic element is a key/value pair. For example, this:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b76aab5cac32dbdb7f2772566dc2600a/href\">https://medium.com/media/b76aab5cac32dbdb7f2772566dc2600a/href</a></iframe><p>Can be rewritten as:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ab1615741e3e7145102bf701b7f4f876/href\">https://medium.com/media/ab1615741e3e7145102bf701b7f4f876/href</a></iframe><p>One real concern we have with all of these features is that we’re essentially giving you new ways to express things you can already express today. This has a cost because it means users need to spend brain juice <a href=\"https://en.wikipedia.org/wiki/Hick%27s_law\">deciding <em>which</em> feature to use</a>, and when reading others’ code, they may spend time questioning why one option was chosen over the other. There are simply more features to learn and the language is bigger.</p><p>We spent a lot of time <a href=\"https://github.com/munificent/ui-as-code/blob/master/Choices.md\">agonizing over this</a>. Sometimes, simply doing nothing is the best design. Simplicity has a lot of value, and it’s rare that you get the chance to make a language simpler over time. However, after looking at a lot of code and working with a delightful UX researcher on a study, we’re fairly confident that these features are lightweight and useful enough to carry their weight.</p><p>As with any language change, you never really know how it will work out until it gets into the hands of users. These features should fall into your grasp in the upcoming Dart 2.3 release, and I’m really excited to see what you make of them.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f1ccaf9f546c\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/making-dart-a-better-language-for-ui-f1ccaf9f546c\">Making Dart a Better Language for UI</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-02-26T17:03:47.000Z":{"title":"Announcing Dart 2.2: Faster native code, support for set literals","link":"https://medium.com/dartlang/announcing-dart-2-2-faster-native-code-support-for-set-literals-7e2ab19cc86d?source=rss----23738d481ce8---4","guid":"https://medium.com/p/7e2ab19cc86d","category":["programming","dart","flutter"],"dc:creator":"Michael Thomsen","pubDate":"Tue, 26 Feb 2019 17:03:47 GMT","atom:updated":"2019-02-26T17:17:13.555Z","content:encoded":"<p>Today, we’re announcing the stable release of the Dart 2.2 SDK, an incremental update to Dart 2 that offers improved performance of <a href=\"https://en.wikipedia.org/wiki/Ahead-of-time_compilation\">ahead-of-time (AOT) compiled</a> native code and a new set literal language feature.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/1*saXdrIB-SjU2EL7gLGPUsA.png\" /></figure><h3>Dart performance improvements for Flutter developers</h3><p>We continue our work to make <a href=\"https://hackernoon.com/why-flutter-uses-dart-dd635a054ebf\">AOT-compiled code</a>, such as Flutter apps, even faster. In Dart 2.1, <a href=\"https://medium.com/dartlang/announcing-dart-2-1-improved-performance-usability-9f55fca6f31a\">we reduced overhead of type checks</a>, greatly reducing the cost of the type checks for both AOT-compiled code and for code run in the VM with JIT (just-in-time) compilation.</p><p>In Dart 2.2, we have focused specifically on performance of AOT-compiled code, improving AOT performance by <a href=\"https://github.com/flutter/flutter/pull/27789#issuecomment-464234710\">11–16% on microbenchmarks</a> (at the cost of a ~1% increase in code size). This improvement is the result of several quarters’ work to reduce the overhead of static calls. Our optimized AOT code is now able to call the destination directly using a PC-relative call (that is, using the <a href=\"https://en.wikipedia.org/wiki/Program_counter\">program counter</a>); before we had to make several lookups to an object pool to determine the destination address. These optimizations are especially useful when code contains lots of constructor and static method calls, such as Flutter user interface code that creates lots of widgets.</p><h3>Dart 2.2 set literal language feature</h3><p>Dart’s core library (dart:core) contains a number of collection classes for modelling <a href=\"https://api.dartlang.org/stable/dart-core/Map-class.html\">Maps</a>, <a href=\"https://api.dartlang.org/stable/dart-core/List-class.html\">Lists</a>, and <a href=\"https://api.dartlang.org/stable/dart-core/Set-class.html\">Sets</a> of objects. Maps are collections of key-value pairs. Lists are ordered sequences of values, where each value may be accessed by an index, and may occur more than once. Sets are unordered collections of values, where each value can occur only once, and where you can efficiently check whether a value is in the set.</p><p>Dart collections are commonly initialized with compile-time constants, so Dart has a convenient literal syntax for expressing this initialization. In Dart, a List can be initialized with:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/bc21e5b9a35552261c0108a898bbecd3/href\">https://medium.com/media/bc21e5b9a35552261c0108a898bbecd3/href</a></iframe><p>Previously, Dart supported the literal syntax only for Lists and Maps, so initialization of Sets was cumbersome as we had to initialize via a list:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/bf21116de2a86c6a3eefd580437f8ded/href\">https://medium.com/media/bf21116de2a86c6a3eefd580437f8ded/href</a></iframe><p>This code is not just inconvenient and inefficient; the lack of literal support prevents making currencies a compile-time constant. With Dart 2.2’s extension of literals to support sets, we can initialize a set and make it const using a convenient new syntax:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/cd3e135c88527ea48f5016fdcbb35a3a/href\">https://medium.com/media/cd3e135c88527ea48f5016fdcbb35a3a/href</a></iframe><p>For real-world examples of how the Flutter team is starting to apply set literals, see <a href=\"https://github.com/flutter/flutter/pull/27811\">PR #27811</a>. For more general details on how to use set literals, see the <a href=\"https://www.dartlang.org/guides/language/language-tour#sets\">updated Dart 2.2 language tour</a>.</p><h3>Building new language features with the Dart 2 Common Front-End (CFE)</h3><p>The Dart language implementations — the Dart VM used by Flutter, the dart2js compiler, and the Dart dev compiler (dartdevc) — share a common front end. The Dart Common Front End, or CFE, parses Dart code, performs type inference, and translates Dart into a lower-level intermediate language that back-end implementations accept as input.</p><p>The set literals feature is an example of a language construct that we were able to develop rapidly because of the CFE. The code for parsing set literals and performing type inference was implemented once in the CFE for all Dart back ends. In addition, we built a front-end-only transitional implementation that could be used by the back ends initially. In the transitional implementation, the non-const version of the currencies set literal above was translated during compilation into the equivalent of:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/1e717ec9060d574b31bac44600c96b98/href\">https://medium.com/media/1e717ec9060d574b31bac44600c96b98/href</a></iframe><p>The transitional implementation of const set literals is different because const sets cannot be built up incrementally in pieces. Instead, we implemented this in terms of a private unmodifiable set class that wraps a const map, where the set elements are the keys of the map:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e6e0d64ae13c2b73429313f46346d9a4/href\">https://medium.com/media/e6e0d64ae13c2b73429313f46346d9a4/href</a></iframe><p>The unmodifiable set class implements the methods in the Set interface in terms of the wrapped map.</p><p>Overall, we were able to implement set literals initially as a CFE-only feature. The back ends could use the CFE implementation initially, and later develop their own native support independently of the initial launch of the feature. This allowed backends to postpone their native support until the performance aspects of this feature were better understood.</p><h3>Dart 2.2 language specification</h3><p>Dart 2 was such a <a href=\"https://medium.com/dartlang/dart-2-stable-and-the-dart-web-platform-3775d5f8eac7\">substantial upgrade</a> to Dart that it’s taken us a while to get the formal <a href=\"https://www.dartlang.org/guides/language/spec\">Dart language specification</a> updated to match all the changes we made. We have finally completed that work, and the spec is up-to-date as of Dart 2.2. We’ve also moved the language specification source to the new <a href=\"https://github.com/dart-lang/language/tree/master/specification\">language repository</a>, and added continuous integration to ensure a rolling draft specification is generated in PDF format as we evolve the specification for future versions of the Dart language. Both the 2.2 and rolling Dart 2.x specifications are available from the <a href=\"https://www.dartlang.org/guides/language/spec\">Dart specification page</a>.</p><h3>Getting Dart 2.2</h3><p><a href=\"https://www.dartlang.org/tools/sdk/archive\">Dart SDK 2.2</a> is available from the Dart homepage today. If you’re a Flutter developer, Dart 2.2 is already included. (<em>Note</em>: the current Flutter master and dev channels will report Dart 2.2. <a href=\"https://developers.googleblog.com/2019/02/launching-flutter-12-at-mobile-world.html\">Today’s Flutter 1.2</a> stable release will report Dart 2.1.2; this has the same features as Dart 2.2).</p><p>That’s it for now. We hope you enjoy Dart 2.2!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7e2ab19cc86d\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-2-2-faster-native-code-support-for-set-literals-7e2ab19cc86d\">Announcing Dart 2.2: Faster native code, support for set literals</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2018-11-15T18:37:52.000Z":{"title":"Announcing Dart 2.1: Improved performance & usability","link":"https://medium.com/dartlang/announcing-dart-2-1-improved-performance-usability-9f55fca6f31a?source=rss----23738d481ce8---4","guid":"https://medium.com/p/9f55fca6f31a","category":["programming","flutter","programming-languages","dart"],"dc:creator":"Michael Thomsen","pubDate":"Thu, 15 Nov 2018 18:37:52 GMT","atom:updated":"2018-11-15T18:37:52.628Z","content:encoded":"<p>Today, we’re announcing the stable release of Dart 2.1, an update to Dart 2 that offers smaller code size, faster type checks, better usability for type errors, and new language features to improve productivity when building user experiences.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/1*xZHP-8eEl6qJCCTKXyQZ8w.png\" /></figure><h3>Landing Dart 2</h3><p>Dart 2 was a huge upgrade to the Dart platform. It completed the transformation from our early web roots to a mainstream programming language suitable for fast development of rich user experiences across mobile and web. Dart is somewhat unique as a language in offering both a virtual machine (VM) and compilation to both native machine code and JavaScript. This supports the differing needs of the various platforms, for both development and production.</p><p>As part of the transition to Dart 2, we added a <a href=\"https://www.dartlang.org/guides/language/sound-dart\">sound type system</a> to support large teams building complex apps, new compiler support for generating native code optimized for mobile devices, and completely reworked <a href=\"https://webdev.dartlang.org/tools\">web platform tools</a>. Dart powers <a href=\"https://flutter.io\">Flutter</a>, our fast-growing toolkit for building beautiful native experiences for iOS and Android from a single code base; it is also the language used by some of the largest projects at Google, such as Google Ads.</p><p>Since the <a href=\"https://medium.com/dartlang/dart-2-stable-and-the-dart-web-platform-3775d5f8eac7\">launch of Dart 2</a> back in August, we’ve worked on getting the whole ecosystem onto Dart 2. We switched our <a href=\"https://www.dartlang.org/\">dartlang.org</a> website over to use Dart 2 examples everywhere, and we offered <a href=\"https://medium.com/dartlang/getting-ready-for-dart-2-and-making-your-packages-look-great-on-the-pub-site-118464d7f59d\">tools and documentation for migrating</a> Dart 1.x packages. We understand that the large changes in Dart 2 involved migration work for existing Dart developers, and we’re very thankful to those who have helped us build a new foundation for the future. Our focus now shifts to taking advantage of these investments to deliver improvements to performance and productivity.</p><h3>Dart 2.1 language support for int-to-double conversion</h3><p>New Flutter developers are often tripped up by analysis errors like these when specifying padding, setting font sizes, etc.:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/718/1*9hItMsF9iM2BHzbuJkHNbg.png\" /></figure><p>From a system point of view, these errors make sense: The API expects one type (a double), and the developer specifies a value of a different type (an int). However, from a usability point of view it seems a bit foolish: There is a trivial conversion from int to double, so why not just do that? Dart 2.1 now <a href=\"https://github.com/dart-lang/language/issues/4\">infers where an int can be silently evaluated as a double</a>:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/327/1*bJV4DQzBey1fc64nerTprg.png\" /></figure><h3>Dart 2.1 language support for mixins</h3><p>We also <a href=\"https://github.com/dart-lang/language/issues/7\">improved Dart’s support for mixins</a>. If you haven’t encountered Dart mixins before, it’s worth reading this great <a href=\"https://medium.com/flutter-community/dart-what-are-mixins-3a72344011f3\">introduction to Dart mixins</a> by Romain Rastel. Dart 2.1 introduces a new syntax for mixins, featuring a new mixin keyword that you can use to define classes that can only be used as mixins. We’ve also added support so that mixins can extend other classes (previously they could only extend Object) and can invoke methods in their superclass.</p><p>One example of extending non-Object classes is from Flutter’s <a href=\"https://flutter.io/tutorials/animation/#rendering-animations\">animation APIs</a>, where the SingleTickerProviderStateMixin — a framework class that provides a ticker for advancing an animation by a single frame — <a href=\"https://github.com/flutter/flutter/blob/master/packages/flutter/lib/src/widgets/ticker_provider.dart#L66\">declares a mixin</a> that implements the general TickerProvider interface. Animations are only applicable to stateful widgets (as the position in the animation is considered state). The new mixin support allows us to express this by declaring that only classes that extend the Flutter State class can use the mixin:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*uUIuZJgNCevxAkZQ\" /></figure><h3>Dart 2.1 compile-time type checks</h3><p>Dart 2’s sound type system protects you during development, telling you when you violate the contract specified by the types. For example, let’s say you’re creating a state class for Flutter. This class is expected to extend the framework State class. A State class expects to be passed the StatefulWidget that it contains the state for.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/449/1*Y_8yHDINe7LtvmyFmCqWzw.png\" /></figure><p>Now, should you make a programming mistake and — say — pass it a descendant of StatelessWidget instead of StatefulWidget, the type information enables the tools to catch the mistake and show you a warning immediately:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/485/1*Ym0nqsHWlTscD140Urk0xw.png\" /></figure><p>These <em>edit-time</em> type checks were added in Dart 2.0 (powered by the <a href=\"https://www.dartlang.org/tools/analyzer\">Dart Analyzer</a>). However, there is another place where you might expect these type checks, namely at <em>compile time</em>, when you do a Flutter release build. These checks were incomplete in Dart 2.0, which could lead to usability issues where bad source code could compile without producing any errors. In Dart 2.1, these checks are complete, and the Analyzer and Dart compiler contain the same checks.</p><h3>Dart 2.1 performance improvements for Flutter developers</h3><p>Dart 2 was generally faster than Dart 1.x for <a href=\"https://hackernoon.com/why-flutter-uses-dart-dd635a054ebf\">AOT-compiled code</a> running on our VM, such as Flutter apps. In a few edge cases, though, the comprehensive checks added by the <a href=\"https://www.dartlang.org/guides/language/sound-dart\">new type system</a> caused an undesirable overhead of 20–40%. In Dart 2.1 we’ve greatly reduced the cost of the type checks, both for AOT-compiled code and for code run in the VM with JIT (just-in-time) compilation.</p><p>One concrete case that benefits from this is our developer tools (which run using the VM). For example, performing code analysis of one large benchmark app (based on multiple concatenated copies of the Flutter Gallery) used to take ~41 seconds; now it takes ~25 seconds.</p><h3>Dart 2.1 performance improvements for web developers</h3><p>We also improved the code size and compile time for Dart code running on the web. We focused on the output size of <a href=\"https://webdev.dartlang.org/tools/dart2js\">dart2js</a> and are seeing good results, such as a <a href=\"https://twitter.com/kevmoo/status/1055292888626515968\">17% reduction in minified output size and 15% improvement in compilation time</a> for one of our samples.</p><h3>Changes beyond the core SDK</h3><p>In addition to the above-mentioned changes in the Dart SDK, we’ve made some exciting changes outside of the core SDK.</p><p>Protocol buffers (or <em>protobuf</em> for short) are a platform-neutral mechanism for serializing structured data. They’re used extensively inside of Google and are also seeing strong adoption outside of Google — for example as part of <a href=\"https://grpc.io/\">gRPC</a>. Dart is now an officially supported protobuf language, and we have added detailed documentation on the <a href=\"https://developers.google.com/protocol-buffers/\">core protocol buffers website</a> with both a <a href=\"https://developers.google.com/protocol-buffers/docs/darttutorial\">tutorial</a> and <a href=\"https://developers.google.com/protocol-buffers/docs/reference/overview\">reference</a> documentation.</p><p>You may have heard about <a href=\"https://cloud.google.com/knative/\">knative</a> — a platform based on <a href=\"https://kubernetes.io/\">Kubernetes</a> — to support building, deploying, and managing serverless workloads. We recently investigated support for serving Dart code on knative, and <a href=\"https://github.com/knative/docs/tree/master/serving/samples/helloworld-dart\">created a small sample</a>. This is likely too low-level for most Dart app developers, but we find it very exciting from a platform perspective, and anticipate this will be a critical building block to get better support for serving Dart code in the Google Cloud — for example to create backends for Flutter apps.</p><h3>Getting Dart 2.1</h3><p><a href=\"https://www.dartlang.org/tools/sdk/archive\">Dart SDK 2.1</a> is available from the Dart homepage. If you’re a Flutter developer, Dart 2.1 is included as part of the upcoming Flutter 1.0 release.</p><p>We’ve also updated <a href=\"https://dartpad.dartlang.org/\">DartPad</a> to run Dart 2.1, and have added samples for <a href=\"https://dartpad.dartlang.org/e93b969fed77325db0b848a85f1cf78e\">int-to-double</a> and <a href=\"https://dartpad.dartlang.org/b60dc2fc7ea49acecb1fd2b57bf9be57\">mixins</a>.</p><h3>What’s next</h3><p>We expect to ship several 2.x releases that take advantage of the Dart 2 platform foundation. We’ll base these on the needs of our framework partners and app developers. In 2019 we expect to investigate the following areas:</p><ul><li>Continued evolution of the Dart language: For Dart 2.2, we’re investigating a number of changes, such as refinements to <a href=\"https://github.com/dart-lang/language/issues/61\">const expressions</a> and support for a new <a href=\"https://github.com/dart-lang/language/issues/37\">Set literal</a>. Beyond 2.2 we’re looking into our support for Unicode strings, and are investigating whether we can offer better null safety.</li><li>Further improvements to optimize Dart as a language for creating user interfaces: Dart 2 began this journey with its new type system and optional new, Dart 2.1 added int to double value inference, and we are currently investigating a number of potential improvements such as support for <a href=\"https://github.com/dart-lang/language/issues/78\">conditionals in widget lists</a>, <a href=\"https://github.com/dart-lang/language/issues/47\">expanding collections of objects</a> into other collections, and even potentially <a href=\"https://github.com/dart-lang/language/issues/72\">removing the need to terminate statements</a> with semicolons.</li><li>Even better performance: We’ll continue to reduce the size and performance of compiled Dart code, including better support for using multi-core processors, further reduction of code size to improve download and startup time, and potentially more control for whether size or runtime performance is most critical.</li></ul><p>For more about both Dart and Flutter, we’d love you to join us at <a href=\"https://developers.google.com/events/flutter-live/\">Flutter Live</a>, an online event taking place on December 4th that will be streamed live on the web. We’re excited to share more about the roadmap with you then.</p><p>That’s it for now. We hope you enjoy Dart 2.1!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9f55fca6f31a\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-2-1-improved-performance-usability-9f55fca6f31a\">Announcing Dart 2.1: Improved performance &amp; usability</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2018-10-30T17:26:22.000Z":{"title":"Future<void> vs Future<Null>, what’s the difference?","link":"https://medium.com/dartlang/future-void-vs-future-null-whats-the-difference-84a42d616e7d?source=rss----23738d481ce8---4","guid":"https://medium.com/p/84a42d616e7d","category":["programming-languages","dartlang","dart","design-patterns","type-theory"],"dc:creator":"Mike Fairhurst","pubDate":"Tue, 30 Oct 2018 17:26:22 GMT","atom:updated":"2018-10-30T17:26:22.755Z","content:encoded":"<p>One of the nice upgrades we were able to do in <a href=\"https://medium.com/dartlang/dart-2-stable-and-the-dart-web-platform-3775d5f8eac7\">Dart 2</a> (in addition to better static checking, runtime type safety, optional new/const, core library improvements, and more) is to formalize void in a way that’s both more useful and less error-prone. This is especially clean in async programming where you can write Future&lt;void&gt; for asynchronous functions that don’t return an answer when their work completes. Before this you probably used Future&lt;Null&gt;, so common questions we get asked are: What’s the difference between Future&lt;void&gt; and Future&lt;Null&gt;? Which should I use, and when?</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/0*x0J9DBRyATjtQn42\" /></figure><p>Since my goal here is to be useful, I’m going to start with a TLDR.</p><p>TL;DR: <strong>You want to use the void type 99.99% of the time.</strong></p><p>I also recommend you turn on two void-related <a href=\"https://www.dartlang.org/guides/language/analysis-options\">lint rules</a> in your projects, right now:</p><ul><li><strong>prefer_void_to_null:</strong> Helps keep you from slipping back into the habit of typing the mostly-antiquated Null.</li><li><strong>void_checks:</strong> Gives you voidness semantics that you may find more intuitive, even though they are not strictly necessary for safe code.</li></ul><p>The rest of this article is not light reading. It is a combination of history, edge cases, and type theory. What I’m about to write is like trying to explain a <a href=\"https://en.wikipedia.org/wiki/Monad_(functional_programming)\">Monad</a>, but I’ll do my best, and I hope you follow along for the ride.</p><h3>Quick Future&lt;Null&gt; trivia</h3><p>To demonstrate the value you might get out of reading this post, I pose a trivia question for you.</p><p>Say we limit ourselves to two Futures — a Future&lt;User&gt; and a Future&lt;Null&gt;. What do the following lines of code do?</p><pre>// does this fail in your editor?<br>Future&lt;User&gt; f1 = Future&lt;Null&gt;.value(null);</pre><pre>// does this fail at runtime?<br>Future&lt;Null&gt; f2 = Future&lt;User&gt;.value(0);</pre><p>Does it help if we switch to awaits?</p><pre>User u = await Future&lt;Null&gt;.value(null);<br>Null n = await Future&lt;User&gt;.value(0);</pre><p><em>*pauses for dramatic effect*</em></p><p>The answer is that none of these four lines will show any errors in your editor, unless you have disabled implicit downcasts. That’s right, taking a Future&lt;Null&gt; and pretending it’s something it isn’t, like Future&lt;User&gt;, is 100% legal. This is not the case with Future&lt;void&gt;!</p><p>Also unintuitively, the second and fourth lines fail at runtime (it’s not “safe” to throw away the result of a Future in this way), and the others succeed silently.</p><p>These behaviors should make you uncomfortable. But don’t worry! You already know the solution: use Future&lt;void&gt;. I’ll break down why this unintuitive behavior works this way.</p><h3>How void works now</h3><p>I debated a lot to myself about what the best ordering would be for this article. There are lots of concepts to explain here. However, I will try to go in order of most useful information to least useful information. Therefore, with void being much more useful than Null in Dart 2, it makes sense to start with Dart 2 void semantics.</p><p>The fundamental idea behind void in Dart is derived from the goal that a void value should not be used.</p><pre>void f() {}<br>print(f()); // error!</pre><p>This is hopefully what you expect to happen! So with that, so far so good.</p><p>It’s worth noting that achieving this goal <em>and</em> opening up void as a fairly normal type can get a bit weird:</p><pre>f(void argument) {<br>  print(argument); // Error!<br>  // we can receive the argument, but we may not use it!<br>}</pre><p>And this is where, in Dart 2, our new “generalized void” starts to get cool, and powerful…albeit sometimes confusing.</p><p>I pose the question to you…what type of value could we pass in as the argument of f?</p><pre>f(void argument) { … }<br>f(x); // what is x?</pre><p>The answer to this is…anything! Because we don’t let you use the value of x inside the function f, we can confidently say that there <em>is no value</em> that x can take <em>that could cause any runtime errors</em>.</p><pre>f(1); // will have no difference compared to<br>f(“foo”); // will have no difference compared to<br>f([1, 2, 3]); // will have no difference compared to<br>// ...</pre><p>If we derive the best semantics for void based on the idea that it is a value that will not be <em>used</em>, this is what we get. Which means, it’s a value that can be <em>filled</em> with absolutely anything. It’s like a vacuum: an input with no output.</p><p>Now, there are cases where something is always error-free at runtime, but still should cause static errors. This is a great case for a lint! And indeed this is the idea behind the void_checks lint. It looks for places where you pass anything but null into a void location, and I would encourage teams to enable it. It’s not required for soundness, but passing anything other than null into a void location is still likely to be an accident, which the lint will flag for you.</p><p>Since all of this is grounded in foundational type theory, void plays well with every part of Dart, even in continuations leveraging type inference in the context of a Future&lt;void&gt;:</p><pre>Future&lt;void&gt;().then((x) {<br>  print(x); // error! x has type “void” so you can’t print it!<br>  // This is what we want!<br>});</pre><pre>// and yes, this is an error too:<br>Foo f = await voidFuture();</pre><p>At this point, the average developer probably knows everything they need to know about void in order to effectively use it.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/268/0*_2MNvj3It63IUFUH\" /></figure><p>If you are still following along, however, there are a few more interesting nuggets.</p><p>Even with void_checks enabled, void locations will not be guaranteed to contain null. Take this override:</p><pre>class A {<br>  void f(Object o) {}<br>}</pre><pre>class B extends A {<br>  @override<br>  Object f(Object o) =&gt; o;<br>}</pre><p>We don’t want to make this override illegal, because it’s safe, useful, and would be a breaking change from Dart 1. And so we are forced to accept that void locations may hold absolutely any value. We also cannot “optimize out” the value that A.f() returns, because at runtime it may be a B!</p><p>Rather, we have the clever option of making void a sister type of Object. After all, it may hold any value, and all values are Objects. This is not something we designed, it’s just reality. Recognizing that reality makes it something we can then leverage.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/0*1ZUU5fNh-kmpPzMU\" /></figure><p>By making void a sibling of Object, we leave ourselves no<em> requirements</em> that a void value go <em>completely</em> unused. We try our best to keep void to itself, but we deliberately relax these restrictions in a few places for the sake of backwards compatibility:</p><pre>dynamic f() =&gt; voidFn(); // this is legal<br>voidFn() as dynamic; // this is legal</pre><p>These are special cases that would be legal for an Object, and we made it legal for void, too, in the interest of making Dart 2 a smoother rollout.</p><p>Making void a sibling of Object also means that void can be used as a type parameter without bloating the compiled output (no “template specialization,” for you C++ folk). This reduction is good for keeping web &amp; Flutter apps small, at the expense of allowing the following:</p><pre>&lt;void&gt;[1, 2, 3].toString(); // this is legal and prints [1, 2, 3]</pre><p>And lastly, it may seem useless to ever type a parameter as void, especially since it’s a form of Object. However, void values can be<em> passed to </em>void<em> locations</em>:</p><pre>f(void x) { … }<br>f(voidFn()); // this is legal</pre><p>This is useful for <em>sequencing</em>, which is for instance used by <a href=\"https://pub.dartlang.org/packages/mockito\">Mockito</a> when mocking methods that return void. (Replace f with when in the above code for a closer approximation.)</p><p>In summary:</p><ul><li>The void type is a sibling of Object.</li><li>Almost always, a void object can’t be used.</li><li>Something marked void could be, in practice, absolutely anything.</li><li>Anything can be “thrown away” into a location marked void, and the lint void_checks restricts this behavior.</li><li>A void value can be passed into other void locations.</li></ul><h3>The bottom type</h3><p>Before I get to talking about Null, it’s critical we talk about the “bottom” type.</p><p>This is a naturally occurring type in type theory, which has a short academic definition with a few practical applications.</p><p>If you stop reading this section because <em>it’s so dang weird</em>, that is strong evidence of my original TLDR. Unless you want your code to be similarly dang weird, you probably want void. Now let’s explore this weird rabbit hole and see how far it goes, eh?</p><p>The bottom type is the subtype of all types. Put in simpler object-oriented terms, that means it’s a Person. And a Car. And an Animal. And every other type from every program ever written.</p><p>If this sounds absurd, that’s because it is. I like to think of it as a “placeholder” type. But “absurd” or “imaginary” type would also be a somewhat reasonable name for it. Instead, though, it’s called the <em>bottom</em> type, because it’s the bottom of the type hierarchy, which, in computer science, is upside down. ¯\\_(ツ)_/¯. Formally, it may be referred to by the symbol ⊥, which you may also recognize as the symbol for “false.”</p><p>If you try to imagine a value that is a Person <em>and</em> a Car <em>and</em> an Animal, you won’t be able to think of anything. And surprisingly, that is where the practical usage of ⊥ comes from!</p><p>What if I write a function that never returns? There are two easy ways to do so:</p><pre>loopForever() {<br>  while(true); // first way<br>}</pre><pre>alwaysThrow() {<br>  throw Exception(); // second way<br>}</pre><p>What is the best return type for these two functions?</p><p>It depends. Because the function never returns, the return type doesn’t really matter. You can use any type — even the absurd bottom type, which can be used in various ways in various languages.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/0*TkwIX5BsrbSzHfLr\" /></figure><p>C++ has this as noreturn. Rust has !, and Scala has Nothing. But my favorite example comes from Haskell, which has a very commonly used undefined function that aborts the program. It returns, you guessed it, the bottom type.</p><p>If we assume an undefined function in Dart like the one in Haskell, which merely throws an exception when called and returns ⊥, then it would look like the following:</p><pre>Foo foo = cond ? val : undefined();</pre><p>In the example usage line, the program can safely run and store val when cond is true. And when cond is false, the program will throw an exception during undefined(). It is safe to “store” the result of undefined() in foo, regardless of the type of foo, because that store will never actually happen!</p><p>undefined()<strong> </strong>here does not return anything. But the lesson here is not that we can make foo empty…it’s that the bottom type is empty like an empty promise. It’s emptier than empty. It just never happens.</p><p>One thing I must be careful to state is that you can and, depending on the usage, often should return void from these functions in practice. Usually code like return loopForever() is more likely to be a mistake than a useful pattern. However, the choice is yours to make.</p><p>The bottom type is also nice for read-only empty lists. In Dart, Lists are covariant, so a List&lt;int&gt; is allowed to be used as a List&lt;Object&gt;. If you then attempt to stick a String inside that List&lt;Object&gt;, a runtime check will catch that for you and throw an error.</p><p>That means that if we make a List of ⊥, there’s nothing we can put into it, but we can treat it as a list of anything:</p><pre>List&lt;int&gt; intList = &lt;⊥&gt;[];<br>  for(int i in intList) {<br>  print(i * 2); // valid, because this simply never happens<br>}</pre><p>There are even more interesting cases when you look at what’s called “contravariant” placement of the bottom type.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/0*OyVAekp1iwSQyfur\" /></figure><p>Let’s say we define a function that has a ⊥ parameter:</p><pre>void f(⊥ x) {}</pre><p>This is almost the opposite of the undefined() example. Rather than a function that never returns, we have declared a function that can’t be called! No actual value is assignable to that parameter x. You can’t pass in a Person because it’s <em>not also a </em>Car, and you can’t pass in a Car because it’s not also a Person. The only thing you could pass in is the absurd type itself:</p><pre>f(undefined());</pre><p>But as we just covered before, undefined() never returns, so f() is still never actually called in this case!</p><p>Typing a parameter as ⊥ may seem useless, but it has esoteric value because all functions that <em>can</em> be called are subtypes of functions that <em>can’t</em> be.<em> </em>(Think about it: a function that <em>can</em> be called doesn’t <em>have</em> to be. And if a function is not called, it cannot produce runtime errors.)</p><p>If you’re still with me, take a deep breath and pat yourself on the back.</p><p>Specifically, it’s safe to cast any Function(X) to a Function(⊥), for any X. This is better than using Dart’s all-encompassing Function type, because it’s more specific.</p><p>With this you can, for instance, store any unary function in a field and call it dynamically, to get past static errors and replace them with runtime errors if you made a mistake:</p><pre>Function(⊥) f;<br>f = (int x) =&gt; x + 1;</pre><pre>// the validity of 123 as an argument to f is checked at runtime<br>(f as dynamic)(123);</pre><p>This is a neat trick to help you in a pinch.</p><p>Now we can talk about Null.</p><h3>Null in Dart 2</h3><p>The conceptual “bottom” type (a type which is a subtype of all types) exists in Dart, but that’s not all. Such a value also exists in Dart 2! In Dart we call it Null, and that value is — you guessed it — null.</p><p>Since I can make anything null(/Null), the absurd type is not so absurd in Dart. Which makes it a bit complicated.</p><p>Note: The value null, of course, is not a Car, and it’s not a Person. And we do get requests for non-nullable types in Dart. So if we do make such a change to Dart, we’ll need a new bottom type, likely named something to the effect of Nothing, and it will be a truer bottom type at that.</p><p>Not only does Null have all the same absurd usages as the bottom type, but it also has an escape hatch. If you ever really need to return from a function that can’t return, or call a function that can’t be called, we give you an out! You can pass null in there! It would be, honestly, a bit unfair of us to do otherwise, when you look at the whole picture.</p><p>It does give a whole lot of caveats, though, to an otherwise simple declaration:</p><pre>Null nothing() =&gt; null;</pre><p>Null is the most specific type for foo(), so it’s a logical choice and a good starting place. The analyzer is also kind enough to warn you if you call methods on it that don’t exist:</p><pre>nothing().x; // error! No member x on Null</pre><p>But this may give a false illusion of safety.</p><pre>nothing().toString(); // no error: Null defines toString()<br>Foo foo = nothing(); // no error: foo will become null</pre><pre>// Acceptable for all parameter types in f(x),<br>// runtime errors if f(x) expects non-null<br>f(nothing());</pre><p>If your goal is for nothing() to be a synonym for null, then this would be the behavior you want, and Null is the correct type for your function that returns null.</p><p>There were good reasons for suggesting Future&lt;Null&gt;, and it worked while we were coming up with the new void semantics. However, it has the same holes:</p><pre>(await futureNull()).toString(); // no error!<br>Foo foo = await futureNull(); // no error!</pre><p>Essentially, by making some function f() return a Future&lt;Null&gt;, you are making await f() a synonym of null in your program! That’s dangerous because you can use null as if it were absolutely anything, absolutely any type. I don’t think that’s what most people want.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/0*4NDBhLva40BBuX0f\" /></figure><p>Why else might you use Future&lt;Null&gt; instead of Future&lt;void&gt;? It all goes back to that mind-boggling bottom type. You might consider Future&lt;Null&gt; for futures that must be awaitable but that never complete, or that always complete with an error. This is directly comparable to why a function would return Null.</p><p>The same logic applies to Stream&lt;Null&gt;: Use this for a Stream that never sends any events. This is directly comparable to why a read-only empty list may be typed as List&lt;Null&gt;.</p><p>Some trickier types to provide a guideline for are StreamController&lt;Null&gt; and Sink&lt;Null&gt;. These are comparable to functions. The most sound reason to use these types is to say that they should never be used. The next most sound is that you would like them to accept only synonyms of Null, which is reasonable only if you don’t have void_checks turned on.</p><p>Imagine that Dart did not have null as an escape hatch for all values. Would you want to make a type Sink&lt;⊥&gt; that can only accept events from a Stream&lt;⊥&gt;, which itself never broadcasts an event? If the answer is yes, then go for it and make a Sink&lt;Null&gt;.</p><p>All of these usages have weak guarantees because the value null itself is an escape hatch for why you otherwise would be most likely to use the Null type itself. However, do not make the mistake of thinking that the <em>value</em> is the escape hatch itself, rather than the bunker. One is safe and sturdy and the other is to save you the effort of digging upwards through reinforced concrete when the bunker catches on fire with you in it.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*yepcr98D1YlpsRJF\" /></figure><p>In summary, here are the main uses of typing something as Null:</p><ul><li>As a synonym for null, usable everywhere as everything</li><li>As a placeholder for execution your program will never reach</li><li>As a container that must stay empty so that it can masquerade as any type</li><li>As an output with no inputs</li></ul><h3>Final comparison</h3><p><em>If you reached this point of the article, you deserve some sort of recompense — reach out to me and I’ll see about buying you a beer next time you’re free in Portland OR. :)</em></p><p>I talked a lot about the bottom type, but I didn’t get into its opposite at all, Top. The top type is, as you would expect, the polar opposite of the bottom type. And while Dart’s name for the bottom type is Null, Dart’s name for the top type is one of dynamic, Object, and void (three heads of the same coin).</p><p>It may seem strange that words like “nothing” and “empty” in English can mean two such dissimilar things in type theory. Both are suitable descriptions of the exact opposite top and bottom types, and therefore, of Null and void. It may seem strange that two opposite types are appealing candidates for the same job! It may seem frustrating that Dart has so many weird quirks and edge cases, now that you’re reading up on which to use.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/0*ybPT9jlu0yGAnu2v\" /></figure><p>Our mistake, I think, was in ever recommending Null to be used like void in the first place. It would at the time have been a disservice to users to withhold what was useful advice, given Dart 1 semantics. But we accidentally made a <em>very</em> esoteric type <em>very</em> commonly used.</p><p>Well you’ve read the article now. What do you think? Do you expect to come across a valid use for Null any time soon? Do you have a firm understanding of where it’s useful?</p><p>And more importantly, can you help us spread the good news that void is here to make it all simpler?</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=84a42d616e7d\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/future-void-vs-future-null-whats-the-difference-84a42d616e7d\">Future&lt;void&gt; vs Future&lt;Null&gt;, what’s the difference?</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2018-09-24T17:18:36.000Z":{"title":"Improved discovery on the Dart package site","link":"https://medium.com/dartlang/improved-discovery-on-the-dart-package-site-9bfe24c3d7d3?source=rss----23738d481ce8---4","guid":"https://medium.com/p/9bfe24c3d7d3","category":["dart","flutter"],"dc:creator":"Michael Thomsen","pubDate":"Mon, 24 Sep 2018 17:18:36 GMT","atom:updated":"2018-09-24T17:18:36.053Z","content:encoded":"<p>Back in July we talked about <a href=\"https://medium.com/dartlang/getting-ready-for-dart-2-and-making-your-packages-look-great-on-the-pub-site-118464d7f59d\">our changes</a> to the Dart package site (<a href=\"http://pub.dartlang.org\">http://pub.dartlang.org</a>), which included better support for analyzing packages for potential issues. Since then we’ve focused on further improvements to discovering content on the package site.</p><h3>Dart 2 incompatibility</h3><p>The vast majority of recent &amp; popular packages have been <a href=\"https://www.dartlang.org/dart-2#migration\">migrated to support Dart 2</a>, so they are ready for <a href=\"https://flutter.io/\">Flutter</a> and <a href=\"https://webdev.dartlang.org/angular\">AngularDart</a> 5 apps. However some packages — mostly older ones not being maintained — still don’t support Dart 2. To make sure you can easily spot these, we now add Dart 2 incompatibility tags to the overview and package detail pages.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*wh9C-VJUKEYz4l2zpUkg4A.png\" /><figcaption>Packages incompatible with Dart 2 are clearly marked ‘Dart 2 incompatible’</figcaption></figure><p>Also, we anticipate that we will be archiving/discontinuing these incompatible packages in a future version of the package site, so if you are an author of a package marked ‘Dart 2 incompatible’, please consider migrating it soon!</p><h3>Support for core libraries</h3><p>Dart comes with a rich set of core (standard) libraries. Developers have told us that it can be hard to remember if a particular utility function is in a core library or in a package. To help you find the API you need, searches on pub.dartlang.org now include not just published packages, but also core libraries. Search results from core libraries have <strong>sdk</strong> in the score circle, and the annotation <strong>Dart core library</strong>. If you click the entry, you go directly to the library API documentation.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/986/1*Q9oEytibPnPy23qiSliyyQ.png\" /><figcaption>Search hits in SDK core libraries are included among the results</figcaption></figure><h3>Package update feed</h3><p>Pub has provided an Atom feed for a while; to make this more discoverable we’ve added a direct link in the site footer.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/530/0*1rSptJGr3iaTKqvb\" /></figure><h3>Scoring changes</h3><p>We’ve made a number of simplifications and adjustments to the scoring model for health and maintenance. For an overview of the current model, please see the <a href=\"https://github.com/dart-lang/pana/blob/master/README.md\">pana README</a> (pana is the tool that provides the scoring).</p><p>In the future, we plan to improve transparency by showing how much each reported issue reduced the overall score directly on the package analysis page.</p><h3>Feedback welcome</h3><p>Found an issue? Have a cool idea or suggestion? Please tell us by <a href=\"https://github.com/dart-lang/pub-dartlang-dart/issues/new?body=URL%3A+https%3A%2F%2Fpub.dartlang.org%2F%0A%0A%3CDescribe+your+issue+or+suggestion+here%3E&amp;title=%3CSummarize+your+issues+here%3E&amp;labels=Area%3A+site+feedback\">opening an issue</a> in our tracker. Also note that even the package site itself is crafted as open-source in the <a href=\"https://github.com/dart-lang/pub-dartlang-dart\">pub-dartlang-dart repo</a>, and contributions and ideas are most welcome!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9bfe24c3d7d3\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/improved-discovery-on-the-dart-package-site-9bfe24c3d7d3\">Improved discovery on the Dart package site</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2018-08-30T16:34:25.000Z":{"title":"Dart 2: Legacy of the `void`","link":"https://medium.com/dartlang/dart-2-legacy-of-the-void-e7afb5f44df0?source=rss----23738d481ce8---4","guid":"https://medium.com/p/e7afb5f44df0","category":["programming","flutter","type-safety","dart","dartlang"],"dc:creator":"Matan Lurey","pubDate":"Thu, 30 Aug 2018 16:34:25 GMT","atom:updated":"2018-08-31T19:41:40.634Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*qGU6soDvCW0RFfDX8vpUow.png\" /><figcaption>A semi-accurate depiction of the <a href=\"https://en.wikipedia.org/wiki/Bo%C3%B6tes_void\">universe</a> of void-like types in Dart2</figcaption></figure><p>One of the questions I see the most asked on StackOverflow, Gitter, and even Google-internal support channels is the difference between the following built-in types in Dart 2: Object, dynamic, void, and Null.</p><p>Long-story short, Null (<a href=\"https://en.wikipedia.org/wiki/Bottom_type\">or </a><a href=\"https://en.wikipedia.org/wiki/Bottom_type\">Bottom in other languages</a>, i.e. “Nothing”) shouldn’t be used in most real user-code, and I suspect we’ll see more articles and lints in the near future to gently discourage usage.</p><p>The rest of the three are not as clear, because something in Dart 2 anything can be dynamic, Objector voidat runtime, varying only by the <em>static</em> type signature. So let’s look at a few practical examples of <em>when</em> you should use which type signature.</p><h3>Object</h3><p><a href=\"https://api.dartlang.org/stable/2.0.0/dart-core/Object-class.html\">Object</a>is the root class of the Dart class hierarchy, and every other class in Dart is a sub-class of Object — including “primitive” types like int, double, or bool. It guarantees a few things: a <a href=\"https://api.dartlang.org/stable/2.0.0/dart-core/Object/hashCode.html\">hashCodeproperty</a>, an <a href=\"https://api.dartlang.org/stable/2.0.0/dart-core/Object/operator_equals.html\">==operator</a>, a <a href=\"https://api.dartlang.org/stable/2.0.0/dart-core/Object/toString.html\">toStringmethod</a>.</p><p>Practically speaking, I use Objectlike a poor man’s union type — expecting users to use the isoperator to determine the real type of something before using it. <strong>I don’t use </strong><strong>dynamic</strong>, because, as outlined in the next section, it disables important static analysis and more easily allows you to get into an invalid state.</p><pre>Object readProperty(String name) { ... }</pre><pre>void main() {<br>  var age = readProperty(&#39;name&#39;);<br>  if (age is int) {<br>    print(&#39;I am $age years old&#39;);<br>  } else if (age is String) {<br>    print(age);<br>  }<br>}</pre><p>Another option is to use Object to declare you <em>don’t care</em> what the inner type of a data structure is, for example List&lt;Object&gt; might mean “a list of anything”. This comes in handy when, for example, writing a function that combines the hashCode of every element in a List:</p><pre>int hashList(List&lt;Object&gt; elements) { ... }</pre><p>A nice property of Object(compared with dynamic) is that you will get immediate analysis and compiler feedback if you try to call a method on it that doesn’t reliably exist. For example, the following produces a <em>static error</em>:</p><pre>void main() {<br>  Object a = 5;<br>  a.aMethodThatDoesNotExist();<br>}</pre><p>In practice though, Object is fairly(and intentionally) limited. My hope is that <a href=\"https://github.com/dart-lang/sdk/issues/26488\">Dart will get support for method overloads</a> and that will allow me to dramatically decrease my usage of the Object type in real code.</p><h3>dynamic</h3><p>I personally <strong>never</strong> use the dynamic type in Dart 2. From my perspective, it is sort of a union of Objectand a special instruction that tells tools and compilers to <em>disable static analysis checks</em>. That is, the following is legal, and will only present an error at runtime (not statically!):</p><pre>void main() {<br>  dynamic x = 5;<br>  x.aMethodThatDoesNotExist();<br>}</pre><p>In Dart 1, dynamic was everywhere, and any other static type was for IDE and static analysis support — but the compiler (and runtime) treated everything as dynamic. There are still some unfortunate “gotchas” in Dart 2 that can <em>accidentally</em> create a dynamic-typed variable, though:</p><pre>computeAge() =&gt; 5; // Return type is dynamic</pre><pre>void main() {<br>  var name; // Static type is dynamic<br>  var animals = []; // Static and runtime type is List&lt;dynamic&gt;<br>}</pre><p>Worse yet, dynamic calls lose type information that is vital in Dart 2:</p><pre>class User {<br>  String name;<br>}</pre><pre>void main() {<br>  var users = []; // Implicitly List&lt;dynamic&gt;, remember?<br>  users.add(new User()..name = &#39;Matan&#39;);</pre><pre>  // Runtime error: List&lt;dynamic&gt; is not a Iterable&lt;String&gt;<br>  Iterable&lt;String&gt; names = users.map((u) =&gt; u.name);<br>}</pre><p>The reason for this error is because the actual call here is:</p><pre>users.map((dynamic u) =&gt; u.name);</pre><p>… which does not have enough static type information to produce a Iterable&lt;String&gt;. By fixing users to have the proper type (and avoiding dynamic calls), everything works:</p><pre>void main() {<br>  // We also could have written `var users = &lt;User&gt;[<br>  var users = [new User()..name = &#39;Matan&#39;];</pre><pre>  // OK!<br>  Iterable&lt;String&gt; names = users.map((u) =&gt; u.name);<br>}</pre><h3>void</h3><p>Lastly, we have void, the newest type in Dart 2. In Dart 1 void was only usable as the return type of a function (such as void main()), but in Dart 2 it has been <em>generalized, </em>and is usable elsewhere, for example Future&lt;void&gt;.</p><p>A void type is semantically similar to Object(it could be anything), except with additional restrictions — a void type cannot be used for anything (even == or hashCode), and it is invalid to assign something to a void type:</p><pre>void foo() {}</pre><pre>void main() {<br>  var bar = foo(); // Invalid<br>}</pre><p>In <em>practice, </em>I use void to mean “anything and I don’t care about the elements” or, more commonly, to mean “omitted”, such as in Future&lt;void&gt; or Stream&lt;void&gt;:</p><pre>/// Clear the cache.<br>Future&lt;void&gt; purgeCache() { ... }</pre><p>In the above code snippet, I don’t want users to try and use the return value of the provided Future, as it is not relevant. I’ve seen examples of using Future&lt;Null&gt;for this purpose, and that was actually a workaround <em>before</em> Future&lt;void&gt;was possible.</p><p>For example, this is statically OK, but at runtime is invalid in Dart 2:</p><pre>import &#39;dart:async&#39;;</pre><pre>Future&lt;String&gt; _doAThing() async =&gt; &#39;Test&#39;;<br>Future&lt;Null&gt; doAThing() async =&gt; _doAThing();</pre><pre>void main() async {<br>  // Future&lt;String&gt; is not a subtype of type FutureOr&lt;Null&gt;<br>  await doAThing();<br>}</pre><p>… where as using Future&lt;void&gt;for doAThing()is valid and correct.</p><p>Another example might be a Stream that fires without any event data:</p><pre>/// Fires an event when a user signs-out of the system.<br>Stream&lt;void&gt; get onLogOut { ... }</pre><p>Another more practical use is implementing a class with generic type arguments you won’t be using. For example, implementing the popular <a href=\"https://en.wikipedia.org/wiki/Visitor_pattern\">Visitor pattern</a>, we can ignore the C(context) type argument when it isn’t used by passing void:</p><pre>abstract class Visitor&lt;N, C&gt; {<br>  N visitNode(N node, [C context]);<br>}</pre><pre>class IdentityVisitor&lt;N&gt; extends Visitor&lt;N, void&gt; {<br>  @override<br>  N visitNode(N node, [_]) =&gt; node;<br>}</pre><p>I hope this brief article helps you with API decisions around using Object, dynamic, void. Leave comments if you have any other questions or ideas!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e7afb5f44df0\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart-2-legacy-of-the-void-e7afb5f44df0\">Dart 2: Legacy of the `void`</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2018-08-07T16:14:17.000Z":{"title":"Announcing Dart 2 Stable and the Dart Web Platform","link":"https://medium.com/dartlang/dart-2-stable-and-the-dart-web-platform-3775d5f8eac7?source=rss----23738d481ce8---4","guid":"https://medium.com/p/3775d5f8eac7","category":["web-development","flutter","programming-languages","dart","mobile-app-development"],"dc:creator":"Kevin Moore","pubDate":"Tue, 07 Aug 2018 16:14:17 GMT","atom:updated":"2018-08-08T16:22:30.284Z","content:encoded":"<h4>Signals the rebirth of Dart as a mainstream programming language for mobile and web development</h4><p>Today, we’re announcing the immediate availability of the stable release of Dart 2, including a rewrite of the Dart web platform that offers a unique combination of productivity, performance and scalability.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/589/1*xV5sN0ycM2OxY5BbGDhdmg.png\" /></figure><p>Flutter developers are already enjoying many of the benefits of Dart 2, since Flutter has been bundling prerelease versions of the Dart 2 SDK for several months. However, the stable release of Dart 2 is another important milestone towards the stable release of Flutter, due to the tight coupling between framework and language. If you haven’t already installed Flutter, <a href=\"https://flutter.io/get-started/install/\">start here</a>.</p><p>With the release of Dart 2, web developers can now leverage the same language, libraries and tools along with a number of web-specific enhancements. Web developers should start at the <a href=\"https://webdev.dartlang.org/guides/get-started\">Get Started</a> page for instructions on installing tools and building a first application.</p><h3>Dart: Growing Excitement</h3><p>Dart 2 marks the rebirth of Dart as a mainstream programming language focused on enabling a fast development and great user experiences for mobile and web applications. We want to enable developers building client applications to be productive, with a language, framework and components that reduce boilerplate and let them concentrate on the business logic, along with tooling that identifies errors early, enables powerful debugging and delivers small, fast runtime code.</p><p>Over the last year, Dart has seen dramatic growth. Our own analytics suggest a ten-fold growth in external usage. In the last quarter, Dart was <a href=\"https://madnight.github.io/githut/#/pull_requests/2018/2\">one of the fastest growing languages on GitHub</a>, as measured by pull requests; the growth of <a href=\"http://sotagtrends.com/?tags=[dart,perl,haskell,rust]&amp;relative=false\">StackOverflow questions</a> also provides a vivid demonstration of Dart’s momentum:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/762/0*s3bqLPad7xh_nFH-\" /></figure><p>Internally, Dart is one of a handful of languages Google uses for web application development, with millions of lines of code from dozens of different projects including Google Ads, Google Shopping and our own internal infrastructure teams.</p><p>In fact, you might already be using Dart without realizing it: the popular <a href=\"https://sass-lang.com/\">Sass stylesheet preprocessor</a> was recently <a href=\"http://sass.logdown.com/posts/7045860-dart-sass-100-is-released\">rewritten in Dart</a> to make it faster, more portable, and easier to write. Sass is now distributed as a standalone executable on Homebrew and Chocolatey, and compiled to pure JavaScript on npm. Dart makes it easy to install applications anywhere without external dependencies, and to slot into the workflows of both people who use Dart and people who don’t.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*YX3CcH4He_IIEhzx\" /></figure><p>Dart 2 is focused on three areas: strengthening and tightening the language, developing our support for web and mobile frameworks, and bringing some of the tooling and components that support Google’s usage of Dart to the outside world. The rest of this post will explore these themes.</p><h3>Dart 2: A Client-Optimized Language</h3><p>As we <a href=\"https://medium.com/dartlang/announcing-dart-2-80ba01f43b6\">highlighted in February</a>, the <a href=\"https://www.dartlang.org/guides/language/sound-dart\">Dart type system</a> is <em>sound</em>. This means that a large class of issues is found before your users run your application — during analysis and compilation. As we scaled Dart to extremely large apps within Google, the type system caught more errors early in the development cycle, leading to higher quality production code.</p><p>With Dart 2, you can’t get into a state where an expression evaluates to a value that doesn’t match the expression’s static type. This means that you can scale your codebase to millions of lines, tackle large refactoring projects, and deploy your code with confidence.</p><p>Don’t worry: soundness doesn’t mean mountains of boilerplate. The type system includes advanced inference — even for generic type arguments.</p><pre>final _field = [3.14, 6.28];</pre><pre>void main() {<br>  // No type parameter is provided, but &lt;int&gt; is inferred<br>  print([1, 2, 3].runtimeType); // List&lt;int&gt;</pre><pre>  // If types are unmatched, their common base type is used<br>  // int (1) and double (3.14) are both `num`<br>  print([1, 3.14].runtimeType); // List&lt;num&gt;</pre><pre>  // Inference goes beyond variables.<br>  // You can omit types on fields, too.<br>  print(_field.runtimeType); // List&lt;double&gt;<br>}</pre><p>To learn more about the Dart 2 type system, check out <a href=\"https://www.dartlang.org/guides/language/sound-dart\">this page</a>.</p><p>As mentioned in previous blog posts, Dart 2 also reduces the language ceremony in a few key areas: for example, the new keyword is now optional, and the const keyword is optional within a constant context.</p><p>Lastly, we’ve done lots of work behind the scenes to unify various supporting tools, with a common front-end that now supports our compilers and runtimes. This ensures consistency for our users now and promises to improve the velocity and quality of new features as Dart continues to evolve.</p><h3>Dart on the Web: A Rich, Powerful Framework</h3><p>Web applications have been central to Dart’s mission from the start. In fact, most Dart development at Google is for web applications. One of the biggest is Google Ads, which powers billions of dollars of the web economy. In the process of migrating their code to Dart, they reduced the size of their UI codebase by 40% while improving developer productivity and application quality.</p><p>While the core Dart SDK provides libraries to access modern browser APIs, we also support a robust Angular-inspired framework for building complex web applications. <a href=\"https://webdev.dartlang.org/angular\">AngularDart 5</a>, shipped as part of Dart 2, takes advantage of Dart’s sound type system and the <a href=\"https://github.com/dart-lang/build\">new build system</a> (described below) to offer fast incremental builds during development and smaller compiled JavaScript when you’re ready to deploy.</p><p>One major area of focus for this release has been improving the amount of code that is processed on page load, significantly reducing the ‘time to interactivity’ for web pages. Many apps have seen code size reduced by more than half compared to AngularDart 4.</p><p>To showcase the improvements in Dart’s web platform, we built out a <a href=\"https://hnpwa.dartlang.org/\">Dart-based client implementation for the HackerNews site</a> as a Progressive Web App; this is published along with other sample implementations at the popular <a href=\"https://hnpwa.com/\">HNPWA site</a>. Using best practices for building Dart web apps, we were able to ship a full-featured experience that is fully interactive in one second on modern devices and under five seconds on a modest mobile device on a slow 3G network. This is competitive even with lightweight web frameworks that are optimized for smaller apps.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/353/1*Zf8U7ODhydytCsOn6_pQcw.png\" /><figcaption><a href=\"https://hnpwa.dartlang.org/\">hnpwa.dartlang.org</a></figcaption></figure><p>Our framework investments extend to our <a href=\"https://pub.dartlang.org/packages/angular_components\">core components</a>, which we’ve also updated. You now have access to 100 new classes, including a number of date, time, and menu <a href=\"https://material.io/\">Material components</a>. You can explore all of our components in the <a href=\"https://dart-lang.github.io/angular_components_example/\">component gallery</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/316/0*drInYm1m0XD2vGZS\" /><figcaption><em>Material Date Picker — one of the rich components available for your web application</em></figcaption></figure><h3>Flexible Tooling for Dart 2</h3><p>With Dart 2, Dart becomes a first-class compiled-to-JavaScript language, with a dev cycle that web developers expect and excellent runtime performance characteristics. This is done while providing benefits most JS-targeted languages don’t provide: a sound type system and excellent support for native mobile apps.</p><p>With Dart 2, our web tools embrace a 100% JavaScript development model with two complementary JavaScript compilers. The development compiler, <a href=\"https://webdev.dartlang.org/tools/dartdevc\">dartdevc</a>, provides fast incremental compilation while generating JavaScript that is easy to read and debug. This allows our production compiler, <a href=\"https://webdev.dartlang.org/tools/dart2js\">dart2js</a>, to focus on producing highly optimized JavaScript for progressive web apps for mobile and complex enterprise experiences for the desktop. Both compilers leverage Dart’s sound type system to optimize their output.</p><p>Our web tools are based on a <a href=\"https://github.com/dart-lang/build\">new build system</a>, designed to be fast, debuggable, and extensible. Now tasks like generating serialization code, compiling Sass to CSS and compiling Dart to JavaScript happen in one toolchain that supports fast, incremental updates as you change parts of your application. The build system is also designed to support uses beyond the web. An example: it’s being used by Flutter developers, to generate <a href=\"https://flutter.io/json/#serializing-json-using-code-generation-libraries\">JSON serialization code</a>.</p><p>With Dart 2, we also have an expanded set of developer tools. In addition to support for <a href=\"https://developer.android.com/studio/\">Android Studio</a> and the JetBrains suite of tools, including <a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a> and <a href=\"https://www.jetbrains.com/webstorm/\">WebStorm</a>, we also support <a href=\"https://code.visualstudio.com/\">Visual Studio Code</a> with the <a href=\"https://dartcode.org/\">Dart Code extension</a>. And we also have a great scratchpad for experimenting: <a href=\"https://dartpad.dartlang.org/\">DartPad</a>, which has been fully updated for Dart 2.</p><p>Finally, the Dart SDK comes with a suite of other useful tools: a package manager that works with our <a href=\"https://pub.dartlang.org/\">package site</a>, a <a href=\"https://www.dartlang.org/tools/analyzer\">static analyzer</a>, a linter that you can consume from the command line or as a package, and tooling for <a href=\"https://pub.dartlang.org/packages/dartdoc\">web documentation</a> and <a href=\"https://pub.dartlang.org/packages/dart_style\">code formatting</a> that conforms with the <a href=\"https://www.dartlang.org/guides/language/effective-dart/style\">Dart style guide</a>.</p><h3>Learn more</h3><p>Check out the instructions for getting started with <a href=\"https://flutter.io/get-started/install/\">Flutter</a> and the <a href=\"https://webdev.dartlang.org/guides/get-started\">Dart web toolset</a>.</p><p>The <a href=\"https://groups.google.com/a/dartlang.org/forum/#!topic/announce/IUWWXwL7QB4\">release</a> notes provide a detailed technical breakdown of the numerous other smaller improvements made since Dart 1, some of which are breaking changes for older Dart code. If you run into problems that a Google search can’t solve, we recommend starting at <a href=\"https://stackoverflow.com/questions/tagged/dart\">StackOverflow</a>. Subscribe to the <a href=\"https://groups.google.com/a/dartlang.org/forum/#!forum/announce\">Dart Announcements</a> mailing list and <a href=\"https://twitter.com/dart_lang\">follow us on Twitter</a> to get updates. We’d also love to see you in our communities, for example the <a href=\"https://gitter.im/dart-lang/home\">Gitter</a> chat room and <a href=\"https://www.reddit.com/r/dartlang/\">r/dartlang subreddit</a>.</p><h3>Thank you</h3><p>Dart has become a general purpose language that is optimized for web and mobile development. We’ve been working on Dart 2 for several years, during which time it has touched every aspect of our ecosystem and required migrating millions of lines of code and hundreds of packages.</p><p>We are grateful to the <a href=\"https://www.dartlang.org/\">Dart</a> and <a href=\"https://flutter.io/\">Flutter</a> communities and well as the hundreds of Google engineers who have helped us on this journey. We couldn’t have done it without you!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3775d5f8eac7\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart-2-stable-and-the-dart-web-platform-3775d5f8eac7\">Announcing Dart 2 Stable and the Dart Web Platform</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2018-07-20T20:33:00.000Z":{"title":"Getting ready for Dart 2, and making your packages look great on the Pub site!","link":"https://medium.com/dartlang/getting-ready-for-dart-2-and-making-your-packages-look-great-on-the-pub-site-118464d7f59d?source=rss----23738d481ce8---4","guid":"https://medium.com/p/118464d7f59d","category":["dartlang","github"],"dc:creator":"Michael Thomsen","pubDate":"Fri, 20 Jul 2018 20:33:00 GMT","atom:updated":"2018-07-20T20:33:00.310Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<p>We have a new release of <a href=\"https://pub.dartlang.org\">Pub</a>, the package repository for Dart! This time around we focused on preparing for the Dart 2 stable release.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*zpVgP0W04QFmqqaJO9fzhg.png\" /></figure><h3>Migrating your packages to Dart 2</h3><p>We expect the Dart 2 release to graduate to stable in the immediate future! Thus, it’s critical that you <a href=\"https://www.dartlang.org/dart-2#migration\">migrate your code</a> — especially any packages you have published — to be Dart 2 compatible. There are three main aspects to this:</p><ul><li>Make sure your code passes Dart 2 analysis (<a href=\"https://www.dartlang.org/dart-2#general-process\">details</a>). We recommend you also pay attention to hints — for example, to prepare for deprecations.</li><li>Run tests to make sure your code passes Dart 2 runtime checks (<a href=\"https://www.dartlang.org/guides/language/sound-problems#runtime-errors\">details</a>).</li><li>Update the upper bound of the SDK constraint of your packages to &lt;3.0.0 (<a href=\"https://www.dartlang.org/dart-2#upper-constraints-on-the-sdk-version\">details</a>).</li></ul><p>We strongly encourage all package authors to do this work, and we will be pushing hard ourselves on the packages we own over the next few days.</p><h3>Improved analysis UI on the Pub site</h3><p>To help with this migration we have updated the analysis tab of the Pub site to make the results of code analysis easier to read. First, at the top of the analysis page we added progress bars allowing you to quickly see the status of the package:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*LatYAFujtrM2yebc\" /><figcaption>Package scores shown on the Pub site</figcaption></figure><p>Below the progress bars are detailed analysis results, grouped by severity: errors (red icon), warnings (yellow icon), and suggested issues (blue icon), as shown in the following screenshot:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*Fq4FHYc9N5aHmYBK\" /><figcaption>Analysis issues shown on the Pub site</figcaption></figure><h3>Updated analysis scores</h3><p>We also made some tweaks to the analysis score. We now lower the score of a package if any of the following are true:</p><ul><li>The package doesn’t pass Dart 2 analysis.</li><li>The upper SDK constraint isn’t at least &lt;3.0.0.</li><li>API reference generation (<a href=\"https://www.dartlang.org/guides/language/effective-dart/documentation\">dartdoc</a>) fails.</li></ul><p>For our next Pub site release we expect to work on some further refinement of the scores, and to add some documentation for how the scores are calculated.</p><h3>Searching the API surface of a package</h3><p>Searching is — not too surprisingly — the most popular feature of the Pub site. We have made a number of improvements in this area over the past few quarters, focused on adding platform filters and better ranking. The new release extends search with support for searching the API surface of a package. In addition to the current search indexing of the package’s description and README.md content, search now covers all the public API members of the package, plus the API documentation for those members! This is great when you want to locate something that isn’t mentioned in the descriptions and README.md files.</p><p>For example, let’s say you’re looking for a package that can format strings using the <a href=\"https://en.wikipedia.org/wiki/ISO_4217\">ISO 4217</a> currency format. A search in description and README.md files gives you <a href=\"https://pub.dartlang.org/packages?q=4217&amp;api=0\">a single result</a>, but a search that includes API documentation gives you <a href=\"https://pub.dartlang.org/packages?q=4217\">several results</a>:</p><pre>10 results for 4217</pre><pre><strong>intl</strong></pre><pre>Contains code to deal with internationalized/localized messages, date and number formatting and parsing, bi-directional text, and other internationalization issues.</pre><pre>v 0.15.2 • Updated: Oct 19, 2017 FLUTTER WEB OTHER</pre><pre>API results:</pre><pre>intl/NumberFormat-class.html</pre><pre><strong>flutter_billing</strong></pre><pre>A flutter plugin to communicate with billing on iOS and Android.</pre><pre>v 0.1.2 • Updated: Feb 10, 2018 FLUTTER</pre><pre>API results:</pre><pre>flutter_billing/BillingProduct-class.html</pre><h3>In summary…</h3><p>The Dart 2 stable channel release is happening very soon, and we’ve made a bunch of Pub site improvements related to Dart 2, ranking, and searching.</p><p>If you’ve published packages, <em>now</em> is the time to update them for Dart 2:</p><ol><li>Make sure your packages pass Dart 2 analysis.</li><li>Update the upper bound of the SDK constraint to &lt;3.0.0 in your pubspec.yaml.</li><li>Republish your updated packages.</li></ol><p>Then go to your package’s analysis page on <a href=\"https://pub.dartlang.org/\">pub.dartlang.org</a>, and see what else you can do to improve your ranking!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=118464d7f59d\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/getting-ready-for-dart-2-and-making-your-packages-look-great-on-the-pub-site-118464d7f59d\">Getting ready for Dart 2, and making your packages look great on the Pub site!</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2018-03-27T16:28:38.000Z":{"title":"Announcement: IDE Tooling for AngularDart 5","link":"https://medium.com/dartlang/announcement-ide-tooling-for-angulardart-5-de01ecccec9d?source=rss----23738d481ce8---4","guid":"https://medium.com/p/de01ecccec9d","category":["angulardart","dartlang","angular","intellij","dart"],"dc:creator":"Mike Fairhurst","pubDate":"Tue, 27 Mar 2018 16:28:38 GMT","atom:updated":"2018-04-17T15:51:42.496Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/667/1*ZrNw6Wd0ZqQibsfXS8Gsng.png\" /></figure><p>Dart is a statically typed language which we know and love, and Dart 2 will be even more strictly typed. That is why it makes such a great platform for the Angular framework, where components are mostly statically linked together in templates to create performant UIs.</p><p>So, to further improve this productive and safe developer experience, we are announcing new IDE tools for preserving that type-safety inside your templates! It supports AngularDart 5, and works out of the box with IntelliJ/WebStorm. It can also be configured to work in VSCode, vim, and more.</p><p>You can skip straight to <a href=\"#a8cb\">setup</a> now if you’re already sold, or follow along for a tour of what our new IDE integration offers you!</p><h3>Errors</h3><p>The new analysis plugin will find many type errors inside your templates for you. Expressions are validated against the directives you use, the inputs they contain, and the references you bind (#foo, let item of, …).</p><p>Here’s a misspelled member, so you don’t have to play human-spellchecker!</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/615/0*Ia1RMoPF9nmaAsIJ.\" /></figure><p>And mismatched types on a component input are no longer a problem either.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/694/0*LJKT0LftQFRjuKaN.\" /></figure><p>We can also give you errors related to $event variable types,</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/430/0*4UKHl3KVHtpV6Ysx.\" /></figure><p>And we check the content you transclude inside your directives. This is one example of where we catch not only type errors but also dead code.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/556/0*2nWPvm2BGmt1SGMZ.\" /></figure><p>And we could go on! We catch a slew of other types of errors, both in templates, and component definitions.</p><p>In addition to being highlighted in your editor, the full listing of errors is displayed in the Dart Analysis panel.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*u34uyVu2qy_7p1xfxHFnCA.png\" /></figure><h3>Autocomplete</h3><p>We didn’t just stop at validation! While much of the work was getting our analysis to be performant and fully well-behaved in regards to the compiler, much of the value comes from using that resolved template state to deliver you the goodness of regular Dart autocompletion in your templates:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/808/1*Qh5P6t4ccwezdMLWjAWw9Q.png\" /></figure><p>But we can complete more than regular Dart members — how about inputs, outputs, and HTML tags?</p><p>Tags? Check.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/441/1*d3wuZHY5Ja52fe00u2jgSQ.png\" /></figure><p>Attributes? Check.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/687/1*UlT5D-O_rajaFS_MCyHWsA.png\" /></figure><p>Stars? Check.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/710/1*3QMba2E4BETXmoi-5bG6gQ.png\" /></figure><p>Attributes within stars? Check.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/417/1*Ep9sEzWfe9Kife8HyMjvKw.png\" /></figure><p>Bonus points: Suggested tags <em>with</em> attributes within component transclusions!</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/497/1*_8_-jlg2S62p_a8plKAtgg.png\" /></figure><p><em>Transclusions are a famously advanced topic within angular, so if you think you know what exactly it is that we’re suggesting, pat yourself on the back for knowing AngularDart very well.</em></p><p>Suffice it to say, component APIs are much easier to follow when using our plugin!</p><h3>Navigation</h3><p>Support here varies a lot more by editor, but within IntelliJ you can click through parts of Dart expressions. In other editors you may be able to navigate on even more entities such as tags and inputs/outputs.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/409/1*ceQlGeSCVnfOJqtHEITljQ.png\" /></figure><h3>How To Use</h3><p>Make sure you are using an AngularDart 5 beta release, and Dart 2.0.0-dev.31 or newer.</p><p>Simply add this to your <a href=\"https://www.dartlang.org/guides/language/analysis-options#the-analysis-options-file\">analysis_options.yaml</a> file:</p><pre>analyzer:<br>  plugins:<br>    - angular</pre><p>And restart your IDE. Note, it may take a few seconds to spin up the plugin. It will first have to download sources &amp; dependencies for you, and the first analysis will be slower than subsequent ones.</p><p>You can also play around with it in our <a href=\"https://github.com/MichaelRFairhurst/dartconf-angular-plugin-lightning-demo\">analyzer plugin demo project</a>.</p><p>If you are using IntelliJ, this should be all you have to do. For other editors, they may not run our plugin on HTML without extra work — for instance, VSCode requires <a href=\"https://github.com/Dart-Code/Dart-Code/issues/396#issuecomment-366058798\">a flag</a>.</p><h3>Feedback &amp; More</h3><p>Our plugins source code lives <a href=\"https://github.com/dart-lang/angular_analyzer_plugin\">on Github</a>, which has more information on what’s supported and where you can file issues if you have questions or come across any bugs.</p><p>The new IDE tooling will be part of the next stable release of AngularDart (v5). We’re very excited to offer you even better productivity as you write your Angular web apps!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=de01ecccec9d\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/announcement-ide-tooling-for-angulardart-5-de01ecccec9d\">Announcement: IDE Tooling for AngularDart 5</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2018-03-23T11:44:18.000Z":{"title":"Announcing official gRPC support for Dart","link":"https://medium.com/dartlang/announcing-official-grpc-support-for-dart-6c9b50357af6?source=rss----23738d481ce8---4","guid":"https://medium.com/p/6c9b50357af6","category":["dart","grpc","flutter","programming"],"dc:creator":"Michael Thomsen","pubDate":"Fri, 23 Mar 2018 11:44:18 GMT","atom:updated":"2018-03-23T11:44:18.564Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/300/1*tWFciSm58uLmvp8i_t3WaQ.png\" /></figure><p>gRPC is a high performance, open source RPC framework. It offers simple service definitions, is built on http/2, and has support for bi-directional streaming and fully integrated pluggable authentication. The gRPC framework supports a <a href=\"https://grpc.io/docs/\">wide range of languages</a>, and we are happy to announce that support for the Dart language is now available in beta!Dart gRPC support works with the Dart SDK, version 1.24.3 or higher, and currently supports the <a href=\"https://flutter.io/\">Flutter</a> and <a href=\"https://www.dartlang.org/dart-vm\">VM/Server</a> platforms.</p><h3>Creating a server and writing gRPC service definitions</h3><p>gRPC services typically describe their endpoints and data serialization using <a href=\"https://github.com/dart-lang/protobuf\">Protocol Buffers</a> v3. Here is a small example service definition which defines a service ‘Greeter’ with a single rpc message ‘SayHello’ (the number ‘1’ in the two messages specifies the unique ID of the <a href=\"https://developers.google.com/protocol-buffers/docs/overview\">message field</a>):</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/4c663609accc6d71c219b63687fba34c/href\">https://medium.com/media/4c663609accc6d71c219b63687fba34c/href</a></iframe><p>Once you have defined the service, you can automatically generate the skeleton of the server:</p><pre>protoc --dart_out=grpc:generated -Iprotos protos/greeter.proto</pre><p>This will produce a GreeterServiceBase class in the generated diretory, which you then subclass to add the actual service implementation:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ca85aaf40fe2831d6308a487de38a6a3/href\">https://medium.com/media/ca85aaf40fe2831d6308a487de38a6a3/href</a></iframe><h3>Calling the server with a gRPC client</h3><p>When we generated the service stub above, the protoc compiler also generated a client library:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/cb3f89b99f26c9173d872e61edde2788/href\">https://medium.com/media/cb3f89b99f26c9173d872e61edde2788/href</a></iframe><p>With that, calling into the service from the client tier is simple:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/38a3097e23c80858ba3027e912570256/href\">https://medium.com/media/38a3097e23c80858ba3027e912570256/href</a></iframe><p>When run, this will print the following output:</p><pre>Greeter client received: Hello, Michael!</pre><h3>Next steps</h3><p>To get started with gRPC in Dart, please take a look at our new <a href=\"https://grpc.io/docs/quickstart/dart.html\">Dart gRPC QuickStart</a>, which walks you through running and extending the Greeter example. Next, check out the <a href=\"https://grpc.io/docs/tutorials/basic/dart.html\">Dart gRPC tutorial</a>.</p><p>Should you encounter any problems, please <a href=\"https://github.com/grpc/grpc-dart/issues/new\">file an issue</a>. We would also gladly hear your feedback on any changes or additions you like to see; for example, we have heard several requests for supporting the <a href=\"https://github.com/grpc/grpc-dart/issues/43\">gRPC-Web protocol</a>. One concrete way of offering quick feedback is to ‘cast a vote’ on an issue by pressing the GitHub thumbs-up 👍 button on the top-most comment of an issue.</p><p>We look forward to seeing what you might build with gRPC for Dart!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6c9b50357af6\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/announcing-official-grpc-support-for-dart-6c9b50357af6\">Announcing official gRPC support for Dart</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-05-08T16:59:00.000Z":{"title":"Announcing Dart 2.3: Optimized for building user interfaces","link":"https://medium.com/dartlang/announcing-dart-2-3-optimized-for-building-user-interfaces-e84919ca1dff?source=rss----23738d481ce8---4","guid":"https://medium.com/p/e84919ca1dff","category":["programming-languages","ui","dart","flutter"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 08 May 2019 16:59:00 GMT","atom:updated":"2019-05-08T17:27:45.294Z","content:encoded":"<p>Today we’re announcing the stable release of the Dart 2.3 SDK, with new language features that improve your coding experience when developing user interfaces, new tooling support for developing Flutter UI, and two new websites: <a href=\"https://dart.dev\">dart.dev</a> &amp; <a href=\"https://pub.dev\">pub.dev</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/0*iKWVPoE5aSiCI-mW\" /></figure><h3>Dart’s momentum</h3><p>One of the developer research reports we look forward to every year is the <a href=\"https://insights.stackoverflow.com/survey/2019\">StackOverflow Developer Survey</a>, which provides a comprehensive dataset on developer trends and sentiment towards different technologies. This year’s edition demonstrated the growth in popularity and awareness of Dart, which entered the list of <a href=\"https://insights.stackoverflow.com/survey/2019#technology-_-most-loved-dreaded-and-wanted-languages\">Most Loved Languages</a> for the first time and ranked alongside other popular languages like JavaScript, C#, and Go and ahead of the likes of C++, F#, and R. At the same time, our good friends in the Flutter community were ranked third in the list of <a href=\"https://insights.stackoverflow.com/survey/2019#technology-_-most-loved-dreaded-and-wanted-other-frameworks-libraries-and-tools\">Most Loved Frameworks</a>. Last month’s Codementor survey on <em>which programming languages to learn and not to learn</em> had similar positive news:.</p><blockquote><em>“</em>Two examples of languages that really rose to the occasion for the title of Most Improved are Dart and Ruby<em>”. </em>Codementor, April 2019 [<a href=\"https://www.codementor.io/blog/worst-languages-2019-6mvbfg3w9x\">source</a>]</blockquote><p>We’d like to extend a big <em>thank you</em> to all developers in the Dart community. It really means a lot to us to see you adopt Dart, offer your feedback, and continue the journey with us as we attempt to build the best client-optimized language for fast apps that run on any platform.</p><h3>New language features for building user interfaces</h3><p>Speaking of client development, one of the longstanding joint projects between the Dart &amp; Flutter teams is creating great support for capturing user interface code using Dart, without needing a markup language. We think that using a single language for both behavior and layout has large benefits. These include reducing context switching, not having to learn two languages, and allowing all of the abstraction features of a general-purpose programming language when building your UI.</p><p>We’ve made several improvements over the last few releases, such as simplifying code for <a href=\"https://medium.com/dartlang/announcing-dart-2-80ba01f43b6#da82\">constructing widgets</a>, adding automatic <a href=\"https://medium.com/dartlang/announcing-dart-2-1-improved-performance-usability-9f55fca6f31a\">int-to-double conversion</a>, and adding <a href=\"https://medium.com/dartlang/announcing-dart-2-2-faster-native-code-support-for-set-literals-7e2ab19cc86d\">set literals</a>. In Dart 2.3 we take another big step forward, with three new features for expressing UI that is list-based, conditional, or repeated.</p><p>You can think of a UI as a tree of widget nodes. Some nodes contain lists of widgets — for example a list of scrollable elements. Often, these lists are built from other lists. For that, we have added a new <a href=\"https://dart.dev/guides/language/language-tour#spread-operator\"><em>spread operator</em></a> feature for <em>unpacking</em> the elements from one list into another. In the following example, buildMainElements() returns a list of widgets, which is then unpacked into the surrounding list using the spread operator …:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/c0e540695e17d207deb07d76bc39032e/href\">https://medium.com/media/c0e540695e17d207deb07d76bc39032e/href</a></iframe><p>Another common UI task is to include a specific element based on a condition. For example, you may want to include a <em>Next</em> button on all pages but the last one. With Dart 2.3, you can do this using a <a href=\"https://dart.dev/guides/language/language-tour#collection-operators\"><em>collection if</em></a>:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/d1208dddd17c81275e070c393ef0086f/href\">https://medium.com/media/d1208dddd17c81275e070c393ef0086f/href</a></iframe><p>Finally, UIs often build repeated elements from other repeated elements. You can express this using the new <a href=\"https://dart.dev/guides/language/language-tour#collection-operators\"><em>collection for</em></a> feature:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/c4ef27ef465faeee3e80829fa2fe7621/href\">https://medium.com/media/c4ef27ef465faeee3e80829fa2fe7621/href</a></iframe><p>And because the three new features are language features, and not markup commands, they are fully composable, and can be used in any context where you work on collections. The features are included in the <a href=\"https://medium.com/flutter-io/announcing-flutter-1-5-d203c6072e5c\">Flutter 1.5</a> release, and are available in the <a href=\"https://dart.dev/get-dart\">Dart 2.3</a> release, which you can download today. We’ve also added new lints that you can <a href=\"https://dart.dev/guides/language/analysis-options#enabling-linter-rules\">configure in static analysis</a> to enforce using the new <a href=\"http://dart-lang.github.io/linter/lints/prefer_spread_collections.html\">spread</a>, <a href=\"http://dart-lang.github.io/linter/lints/prefer_if_elements_to_conditional_expressions.html\">collection if</a>, and <a href=\"http://dart-lang.github.io/linter/lints/prefer_for_elements_to_map_fromIterable.html\">collection for</a> features.</p><p>For details on all the work that was done to add these features, check out <a href=\"https://medium.com/dartlang/making-dart-a-better-language-for-ui-f1ccaf9f546c\">this recent post</a> from Bob Nystrom (aka <a href=\"https://twitter.com/munificentbob\">munificentbob</a>), an engineer on the Dart language team.</p><p>We’d also like to extend our gratitude to the developers who participated in the UX studies that were critical in shaping these new language features.</p><h3>IDE &amp; editor features</h3><p>In keeping with Dart 2.3’s UI theme, we’ve also added a new UI Guides feature to our IDE support. UI Guides are horizontal and vertical lines drawn within UI code, making it much easier to see the tree structure of Flutter UI build() methods. Here’s an example (from a Calculator app) where the UI Guides clearly illustrate that the UI is built from an Expanded Column containing several KeyRows, each of which contains NumberKeys.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/438/1*CsGJu4iSvHzspALjfbQRfA.png\" /><figcaption>IDE with UI Guides visualizing the tree structure of UI code</figcaption></figure><p>UI Guides are available in <a href=\"https://plugins.jetbrains.com/plugin/9212-flutter\">version 35.2</a> of the IntelliJ IDEA and Android Studio plugin. To enable the feature, choose the setting <em>Preferences &gt; Languages &amp; Frameworks &gt; Flutter &gt; UI Guides</em>. We hope to offer similar support in VS Code in a later release.</p><p>Finally, we’ve observed that developers often use code completion in their IDE as a way of exploring APIs. Code completion has worked well for exploring the APIs in the libraries that you’ve already imported, but it hasn’t been available for APIs in libraries that aren’t yet imported. Our tools can now support the latter use case: you can invoke code completion on any prefix, and you’ll see completions for all APIs in the current package, the packages it directly depends on, and the SDK. If you choose a completion from a not-yet-imported library (marked <em>Auto import</em>, as the following animation shows), then the tool adds the import statement for you.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*fqBkEGgVtWMT1QRy\" /><figcaption>Animation showing code completion &amp; automatic import adding</figcaption></figure><p>This new auto-import feature is available in VS Code with the <a href=\"https://dartcode.org/releases/v2-26/\">v2.26 plugin</a>, in IntelliJ 2019.1, and the upcoming Android Studio 3.5 release.</p><h3>New Dart &amp; Pub websites</h3><p>Last, but certainly not least, we’ve been very busy the last few months building a new website for the Dart platform: <a href=\"https://dart.dev\">dart.dev</a></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/955/1*ydTSALWV77UbB3WHKsy9cg.png\" /><figcaption>Redesigned <a href=\"https://dart.dev\">https://dart.dev</a> homepage</figcaption></figure><p>This new site features an entirely new landing page, focused on explaining the core benefits of the Dart platform. We’ve also updated the documentation pages to have better navigation and more visual appeal. Lastly, we’ve done a huge reorganization of all content to make discovery easier, and added new pages for core content that was missing before.</p><p>In a similar vein, we’ve visually updated the Pub package site, and we’ve moved it to a convenient new URL: <a href=\"https://pub.dev\">pub.dev</a>.</p><p>We’d love to hear your feedback on both sites. If you find a problem or have a suggestion, please create an issue in the <a href=\"https://github.com/dart-lang/site-www/issues\">dart.dev issue tracker</a> or the <a href=\"https://github.com/dart-lang/pub-dartlang-dart/issues\">pub.dev issue tracker</a>. Thanks for your support!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e84919ca1dff\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-2-3-optimized-for-building-user-interfaces-e84919ca1dff\">Announcing Dart 2.3: Optimized for building user interfaces</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-04-15T07:47:10.000Z":{"title":"Announcing Windows support for Dart on Travis CI","link":"https://medium.com/dartlang/announcing-windows-support-for-dart-on-travis-ci-8160f53662f?source=rss----23738d481ce8---4","guid":"https://medium.com/p/8160f53662f","category":["continuous-integration","travis-ci","flutter","dart"],"dc:creator":"Michael Thomsen","pubDate":"Mon, 15 Apr 2019 07:47:10 GMT","atom:updated":"2019-04-15T07:47:10.437Z","content:encoded":"<p>Recently, <a href=\"https://travis-ci.com/\">Travis CI</a> — a continuous integration (CI) service for GitHub repos — <a href=\"https://blog.travis-ci.com/2018-10-11-windows-early-release\">announced</a> early release support for the Windows operating system. Today, we’re announcing that Travis CI on Windows supports the Dart SDK, so you can run Dart build and test jobs on all three major desktop operating systems: Linux, Mac, and Windows.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/1*Zh0PvesZNUKCljlerYe4Sg.png\" /></figure><h4>Configuring Travis CI jobs for multiple operating systems</h4><p>If you already use Travis CI to build or test your Dart code, you can easily run your jobs on all three operating systems. Just add (or extend) the os: section in your repo’s .travis.yml file:</p><pre>os:<br>- linux<br>- osx<br>- windows</pre><p>Then, whenever Travis CI runs, you’ll see entries for each test configuration running on each of the enabled operating systems. Here’s <a href=\"https://travis-ci.org/grpc/grpc-dart/builds/517691491\">an example</a> from the <a href=\"https://github.com/grpc/grpc-dart\">grpc-dart</a> repo, after we <a href=\"https://github.com/grpc/grpc-dart/commit/0cbc5401c82500bf20b89654c4adbde355dcc8d3\">added Windows</a> to the test matrix:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/495/0*wegLWjqUZkUfufxl\" /><figcaption>Travis CI test matrix run on Linux, MacOS, and Windows</figcaption></figure><p>Because Windows support on Travis CI is still in an early release stage, we recommend that you review the <a href=\"https://travis-ci.community/t/current-known-issues-please-read-this-before-posting-a-new-topic/264\">known issues</a> before adding Windows to your Travis jobs.</p><h4>Adding Travis CI test support to a project</h4><p>If you don’t yet use Travis CI for testing Dart, it’s really easy to get started. The most minimal .travis.yml file contains just one line:</p><pre>language: dart</pre><p>This config is the equivalent of pub run test.</p><p>List any additional tasks under the dart_task: tag. These include running static analysis and code formatting checks (for full details, see the <a href=\"https://docs.travis-ci.com/user/languages/dart/\">Travis documentation</a>).</p><p>Here’s how to run static analysis, which checks your code for analysis errors:</p><pre>language: dart<br>dart_task:<br>- dartanalyzer</pre><p>Here’s how to make sure that all Dart files are correctly formatted:</p><pre>language: dart<br>dart_task:<br>- dartfmt</pre><p>If you have a more complicated repo with multiple Dart packages, you need a slightly more detailed setup. The travis command in the <a href=\"https://pub.dartlang.org/packages/mono_repo\">mono_repo tool</a> is one possible solution for creating this setup.</p><h4>Alternatives to Travis CI</h4><p>Travis CI is one of several popular providers of continuous integration. Others with support for the Dart SDK include <a href=\"https://www.appveyor.com/\">AppVeyor</a> (<a href=\"https://github.com/dart-lang/dartdoc/blob/master/appveyor.yml\">sample</a>) and <a href=\"https://documentation.codeship.com/basic/languages-frameworks/dart/\">Codeship</a>. For <a href=\"https://flutter.dev/\">Flutter</a> apps, options include <a href=\"https://developer.nevercode.io/docs/building-flutter-apps\">NeverCode</a>, <a href=\"https://cirrus-ci.org/examples/#flutter\">CirrusCI</a>, and <a href=\"https://devcenter.bitrise.io/getting-started/getting-started-with-flutter-apps/\">Bitrise</a>.</p><p>That’s it for now. We hope you enjoy this new CI support for Dart.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8160f53662f\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/announcing-windows-support-for-dart-on-travis-ci-8160f53662f\">Announcing Windows support for Dart on Travis CI</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-07-25T16:08:10.000Z":{"title":"Dart asynchronous programming: Isolates and event loops","link":"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a?source=rss----23738d481ce8---4","guid":"https://medium.com/p/bffc3e296a6a","category":["event-loop","dart","flutter","dartlang","asynchronous-programming"],"dc:creator":"Kathy Walrath","pubDate":"Thu, 25 Jul 2019 16:08:10 GMT","atom:updated":"2019-07-25T16:16:34.255Z","content:encoded":"<p>Dart, despite being a single-threaded language, offers support for futures, streams, background work, and all the other things you need to write in a modern, asynchronous, and (in the case of Flutter) reactive way. This article covers the foundations of Dart’s support for background work: <em>isolates</em> and <em>event loops</em>.</p><p>If you prefer to learn by watching or listening, everything in this article is covered in the following video, which is part of the <em>Flutter in Focus</em> video series <em>Asynchronous Programming in Dart:</em></p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fvl_AaCgudcY%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dvl_AaCgudcY&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2Fvl_AaCgudcY%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e80af6e037b2f07d9cd64134c3a9383c/href\">https://medium.com/media/e80af6e037b2f07d9cd64134c3a9383c/href</a></iframe><p>Still here? Let’s talk about isolates.</p><h3>Isolates</h3><p>An <em>isolate</em> is what all Dart code runs in. It’s like a little space on the machine with its own, private chunk of memory and a single thread running an event loop.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/278/1*xtjhmzoLQEmh7Od1BkroVg.png\" /><figcaption>An isolate has its own memory and a single thread of execution that runs an event loop.</figcaption></figure><p>In a lot of other languages like C++, you can have multiple threads sharing the same memory and running whatever code you want. In Dart, though, each thread is in its own isolate with its own memory, and the thread just processes events (more on that in a minute).</p><p>Many Dart apps run all their code in a single isolate, but you can have more than one if you need it. If you have a computation to perform that’s so enormous it could cause you to drop frames if it were run in the main isolate, then you can use <a href=\"https://api.dartlang.org/stable/dart-isolate/Isolate/spawn.html\">Isolate.spawn()</a> or <a href=\"https://flutter.dev/docs/cookbook/networking/background-parsing#4-move-this-work-to-a-separate-isolate\">Flutter’s compute() function</a>. Both of those functions create a separate isolate to do the number crunching, leaving your main isolate free to — say— rebuild and render the widget tree.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/630/1*MnJQG2bdbcqmEwu1lSL52Q.png\" /><figcaption>Two isolates, each with its own memory and thread of execution.</figcaption></figure><p>The new isolate gets its own event loop and its own memory, which the original isolate — even though it’s the parent of this new one — isn’t allowed to access. That’s the source of the name <em>isolate</em>: these little spaces are kept <em>isolated</em> from one another.</p><p>In fact, the only way that isolates can work together is by passing messages back and forth. One isolate sends a message to the other, and the receiving isolate processes that message using its event loop.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/624/1*kxDfLtL2ySN1yiY1nmcTrA.png\" /><figcaption>Isolates can send messages to other isolates.</figcaption></figure><p>This lack of shared memory might sound kind of strict, especially if you’re coming from a language like Java or C++, but it has some key benefits for Dart coders.</p><p>For example, memory allocation and garbage collection in an isolate don’t require locking. There’s only one thread, so if it’s not busy, you know the memory isn’t being mutated. That works out well for Flutter apps, which sometimes need to build up and tear down a bunch of widgets quickly.</p><h3>Event loops</h3><p>Now that you’ve had a basic introduction to isolates, let’s dig in to what really makes asynchronous code possible: the <em>event loop</em>.</p><p>Imagine the life of an app stretched out on a timeline. The app starts, the app stops, and in between a bunch of events occur — I/O from the disk, finger taps from the user… all kinds of stuff.</p><p>Your app can’t predict when these events will happen or in what order, and it has to handle all of them with a single thread that never blocks. So, the app runs an event loop. It grabs the oldest event from its event queue, processes it, goes back for the next one, processes it, and so on, until the event queue is empty.</p><p>The whole time the app is running — you’re tapping on the screen, things are downloading, a timer goes off — that event loop is just going around and around, processing those events one at a time.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/624/1*t-mHg6JrdkKCs65UvD70-Q.png\" /><figcaption>The event loop processes one event at a time.</figcaption></figure><p>When there’s a break in the action, the thread just hangs out, waiting for the next event. It can trigger the garbage collector, get some coffee, whatever.</p><p>All of the high-level APIs and language features that Dart has for asynchronous programming — futures, streams, async and await — they’re all built on and around this simple loop.</p><p>For example, say you have a button that initiates a network request, like this one:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5f48733b8fa51f699640162252d2c611/href\">https://medium.com/media/5f48733b8fa51f699640162252d2c611/href</a></iframe><p>When you run your app, Flutter builds the button and puts it on screen. Then your app waits.</p><p>Your app’s event loop just sort of idles, waiting for the next event. Events that aren’t related to the button might come in and get handled, while the button sits there waiting for the user to tap on it. Eventually they do, and a tap event enters the queue.</p><p>That event gets picked up for processing. Flutter looks at it, and the rendering system says, “Those coordinates match the raised button,” so Flutter executes the onPressed function. That code initiates a network request (which returns a future) and registers a completion handler for the future by using the then() method.</p><p>That’s it. The loop is finished processing that tap event, and it’s discarded.</p><p>Now, onPressed is a property of <a href=\"https://api.flutter.dev/flutter/material/RaisedButton-class.html\">RaisedButton</a>, and the network event uses a callback for a <a href=\"https://api.dart.dev/stable/dart-async/Future-class.html\">future</a>, but both of those techniques are doing the same basic thing. They’re both a way to tell Flutter, “Hey, later on, you might see a particular type of event come in. When you do, please execute this piece of code.”</p><p>So, onPressed is waiting for a tap, and the future is waiting for network data, but from Dart’s perspective, those are both just events in the queue.</p><p>And that’s how asynchronous coding works in Dart. Futures, streams, async and await — these APIs are all just ways for you to tell Dart’s event loop, “Here’s some code, please run it later.”</p><p>If we look back at the code example, you can now see exactly how it’s broken up into blocks for particular events. There’s the initial build (1), the tap event (2), and the network response event (3).</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/4ae7636cc12b748fde92de79364c9219/href\">https://medium.com/media/4ae7636cc12b748fde92de79364c9219/href</a></iframe><p>After you get used to working with asynchronous code, you’ll start recognizing these patterns all over the place. Understanding the event loop is going to help as you move on to the higher level APIs.</p><h3>Summary</h3><p>We took a quick look at isolates, the event loop, and the foundation of asynchronous coding in Dart.</p><p>If you’d like to learn more, check out the next video in the <em>Asynchronous Programming in Dart </em>series. It talks about the <em>Future API</em>, which you can use to do asynchronous programming without a ton of code.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FOTS-ap9_aXc%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DOTS-ap9_aXc&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FOTS-ap9_aXc%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/8b6cf4ee42282247c713fd0c0da5298c/href\">https://medium.com/media/8b6cf4ee42282247c713fd0c0da5298c/href</a></iframe><p><em>Big thanks to Andrew Brogdon, who created the video that this article is based on.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bffc3e296a6a\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a\">Dart asynchronous programming: Isolates and event loops</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-02-27T13:01:02.000Z":{"title":"Students: Join a Dart project for Google Summer of Code 2020","link":"https://medium.com/dartlang/students-join-a-dart-project-for-google-summer-of-code-2020-655d39b557c2?source=rss----23738d481ce8---4","guid":"https://medium.com/p/655d39b557c2","category":["dartlang","open-source","google-summer-of-code","flutter"],"dc:creator":"Jonas Finnemann Jensen","pubDate":"Thu, 27 Feb 2020 13:01:02 GMT","atom:updated":"2020-02-27T13:01:02.605Z","content:encoded":"<figure><img alt=\"Google Summer of Code logo\" src=\"https://cdn-images-1.medium.com/max/367/1*s8NsJv2UhKO1omeN7hX9wQ.jpeg\" /></figure><p><a href=\"https://summerofcode.withgoogle.com/\">Google Summer of Code</a> (<em>GSoC</em>) is a global program focused on bringing student developers into open source software development. Students are sponsored by Google to work with a mentoring open source organization on a 3-month programming project during the summer. Over the past 15 years more than 15,000 students have participated in Google Summer of Code.</p><p>This year we’re thrilled to announce that <a href=\"https://summerofcode.withgoogle.com/organizations/6544944065413120/\">Dart is a mentoring organization</a> in Google Summer of Code 2020.</p><h3>Are you interested?</h3><p>Get started now by reading <a href=\"https://github.com/dart-lang/sdk/wiki/Dart-GSoC-2020-Project-Ideas\">the list of project ideas</a> to find a match for your skills and interests. Although formal applications <a href=\"https://summerofcode.withgoogle.com/how-it-works/\">open on March 16th</a>, you can discuss and adapt project ideas with prospective mentors today.</p><blockquote>The Dart team only expects to have enough mentors to accept a handful of applications. So be sure to also check out the <a href=\"https://summerofcode.withgoogle.com/organizations/\">other mentoring organizations</a> for Google Summer of Code 2020.</blockquote><p>If you have questions specific to Dart and GSoC, ask them on <a href=\"https://groups.google.com/forum/#!forum/dart-gsoc\">our dedicated mailing list</a>.</p><p>For more information about Google Summer of Code, watch the video below. Or read the <a href=\"https://google.github.io/gsocguides/student/\">student guide for Google Summer of Code</a>.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FS6IP_6HG2QE%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DS6IP_6HG2QE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FS6IP_6HG2QE%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href\">https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href</a></iframe><p>We look forward to hearing from you!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=655d39b557c2\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/students-join-a-dart-project-for-google-summer-of-code-2020-655d39b557c2\">Students: Join a Dart project for Google Summer of Code 2020</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-02-11T18:01:02.000Z":{"title":"Dart asynchronous programming: Streams","link":"https://medium.com/dartlang/dart-asynchronous-programming-streams-2569a993324d?source=rss----23738d481ce8---4","guid":"https://medium.com/p/2569a993324d","category":["dartlang","flutter","programming","asynchronous-programming","programming-languages"],"dc:creator":"Kathy Walrath","pubDate":"Tue, 11 Feb 2020 18:01:02 GMT","atom:updated":"2020-07-10T23:09:46.928Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/272/1*7v26fZu7zzY0QSBQAwj42Q.gif\" /><figcaption>A simple Flutter app that displays data from a stream</figcaption></figure><p>This article covers one of the fundamentals of reactive programming: streams, which are objects of type <a href=\"https://api.dart.dev/stable/dart-async/Stream-class.html\">Stream</a>.</p><p>If you’ve read the <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137\">previous article on futures</a>, you might remember that <strong>each future represents a single value</strong> (either an error or data) that it delivers <strong>asynchronously</strong>. Streams work similarly, but instead of a single thing, <strong>a stream can deliver zero or more values and errors </strong>over <strong>time.</strong></p><blockquote>This article is the third one based on the <em>Flutter in Focus</em> video series <em>Asynchronous Programming in Dart</em>. The first article, <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a\">Isolates and event loops</a>, covered the foundations of Dart’s support for background work. The second one, <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137\">Futures</a>, discussed the Future class.</blockquote><blockquote>If you prefer to learn by watching or listening, everything in this article is covered in the following video.</blockquote><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FnQBpOIHE4eE%3Ffeature%3Doembed&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DnQBpOIHE4eE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FnQBpOIHE4eE%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/19f7572c0ed7e65b2b45fc00703972c6/href\">https://medium.com/media/19f7572c0ed7e65b2b45fc00703972c6/href</a></iframe><p>If you think about the way a single value relates to an <a href=\"https://dart.dev/codelabs/iterables\">iterator</a> of the same type, that’s how a future relates to a stream.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/429/1*q9cqGB5uXOX3tNw07SoJnQ.png\" /></figure><p>Just like with futures, the key is deciding in advance, “Here’s what to do when a piece of data is ready, and when there’s an error, and when the stream completes.”</p><p><em>Also</em> just like with futures, the Dart event loop is still running the show.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/624/0*UVy8BLEUm4CifwDE.png\" /><figcaption>Streams work with the Dart event loop.</figcaption></figure><p>If you’re using the File class’s <a href=\"https://api.dart.dev/stable/dart-io/File/openRead.html\">openRead()</a> method to read data from a file, for example, that method returns a stream.</p><p>Chunks of data are read from disk and arrive at the event loop. A Dart library looks at them and says, “Ah, I’ve got somebody waiting for this,” adds the data to the stream, and it pops out in your app’s code.</p><p>When another piece of data arrives, in it goes, and out it comes. Timer-based streams, streaming data from a network socket — they work with the event loop, too, using clock and network events.</p><h3>Listening to streams</h3><p>Let’s talk about how to work with data provided by a stream. Say you have a class that gives you a stream that kicks out a new integer once per second: 1, 2, 3, 4, 5…</p><p>You can use the <a href=\"https://api.dart.dev/stable/dart-async/Stream/listen.html\">listen()</a> method to subscribe to the stream. The only required parameter is a function.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/c31dc00c60729231ff711a1f2c5a7c06/href\">https://medium.com/media/c31dc00c60729231ff711a1f2c5a7c06/href</a></iframe><p>Every time a new value is emitted by the stream, the function gets called and prints the value:</p><pre>Data: 1<br>Data: 2<br>Data: 3<br>Data: 4<br>...</pre><p>That’s how listen() works.</p><blockquote><strong>Important:</strong> By default, streams are set up for single subscription. They hold onto their values until someone subscribes, and they only allow a single listener for their entire lifespan. If you try to listen to a stream twice, you’ll get an exception.</blockquote><blockquote>Fortunately Dart also offers broadcast streams. You can use the <a href=\"https://api.dart.dev/stable/dart-async/Stream/asBroadcastStream.html\">asBroadcastStream()</a> method to make a broadcast stream from a single subscription one. Broadcast streams work the same as single subscription streams, but they can have multiple listeners, and if nobody’s listening when a piece of data is ready, that data is tossed out.</blockquote><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/be6e85178bdfcd755067c7a16de5b022/href\">https://medium.com/media/be6e85178bdfcd755067c7a16de5b022/href</a></iframe><p>Let’s go back to that first listen() call, because there are a couple more things to talk about.</p><p>As we mentioned earlier, streams can produce errors just like futures can. By adding an onError function to the listen() call, you can catch and process any error.</p><p>There’s also a cancelOnError property that’s true by default, but can be set to false to keep the subscription going even after an error.</p><p>And you can add an onDone function to execute some code when the stream is finished sending data, such as when a file has been completely read.</p><p>With all four of those parameters combined — onError, onDone, cancelOnError, and the required parameter (onData) — you can be ready in advance for whatever happens.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/dea319494190bd75b912520147b65906/href\">https://medium.com/media/dea319494190bd75b912520147b65906/href</a></iframe><blockquote><strong>Tip:</strong> The little subscription object that listen() returns has some useful methods of its own. It’s a <a href=\"https://api.dart.dev/stable/dart-async/StreamSubscription-class.html\"><em>StreamSubscription</em></a>, and you can use it to pause, resume, and even cancel the flow of data.</blockquote><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/520a9f66cf6b442e8cbcd16bc03dc7b1/href\">https://medium.com/media/520a9f66cf6b442e8cbcd16bc03dc7b1/href</a></iframe><h3>Using and manipulating streams</h3><p>Now that you know how to use listen() to subscribe to a stream and receive data events, we can talk about what makes streams really cool: manipulating them. Once you’ve got data in a stream, a lot of operations become fluent and elegant.</p><p>Going back to that number stream from earlier, we can use a method called <a href=\"https://api.dart.dev/stable/dart-async/Stream/map.html\">map()</a> to take each value from the stream and convert it on the fly into something else. Give map() a function to do the conversion, and it returns a new stream, typed to match the return value of the function. Instead of a stream of ints, you now have a stream of strings. You can throw a listen() call on the end, give it the print() function, and now you’re printing strings directly off the stream, asynchronously, as they arrive.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/6ac03783e253fb674f00ca75a2cdf722/href\">https://medium.com/media/6ac03783e253fb674f00ca75a2cdf722/href</a></iframe><p>There are a ton of methods that you can chain up like this. If you only want to print the even numbers, for example, you can use <a href=\"https://api.dart.dev/stable/dart-async/Stream/where.html\">where()</a> to filter the stream. Give it a test function that returns a boolean for each element, and it returns a new stream that only includes values that pass the test.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/8f291bde6b2e14f0acd17743cecf36b3/href\">https://medium.com/media/8f291bde6b2e14f0acd17743cecf36b3/href</a></iframe><p>The <a href=\"https://api.dart.dev/stable/dart-async/Stream/distinct.html\">distinct()</a> method is another good one. If you have an app that uses a Redux store, that store emits new app state objects in an onChange stream. You can use map() to convert that stream of state objects to a stream of view models for one part of the app. Then you can use the distinct() method to get a stream that filters out consecutive identical values (in case the store kicks out a change that doesn’t affect the subset of data in the view model). Then you can listen and update the UI whenever you get a new view model.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a41b8d1210d6b2168bbbb8d194aea8ba/href\">https://medium.com/media/a41b8d1210d6b2168bbbb8d194aea8ba/href</a></iframe><p>There are a bunch of additional methods built into Dart that you can use to shape and modify your streams. Plus, when you’re ready for even more advanced stuff, there’s the <a href=\"https://pub.dev/packages/async\">async package</a> maintained by the Dart team and available on <a href=\"https://pub.dev\">pub.dev</a>. It has classes that can merge two streams together, cache results, and perform other types of stream-based wizardry.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*WTHZRJjgF4qQvSDvY0Z9ow.png\" /><figcaption>Try the async package for more stream-based wizardry.</figcaption></figure><p>For even more stream magic, take a look at the <a href=\"https://pub.dev/packages/stream_transform\">stream_transform package</a>.</p><h3>Creating streams</h3><p>One advanced topic deserves a mention here, and that’s how to create streams of your own. Just like with futures, most of the time you’re going to be working with streams created for you by network libraries, file libraries, state management, and so on. But you can make your own as well, using a <a href=\"https://api.dart.dev/stable/dart-async/StreamController-class.html\">StreamController</a>.</p><p>Let’s go back to that NumberCreator we’ve been using so far. Here’s the actual code for it:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/7e4d50381bdf969e768232b9fa01a804/href\">https://medium.com/media/7e4d50381bdf969e768232b9fa01a804/href</a></iframe><p>As you can see, it keeps a running count, and it uses a timer to increment that count each second. The interesting bit, though, is the stream controller.</p><p>A StreamController creates a brand new stream from scratch, and gives you access to both ends of it. There’s the stream end itself, where data arrives. (We’ve been using that one throughout this article.)</p><pre>Stream&lt;int&gt; get stream =&gt; _controller.stream;</pre><p>Then there’s the sink end, which is where new data gets added to the stream:</p><pre>_controller.sink.add(_count);</pre><p>NumberCreator here uses both of them. When the timer goes off, it adds the latest count to the controller’s sink, and then it exposes the controller’s stream with a public property so other objects can subscribe to it.</p><h3>Building Flutter widgets using streams</h3><p>Now that we’ve covered creating, manipulating, and listening to streams, let’s talk about how to put them to work building widgets in Flutter.</p><p>If you saw the previous video on futures, you might remember <a href=\"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html\">FutureBuilder</a>. You give it a future and a builder method, and it builds widgets based on the state of the future.</p><p>For streams, there’s a similar widget called <a href=\"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html\">StreamBuilder</a>. Give it a stream and a builder method, and it will rebuild its children whenever a new value is emitted by the stream.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/6a05ff211a85991d373ff0849f0de937/href\">https://medium.com/media/6a05ff211a85991d373ff0849f0de937/href</a></iframe><p>The snapshot parameter is an <a href=\"https://api.flutter.dev/flutter/widgets/AsyncSnapshot-class.html\">AsyncSnapshot</a>, just like with FutureBuilder. You can check its connectionState property to see if the stream hasn’t yet sent any data or if it’s completely finished. You can use the hasError property to see if the latest value is an error. And, of course, you can handle data values.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/07b72fea9c66c729c75471dbbeeb3991/href\">https://medium.com/media/07b72fea9c66c729c75471dbbeeb3991/href</a></iframe><p>The main thing is just to make sure your builder knows how to handle all the possible states of the stream. Once you’ve got that, it can react to whatever the stream does.</p><h3>Summary</h3><p>This article talked about what streams represent, how you get values from a stream, ways to manipulate those values, and how StreamBuilder helps you use stream values in a Flutter app.</p><p>You can learn more about streams from the Dart and Flutter documentation:</p><ul><li>On <a href=\"https://dart.dev\">dart.dev</a>, see the <a href=\"https://dart.dev/tutorials/language/streams\">streams tutorial</a>, the <a href=\"https://dart.dev/tutorials/server/cmdline\">command-line app tutorial</a>, and the <a href=\"https://dart.dev/guides/libraries/library-tour#stream\">stream section</a> of the library tour.</li><li>On <a href=\"https://flutter.dev\">flutter.dev</a>, see <a href=\"https://flutter.dev/docs/cookbook/networking/web-sockets\">Work with WebSockets</a>, which features an example that uses StreamBuilder.</li></ul><p>Or go on to the next video in the <em>Asynchronous Programming in Dart </em>series. It talks about async and await, which are two keywords that Dart offers to help you keep your asynchronous code tight and easy to read.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FSmTCmDMi4BY%3Ffeature%3Doembed&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DSmTCmDMi4BY&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FSmTCmDMi4BY%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/924c442a7c91b7366476ddd092178bfe/href\">https://medium.com/media/924c442a7c91b7366476ddd092178bfe/href</a></iframe><p><em>Big thanks to Andrew Brogdon, who created the video that this article is based on.</em></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/740/1*Q2-Ac9rjIDSuXzbrQqGkVA.png\" /></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2569a993324d\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart-asynchronous-programming-streams-2569a993324d\">Dart asynchronous programming: Streams</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-12-19T18:38:21.000Z":{"title":"Dart declaration-site variance","link":"https://medium.com/dartlang/dart-declaration-site-variance-5c0e9c5f18a5?source=rss----23738d481ce8---4","guid":"https://medium.com/p/5c0e9c5f18a5","category":["variance","dartlang","programming-languages","programming"],"dc:creator":"Kallen Tu","pubDate":"Thu, 19 Dec 2019 18:38:21 GMT","atom:updated":"2019-12-19T18:52:29.665Z","content:encoded":"<figure><img alt=\"A code snippet showing the contravariant variance modifier (`in`) in use.\" src=\"https://cdn-images-1.medium.com/max/1024/0*XcEdm2vmIBW8Wovr\" /></figure><p>Declaration-site variance was my internship project on the Dart team, and I’ve documented my personal experience on the team in the article <a href=\"https://medium.com/dartlang/life-as-a-dart-intern-a62cb8db2414\">Life as a Dart intern</a>. As the primary implementer of the <a href=\"https://github.com/dart-lang/language/issues/524\">declaration-site variance feature</a>, I want to share the usages and benefits of sound variance.</p><p>We’ll discuss how to use variance, why we want to use the modifiers, how the feature can build on top of classes that don’t use the modifiers, and what benefits this feature provides us.</p><p><strong><em>Note:</em></strong><em> The implementation of variance isn’t finished yet. Although you can play with it by enabling the experiment (instructions below), the feature might change before it’s finalized.</em></p><p>Before diving into Dart’s declaration-site variance feature, we’ll take a quick detour to discuss what variance means and how it’s used.</p><h3><strong>What is variance?</strong></h3><p>To briefly introduce variance, we can look at this example:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a213f1dad314a16c2281caea8a838c78/href\">https://medium.com/media/a213f1dad314a16c2281caea8a838c78/href</a></iframe><p>From this, an Iterable of integers can be substituted as an Iterable of Objects because an integer <em>is</em> an Object and can be used in an Iterable in every place an Object would be. The language allows this by saying that two instantiations of the same generic type (like Iterable&lt;int&gt; and Iterable&lt;Object&gt; here) are considered subtypes if their type arguments (int and Object) are. This subtyping relation is considered <strong>covariance</strong>.</p><p>This is convenient and logical. It makes sense, that is, until you take a look at the variance of the parameters of a method. Say you want to make a objectWriter in Dart:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a2f87f5c17d57f66734c6f8b9551d9bf/href\">https://medium.com/media/a2f87f5c17d57f66734c6f8b9551d9bf/href</a></iframe><p>Then you eagerly have your objectWriter write a String to discover that it produces a runtime error. The compiler allows this code, but when you run it, it throws an exception.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2c8b077a9cae4da62da97f64a63d1488/href\">https://medium.com/media/2c8b077a9cae4da62da97f64a63d1488/href</a></iframe><p>Why is this? With <strong>contravariance,</strong> the subtyping relation is reversed compared to covariance. We need to be able to <em>write</em> any Object to the objectWriter, but from earlier we know that the objectWriter is actually a disguised writer of integers.</p><p>The final variant type you will need to know about is <strong>invariance</strong>. Invariant subtyping relation means no subtype relation between two invariant types unless they are the <em>exact same</em> type.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a21b886c8f60c9bb654907b193155236/href\">https://medium.com/media/a21b886c8f60c9bb654907b193155236/href</a></iframe><h3><strong>What is the variance feature in Dart?</strong></h3><p>Since the Dart team proposed to add explicit variance modifiers to the language, we’ll preview some of the changes to expect.</p><p>Dart will have variance modifiers that can be applied to type parameters in classes and mixins. The syntax is similar to variance modifiers in C#.</p><p>You can use the keywords out, in<em>, </em>and inoutto declare a covariant, contravariant, and invariant type parameter respectively. This is used with generic types as such:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/fc85a7af3115c32a364a8cd873a3004a/href\">https://medium.com/media/fc85a7af3115c32a364a8cd873a3004a/href</a></iframe><h3><strong>Why define explicit variance for generic types? Why do we want this feature?</strong></h3><p>Dart’s static type system currently treats all type parameters as covariant. That’s correct and convenient for generics where the type is used in a safely covariant place like a return type. But it’s wrong when the type argument should be contravariant or invariant:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a7117be976004d877c11a6d461c888d9/href\">https://medium.com/media/a7117be976004d877c11a6d461c888d9/href</a></iframe><p>When you use objectWriter, you <em>expect</em> to be able to write any Object. Unfortunately, the objectWriter only writes integers. The compiler doesn’t know any better and when you run the code, you receive the dreaded runtime error. To avoid unsoundness, Dart throws an error at runtime if you use a type argument in an unsafe way.</p><p>Fortunately, adding a variance modifier turns this incorrect use from a runtime error into a compile-time error.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/f010e9130f24f791c6e00738811bb3a6/href\">https://medium.com/media/f010e9130f24f791c6e00738811bb3a6/href</a></iframe><p>This is much better. Long before you write objectWriter.write(&quot;I&#39;m a string!&quot;), the compiler will notify you that there’s something wrong.</p><p>Now, let’s take a look at what adding safely typed parameters using a variance modifier provides you.</p><h3><strong>Type parameters in members</strong></h3><p>If you mark a generic type parameter with out, the compiler emits a static error if you use that type in a method or field in a place that isn’t safely covariant like a return type. Likewise, a type parameter marked in can only be used in a place that is safely contravariant like a method parameter type. Type parameters marked inout can be used anywhere.</p><p>Here are some method variance position errors and correct usages that you may find helpful. The same error checking also occurs for mixins.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3b0c16a20c5dfea8c2ec4f685653836e/href\">https://medium.com/media/3b0c16a20c5dfea8c2ec4f685653836e/href</a></iframe><p>Errors can be emitted in fields as well.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/8a012b2476894c85e83bbd9ce4caf9da/href\">https://medium.com/media/8a012b2476894c85e83bbd9ce4caf9da/href</a></iframe><h3><strong>Assignment and subtyping</strong></h3><p>The errors the compiler reports for misusing type parameters help the generic class author <strong>write</strong> correct code. The other half is the set of errors that help others <strong>use</strong> the class correctly. One of the changes that come with sound variance modifiers is the subtyping change that we can see through assignment.</p><p>If a generic type parameter is covariant, then you can assign it when its type argument is a subtype of the expected type’s type argument. For example, you can assign a Reader&lt;int&gt; to something that expects a Reader&lt;Object&gt;.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/46b7153790b49463f0d9fb5a94c6bc64/href\">https://medium.com/media/46b7153790b49463f0d9fb5a94c6bc64/href</a></iframe><p>Likewise, if a generic type parameter is contravariant, assignment is allowed when its type argument is a supertype of the expected type’s type argument. You can assign a Writer&lt;Object&gt; to something that expects a Writer&lt;int&gt;, as such:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/f27a4a017c0d9beb775629fb7802ecdf/href\">https://medium.com/media/f27a4a017c0d9beb775629fb7802ecdf/href</a></iframe><p>For invariant parameters, the type argument must be the same type.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/822bb2def25627eef48876f0eef2e994/href\">https://medium.com/media/822bb2def25627eef48876f0eef2e994/href</a></iframe><h3><strong>Interface inheritance</strong></h3><p>So you might be asking, “<em>Can we opt into stronger compile time checking with variance even when extending older classes?”</em> The good news is that you can; however, there are a few restrictions.</p><p>out parameters can only extend parameter positions that are covariant or have default Dart type variance.</p><p>Keep in mind that any methods inherited from legacy classes could still be unsoundly variant, and hence may still cause runtime errors. Otherwise, all new methods in a subclass with type parameters that have variance modifiers will emit errors if the types are in unsound positions.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/515314c65eb313216514d8a608afa66e/href\">https://medium.com/media/515314c65eb313216514d8a608afa66e/href</a></iframe><p>in parameters can only extend parameter positions that are contravariant.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/046193ad3a8e00c6afdc58b5bfb446ce/href\">https://medium.com/media/046193ad3a8e00c6afdc58b5bfb446ce/href</a></iframe><p>inout parameters can extend all parameter positions. However, a parameter that is defined as inout can only be inherited by other invariant positions.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/54d4a38240d2af697e3852c377e71d72/href\">https://medium.com/media/54d4a38240d2af697e3852c377e71d72/href</a></iframe><h3>How can I give feedback on the variance feature?</h3><p>We recommend trying the variance feature using the <a href=\"https://dart.dev/get-dart#about-release-channels-and-version-strings\">latest dev channel</a>. Play around with this example to get a grasp on how variance works and what it can do for you.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/204f165a23c7c2f1961add7f27199cc0/href\">https://medium.com/media/204f165a23c7c2f1961add7f27199cc0/href</a></iframe><p>Because the variance feature is still being implemented, you need to set an experimental flag to enable it:</p><pre>dart --enable-experiment=variance variance_example.dart</pre><p>We appreciate any and all feedback! You can let us know what you think in <a href=\"https://github.com/dart-lang/language/issues/524\">this GitHub issue</a>.</p><h3><strong>Summary</strong></h3><p>Existing Dart generics are covariant by default, which makes it easy to start writing new classes and to get started. This means, however, that more errors appear at runtime rather than at compile time. The user is also paying for the cost of additional runtime checks. The main idea behind variance is to provide users with more informative error checking at compile time.</p><p>Variance is defined only for the parameters of generic classes and mixins. Users can use the variance feature by adding one of the in, out or inout keywords before a type parameter.</p><p>Additionally, new generic interfaces with these modifiers can extend legacy interfaces with no variance modifiers.</p><p>Declaration-site variance allows you to reap a bunch of new benefits, including:</p><ul><li>Compile-time variant position checking within members of the interface</li><li>Removal of pesky runtime errors that occur with down and up casting</li><li>Additional subtyping changes based on the variance declared</li><li>More informative and accessible error checking</li></ul><p>Now you won’t have to worry if that objectWriter is <em>truly</em> a writer of any object. You <em>know</em> it is.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5c0e9c5f18a5\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart-declaration-site-variance-5c0e9c5f18a5\">Dart declaration-site variance</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-12-19T18:38:08.000Z":{"title":"Life as a Dart intern","link":"https://medium.com/dartlang/life-as-a-dart-intern-a62cb8db2414?source=rss----23738d481ce8---4","guid":"https://medium.com/p/a62cb8db2414","category":["programming","intern","dart"],"dc:creator":"Kallen Tu","pubDate":"Thu, 19 Dec 2019 18:38:08 GMT","atom:updated":"2019-12-19T18:38:08.247Z","content:encoded":"<p><em>I don’t know.</em></p><p>Those three words run through the minds of software engineers every day. Engineering work consists of puzzles and problems, so not knowing something is just another indicator that an engineer has the capacity to grow. Yet, the lack of knowledge can also generate self-doubt.</p><p>Before I started my internship this fall, I didn’t know much about programming languages, type systems, or even variance (which was my entire project). As far as I knew, variance was just a value I needed to calculate the square root of, so I could obtain a standard deviation. Programming languages and compilers seemed like some black magic sorcery that mystified most developers.</p><p>Thankfully my manager, being the mind reader that he was, understood how I felt and remedied my nervousness.</p><p><em>“So, I’m going to be completely honest, this project will throw you completely into the deep end. You don’t know anything yet, but that’s okay because I want you to ask questions, lots of them,”</em> he explained.</p><p>It was scary going head-first into a new project where I had little-to-no background knowledge of the work, but I knew I had support from my manager. He gave me the freedom to <em>try</em>, the freedom to <em>make mistakes</em>. It meant a lot to me.</p><p>That quick chat with my manager jump-started the first month of my time here: I met my team in Fremont Seattle and was ready to throw myself into this deep unknown called <em>variance,</em> which you can read about in the article <a href=\"https://medium.com/dartlang/dart-declaration-site-variance-5c0e9c5f18a5\">Dart declaration-site variance</a>.</p><p>I had weekly variance boot camps with my manager, providing me with the theory that I had to translate into code. I remember reading the proposal of the <a href=\"https://github.com/dart-lang/language/issues/524\">variance feature</a> that I would be implementing and feeling overwhelmed at the seven milestones required to complete the project: (1) scan then parse the new keywords, (2) modify the kernel AST, (3) support variance in the subtyping algorithm, (4) add errors and warnings, (5) change the upper and lower bound calculation, (6) alter the type inference rules, and (7) work on the runtime behaviour changes.</p><p>Between changing the kernel (the compiler’s intermediate representation) and the subtyping logic, I needed to serialize and deserialize variance annotations. Runtime behaviour was considered a stretch goal, but I could barely understand the six tasks before it. I wasn’t sure where or how to begin.</p><p>But it got better.</p><p>I started each workday at 9 am. Scrambled eggs, sausages, kale, and orange juice were all I needed. I was ready to squint at code, wondering how in the world people made the first compiler.</p><p>I often worked on different components in parallel with one another. It kept me busy and I enjoyed organizing goals. Every morning I would create a new document that would list out what I wanted to accomplish, breaking down the goals into manageable tasks.</p><figure><img alt=\"A to-do list with most items crossed out (done!).\" src=\"https://cdn-images-1.medium.com/max/992/0*6Ct-NyRGmYp_bmgp\" /><figcaption>A typical to-do list</figcaption></figure><p>At night, the Google office in Aarhus, Denmark, was active. Knowing that I had to work with a couple of engineers from Denmark, I often wrote up my questions, finalized them and sent them off late at night in Seattle. Code review times shifted forward 9 hours, but fortunately the time offset also let me proofread my own work more often before it was critiqued.</p><p>The critique from the team improved my ability to judge my own code and to contemplate the trade offs for different implementations. My reviewers pointed out areas I overlooked and asked questions about what variance is and how to use it. I’d fix my code, answer their questions, and make sure to watch out for the same issues in the future. More importantly, I’d dig deeper and ask myself, <em>How did they think of this improvement? What piece of knowledge can I take away from this, more than the corrected version of the code?</em> It was important to me that I learned from each comment, rather than mindlessly clicking the convenient <strong>Done</strong> button.</p><p>How I learned was through asking questions. There’s always a fragile balance between being a stubborn software engineer by gritting your teeth and grinding through code that doesn’t make any sense, and reluctantly poking the expert in that code base to help you. The latter almost always saved more time. I preferred allocating a decent amount of time to working independently, taking notes and writing questions as I came across new areas, then prodding another engineer when I had 2 or 3 questions and a solid roadblock. I realized I was much more productive inquiring about problems that would have required 3 hours of troubleshooting alone, compared to 10 minutes of direction and explanation from someone else.</p><p>Safety in a workplace also increases productivity.</p><p>Safety, for me, came in the form of asking questions, making jokes, and having lunch with the team. As soon as the clock flickered to 11:30, I knew that the next half hour would be filled with warm food and bright faces. Every day I would listen to the most elaborate stories and thoughts: the advantages of having 6 fingers, getting a cooked lobster as a Christmas gift, the hours of cleanup after mixing two different pipes in Factorio… anything and everything. My team supported me through my mistakes and my accomplishments. A good team makes it a lot easier to get out of bed in the morning to go to work.</p><p>The hours before and after lunch were also just as enjoyable. I spent most of the time reading code and understanding new concepts. The Dart compiler is comprised of many large, constantly changing components, which meant I needed to dive into a few different code bases. I loved having the opportunity to reach out to the front-end teams in charge of the static analysis, as well as the back-end teams who managed runtime behaviours. It was amazing to see how the components work together to create a new feature in the Dart language.</p><p>The rift between implementation and theory was the most challenging aspect of my project. It’s not every day that one would need to solidify a proof into tangible code. While working on variance, this rift surfaced when I had questions — sometimes my inquiries weaved the components of the language proposal with an appropriate implementation. The people I sought for answers either knew which file contained the subtyping algorithm, or knew how the subtyping changes affected assignment operations, but never both. It felt like building a treehouse with a couple pieces of plywood and an artist’s rendition of the end result.</p><p>Still, working on Dart was immensely rewarding and fun. I loved the challenge, especially knowing that there was so much to learn about areas beyond variance. Dart was, and still is, growing and evolving to better support the developers that use the language. I watched the team move like well-tuned clockwork when crucial issues surfaced and required immediate attention. I listened in as the team looked back on previous mistakes, ensuring that future processes don’t repeat them.</p><p>My internship on the Dart team improved my engineering skills, my communication skills, and my confidence in my own abilities. It taught me the importance of having a friendly, but also very functional team. It taught me the many ways that theory can translate into code, and the problem-solving techniques necessary to do so. It taught me more about myself and what I value in the work I do.</p><p>Thanks Dart. Until next time.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a62cb8db2414\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/life-as-a-dart-intern-a62cb8db2414\">Life as a Dart intern</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-12-11T15:05:15.000Z":{"title":"Announcing Dart 2.7: A safer, more expressive Dart","link":"https://medium.com/dartlang/dart-2-7-a3710ec54e97?source=rss----23738d481ce8---4","guid":"https://medium.com/p/a3710ec54e97","category":["programming","mobile","announcements","dartlang"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 11 Dec 2019 15:05:15 GMT","atom:updated":"2019-12-12T12:06:53.544Z","content:encoded":"<p>Today we’re announcing the stable release of the Dart 2.7 SDK, with additional new capabilities for developers. It’s been a busy year for Dart, our client-optimized language for fast apps on any platform. We’ve shipped six new releases with dozens of new features. It’s been very rewarding to see the Dart community use these features, and we were delighted by the recent <a href=\"https://octoverse.github.com/\">GitHub Octoverse</a> report listing Dart as the <a href=\"https://octoverse.github.com/#top-languages\">#1 fastest growing language</a>, ranked by number of contributors.</p><p>Dart 2.7 adds support for extension methods, plus a new package for handling strings with special characters. We have an update on null safety (type-safe nullable and non-nullable types) and a brand new null safety playground experience in DartPad. At the ecosystem level, pub.dev has a new <em>Like</em> feature for giving feedback to packages that you appreciate. Dart 2.7 is available today as an SDK download from <a href=\"http://dart.dev\">dart.dev</a>, and it’s also built into today’s <a href=\"https://medium.com/@csells_18027/flutter-1-12-release-blog-22c256ba525d\">Flutter 1.12 release</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/0*G-I1kyYJFCTCiAUk\" /></figure><h3>Extension methods</h3><p>Dart 2.7 adds a long-requested, powerful new language feature: <strong>extension methods</strong>. These enable you to add new functionality to any type — even types you don’t control — and have the brevity and auto-complete experience of regular method calls.</p><p>Let’s look at a small example: adding support for parsing ints and doubles from Strings. As app developers we can’t change the String class, because that’s defined in the dart:core library, but with extension methods we can extend it! Once we define this extension, we can call our new parseInt method on a String as if the method was defined on the String class itself:</p><pre>extension ParseNumbers on String {<br>  int parseInt() {<br>    return int.parse(this);<br>  }</pre><pre>  double parseDouble() {<br>    return double.parse(this);<br>  }<br>}</pre><pre>main() {<br>  int i = &#39;42&#39;.parseInt();<br>  print(i);<br>}</pre><h3>Extension methods are static</h3><p>Extension methods are resolved and dispatched statically, which means you can’t call them on values whose type is dynamic. Here the call throws an exception at runtime:</p><pre>dynamic d = &#39;2&#39;;</pre><pre>d.parseInt();</pre><pre>→ Runtime exception: NoSuchMethodError</pre><p>Extension methods work well with Dart’s <a href=\"https://dart.dev/guides/language/sound-dart#type-inference\">type inference</a>, so in the following variable v is inferred to have type String, and the extension on String is available:</p><pre>var v = &#39;1&#39;;<br>v.parseInt(); // Works!</pre><p>Because extension methods are resolved statically, they’re as fast as calling a static function or helper method, but with a much friendlier invocation syntax.</p><h3>Extensions can have type variables</h3><p>Imagine we want to define an extension on List for getting the elements at even indices. We’d like this extension to work on lists of any type, returning a new list of the same type as the input list. We can do this by making the extension generic and applying its type parameter to both the type it extends and the extension method:</p><pre>extension FancyList&lt;T&gt; on List&lt;T&gt; {<br>  List&lt;T&gt; get evenElements {<br>    return &lt;T&gt;[for (int i = 0; i &lt; this.length; i += 2) this[i]];<br>  }<br>}</pre><h3>Extension methods are really extension members</h3><p>We call the feature <em>extension methods</em> because that’s familiar terminology if you’ve used the corresponding language feature in other programming languages. But in Dart the feature is more general: it also supports extending classes with new getters, setters, and operators. In the FancyList example above, evenElements is a getter. Here’s an example of adding an operator for shifting strings:</p><pre>extension ShiftString on String {<br>  String operator &lt;&lt;(int shift) {<br>    return this.substring(shift, this.length) + this.substring(0, shift);<br>  }<br>}</pre><h3>Great examples from the community</h3><p>We’ve already seen many developers in the Dart community experiment with extension methods. Here are some of the cool uses we’ve seen so far.</p><p>Jeremiah Ogbomo created the <a href=\"https://pub.dev/packages/time\">time package</a>, which uses extensions on num (the base class for ints and doubles) to enable easy construction of Duration objects:</p><pre>// Create a Duration via a `minutes` extension on num.<br>Duration tenMinutes = 10.minutes;</pre><pre>// Create a Duration via an `hours` extension on num.<br>Duration oneHourThirtyMinutes = 1.5.hours;</pre><pre>// Create a DateTime using a `+` operator extension on DateTime.<br>final DateTime afterTenMinutes = DateTime.now() + 10.minutes;</pre><p>Marcelo Glasberg created an <a href=\"https://www.reddit.com/r/FlutterDev/comments/dm288s/dart_extensions_applied_to_i18n_you_have/\">i18n (internationalization) package</a> that uses extension methods to simplify string localization:</p><pre>Text(&#39;Hello&#39;.i18n) // Displays Hello in English, Hola in Spanish, etc.</pre><p>Simon Leier created the <a href=\"https://pub.dev/packages/dartx\">dartx package</a>, which contains extensions for a bunch of core Dart types. Some examples:</p><pre>var allButFirstAndLast = list.slice(1, -2);    // [1, 2, 3, 4]<br>var notBlank = &#39; .&#39;.isBlank;                   // false<br>var file = File(&#39;some/path/testFile.dart&#39;);<br>print(file.name);                              // testFile.dart<br>print(file.nameWithoutExtension);              // testFile</pre><p>Brian Egan is <a href=\"https://github.com/ReactiveX/rxdart/pull/368\">updating</a> the popular <a href=\"https://pub.dev/packages/rxdart\">RxDart package</a> with extension methods to redefine the API for working with streams.</p><h3>Safe substring handling</h3><p>Dart’s standard String class uses the <a href=\"https://en.wikipedia.org/wiki/UTF-16\">UTF-16</a> encoding. This is a common choice in programming languages, especially those that offer support for running both natively on devices, and on the web.</p><p>UTF-16 strings usually work well, and the encoding is transparent to the developer. However, when manipulating strings, and especially when manipulating strings entered by users, you may experience a difference between what the user perceives as a character, and what is encoded as a code unit in UTF-16. Let’s look at a small example, extracting the first three characters of a string entered by a user:</p><pre>var input = [&#39;Resume&#39;];<br>input.forEach((s) =&gt; print(s.substring(0, 3)));</pre><pre>$ dart main.dart<br>Res</pre><p>No problems so far; we printed the first three characters of the string in our input list, and the result is Res. Now let’s consider users from varying regions, who might enter strings that contain accents, Hangul (Korean script), and even a combination of emoji to represent the concept ‘resume’:</p><pre>// New longer input list:<br>var input = [&#39;Resume&#39;, &#39;Résumé&#39;, &#39;이력서&#39;, &#39;💼📃&#39;, &#39;Currículo&#39;];</pre><pre>$ dart main.dart<br>Res<br>Ré<br>이력서<br>💼�<br>Cur</pre><p>Hmm, some of those worked, but what happened to the elements Résumé and 💼📃? For Résumé, why did we get a “two character” string? For 💼📃, what’s up with the odd question mark? The problems here lie in the <a href=\"https://eev.ee/blog/2015/09/12/dark-corners-of-unicode/\">dark corners of Unicode</a>. The accented é in Résumé is actually two code points: an <em>e</em> and a <a href=\"https://unicode.org/cldr/utility/character.jsp?a=0301\"><em>combining acute accent</em></a>. And 📃, the <a href=\"https://emojipedia.org/emoji/%F0%9F%93%83/\">page with curl</a> emoji, is a single code point that happens to be encoded with a surrogate pair of U+d83d U+dcc3. Confused?</p><p>As we said, often you don’t need to worry about characters and code points. If all you do is receive, pass around, and hand over whole strings, the internal encoding is transparent. But if you need to iterate over the characters of a string or to manipulate the contents of a string, you can get into trouble. The good news is that Dart 2.7 <strong>introduces a new package, </strong><a href=\"https://pub.dev/packages/characters\"><strong>characters</strong></a>, for handling these cases. This package supports strings viewed as sequences of user-perceived characters, also known as Unicode <a href=\"https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\">grapheme clusters</a>. With the characters package we can fix our code with a small change to the code that shortens the text:</p><pre>// Before:<br>input.forEach((s) =&gt; print(s.substring(0, 3)));</pre><pre>// After, using the characters package:<br>input.forEach((s) =&gt; print(s.characters.take(3)));</pre><p>First we create a new Characters instance from the string in s (using the convenient .characters extension method). Then we use the nifty take() method to extract the initial 3 characters.</p><p>A technical preview of this new package is <a href=\"https://pub.dev/packages/characters\">available on pub.dev</a>. We’d love to hear your thoughts about this package. If you find any issues, <a href=\"https://github.com/dart-lang/characters/issues\">please report them</a>.</p><h3>Null safety preview</h3><p>A few months ago we <a href=\"https://medium.com/dartlang/announcing-dart-2-5-super-charged-development-328822024970#0391\">announced our intent</a> to support <strong>null safety</strong> in Dart, adding support for accessing object references safely without triggering null reference exceptions. Today we’re giving you a way to preview null safety static analysis. Let’s look at a small motivating example:</p><pre>void main() {<br>  Person(&#39;Larry&#39;, birthday: DateTime(1973, 03, 26)).describe();<br>  Person(&#39;Sergey&#39;).describe();<br>}</pre><pre>class Person {<br>  String firstName;<br>  DateTime birthday;<br>  Person(this.firstName, {this.birthday});</pre><pre>  void describe() {<br>    print(firstName);<br>    int birthyear = birthday?.year;<br>    print(&#39;Born ${DateTime.now().year - birthyear} years ago&#39;);<br>  }<br>}</pre><p>If we run this code it crashes with a null pointer exception while describing the second person, because that person doesn’t have a birthday set. We made a coding mistake: while we did anticipate some persons having unknown birthdays by making the birthday field optional in the constructor and by testing for a null birthday in birthday?.year, we forgot to handle the case where birthyear is null.</p><p>Let’s try to paste this code into our new <a href=\"https://nullsafety.dartpad.dev\">null safety playground</a>, a special build of DartPad that contains a technical preview of the static analysis part of the null safety feature. Without even running the code, we can see three issues:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*YFTJUSwsYzsHTY4b\" /><figcaption>DartPad with null safety showing three analysis errors related to nulls</figcaption></figure><p>By fixing these analysis errors, we can begin to take advantage of null safety. Try making the following edits in the null safety playground (eventually getting to <a href=\"https://gist.github.com/mit-mit/c210bfb088545e69ba9231ee459615ba\">this safe code</a>):</p><ol><li>To declare that birthday might be null, change<br><em>DateTime birthday</em> to <em>DateTime? birthday</em></li><li>To declare that birthyear might be null when birthday is null, change <br><em>int birthyear</em> to <em>int? birthyear</em></li><li>Wrap the last print call in a null test:<br><em>if (birthyear != null)</em> {…}</li></ol><p>We hope this example gives you a good indication of the experience we want with null safety. As mentioned, this playground is just an early technical preview of part of null safety, as it’s being built. We’re working hard on completing a first beta release of null safety in the Dart SDK. Here’s what we’re working on for beta:</p><ol><li>Completing the full implementation of nullable and non-nullable references</li><li>Integrating null safety into Dart’s type inference and smart promotion (for example, allowing safe access to a nullable variable after an assignment or null-check)</li><li>Porting the Dart <a href=\"https://dart.dev/guides/libraries\">core libraries</a> to declare which types are nullable and which are non-nullable</li><li>Adding a migration tool, which can automate the majority of the upgrade tasks for porting Dart apps and packages</li></ol><p>Once this work is complete, we’ll make it available in a beta SDK, and you can begin to take advantage of the feature in your apps and packages. We also plan to keep the null safety playground updated with new features as they’re implemented.</p><p>While we’re sure many developers will want to use null safety as soon as it’s available, you can migrate whenever it’s convenient, opting into the feature when you’re ready. Libraries and packages that haven’t yet opted into the feature will be able to depend on libraries that <em>have opted in</em>, and vice versa.</p><p>We’ll have more to say about null safety in the coming months, including more detailed advice on how to prepare for the transition.</p><h3>Liking 👍 packages on pub.dev</h3><p>Also launching on pub.dev today is a new <strong><em>Like</em> feature</strong> for packages. This introduces a new “human signal” for indicating which packages you’re fond of. To like a package, simply click the thumbs-up icon that’s next to the package detail information:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/667/0*xCGEGkntNxnM1XAh\" /><figcaption><em>pub.dev package detail page with new Like-feature voting button</em></figcaption></figure><p>Currently we don’t factor the number of likes into our overall scoring model, but we plan on doing so in a later release. We also plan on giving our general search UI and list pages a visual overhaul that will highlight the like-ability of a package.</p><h3>Thank you</h3><p>On behalf of the Dart team, we’d like to thank you — and everyone in the Dart community — for your continued support! Please continue to offer us feedback, and participate in Dart <a href=\"https://dart.dev/community\">discussions and communities</a>. We wouldn’t be a well-functioning open source project without the support we get from the Dart community.</p><p>2019 has been an incredibly exciting year for Dart, but we’re not stopping here. We have bold plans for 2020, including shipping stable versions of features like <a href=\"https://dart.dev/guides/libraries/c-interop\">dart:ffi</a> and <a href=\"https://github.com/dart-lang/language/issues/110\">null safety</a> and introducing new features. We invite you to start using Dart 2.7 today. It’s available from <a href=\"http://dart.dev\">dart.dev</a>, in today’s <a href=\"https://medium.com/@csells_18027/flutter-1-12-release-blog-22c256ba525d\">Flutter 1.12</a> release, and on the recently <a href=\"https://medium.com/dartlang/a-brand-new-dartpad-dev-with-flutter-support-16fe6027784\">redesigned DartPad</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a3710ec54e97\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart-2-7-a3710ec54e97\">Announcing Dart 2.7: A safer, more expressive Dart</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-12-04T17:27:59.000Z":{"title":"A brand new DartPad.dev with Flutter support","link":"https://medium.com/dartlang/a-brand-new-dartpad-dev-with-flutter-support-16fe6027784?source=rss----23738d481ce8---4","guid":"https://medium.com/p/16fe6027784","category":["dart","dartpad","announcements","flutter"],"dc:creator":"John Ryan","pubDate":"Wed, 04 Dec 2019 17:27:59 GMT","atom:updated":"2019-12-05T23:55:27.739Z","content:encoded":"<p>Today we’re announcing a major upgrade of <a href=\"https://dartpad.dev\">DartPad.dev</a> with a fresh new look-and-feel and support for the popular <a href=\"https://flutter.dev/\">Flutter</a> UI toolkit. DartPad is our online editor that runs Dart programs directly in your browser, and now it runs Flutter apps too.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/1*X7Sild_wdEFGRYaSk2C3Og.gif\" /></figure><h3>Make something today</h3><p>To create a new Flutter project, click the <strong>New Pad</strong> button and choose <strong>Flutter</strong>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/1*Sd404nMeJmYEgbPpE7HN7g.gif\" /></figure><p>This adds some starter code to the editor and runs it. Any time that DartPad sees that you’re using package:flutter, a panel comes up to display the UI. Or use the <strong>Samples</strong> menu to find a Flutter sample.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*CONdjdCgZJH6oN7B4tjA5w.png\" /></figure><h3>Features</h3><p>All of Flutter’s core libraries, like <a href=\"https://api.flutter.dev/flutter/cupertino/cupertino-library.html\">cupertino</a> and <a href=\"https://api.flutter.dev/flutter/material/material-library.html\">material</a>, are available to use, and DartPad can display their documentation. Select a symbol to see the documentation in the bottom panel.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/1*pjBKPqejQhVga2yXYWWigw.gif\" /></figure><p>DartPad formats code using the Dart formatter (<a href=\"https://github.com/dart-lang/dart_style\">dartfmt</a>), offers assists, provides fixes, suggests auto-completions, and shows errors and warnings.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/1*f-DNPnkA6gB5wkT_TVVpSQ.gif\" /></figure><p>When you’re ready to share your snippet, you can <a href=\"https://help.github.com/en/github/writing-on-github/creating-gists\">create a GitHub gist</a> and put the gist ID in a URL like this: https://dartpad.dev/&lt;GistID&gt;. You can share this link in a bug report, in a StackOverflow question, or on your social media platform of choice. Check out the <a href=\"https://github.com/dart-lang/dart-pad/wiki/Sharing-Guide\">sharing guide</a> for more details.</p><p>You can also embed DartPad into a page, <a href=\"https://flutter.dev/docs/codelabs/layout-basics\">like in this codelab</a>. Embedded DartPads are especially good for articles, codelabs, and tutorials. (Check out <a href=\"https://dart.dev/resources/dartpad-tutorials.pdf\">this guide</a> if you’re interested in using DartPad in codelabs and tutorials.) To learn more about adding DartPad to a page, check out the <a href=\"https://github.com/dart-lang/dart-pad/wiki/Embedding-Guide\">embedding guide</a>.</p><h3>Thanks!</h3><p>DartPad is part of the Dart <a href=\"https://github.com/dart-lang\">open-source project</a>. If you’ve filed <a href=\"https://github.com/dart-lang/dart-pad/issues\">issues</a> or submitted changes to DartPad, thank you for making it better. If you’d like to contribute, get started at <a href=\"https://github.com/dart-lang/dart-pad\">github.com/dart-lang/dart-pad</a>. To learn more about running Flutter on the web, visit <a href=\"https://flutter.dev/web\">flutter.dev/web</a>.</p><p>We can’t wait to see what you build!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=16fe6027784\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/a-brand-new-dartpad-dev-with-flutter-support-16fe6027784\">A brand new DartPad.dev with Flutter support</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-11-05T16:38:42.000Z":{"title":"Announcing Dart 2.6 with dart2native: Compile Dart to self-contained, native executables","link":"https://medium.com/dartlang/dart2native-a76c815e6baf?source=rss----23738d481ce8---4","guid":"https://medium.com/p/a76c815e6baf","category":["dart","native-code","programming","compilers"],"dc:creator":"Michael Thomsen","pubDate":"Tue, 05 Nov 2019 16:38:42 GMT","atom:updated":"2019-11-08T12:32:12.170Z","content:encoded":"<p>Dart already offers <a href=\"https://dart.dev/platforms\">an extensive set of compilers</a> for building production-optimized code for mobile devices and the web. These flexible compilers enable our framework partners to target a wide range of form factors: Flutter apps on <a href=\"https://flutter.dev/docs\">Android &amp; iOS</a>, Flutter apps on the <a href=\"https://flutter.dev/web\">web</a> &amp; <a href=\"https://flutter.dev/desktop\">desktop</a>, AngularDart apps on the <a href=\"https://angulardart.dev/\">web</a>, and Google Assistant on <a href=\"https://developers.googleblog.com/2019/05/Flutter-io19.html\">embedded devices</a>.</p><p>Today we’re announcing <strong>dart2native</strong>, an extension of our existing compiler set, with the ability to compile Dart programs to self-contained executables containing ahead-of-time-compiled machine code. With dart2native, you can create tools for the command line on <strong>macOS, Windows, or Linux</strong> using Dart. This feature’s announcement picture <a href=\"https://gist.github.com/mit-mit/faec2bfc1d1cef7cd09df917e531c5c0\">was implemented</a> using the feature itself :-)</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/590/0*lY0iF-neazyL0aE-\" /></figure><h3>Dart Native and the dart2native compiler</h3><p>Dart has supported AOT (ahead-of-time) compilation to native machine code for several years, and <a href=\"https://dart.dev/platforms\">Dart Native</a> is thus fairly mature technology. However, in the past we only exposed this capability on iOS and Android mobile devices, via <a href=\"http://flutter.dev\">Flutter</a>.</p><p>With dart2native, we’re extending our native compilation support to support traditional desktop operating systems running macOS, Windows, and Linux. Because the executables created with dart2native are self-contained, they can run on machines that don’t have the Dart SDK installed. And because they’re compiled with Dart’s AOT compiler, the executables start running in just a few milliseconds. As with other Dart compilers and runtimes, the same set of rich and consistent <a href=\"https://dart.dev/guides/libraries\">core libraries</a> are available in Dart when compiling to native code.</p><p>We’ve heard many customers ask for AOT compilation for desktop operating systems — the <a href=\"https://github.com/dart-lang/sdk/issues/36915\">sixth highest-rated issue</a> in our issue tracker — so we’re delighted to be able to make this feature available.</p><blockquote>If you used dart2aot before, then as of 2.6 you’ll use dart2native. It provides a superset of dart2aot’s functionality.</blockquote><h3>Building command line apps with dart2native</h3><p>The dart2native compiler is a great choice for building and deploying <a href=\"https://dart.dev/tutorials/server/cmdline\">Dart-based apps for the command line</a>. These apps often use libraries such as <a href=\"https://api.dart.dev/stable/dart-io/dart-io-library.html\">dart:io</a> (basic I/O), package:<a href=\"https://pub.dev/packages/http\">http</a> (networking), and package:<a href=\"https://pub.dev/packages/args\">args</a> (argument parsing). Let’s review the basics of compiling a “hello, world” app to an executable:</p><p>The source code hello.dart:</p><pre>main() {<br>  print(‘Hello Dart developers’);<br>}</pre><p>Compile hello.dart to a hello executable:</p><pre>$ dart2native src/hello.dart -o hello<br>Generated: /Users/mit/hello</pre><p>Run hello measuring execution time:</p><pre>$ time ./hello<br>Hello Dart developers</pre><pre>real 0m0.049s<br>user 0m0.018s<br>sys 0m0.020s</pre><p>Notice how the command starts, prints to stdout, and exits in a combined time of just 49 milliseconds!</p><p>We’ve seen a few Dart developers already experiment with dart2native for command-line tools:</p><ul><li>Natalie from the <a href=\"https://sass-lang.com/\">SASS</a> (a popular CSS extension tool) team <a href=\"https://github.com/dart-lang/sdk/issues/32894#issuecomment-513975562\">reports</a> that after switching their Dart-based SASS implementation to compile with dart2native, it is now competitive in performance with LibSass, a C++ based implementation.</li><li>Filip from the Dart DevRel team recompiled his <a href=\"https://github.com/filiph/linkcheck/\">linkchecker</a> tool with dart2native, and saw a <a href=\"https://github.com/filiph/linkcheck/issues/7#issuecomment-496308288\">27x speedup</a> when checking small sites.</li></ul><h3>Interoperability with C code via dart:ffi</h3><p>Native apps often need to access native functionality from the surrounding operating system. These system APIs are typically exposed in native C-based libraries, and Dart supports interoperability with these libraries via dart:ffi, our new mechanism for <a href=\"https://dart.dev/guides/libraries/c-interop\">C interop</a>, which we launched in preview in <a href=\"https://medium.com/dartlang/announcing-dart-2-5-super-charged-development-328822024970\">Dart 2.5</a>. The dart2native compiler is compatible with dart:ffi, so you can create and compile natively Dart apps that use it.</p><p>One team member recently used dart:ffi to create a <a href=\"https://pub.dev/packages/dart_console\">dart_console</a> library for console app development, which has functionality like getting window dimensions, reading and setting the cursor location, managing colors, and reading keys and control sequences. The ability to use dart:ffi makes Dart a very powerful language for console apps.</p><h3>kilo: a 7MB code editor written in less than 500 lines of Dart code</h3><p>Using Dart core libraries, dart:ffi, and the dart_console library, we can create pretty interesting console apps. The dart_console package includes a full demo of <em>kilo</em>, a console text editor written in just ~<a href=\"https://github.com/timsneath/dart_console/blob/master/example/kilo.dart\">500 lines of Dart code</a>. The name kilo comes from its origin, <a href=\"https://github.com/antirez/kilo/blob/master/kilo.c\">kilo.c</a>, which was a C implementation in roughly 1000 lines of code.</p><p>With the new dart2native compiler we can easily package this, and we end up with a 7MB self-contained code editor. Here’s a demo of compiling the editor, and then using the compiled editor to edit its own source code to fix a bug:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/586/0*f5pvUnbesO4mGZmW\" /><figcaption>The kilo editor written in Dart and compiled to an executable with dart2native editing it’s own source code</figcaption></figure><h3>Building services with dart2native</h3><p>Another potential use of the dart2native compiler is for small services — for example, a backend supporting a frontend app written using Flutter. In recent years, a growing trend has been the use of services running on <a href=\"https://en.wikipedia.org/wiki/Serverless_computing\">serverless computing</a>. These are fully managed services that automatically scale, including scaling up from and down to zero (not running), providing the potential to greatly lower cost because they are billed only when actually running. Google Cloud makes serverless computing available via <a href=\"https://cloud.google.com/run/\">Cloud Run</a>.</p><p>For serverless backends it’s critical that the service starts quickly. Traditionally, Dart-based services have run with our JIT (just-in-time) compiler, but JIT-based execution has a high latency when starting as the code needs to be compiled and warmed up before it can start executing. By compiling your service’s code ahead-of-time to native code, you can avoid this latency and begin running right away. In addition, with native code you can create Dart services that have a small disk footprint and are self-contained, greatly reducing the size of the container in which the Dart service runs. Dart developer Paul Mundt recently <a href=\"https://itnext.io/experiments-with-dart-microservices-fa117aa408c7\">documented his experiences</a> with using the dart2native compiler; he was able to reduce the size of his Docker image by 91% from 220MB using JIT-compiled code down to just 20MB by using native code! See our documentation for more details about <a href=\"https://dart.dev/tutorials/server/httpserver\">server-side apps</a> and <a href=\"https://dart.dev/server/libraries#server-packages\">packages</a>.</p><h3>Availability</h3><p>The dart2native compiler is available in the Dart SDK starting with version 2.6, which is available starting today from <a href=\"https://dart.dev/get-dart\">dart.dev/get-dart</a>. Once you’ve installed the SDK, you should see the new compiler inside the bin/ directory and in your PATH. Dart.dev has <a href=\"https://dart.dev/tools/dart2native\">more documentation</a>.</p><p>If you’re getting the Dart SDK via Flutter, note that current Flutter builds have incomplete dart2native support. We recommend you install the Dart 2.6 SDK from <a href=\"https://dart.dev/get-dart\">dart.dev/get-dart</a>.</p><h3>Known limitations</h3><p>This initial version of the dart2native compiler has a few known limitations, listed below. You can let us know which issues are important to you by adding a “thumbs up” to the issue in our GitHub issue tracker.</p><ul><li>No cross-compilation support (<a href=\"https://github.com/dart-lang/sdk/issues/28617\">issue 28617</a>): The dart2native compiler supports creating machine code only for the operating system it’s running on. Thus, you’ll need to run the compiler three times — on macOS, Windows, and Linux — if you want to create executables for all three. One way of doing this is by using a CI (Continuous Integration) provider that supports all three operating systems.</li><li>No signing support (<a href=\"https://github.com/dart-lang/sdk/issues/39106\">issue 39106</a>): The executables produced use a format that isn’t compatible with standard signing tools such as codesign and signtool.</li><li>No support for dart:mirrors and dart:developer (see <a href=\"https://dart.dev/guides/libraries\">Dart core libraries</a>).</li></ul><h3>Other changes in Dart 2.6</h3><p>Version 2.6 of the Dart SDK also has a few other changes.</p><p>We launched a preview of dart:ffi, our new mechanism for <a href=\"https://dart.dev/guides/libraries/c-interop\">C interop</a>, in <a href=\"https://medium.com/dartlang/announcing-dart-2-5-super-charged-development-328822024970\">Dart 2.5</a>. Dart 2.6 has a new version of dart:ffi. This new version has a number of breaking API changes to make our APIs easier to use, provide more type safety, and to provide convenient access to memory. For additional details, see the <a href=\"https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md#foreign-function-interface-dartffi\">Dart 2.6 changelog</a>. With these changes dart:ffi graduates to the beta, and we expect API changes to be much less frequent going forward, and general stability is expected to be high. Please continue to give us feedback via the <a href=\"https://github.com/dart-lang/sdk/issues\">issue tracker</a>.</p><p>Dart 2.6 also contains a preview of an exciting new language feature, <a href=\"https://github.com/dart-lang/language/issues/41\">extension methods</a>. We still have a bit of polish and tools work left to complete this feature, but we hope to formally launch it in our next Dart SDK version. We’ll have much more to say about extension methods then; for now you can read about the <a href=\"https://medium.com/dartlang/extension-methods-2d466cd8b308\">design considerations behind the feature</a>.</p><h3>Next steps</h3><p>Download the Dart 2.6 SDK (<a href=\"https://dart.dev/get-dart\">dart.dev/get-dart</a>), build something cool with dart2native, and then tell us about it. If you’re willing to share the details, please leave a response at the bottom of this article. We’re excited to see what you build!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a76c815e6baf\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart2native-a76c815e6baf\">Announcing Dart 2.6 with dart2native: Compile Dart to self-contained, native executables</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-11-05T16:33:42.000Z":{"title":"Dart extension method fundamentals","link":"https://medium.com/dartlang/extension-methods-2d466cd8b308?source=rss----23738d481ce8---4","guid":"https://medium.com/p/2d466cd8b308","category":["dartlang","extension-method","programming-languages"],"dc:creator":"Lasse Reichstein Holst Nielsen","pubDate":"Tue, 05 Nov 2019 16:33:42 GMT","atom:updated":"2019-12-11T12:30:48.394Z","content:encoded":"<h3>Dart Extension Methods Fundamentals</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/903/1*D57vLbx-SwCUSnLXA9zHRQ.png\" /></figure><p>In a future release, the Dart language is adding a new feature, <em>extension methods</em>, which allows you to (pretend to) add new members to existing types. An extension method can be invoked just like a normal method, o.extensionMethod(42), even though it really is just a static function.</p><p>Why are we adding extension methods? What are they good for? How do you use them? And why do I call them “extension <em>methods</em>” when you can add other members too? (The last one is easy: I personally think of them as extension <em>members</em>, but “extension methods” was the working title, and it’s what the similar feature is called in other languages, so in good Dart tradition, we went for the familiar and unsurprising name. I won’t be needing extension getters, setters or operators here, but you can totally add a % operator to String if you want to, no matter what we call the feature.)</p><p>Since I’m one of the people who designed the feature, I’ll opportunistically answer all these questions before anyone else has a chance. (And, because I released this article before we finished the feature, I’ve even gotten to edit out the things that are no longer true!)</p><p>But first, a detour!</p><h3>What I Would Have Done Before Extension Methods</h3><p>Assume, purely hypothetically, that I think the <a href=\"https://api.dartlang.org/stable/2.5.0/dart-async/Future/catchError.html\">catchError</a> function on <a href=\"https://api.dartlang.org/stable/2.5.0/dart-async/Future-class.html\">Future</a> is awful and should be replaced by something newer, shinier and better. Say, because it takes a<a href=\"https://api.dartlang.org/stable/2.5.0/dart-core/Function-class.html\">Function</a> as argument instead of a proper function type, which it does for perfectly reasonable <em>historical</em> reasons, and that means you won’t get any static type checking. That is bad, and the method should feel bad.</p><p>Obviously I can’t remove the function, that would break, like, every serious Dart program <em>ever</em>.</p><p>Then I’d want to at least add a new method to Future&lt;T&gt; so that users can use that one instead, say one like:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ac8e3c2944d7498df333d648eb83fd92/href\">https://medium.com/media/ac8e3c2944d7498df333d648eb83fd92/href</a></iframe><p>which you can call as:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/6fb6ffc04790bb7fa325dc0d1ccb599d/href\">https://medium.com/media/6fb6ffc04790bb7fa325dc0d1ccb599d/href</a></iframe><p>Sadly, I can’t just add that to the Future class. If I do that, I also add it to the Future interface, and any other class implementing that interface will then be incomplete and will no longer compile. At some point we counted 76 classes implementing Future. That was a while ago, and we’ve stopped counting. We still can&#39;t break everybody, so that option is also not on the table.</p><p>Well, then I’ll use a static helper function:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/83d27b15c8cc3571a182ff54519c2d9f/href\">https://medium.com/media/83d27b15c8cc3571a182ff54519c2d9f/href</a></iframe><p>which you can call as:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/761f39a73ad7c35d7e493ec885defe61/href\">https://medium.com/media/761f39a73ad7c35d7e493ec885defe61/href</a></iframe><p>Almost as sadly, that simply doesn’t read well. We <em>like</em> using .-based method chaining because it allows us to read from left to right: “Do this, then do that, then do something more”. Using the static helper function forces us to read it as: “Do that to the following: Do this. After that, do something more” … say what? It just doesn&#39;t have the same <em>flow</em>, the same <em>schwung</em>. It&#39;s darn nigh unreadable in practice.</p><p>OK then, I’m undeterred in my quest, so instead of improving the Future class, I&#39;ll introduce a new and improved interface and give users a way to wrap the old interface:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/17cc7f58a241152d9eb13179c4346b3a/href\">https://medium.com/media/17cc7f58a241152d9eb13179c4346b3a/href</a></iframe><p>which you can use as:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/d5bbc43d94a9674ee0b7f39df02e41d5/href\">https://medium.com/media/d5bbc43d94a9674ee0b7f39df02e41d5/href</a></iframe><p>I’d probably even let MyFuture implement Future and forward all the Future members to the _wrappee future, and then also let all the methods return a MyFuture wrapper again, so I can keep going.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/54e8a2aff584549c21f950a6f66a158a/href\">https://medium.com/media/54e8a2aff584549c21f950a6f66a158a/href</a></iframe><p>Nice and smooth, if I do say so myself!</p><p>This was pretty much as good as it got, back before extension methods … which meant manually adding the wrapper and taking the performance hit from the extra wrapper objects and intermediate forwarding functions.</p><h3>What I Will Do With Extension Methods</h3><p>Once we’re out of the dark no-extension ages, I can use extension methods to get what I really, really want. I’ll write:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/f4b16ef1cf90ab30709c87b401136bc7/href\">https://medium.com/media/f4b16ef1cf90ab30709c87b401136bc7/href</a></iframe><p>and then you can call it as:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/366a3bf4f049bad6a8f80998181eaf91/href\">https://medium.com/media/366a3bf4f049bad6a8f80998181eaf91/href</a></iframe><p>and that is all. Mission accomplished in five lines!</p><p>“But how does it <em>work</em>?”, you might ask. It works very well, thank you.</p><p>In truth, <em>it behaves almost exactly the same way as the wrapper class</em>, even though it really is just a static helper function. You can even write MyFuture(eventualInteger).onError(...) explicitly, as if the extension was a wrapper class. It isn&#39;t, but it looks and acts <em>almost</em> as if it was. And you can omit the explicit wrapping and have it <em>implicitly</em> applied when the types are right.</p><h3>It’s (not) a Wrapper Class</h3><p>The design of the extension declaration is deliberately made so that it looks like a class or mixin declaration, and it acts just as if it was a wrapper class with a hidden _wrappee. You can even have static members in the declaration, and they work just like static members on a class or mixin declaration.</p><p>There is one <em>improvement</em> over the wrapper class: You can write this inside instance members to refer to the _wrappee instead of the wrapper object.</p><p>Changing the meaning of this was not just an improvement. These are <em>static</em> extension methods, and as I said earlier, they are really just a more convenient way to call static functions. That means that there is no wrapper <em>object</em>. It never existed, we just pretended that it did, but that means that we can&#39;t let this refer to the non-existing object.</p><p>We also can&#39;t allow you to use MyFuture(eventualInteger) as a value, so if you try to do var myFuture = MyFuture(eventualInteger), we won&#39;t allow it. The only way to use MyFuture(eventualInteger) is as the target of an extension member invocation.</p><pre>MyFuture(eventualInteger).onError(...); // GOOD: Use to call method.<br>var x = MyFuture(eventualInteger); // BAD: Use as stand-alone value.</pre><p>It’s the same as how you can use super to call methods, but not for its value. Or just like a library prefix. All you can do is access a member; you cannot treat it as a value because it has no value, and there is no value for it to have.</p><p>Because there is no object, you can’t declare <em>instance fields</em> in an extension declaration. You <em>can</em> declare getters and setters though, and perhaps even back them by an <a href=\"https://api.dartlang.org/stable/2.5.1/dart-core/Expando-class.html\">Expando</a>. An extension also cannot declare any constructors since nothing is being constructed; it just pretends to have a constructor taking the wrappee object.</p><h3>It Does (not) Extend the Type</h3><p>If you had to write the MyFuture(...) wrapping every time you used an extension member, then it wouldn&#39;t be much of an improvement. We could probably just write the wrapper classes directly and spend some compiler engineer hours ensuring that we optimize away the intermediate object.</p><p>I said above that you can write eventualInteger.onError(...). This works because we <em>implicitly wrap</em> expressions based on their static type and the name of the member they call. We automatically wrap expr.method() as Ext(expr).method() when all of the following are true:</p><ul><li>The static type of expr does not have a member with (base-)name method (the interface always wins).</li><li>The extension Ext is imported or declared in the current library scope (the extension is <em>accessible</em>).</li><li>The extension declares a member with base-name method, <em>and </em>the static type of expr is a subtype of the on type of the Ext declaration (the extension is <em>applicable</em>).</li></ul><p>If there is more than one accessible and applicable extension for a member invocation, there are rules about which one will win the conflict. In some cases, there’s no way to pick a winner, and then it’s just a compile-time error. These rules depend only on the extension declaration’s on type, not on member declaration. (Dart does not have “overloading” — multiple methods with the same name and different signatures, which you choose between based on the argument structure or types — and extension methods do not provide a back-door to get overloading.)</p><h3>It Is All Static</h3><p>I said “s<em>tatic</em> extension methods” above, and I did so for a reason!</p><p>Dart is statically typed. The compiler knows the type of every expression at compile-time, so if you write target.member(42), and member is an extension member, then the compiler needs to figure out <em>which</em> extension to implicitly wrap target with, in order to find the type of the entire member invocation.</p><p>If implicit extension wrapping has to happen <em>between</em> finding the type of the target expression <em>and</em> finding the type of the member invocation, it seems obvious that “extension inference” has to happen during the increasingly more inaccurately named “type inference” phase. That’s the phase which is mostly known for filling in missing generics.</p><p>I did write eventualInteger.onError((FormatException e, s) {...}), even though both the MyFuture extension and the onError method are generic. While doing type inference, the Dart compiler both selects the extension and infers missing type arguments. Here it first decides to use the MyFuture extension, then inserts the implicit wrapper, and finally performs type inference for the extension application MyFuture(eventualInteger).onError((FormatException e, s) {...}) in <em>exactly the same way</em> as it would for a corresponding wrapper class:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/23c1d0ef98ac0e46adb0a20e492b1f0a/href\">https://medium.com/media/23c1d0ef98ac0e46adb0a20e492b1f0a/href</a></iframe><p>In this case, the type inference would infer the following extension application and complete types for the invocation:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/6d78ab68999204ae9a6e1355970a1d81/href\">https://medium.com/media/6d78ab68999204ae9a6e1355970a1d81/href</a></iframe><p>This means that <em>the type arguments to the extension are based on the static type of the wrapped expression</em>. If you have a Future&lt;num&gt; fut = Future&lt;int&gt;.value(42); then fut.onError(...) will bind the T type parameter of MyFuture to num at compile-time, not to int. It&#39;s all static, just as for any other inferred type arguments.</p><p>That also means that you will never be able to call an extension member on a target typed as dynamic.</p><h3>Conflict Resolution</h3><p>As stated above, there are rules about which extension wins when there is more than one in scope which applies. Basically, the winner is the extension with an on type closest to the actual type of the expression you are calling a member on, with some caveats and tie-breakers. It usually “just works” for extensions which are written together. Instead of going into those details, I&#39;ll tell you what to do when it <em>doesn&#39;t</em> just work.</p><p>You might have a problem when two different authors have written conflicting extensions for the same type and member name. Say the extensions Ext1 and Ext2 both define a bubbleSort method that applies to your List object, and either there is no clear winner of the conflict, or the one which wins is not the one you actually want to call (say Ext2 wins and you want to call Ext1.bubbleSort). Then you have to do <em>something</em>.</p><p>The easiest solution is to use an explicit extension application: Ext1(list).bubbleSort(). This avoids the automatic resolution and just picks the one that you want. If you only have a few conflicts, then that&#39;s both easy and readable.</p><p>However, if you have three hundred conflicts in the same file, then you might want to avoid the extra typing. It’s hard to change whether an extension is <em>applicable</em> to an invocation, but you can change whether it’s <em>accessible</em>.</p><p>You do that by <em>hiding</em> the conflicting extension (or extension<em>s,</em> if you are really unlucky) where you import it: import &quot;ext2lib.dart&quot; hide Ext2;. Doing so will prevent the Ext2 extension from being imported into the current library scope, which makes it not accessible. Obviously, so will not importing ext2lib.dart at all, but unless the extension is the only thing you use from that library, that’s not practical.</p><p>(Edited Dec. 11th) Here I used to say that you could import one of the conflicting extensions with a <em>prefix</em> and that then it would not be available for implicit use. Turns out that some people declare extension methods in the same library as the class they extend, and it is really annoying if that library doesn’t work when imported with a prefix. So we fixed that. Extensions imported with a prefix <em>do</em> work implicitly as well. If you really need to use two conflicting extension in the same library, you will have to use explicit extension application everywhere there is a conflict. We may consider adding a different way to disable implicit extensions in the future, at least if conflicting extensions turn out to be a recurring issue.</p><h3>Summary</h3><p>Dart will get <em>extension methods </em>in an upcoming release <em>— </em>a pretty way to call static functions.</p><p>You can define extension members for <strong>instance methods</strong>, <strong>operators</strong>, <strong>setters</strong> and <strong>getters</strong>, but <strong>not fields</strong>.</p><p>You can invoke extension methods either explicitly or — when there’s no conflict with an interface member or another extension — implicitly:</p><pre>Ext1(list).bubbleSort() // Explicit, like it&#39;s a wrapper class.<br>list.bubbleSort()       // Implicitly, like it extends the type.</pre><p>Implicit invocations work the same as explicit invocations, but they first <em>infer</em> which extension is being applied. If extension inference fails due to conflicting extensions, then you can do any one of the following:</p><ul><li>Apply the extension explicitly.</li><li>Don’t import the conflicting extension at all (remove the import or hide the extension).</li><li>(Edited Dec 11th): And that is it (for now).</li></ul><p>Extensions are <em>static</em>. Everything about them is decided based on static types.</p><p>Enjoy responsibly!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2d466cd8b308\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/extension-methods-2d466cd8b308\">Dart extension method fundamentals</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-10-10T19:01:08.000Z":{"title":"Announcing verified publishers on pub.dev","link":"https://medium.com/dartlang/verified-publishers-98f05466558a?source=rss----23738d481ce8---4","guid":"https://medium.com/p/98f05466558a","category":["flutter","dart","package-management"],"dc:creator":"Michael Thomsen","pubDate":"Thu, 10 Oct 2019 19:01:08 GMT","atom:updated":"2019-10-10T19:01:07.840Z","content:encoded":"<p>Today we’re announcing a new feature on <a href=\"https://pub.dev\">pub.dev</a> (the Dart package repository): <em>verified publishers</em>. When you <em>use</em> a package that has a verified publisher, you can be sure that the publisher is who they claim to be. When you <em>publish</em> packages as a verified publisher, you get the bonus of easier package administration.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/0*DfmB09PD2DK-pvTz\" /></figure><h3>Increasing trust for package consumers</h3><p>App developers building apps with <a href=\"https://flutter.dev\">Flutter</a> tell us that having a rich selection of high-quality packages is critical to their productivity, allowing them to reuse common components and access popular SDKs and libraries. We’re seeing an immense amount of growth in the <a href=\"https://pub.dev/\">pub.dev</a> ecosystem, with thousands of packages published over the past year, and hundreds of thousands of developers using pub.dev every month to browse and search for new package content.</p><p>One of the most important selection criteria we hear from package users is <em>who published the package. </em>Verified publishers strengthen this signal by verifying the identity of the publisher, and by clearly listing the publisher identity in package search results and on package detail pages (note the blue badge next to dart.dev in the screenshots below).</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/507/0*LQMWHLFUi6F7nPO1\" /><figcaption><em>Package search result showing a package that was published by a verified publisher</em></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*GJcMpmN8bNi6H5_g\" /><figcaption><em>Package detail page showing a package that was published by a verified publisher</em></figcaption></figure><p>When you click the publisher, you can see a few more details, including a contact email for the publisher, a link to the publisher homepage, and a short description of the publisher. The publisher description is provided by the publisher, offering a small branding opportunity.</p><p>You can also view a list of all packages published by the publisher. Below is an example from the new <a href=\"https://pub.dev/publishers/dart.dev/packages\">dart.dev publisher</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*Q24NUEox8eA10hVB\" /><figcaption><em>Sample package list for a publisher</em></figcaption></figure><h4>Publisher verification process</h4><p>When we designed the verification process, we wanted a mechanism that was trustworthy, low cost, and available to anyone interested in being a verified publisher. We also preferred a process that was automated, so accounts could be created without delays.</p><p>After reviewing several alternatives, we decided to base the verification on DNS (domain name system) second-level domains. We chose DNS because we believe that most package publishers already have a domain and a homepage at that domain. During the <a href=\"https://dart.dev/tools/pub/publishing#create-verified-publisher\">publisher creation process</a>, pub.dev verifies that the user creating the verified publisher has admin access to the associated domain, based on existing logic in the <a href=\"https://search.google.com/search-console/about\">Google Search Console</a>.</p><h4>Improved package administration</h4><p>Besides the clear benefits of verifying the publisher identity, the verified publishers feature also offers administrative benefits. Previously, if you published many packages, access management was a tedious, package-by-package job that took away time you could be spending on improving your packages. With verified publishers, you can configure a single team of admins for your publisher account, where all team members have the ability to publish updates to all packages owned by the publisher.</p><p>We’ve also added a few new self-administration options, including the ability to move an existing package to a publisher account (see below), or to mark a package as <a href=\"https://dart.dev/tools/pub/publishing#discontinue\">discontinued</a>.</p><h4>Transfer existing packages</h4><p>It’s easy to transfer existing packages to a verified publisher. Just <a href=\"https://dart.dev/tools/pub/publishing#create-verified-publisher\">create a verified publisher</a>, and use the <a href=\"https://dart.dev/tools/pub/publishing#transferring-a-package-to-a-verified-publisher\">transfer function</a> on your existing packages. This simple process takes just a few minutes per package.</p><h4>Pub.dev roadmap</h4><p>We’re discussing lots of future improvements to pub.dev. Here are some of the ideas:</p><ul><li>Search support for packages that support a particular platform (for example, Android or web; <a href=\"https://github.com/dart-lang/pub-dev/issues/187\">#187</a>), incl. better understanding of Dart web vs Flutter web packages</li><li>Tags or categories for packages (<a href=\"https://github.com/dart-lang/pub-dev/issues/367\">#367</a>)</li><li>Voting on or liking high-quality packages (<a href=\"https://github.com/dart-lang/pub-dev/issues/798\">#798</a>)</li><li>Clear policy and process for reporting questionable content (<a href=\"https://github.com/dart-lang/pub-dev/issues/1570\">#1570</a>)</li></ul><p>If you’re interested in a particular idea, we encourage you to check the <a href=\"https://github.com/dart-lang/pub-dev/issues?q=is%3Aissue+is%3Aopen+sort%3Areactions-%2B1-desc\">pub.dev issue tracker</a> to make sure the idea is already tracked, and to indicate your interest by adding a <em>thumbs up</em> reaction to the topmost comment of the issue.</p><h4>Next steps</h4><p>If you’re a package publisher, we encourage you to get your packages transferred to a verified publisher account as soon as possible, to get the benefits listed above for both yourself and the users of your packages. We’ve already transferred many of the most popular <a href=\"https://pub.dev/publishers/dart.dev/packages\">dart.dev packages</a>, and expect more to be transferred shortly.</p><p>That’s all for now. We look forward to seeing even more high-quality packages on <a href=\"https://pub.dev/\">pub.dev</a>!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=98f05466558a\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/verified-publishers-98f05466558a\">Announcing verified publishers on pub.dev</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2019-09-18T14:01:03.000Z":{"title":"Dart asynchronous programming: Futures","link":"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137?source=rss----23738d481ce8---4","guid":"https://medium.com/p/96937f831137","category":["programming","asynchronous-programming","flutter","programming-languages","dartlang"],"dc:creator":"Kathy Walrath","pubDate":"Wed, 18 Sep 2019 14:01:03 GMT","atom:updated":"2019-09-18T14:01:03.753Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/394/1*G4044qvxp8yBjmGVHVLEyw.png\" /><figcaption>Many asynchronous Dart APIs return futures.</figcaption></figure><p>One of the most basic APIs that Dart has for asynchronous programming is <em>futures — </em>objects of type <a href=\"https://api.dartlang.org/stable/dart-async/Future-class.html\">Future</a>. For the most part, Dart’s futures are very similar to the <em>future</em> or <em>promise</em> APIs found in other languages.</p><p>This article discusses the concepts behind Dart futures and tells you how to use the Future API. It also discusses the Flutter FutureBuilder widget, which helps you update a Flutter UI asynchronously, based on the state of a future.</p><p>Thanks to Dart language features like <a href=\"https://dart.dev/codelabs/async-await\">async-await</a>, you might never need to use the Future API directly. But you’re almost certain to encounter futures in your Dart code. And you might want to <em>create</em> futures or <em>read</em> code that uses the Future API.</p><blockquote>This article is the second one based on the <em>Flutter in Focus</em> video series <em>Asynchronous Programming in Dart</em>. The first article, <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a\">Isolates and event loops</a>, covered the foundations of Dart’s support for background work.</blockquote><blockquote>If you prefer to learn by watching or listening, everything in this article is covered in the following video<em>.</em></blockquote><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FOTS-ap9_aXc%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DOTS-ap9_aXc&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FOTS-ap9_aXc%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/8b6cf4ee42282247c713fd0c0da5298c/href\">https://medium.com/media/8b6cf4ee42282247c713fd0c0da5298c/href</a></iframe><p>You can think of futures as little gift boxes for data. Somebody hands you one of these gift boxes, which starts off closed. A little while later the box pops open, and inside there’s either a value or an error.</p><p>So a future can be in one of 3 states:</p><ol><li><strong>Uncompleted:</strong> The gift box is closed<em>.</em></li><li><strong>Completed with a value:</strong> The box is open, and your gift (data) is ready.</li><li><strong>Completed with an error:</strong> The box is open, but something went wrong.</li></ol><p>Most of the code you’re about to see revolves around dealing with these three states. You receive a future, and you need to decide what to do until the box opens, what to do when it opens with a value, and what to do if there’s an error. You’ll see that 1–2–3 pattern a lot.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/584/1*UD63BMoIBmzoA6jo3LjCCg.png\" /><figcaption>The 3 states of a future</figcaption></figure><p>You might remember the event loop (pictured below) from our <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a\">article about the Dart event loop</a>. A good thing to know about futures is that they’re really just an API built to make using the event loop easier.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/624/0*xlxALlxjazVifRep.png\" /><figcaption>The Dart event loop processes one event at a time.</figcaption></figure><p>The Dart code you write is executed by a single thread. The whole time your app is running, that one little thread just keeps going around and around, picking up events from the event queue and processing them.</p><p>Say you have some code for a download button (implemented below as a RaisedButton). The user taps, and your button starts downloading a picture.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/d117128d4388430b3f161a8970cc27a0/href\">https://medium.com/media/d117128d4388430b3f161a8970cc27a0/href</a></iframe><p>First the tap event occurs. The event loop gets the event, and it calls your tap handler (which you set using the onPressed parameter to the RaisedButton constructor). Your handler uses the http library to make a request (http.get()), and it gets a future in return (myFuture).</p><p>So now you’ve got your little box, myFuture. It starts off closed. To register a callback for when it opens, you use then().</p><p>Once you have your gift box, you wait. Maybe some other events come in, the user does some stuff, and your little box just sits there while the event loop keeps going around.</p><p>Eventually, data for the image is downloaded, and the http library says, “Great! I’ve got this future right here.” It puts the data in the box and pops it open, which triggers your callback.</p><p>Now that little piece of code you handed to then() executes, and it displays the image.</p><p>Throughout that process, your code never had to touch the event loop directly. It didn’t matter what else was going on, or what other events came in. All you needed to do was get the future from the http library, and then say what to do when the future completed.</p><p>In real code, you’d also take care of errors. We’ll show you how to do that a little later.</p><p>Let’s take a closer look at the Future API, some of which you just saw in use.</p><p>OK, first question: how do you get an instance of a Future? Most of the time, you don’t create futures directly. That’s because many of the common asynchronous programming tasks already have libraries that generate futures for you.</p><p>For example, network communication returns a future:</p><pre>final myFuture = http.get(&#39;http://example.com&#39;);</pre><p>Getting access to shared preferences also returns a future:</p><pre>final myFuture = SharedPreferences.getInstance();</pre><p>But you can also use Future constructors to create futures.</p><h3>Future constructors</h3><p>The simplest constructor is <a href=\"https://api.dartlang.org/stable/dart-async/Future/Future.html\">Future()</a>, which takes a function and returns a future that matches the function’s return type. Later the function runs asynchronously, and the future completes with the function’s return value. Here’s an example of using Future():</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e27a259c2540f79cd29b55eb1f790e92/href\">https://medium.com/media/e27a259c2540f79cd29b55eb1f790e92/href</a></iframe><p>Let’s add a couple of print statements to make the asynchronous part clear:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/9f21b9217f909011fb1789ff165ae78a/href\">https://medium.com/media/9f21b9217f909011fb1789ff165ae78a/href</a></iframe><p>If you run that code in DartPad (<a href=\"https://dartpad.dev\">dartpad.dev</a>), the entire main function finishes before the function given to the Future() constructor. That’s because the Future() constructor just returns an uncompleted future at first. It says, “Here’s this box. You hold onto that for now, and later I’ll go run your function and put some data in there for you.” Here’s the output of the preceding code:</p><pre>Done with main().<br>Creating the future.</pre><p>Another constructor, <a href=\"https://api.dartlang.org/stable/dart-async/Future/Future.value.html\">Future.value()</a>, is handy when you already know the value for the future. This constructor is useful when you’re building services that use caching. Sometimes you already have the value you need, so you can pop it right in there:</p><pre>final myFuture = Future.value(12);</pre><p>The Future.value() constructor has a counterpart for completing with an error. It’s called <a href=\"https://api.dartlang.org/stable/dart-async/Future/Future.error.html\">Future.error()</a>, and it works essentially the same way, but takes an error object and an optional stacktrace:</p><pre>final myFuture = Future.error(ArgumentError.notNull(&#39;input&#39;));</pre><p>The handiest future constructor is probably <a href=\"https://api.dartlang.org/stable/dart-async/Future/Future.delayed.html\">Future.delayed()</a>. It works just like Future(), except that it waits for a specified length of time before running the function and completing the future.</p><p>One way to use Future.delayed() is when you’re creating mock network services for testing. If you need to make sure your loading spinner displays correctly, a delayed future is your friend.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5b436044f5e815fb6fae7547737bdefa/href\">https://medium.com/media/5b436044f5e815fb6fae7547737bdefa/href</a></iframe><h3>Using futures</h3><p>Now that you know where futures come from, let’s talk about how to use them. As we mentioned earlier, using a future is mostly about accounting for the three states it can be in: uncompleted, completed with a value, or completed with an error.</p><p>The following code uses Future.delayed() to create a future that completes after 3 seconds with a value of 100.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ab4bcdad8dbe7a1b5424537f1ae494c8/href\">https://medium.com/media/ab4bcdad8dbe7a1b5424537f1ae494c8/href</a></iframe><p>When this code executes, main() runs from top to bottom, creating the future and printing “Waiting for a value…” That whole time, the future is uncompleted. It doesn’t complete for another 3 seconds.</p><p>To <em>use</em> the completed value, you can use <a href=\"https://api.dartlang.org/stable/dart-async/Future/then.html\">then()</a>. That’s an instance method on each future that you can use to register a callback for when the future completes with a value. You give it a function that takes a single parameter matching the type of the future. Once the future completes with a value, your function is called with that value.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/f988acb78c06b4f422eb91fc8a37698c/href\">https://medium.com/media/f988acb78c06b4f422eb91fc8a37698c/href</a></iframe><p>Here’s the output of the preceding code:</p><pre>Waiting for a value... <em>(3 seconds pass until callback executes)</em><br>The value is 100.</pre><p>In addition to executing your code, then() returns a future of its own, matching the return value of whatever function you give it. So if you need to make a couple of asynchronous calls, you can chain them together even if they have different return types.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5a6e0a91c6b445d288a0000afcca55b3/href\">https://medium.com/media/5a6e0a91c6b445d288a0000afcca55b3/href</a></iframe><p>Back to our first example, what happens if that initial future doesn’t complete with a value — what if it completes with an error? The then() method expects a value. You need a way to register another callback in case of an error.</p><p>The answer is to use <a href=\"https://api.dartlang.org/stable/dart-async/Future/catchError.html\">catchError()</a>. It works just like then(), except that it takes an error instead of a value, and it executes if the future completes with an error. Just like then(), the catchError() method returns a future of its own, so you can build a whole chain of then() and catchError()methods that wait on one another.</p><blockquote><strong>Note: </strong>You don’t need to call then() or catchError() if you use the async-await language feature. Instead, you await the completed value, and you use try-catch-finally to handle errors. For details, see the Dart language tour’s <a href=\"https://dart.dev/guides/language/language-tour#asynchrony-support\">asynchrony support section</a>.</blockquote><p>Here’s an example of using catchError() to handle the case where a future completes with an error:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/db525189bde74549870e219535581770/href\">https://medium.com/media/db525189bde74549870e219535581770/href</a></iframe><p>You can even give catchError() a test function to check the error before invoking the callback. You can have multiple catchError() functions this way, each one checking for a different kind of error. Here’s an example of specifying a test function, using the optional test parameter to catchError():</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/fe5017c41b1935118b8bac05a0e78bb0/href\">https://medium.com/media/fe5017c41b1935118b8bac05a0e78bb0/href</a></iframe><p>Now that you’ve gotten this far, hopefully you can see how the three states of a future are often reflected by the structure of the code. There are three blocks in the preceding example:</p><ol><li>The first block creates an uncompleted future.</li><li>Then there’s a function to call if the future completes with a value.</li><li>Then there’s another function to call if the future completes with an error.</li></ol><p>There’s one more method you might want to use: <a href=\"https://api.dartlang.org/stable/dart-async/Future/whenComplete.html\">whenComplete()</a>. You can use it to execute a function when the future is completed, no matter whether it’s with a value or an error.</p><p>It’s kind of like the <em>finally</em> block in a try-catch-finally. There’s code executed if everything goes right, code for an error, and code that runs no matter what.</p><h3>Using futures in Flutter</h3><p>So that’s how you create futures, and a bit about how you can use their values. Now let’s talk putting them to work in Flutter.</p><p>Say you have a network service that’s going to return some JSON data, and you want to display that data. You could create a <a href=\"https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html\">StatefulWidget</a> that creates the future, checks for completion or error, calls setState(), and generally handles all the wiring manually.</p><p>Or you can use <a href=\"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html\">FutureBuilder</a>. It’s a widget that comes with the Flutter SDK. You give it a future and a builder function, and it automatically rebuilds its children when the future completes.</p><p>The FutureBuilder widget works by calling its builder function, which takes a context and a snapshot of the current state of the future.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/d4d061e92c50ac8668b523456fd22ca3/href\">https://medium.com/media/d4d061e92c50ac8668b523456fd22ca3/href</a></iframe><p>You can check the snapshot to see whether the future completed with an error:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ec30bac06a737610df8007c8a790080b/href\">https://medium.com/media/ec30bac06a737610df8007c8a790080b/href</a></iframe><p>Otherwise you can check the hasData property to see if it completed with a value:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/822acd24d8ce82d850f9478bfc202de2/href\">https://medium.com/media/822acd24d8ce82d850f9478bfc202de2/href</a></iframe><p>If neither hasError nor hasData is true, then you know you’re still waiting, and you can output something for that as well.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2dcbbe30464eec59149d857caf678ea8/href\">https://medium.com/media/2dcbbe30464eec59149d857caf678ea8/href</a></iframe><p>Even in Flutter code, you can see how those three states keep popping up: uncompleted, completed with value, and completed with error.</p><h3>Summary</h3><p>This article talked about what futures represent and how you can use the Future and FutureBuilder APIs to create futures and use their completed values.</p><p>If you’d like to learn more about using futures—with the option of using runnable examples and interactive exercises to test your understanding—check out the asynchronous codelab on <a href=\"https://dart.dev/codelabs/async-await\">futures, async, and await</a>.</p><p>Or go on to the next video in the <em>Asynchronous Programming in Dart </em>series. It talks about <em>streams</em>, which are a lot like futures in that they can provide either values or errors. But where futures just give you one result and stop, streams just keep right on going.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FnQBpOIHE4eE%3Ffeature%3Doembed&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DnQBpOIHE4eE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FnQBpOIHE4eE%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/19f7572c0ed7e65b2b45fc00703972c6/href\">https://medium.com/media/19f7572c0ed7e65b2b45fc00703972c6/href</a></iframe><p><em>Big thanks to Andrew Brogdon, who created the video that this article is based on.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=96937f831137\" width=\"1\" height=\"1\"><hr><p><a href=\"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137\">Dart asynchronous programming: Futures</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-05-06T14:58:48.000Z":{"title":"Announcing Dart 2.8","link":"https://medium.com/dartlang/announcing-dart-2-8-7750918db0a?source=rss----23738d481ce8---4","guid":"https://medium.com/p/7750918db0a","category":["dart","dependency-management","flutter","announcements"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 06 May 2020 14:58:48 GMT","atom:updated":"2020-05-06T14:58:47.955Z","content:encoded":"<h4>Faster package tools, new tool for ensuring dependencies never go stale</h4><p>Today we’re announcing a new release of the Dart SDK, version 2.8. We’re continuing to see amazing growth in the Dart community; we now have <a href=\"https://medium.com/flutter/flutter-spring-2020-update-f723d898d7af\">millions of Flutter developers</a> using Dart as their client-optimized language for building fast apps on any platform. While we’re still working hard on completing our <a href=\"https://medium.com/dartlang/dart-2-7-a3710ec54e97\">upcoming null safety</a> feature to make Dart an even more optimized language for building fast and stable user interfaces, we have a few exciting new features focused on making developers even more productive when managing dependencies.</p><p>The Dart platform comes with built-in support for package management via the <a href=\"https://dart.dev/tools/pub/cmd\">pub client tool</a> and the <a href=\"https://pub.dev/\">pub.dev</a> package repository, which has grown 200% over the past year and now is home to nearly 10,000 packages. As part of our ongoing work to improve the Dart ecosystem, the Dart 2.8 SDK brings two improvements to the pub client tool: much better performance in pub get, and a new tool for ensuring your package dependencies are kept up-to-date.</p><p>Dart 2.8 also brings a set of small breaking changes in the Dart language and libraries. These changes lay the groundwork for our first version of the null safety feature.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*JrrSSD8LCLMkAUIV8RJlkw.png\" /><figcaption>Announcing Dart 2.8: Faster package tools, new tool for ensuring dependencies never go stale</figcaption></figure><h3>Breaking changes paving the way for null safety</h3><p>A common source of app crashes is code that attempts to use a variable that happens to be null. Sir Tony Hoare, who introduced null references in the ALGOL programming language in 1965, famously called them his <em>“billion-dollar mistake”</em> in a <a href=\"https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/\">QCon talk in 2009</a>. In some cases null values are useful; the challenge is separating those from the cases where they aren’t. For the past year we’ve been busy building support for <a href=\"https://github.com/dart-lang/language/issues/110\">sound null safety</a> in Dart. This support will extend the type system to express variables that are always non-nullable, but in addition the type system will be fully sound: the Dart compilers and runtimes will be able to trust those types, and be able to produce optimized code when the type system guarantees that a variable isn’t null.</p><p>As you can imagine, this is a large undertaking with a lot of moving parts. To ensure that we can build null safety with clean semantics, we’ve decided to make some small breaking changes in the Dart language and libraries. These breaking changes make minor adjustments to corner cases of the Dart type system and to a few Dart core libraries to ensure great nullability-related usability and performance. We expect the actual impact of these breaking changes — which were <a href=\"https://groups.google.com/a/dartlang.org/g/announce/c/JwPWiC0jTiU\">pre-announced</a> on the Dart announcement list — to be minimal for regular app code. If you experience any issues with Dart 2.8, we encourage you to review <a href=\"https://github.com/dart-lang/sdk/issues/40686\">the breaking changes</a> and their descriptions and mitigation steps. If that doesn’t resolve the issue, please file an issue in <a href=\"https://github.com/dart-lang/sdk/issues\">our issue tracker</a>. For a preview of the null safety experience, try the <a href=\"https://nullsafety.dartpad.dev/53257b6da4cb128dc1e069df64748ed1\">null safety playground</a>.</p><h3>A higher quality package ecosystem</h3><p>The pub package manager and <a href=\"https://pub.dev\">pub.dev</a> site power an ever-growing ecosystem for Dart and Flutter. Nearly 10,000 packages are available at pub.dev, and we’re continually amazed by the many interesting packages being shared. It’s been our core mission to help package authors create high-quality packages and to help app developers find those packages — for example, we’ve added <a href=\"https://medium.com/dartlang/improved-discovery-on-the-dart-package-site-9bfe24c3d7d3\">improved pub.dev discovery</a>, <a href=\"https://medium.com/dartlang/verified-publishers-98f05466558a\">verified publishers</a>, and <a href=\"https://flutter.dev/docs/development/packages-and-plugins/favorites\">Flutter Favorites</a>.</p><p>Today we’re announcing much faster performance when retrieving packages from the <a href=\"https://pub.dev\">pub.dev</a> repository, and a new tool to help you keep all your package dependencies updated. With the complexity of modern apps, your app likely depends on dozens of packages. But how do you keep them all updated to the latest version, to ensure you are getting the most recent dependencies with all the bug fixes and performance improvements available? As of Dart 2.8, you can use pub outdated, a new tool for automatically determining which of your dependencies need to be updated to the latest and greatest versions.</p><h3>Dart 2.8 pub tool performance improvements</h3><p>We optimized the performance of the pub tool by adding support for parallel fetching of packages when running pub get, and by deferring pub run precompilation.</p><p>In an informal benchmark of running flutter pub get on a new project created with flutter create, the total execution time decreased from about 6.5 seconds in Flutter 1.12 (which uses Dart 2.7) to just 2.5 seconds with Flutter 1.17 (Dart 2.8). In a larger app like the <a href=\"https://github.com/flutter/gallery\">Flutter gallery</a>, the time drops from about 15 seconds to about 3 seconds!</p><h3>Managing dependencies with pub outdated</h3><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*av2bRfpUdU2Fk4s8xRPnhA.gif\" /></figure><p>Dependencies in Dart code are captured in the <a href=\"https://kw-staging-dartlang-2.firebaseapp.com/tools/pub/pubspec\">pubspec</a> file. When you retrieve packages from <a href=\"https://pub.dev/\">pub.dev</a> by running the pub get command, the pub version solver (which uses the <a href=\"https://medium.com/@nex3/pubgrub-2fb6470504f\">PubGrub</a> algorithm) runs a process to determine the latest possible set of versions of all your dependencies that satisfies the constraints listed in your pubspec. Note that pub uses a single-version scheme where each package is included in a single-version-only in your app; this is an important optimization to ensure that your app size is as small as possible.</p><p>It’s <a href=\"http://dart.dev/tools/pub/dependencies#best-practices\">a best practice</a> to always use the latest stable package versions, but doing so can be laborious. Dart has support for upgrading to the latest versions that are <a href=\"https://dart.dev/tools/pub/dependencies#version-constraints\">semantically compatible</a> using <a href=\"https://dart.dev/tools/pub/cmd/pub-upgrade\">pub upgrade</a>, but you can’t include new major versions of packages without updating the pubspec. The pub outdated command helps you understand when both minor and major versions are available by comparing currently used versions against the latest versions available on pub.dev.</p><p>Let’s consider a concrete example. Imagine you’re building an app, and its pubspec.yaml contains the following:</p><pre>dependencies:<br>  foo: ^1.3.0<br>  bar: ^2.0.0</pre><p>You run pub get, and the tool creates a pubspec.lock file with the following versions:</p><pre>packages:<br>  foo:<br>    version: &quot;1.3.0&quot;<br>  bar:<br>    version: &quot;2.0.1&quot;</pre><p>A few months pass, and pub.dev now has new versions of foo (1.3.1) and bar (2.1.0 and 3.0.3). How do you discover that these new versions are available? For the minor version upgrades (foo 1.4.0 and bar 2.1.0) you could run pub upgrade, but that wouldn’t give you bar 3.0.0. To discover that new version you’d have to visit each package on pub.dev and look at its latest version. Alternatively, you could use a community solution like Paulina Szklarska’s <a href=\"https://plugins.jetbrains.com/plugin/12400-flutter-pub-version-checker\">version checker</a> or Jeroen Meijer’s <a href=\"https://marketplace.visualstudio.com/items?itemName=jeroen-meijer.pubspec-assist\">pubspec assist</a>.</p><p>With pub outdated, the Dart SDK now supports version discovery. If you’re using an IDE with Dart or Flutter support, use the <strong>Pub outdated</strong> action that’s shown when the pubspec.yaml file is open. Or you can run pub outdated (or flutter pub outdated) from the terminal:</p><pre><strong>$</strong> pub outdated</pre><pre><strong>Dependencies            Current  Upgradable  Resolvable  Latest<br></strong>foo                     1.3.0    <strong>1.3.1</strong>       1.3.1       1.3.1<br>bar                     2.0.1    2.1.0       <strong>3.0.3</strong>       3.0.3</pre><pre>1 upgradable dependency is locked (in pubspec.lock) to an older version.</pre><pre>To update it, use `pub upgrade`.</pre><pre>1 dependency is constrained to a version that is older than a resolvable version.</pre><p>This output tells us that we can automatically upgrade to foo 1.3.1 with pub upgrade, which will put us on the latest version available of foo. But it also tells us that while we could upgrade automatically to bar 2.1.0, a version 3.0.3 is available. Because the upgrade to bar 3.0.3 is a major version upgrade, we need to opt into that upgrade by editing our pubspec.yaml file:</p><pre>dependencies:<br>  foo: ^1.3.0<br>  bar: ^3.0.3</pre><p>After we make that edit and run pub upgrade, pub outdated now reports that all dependencies are up-to-date:</p><pre><strong>$</strong> pub outdated</pre><pre><strong>Dependencies            Current   Upgradable  Resolvable  Latest</strong></pre><pre>all up-to-date</pre><p>Success, we’re up-to-date! Because we just picked up new versions, including a new major version, we should review any potential breaking changes in those versions, and run all tests to make sure that our app still works as expected.</p><h3>Next steps</h3><p>The performance improvements, <a href=\"https://github.com/dart-lang/sdk/issues/40686\">breaking changes</a>, and new pub outdated command are available today in the stable <a href=\"https://dart.dev/get-dart\">Dart 2.8 SDK</a> and in the stable <a href=\"https://flutter.dev/docs/get-started/install\">Flutter 1.17 SDK</a>. We recommend that you <a href=\"https://dart.dev/tools/pub/cmd/pub-outdated\">run </a><a href=\"https://dart.dev/tools/pub/cmd/pub-outdated\">pub outdated today</a> to see the health of your dependencies!</p><p>Should you find any issues, please report them in the <a href=\"https://github.com/dart-lang/pub/issues\">pub issue tracker</a>, or in the <a href=\"https://github.com/dart-lang/sdk/issues\">SDK issue tracker</a> for general issues. We’d love to hear about your experience with pub outdated. Leave a comment below or send a tweet to <a href=\"https://twitter.com/dart_lang\">@dart_lang</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7750918db0a\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-2-8-7750918db0a\">Announcing Dart 2.8</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-05-20T16:01:01.000Z":{"title":"3 cool Dart patterns","link":"https://medium.com/dartlang/3-cool-dart-patterns-6d8d9d3d8fb8?source=rss----23738d481ce8---4","guid":"https://medium.com/p/6d8d9d3d8fb8","category":["iife","dart","coding","conditional-statements","flutter"],"dc:creator":"Jose Alba","pubDate":"Wed, 20 May 2020 16:01:01 GMT","atom:updated":"2020-05-20T16:43:44.439Z","content:encoded":"<p><em>About the author: Jose recently graduated from university and now works on </em><a href=\"https://material.io\"><em>Material</em></a><em>, a design system that helps teams build high-quality digital experiences. Jose’s team maintains the Flutter </em><a href=\"https://api.flutter.dev/flutter/material/material-library.html\"><em>material library</em></a><em>.</em></p><p>With the Flutter framework, you use the Dart programming language to create beautiful applications. Over time, I have learned useful Dart patterns that have helped me become a better Flutter developer. Here are three that I recommend you try in your next application:</p><ul><li>Conditionally assigning a value: boolean ? widget : widget</li><li>Merging widgets into a collection: for ()...[]</li><li>Immediately invoking an anonymous function: () {} ()</li></ul><p>This article shows you how to use each pattern, finishing with an embedded Pen where you can play with the code.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*alx_hKg5fP3b1b22\" /><figcaption>This screenshot shows the code I will discuss and the UI it produces.</figcaption></figure><h3>Conditionally assigning a value</h3><p>The <a href=\"https://dart.dev/guides/language/language-tour#conditional-expressions\">conditional assignment operator</a>, ?: (also known as a <a href=\"https://en.wikipedia.org/wiki/%3F:\">ternary operator</a>), requires one conditional expression and two value expressions. This pattern is useful when your widget depends on a boolean value. Instead of modularizing the operation into a separate method, you can use the ternary operator to run the code inline. I have used this technique countless times.</p><p>In the following example, the AppBar title depends on a boolean value. (In this case, the value is dependent on the isVegetarian boolean.) If the value is true, the title text is set to the first value (“Vegetarian Food”); otherwise it’s the second value (“Non-Vegetarian Food”).</p><pre>appBar: AppBar(<br>  title: Text(Random().nextBool() <br>      ? &#39;Vegetarian Food&#39; <br>      : &#39;Non-Vegetarian Food&#39;),<br>),</pre><h3>Merging widgets into a collection</h3><p>This pattern, for () ...[], uses the spread operator (...) to merge a list of widgets into an existing collection. I use this any time I am working with a list of widgets, often with the children property. The following example uses this technique to create a list of widgets:</p><pre>children: [<br>  Container(),<br>  for (final food in foods) ...[<br>    if (isVegetarian == food.isVegetarian)<br>      ListTile(title: Text(food.name)),<br>    SizedBox(height: 50.0),<br>  ],<br>],</pre><p>In this example, foods is a list of Food objects, defined as follows:</p><pre>List&lt;Food&gt; foods = [<br>  Food(name: &#39;apple&#39;, isVegetarian: true),<br>  Food(name: &#39;nuts&#39;, isVegetarian: true),<br>  Food(name: &#39;eggs&#39;, isVegetarian: true),<br>  Food(name: &#39;chicken&#39;, isVegetarian: false),<br>];</pre><pre>class Food {<br>  Food({<br>    this.name,<br>    this.isVegetarian,<br>  });</pre><pre>  String name;<br>  bool isVegetarian;<br>}</pre><p>The for () ...[] pattern is handy whenever you need to add multiple widgets (such as the ListTile widgets in the example if isVegetarian is true) multiple times (3 times, in the example) into a list of widgets.</p><p>Because the spread operator (...) is relatively new to Dart, make sure that your pubspec.yaml file specifies a Dart SDK of 2.3.0 or later:</p><pre>environment:<br>  sdk: &quot;&gt;=2.3.0 &lt; 3.0.0&quot;</pre><p>To learn more about <a href=\"https://dart.dev/guides/language/language-tour#collection-operators\">collection operators</a> and <a href=\"https://dart.dev/guides/language/language-tour#spread-operator\">spread operators</a>, read the <a href=\"https://dart.dev/guides/language/language-tour\">Dart language tour</a>.</p><h3>Immediately invoking an anonymous function</h3><p>The third pattern, () {} (), is the Dart equivalent of an <em>immediately invoked function expression (</em><a href=\"https://en.wikipedia.org/wiki/Immediately_invoked_function_expression\"><em>IIFE</em></a><em>).</em> This handy pattern lets you define an anonymous function and execute it immediately. I found this pattern extremely useful when working with a widget that could have multiple outputs. Instead of having nested ternary operators or modularizing a simple call, the code is available inline. The following example shows this pattern, with an anonymous function that contains a switch statement.</p><pre>color: () {<br>  switch (getRandomElement(foods).name) {<br>    case &#39;apple&#39;:<br>      return Colors.green;<br>    case &#39;nuts&#39;:<br>      return Colors.brown;<br>    case &#39;eggs&#39;:<br>      return Colors.yellow;<br>    default:<br>      return Colors.transparent;<br>  }<br>}(),</pre><h3>Conclusion</h3><p>You can use CodePen to play with Flutter code. Here’s a Pen that has all the code in this article:</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2FJoseAlba%2Fembed%2Fpreview%2FmdeKexM%3Fheight%3D600%26slug-hash%3DmdeKexM%26default-tabs%3Djs%2Cresult%26host%3Dhttps%3A%2F%2Fcodepen.io&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2FJoseAlba%2Fpen%2FmdeKexM&amp;image=https%3A%2F%2Fscreenshot.codepen.io%2F4404447.mdeKexM.small.639bc042-f20b-4346-89cc-073a0500f278.png&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/1c05a523420e8c039a9cd0f7f73fae99/href\">https://medium.com/media/1c05a523420e8c039a9cd0f7f73fae99/href</a></iframe><p>Here is another CodePen example with just colors:</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fcodepen.io%2FJoseAlba%2Fembed%2Fpreview%2FeYpgpzY%3Fheight%3D600%26slug-hash%3DeYpgpzY%26default-tabs%3Djs%2Cresult%26host%3Dhttps%3A%2F%2Fcodepen.io&amp;display_name=CodePen&amp;url=https%3A%2F%2Fcodepen.io%2FJoseAlba%2Fpen%2FeYpgpzY&amp;image=https%3A%2F%2Fscreenshot.codepen.io%2F4404447.eYpgpzY.small.79a6eaaa-84bc-4960-8e82-1a3ea215fde9.png&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=codepen\" width=\"800\" height=\"600\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3b4a9c1293856a063957eb063d0ae9f2/href\">https://medium.com/media/3b4a9c1293856a063957eb063d0ae9f2/href</a></iframe><p>I hope that these three Dart patterns give you more freedom while developing Flutter applications. If you have other favorite techniques, share them in the comments!</p><p><em>To learn more about Jose, visit him on </em><a href=\"https://github.com/JoseAlba\"><em>GitHub</em></a><em>, </em><a href=\"https://www.linkedin.com/in/josealba1996/\"><em>LinkedIn</em></a><em>, </em><a href=\"https://www.youtube.com/channel/UCOdKA_On0oPe1tz02z1QfxA?view_as=subscriber\"><em>YouTube</em></a><em>, or </em><a href=\"https://www.instagram.com/jose.alba/\"><em>Instagram</em></a><em>.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6d8d9d3d8fb8\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/3-cool-dart-patterns-6d8d9d3d8fb8\">3 cool Dart patterns</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-06-10T16:00:36.000Z":{"title":"Announcing sound null safety","link":"https://medium.com/dartlang/announcing-sound-null-safety-defd2216a6f3?source=rss----23738d481ce8---4","guid":"https://medium.com/p/defd2216a6f3","category":["flutter","programming-languages","announcements","dart"],"dc:creator":"Filip Hracek","pubDate":"Wed, 10 Jun 2020 16:00:36 GMT","atom:updated":"2020-06-10T16:00:36.822Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<h4>Make your apps more stable and performant with Dart’s null safety</h4><p><em>By: </em><a href=\"https://medium.com/u/696ae61bc6e2\"><em>Filip Hracek</em></a><em> &amp; </em><a href=\"https://medium.com/u/a6d788faa5e5\"><em>Michael Thomsen</em></a></p><p>Today is a major milestone for the Dart team with the tech preview of our null safety work. Null safety helps you avoid a class of bugs that are often hard to spot, and as an added bonus enables a range of performance improvements. We’re now releasing an early tech preview, and we’re looking forward to your feedback.</p><p>This post describes the Dart team’s plans for rolling out null safety. It also explains what we mean by <em>sound </em>null safety and<em> </em>why that’s different from approaches that many other languages take.</p><h3>Why null safety?</h3><p>Dart is a type-safe language. This means that when you get a variable of some type, the compiler can <em>guarantee</em> that it is of that type. But type safety by itself doesn’t guarantee that the variable is not null.</p><p>Null errors are very common. A search on GitHub leads to <a href=\"https://github.com/search?l=Dart&amp;q=%22called+on+null%22&amp;type=Issues\">thousands of issues</a> caused by nulls in Dart code, and even more <a href=\"https://github.com/search?l=Dart&amp;q=%22called+on+null%22&amp;type=Commits\">thousands of commits</a> trying to fix those issues.</p><p>Try to see if you can spot the nullability problems in the following example code:</p><pre>void printLengths(List&lt;File&gt; files) {<br>  for (var file in files) {<br>    print(file.lengthSync());<br>  }<br>}</pre><p>This function will certainly fail if called with null, but there’s a second case to consider:</p><pre>void main() {<br>  // Error case 1: passing a null to files.<br>  printLengths(null);</pre><pre>  // Error case 2: passing list of files, containing a null item.<br>  printLengths([File(&#39;filename1&#39;), File(&#39;filename2&#39;), null]);<br>}</pre><p>The null safety feature makes this problem go away:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HKl1Jf0uBNP-gReYYcgC_g.png\" /></figure><p>With null safety, you can reason about your code with more confidence. No more pesky runtime null dereferencing errors. Instead, you get static errors as you code.</p><h3>Sound null safety</h3><p>Dart’s null safety is <em>sound</em>. This means that Dart is 100% sure that the files list, and the elements in it, cannot be null in the above example. When Dart analyzes your code and determines that a variable is non-nullable, that variable is <em>always</em> non-nullable: if you inspect your running code in the debugger, you’ll see that non-nullability is retained at runtime. By contrast, some other implementations are unsound, and in many cases still need to perform runtime null checks. Dart shares sound null safety with Swift, but not very many other programming languages.</p><p>The soundness of Dart’s null safety has another welcome implication: it means your programs can be smaller and faster. Because Dart is <em>really</em> sure that files is never null, Dart can optimize. For example, the Dart ahead-of-time (AOT) compiler can produce smaller and faster native code, because it doesn’t need to add checks for nulls when it <em>knows</em> that a variable isn’t null.</p><p>We’ve seen some very promising preliminary results. For example, we saw a <a href=\"https://gist.github.com/a-siva/07e8a5bfa8548a3041d44d5d1c6f3a40\">19% performance improvement</a> in a microbenchmark that emulates typical Flutter framework rendering patterns.</p><h3>Design principles</h3><p>Before starting the detailed design for null safety, the Dart team defined the following three core principles:</p><ul><li><strong>Non-nullable by default.</strong> Unless you explicitly tell Dart that a variable can be null, it will consider it non-nullable. We chose this as the default because we found that non-null was by far the most common choice in APIs.</li><li><strong>Incrementally adoptable.</strong> There’s a lot of Dart code out there. It must be possible to migrate to null safety incrementally, part by part. It should be possible to have null-safe and non-null-safe code in the same project. We’ll also provide tools to help you with the migration.</li><li><strong>Fully sound.</strong> As mentioned above, Dart’s null safety is sound. Once you migrate your whole project and your dependencies to null safety, you reap the full benefits of soundness.</li></ul><h3>Declaring variables with null safety</h3><p>The core syntax is simple enough. Here are some non-nullable variables, declared in different ways. Remember, non-nullable is the default, so these declarations look like they do today, but their meaning changes.</p><pre>// In null-safe Dart, none of these can ever be null.<br>var i = 42;<br>final b = Foo();<br>String m = &#39;&#39;;</pre><p>Dart will make sure that you never assign null to any of the above variables. If you try to do i = null a thousand lines later, you’ll get a static analysis error and red squiggly lines, and your program will refuse to compile.</p><p>If you want your variable to be nullable, you can use ?, like this:</p><pre>// These are all nullable variables.<br>int? j = 1;  // Can be null later.<br>final Foo? c = getFoo();  // Maybe the function returns null.<br>String? n;  // Is null at first. Can be null at any later time, too.</pre><p>The above variables behave the same way that all variables do today.</p><p>You can use the ? syntax in other places, too:</p><pre>// In function parameters.<br>void boogie(int? count) {<br>  // It&#39;s possible that count is null.<br>}</pre><pre>// In function return values.<br>Foo? getFoo() {<br>  // Can return null instead of Foo.<br>}</pre><pre>// Also: generics, typedefs, type checks, etc.<br>// And any combination of the above.</pre><p>But, once again, the dream is that you’ll almost never have to use ?. The vast majority of your types will be non-nullable.</p><h3>Making null safety easier to use</h3><p>The Dart team is trying hard to make null safety as easy to use as possible. For example, look at this code, which uses if to check for a null value:</p><pre>void honk(int? loudness) {<br>  if (loudness == null) {<br>    // No loudness specified, notify the developer<br>    // with maximum loudness.<br>    _playSound(&#39;error.wav&#39;, volume: 11);<br>    return;<br>  }</pre><pre>  // Loudness is non-null, let&#39;s just clamp it to acceptable levels.<br>  _playSound(&#39;honk.wav&#39;, volume: loudness.clamp(0, 11));<br>}</pre><p>Note how Dart is smart enough to realize that by the time we pass that if statement, the loudness variable <em>cannot</em> be null. And so Dart lets us call the clamp() method without jumping through hoops. This convenience is enabled by something called <em>flow analysis</em>: the Dart analyzer goes through your code as if it was executing it, figuring out additional information about your code automatically.</p><p>Here’s another example, which shows a case where Dart can be sure that a variable is non-null because we always assign a non-null value to it:</p><pre>int sign(int x) {<br>  // The result is non-nullable.<br>  int result;</pre><pre>  if (x &gt;= 0) {<br>    result = 1;<br>  } else {<br>    result = -1;<br>  }</pre><pre>  // By this point, Dart knows the result cannot be null.<br>  return result;<br>}</pre><p>If you remove any of the assignments above (for example, by deleting the result = -1; line), Dart cannot guarantee that result will be non-null: you’ll get a static error and your code won’t compile.</p><p>Flow analysis only works inside functions. If you have a global variable or a class field, then Dart can’t guarantee when it will be assigned what value. Dart can’t model the flow of your whole application. For that reason, you can use the new late keyword when you <strong><em>know</em></strong> that a variable will be non-null before you first read it, but you can’t initialize it immediately.</p><pre>class Goo {<br>  late Viscosity v;</pre><pre>  Goo(Material m) {<br>    v = m.computeViscosity();<br>  }<br>}</pre><p>Note that v is non-null, although it starts uninitialized. Dart trusts you that you won’t try to read v before it’s assigned a non-null value, and your code compiles without errors.</p><h3>Null safety is backwards compatible</h3><p>The Dart team has been working for more than a year to get null safety to tech preview. It’s the largest addition to the Dart language since we introduced Dart 2. Yet, it’s not a breaking change. Existing code can call into code that uses null safety, and vice versa. Even after null safety is available, it will be an optional feature that you can adopt when you’re ready. <strong>Your existing code will continue to run without change</strong>.</p><p>We recently migrated the Dart <a href=\"https://api.dart.dev/dev/2.9.0-13.0.dev/index.html\">core libraries to fully use null safety</a>. As an example of null safety’s backwards compatibility, we replaced the existing core libraries without any breakage in existing tests and test apps running in the Dart and Flutter test environments. We even rolled the new core libraries to our many internal Google customers, directly into their production code bases, without a hitch. We plan on migrating all of our packages and apps to use null safety when the feature launches, and we hope you’ll do the same. But you’ll be able to do it on your timeline, package by package, app by app.</p><h3>The null safety roadmap</h3><p>We plan to roll out null safety gradually, in three steps:</p><ol><li><strong>Tech preview.</strong> This is <strong><em>launching today</em></strong>, and is available in Dart’s <a href=\"https://dart.dev/get-dart#release-channels\">dev channel</a>. See the “Try it now” section below for details. Things are still subject to change, so <strong>don’t use null safety in production code</strong> just yet. Do test things out and <a href=\"https://github.com/dart-lang/sdk/issues/new?title=Null%20safety%20feedback:%20[issue%20summary]&amp;labels=NNBD&amp;body=Describe%20the%20issue%20or%20potential%20improvement%20in%20detail%20here\">give us feedback</a>, though!</li><li><strong>Beta release.</strong> Null safety will be available in Dart’s beta channel, and no longer behind an <a href=\"https://github.com/dart-lang/sdk/blob/master/docs/process/experimental-flags.md\">experimental flag</a>. The feature will be very close to the expected final version. If you own a <a href=\"https://pub.dev/\">pub.dev</a> package or plugin, this is when you can begin migrating, but you shouldn’t publish it as a stable version just yet.</li><li><strong>Stable release.</strong> Everyone will have null safety, and you’ll be encouraged to publish your migrated packages and plugins as stable versions. You should also migrate your production apps.</li></ol><p>If all goes well, we plan to release null safety as a stable feature before the end of the year. Between now and then, we’ll add tooling to help you make your code null safe, including:</p><ul><li>A migration tool to support you in automating many of the steps for upgrading existing packages and apps</li><li>Tags on <a href=\"https://pub.dev\">pub.dev</a>, so you can tell if a package supports null safety or not</li><li>An extension to the <a href=\"https://dart.dev/tools/pub/cmd/pub-outdated\">pub outdated</a> command, with support for finding the latest versions of your dependencies that support null safety</li></ul><h3>Try it now</h3><p>The quickest way to try null safety today is through <a href=\"https://nullsafety.dartpad.dev/3d9c1769de7912c654bc5d132aff60ac\">nullsafety.dartpad.dev</a>, a version of DartPad with null safety enabled. Open the <strong>Learn with Snippets</strong> drop-down to find a series of learning exercises that walk through the new syntax and basics of null safety.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*7alHbKGJ1FoeNqII\" /></figure><p>You can also try null safety in small command-line apps. (We haven’t migrated larger frameworks like Flutter yet.) Start by downloading a copy of the <a href=\"https://github.com/dart-lang/samples/blob/master/null_safety/calculate_lix/README.md#dart-preview-sdk-installation\">dev-channel Dart SDK</a>, and then get a copy of <a href=\"https://github.com/dart-lang/samples/tree/master/null_safety/calculate_lix\">this sample Dart CLI app</a> (<a href=\"https://github.com/dart-lang/samples\">GitHub repo</a>, <a href=\"https://github.com/dart-lang/samples/archive/master.zip\">zip archive</a>). The sample app’s <a href=\"https://github.com/dart-lang/samples/blob/master/null_safety/calculate_lix/README.md\">README file</a> has instructions for running the app with the null safety experiment flag. Other files in the sample provide launch configurations that enable debugging in VS Code and Android Studio.</p><p>We also have documentation, with plans to produce more:</p><ul><li><a href=\"https://dart.dev/null-safety\">Null safety guide</a></li><li><a href=\"https://api.dart.dev/dev/2.9.0-13.0.dev/index.html\">API reference for core libraries with null safety</a></li></ul><p>We’re very happy to bring null safety to Dart. Sound null safety is a distinctive feature of Dart that helps you write less error-prone code and get better performance. We hope you’ll experiment with the feature in tech preview, and <a href=\"https://github.com/dart-lang/sdk/issues/new?title=Null%20safety%20feedback:%20[issue%20summary]&amp;labels=NNBD&amp;body=Describe%20the%20issue%20or%20potential%20improvement%20in%20detail%20here\">give us feedback</a> through our issue tracker. Happy coding!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=defd2216a6f3\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-sound-null-safety-defd2216a6f3\">Announcing sound null safety</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-07-15T15:01:02.000Z":{"title":"Introducing a brand new pub.dev","link":"https://medium.com/dartlang/pub-dev-redesign-747406dcb486?source=rss----23738d481ce8---4","guid":"https://medium.com/p/747406dcb486","category":["flutter","development","google","package-management","dart"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 15 Jul 2020 15:01:02 GMT","atom:updated":"2020-07-15T15:15:09.953Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<h4>Redesigned for high-quality, multiplatform packages</h4><p>Today we’re launching a brand new <a href=\"https://pub.dev\">pub.dev</a> site. It features new scoring metrics to give you a better understanding of potentially useful packages, and to provide package publishers with more actionable feedback on how to improve package quality. To help you find packages that support all the platforms you’re interested in, we’ve added support for identifying and searching for multiplatform packages. And overall we’ve redesigned the UI, aiming for a delightful and elegant experience that’s consistent with our <a href=\"https://dart.dev\">dart.dev</a> and <a href=\"https://dartpad.dev\">dartpad.dev</a> sites.</p><figure><img alt=\"A screenshot of the page at https://pub.dev\" src=\"https://cdn-images-1.medium.com/max/1024/0*efALL34OP6a4tcxh\" /><figcaption>The new pub.dev site</figcaption></figure><h3>Finding the best packages for your needs</h3><p>With<em> </em>nearly 7,000 new packages published over the past year, you have no shortage of options when looking for packages to extend the functionality of your apps. But with so many packages to choose from, naturally you want the most liked, highest quality, and most popular packages to bubble to the surface. To support better package search results, we’ve redesigned the scoring system in pub.dev around three dimensions:</p><figure><img alt=\"Screenshot of a package summary: 552 likes; 100/110 pub points; 98% popularity\" src=\"https://cdn-images-1.medium.com/max/1024/0*OmvIh_FRHtJDrSIk\" /><figcaption><em>The three scoring dimensions for a pub package</em></figcaption></figure><ol><li><strong>Likes</strong>: A measure of how many developers have liked a package. This provides a raw measure of the overall sentiment toward a package.</li><li><strong>Pub points</strong>: A new measure of quality. This includes several dimensions of quality such as code style, platform support, and maintainability. More about this below.</li><li><strong>Popularity</strong>: A measure of how many developers use a package. This reflects the number of apps that depend on the package over the past sixty days. The normalized scale ranges from 100% (the most used package) to 0% (the least used package), but we’re investigating whether we can provide absolute usage counts in a future version.</li></ol><p>We hope that these new dimensions help both package consumers who are looking for packages to depend on, and package publishers working on shipping a high quality packages.</p><h3>Measuring quality with pub points</h3><p>With likes and popularity providing community-sourced, subjective measures, the goal of pub points is to provide a close approximation of measurable, objective quality. This isn’t easy; developers perceive quality in a variety of ways, but we still believe that most developers look for core traits that we can measure. The previous pub.dev scoring model was based on subtracting points for issues. The new scoring model reverses this approach, instead awarding points based on traits in five categories:</p><figure><img alt=\"Screenshot: Pub points overview for a package\" src=\"https://cdn-images-1.medium.com/max/1024/0*RWVQoe0INHUfS_Ax\" /><figcaption><em>Pub points overview with categories and checks, as well as points awarded</em></figcaption></figure><ol><li><em>Follow Dart file conventions</em>: Follow best practices around pubspec, readme, and changelog files</li><li><em>Provide documentation</em>: Provide API documentation and an illustrative example</li><li><em>Support multiple platforms</em>: Support as many Dart and Flutter platforms as possible</li><li><em>Pass static analysis</em>: Provide code that is free from errors, warnings, and lints</li><li><em>Support up-to-date dependencies</em>: Have dependency constraints that support the latest Dart &amp; Flutter SDKs, and the latest package dependencies</li></ol><p>We expect to add more checks and categories for pub points over time, raising the ceiling for how many points a package can have. For example, we plan to add a score for supporting <a href=\"https://medium.com/dartlang/announcing-sound-null-safety-defd2216a6f3\">null safety</a> when that feature launches. And we’re investigating how to measure maintainability (issue and pull request responsiveness), testability (automated test coverage), and community friendliness (number of contributors, maintainers, etc.). If you have an idea for a great measure, we’d love to <a href=\"https://github.com/dart-lang/pub-dev/issues\">hear from you</a>!</p><h3>Supporting multiplatform apps</h3><p>Both Dart and Flutter excel at creating apps that target multiple platforms. On pub.dev we’ve provide clear platform tags for mobile (iOS and Android) and web platforms, as well as search filters for these platforms:</p><figure><img alt=\"Screenshot: Search results for Flutter packages that support both Android and Web\" src=\"https://cdn-images-1.medium.com/max/1024/0*aTIl5H_AbGmOJBKO\" /><figcaption>Platform filters in search</figcaption></figure><p>To make sure that your package is tagged with the correct platform support, follow the guidance on the pub.dev <a href=\"https://pub.dev/help/scoring\">scoring help page</a>.</p><p>We’ll be adding similar support for desktop platforms (macOS, Windows, and Linux) when that advances to a more final state. For now you can find filters for those platforms inside the <strong>Advanced</strong> search options:</p><figure><img alt=\"Screenshot: Search results for Flutter packages that support Android, iOS, and macOS platforms\" src=\"https://cdn-images-1.medium.com/max/1024/0*LpResE7zZv_5x3xB\" /><figcaption><em>Desktop platforms in advanced filters</em></figcaption></figure><h3>An elegant and delightful design</h3><p>The Dart pub.dev team collaborated with Google Developer Studio, our internal creative team, with Jeremy Sie as the main designer. Alongside functional updates, the team took a considered look at the visual design, sharing their thoughts on the project. With an eye to providing a coherent, accessible, and user-focused experience, we made a range of refinements rooted in Google’s <a href=\"https://material.io/design/\">Material Design system</a>. Our aim was to create a lightweight and streamlined interface, allowing for clear and concise workflows for both package publishers and consumers.</p><p>The updated design features <a href=\"https://material.io/components\">Material components</a> such as cards and chips that clearly display package details and allow greater transparency into how individual packages function. We updated the typographic system and improved the <a href=\"https://material.io/design/typography/the-type-system.html#type-scale\">type scale</a> across the site, bringing greater clarity to search results and improving the way package information is displayed. Components such as package scores have been redesigned to be clearer and structured in a way that makes the scoring process more transparent and easier to understand.</p><figure><img alt=\"Screenshot: Package search results\" src=\"https://cdn-images-1.medium.com/max/1024/0*6UWz21c0wZuisozR\" /><figcaption><em>Search showing all three pub.dev scores</em></figcaption></figure><p>We also made changes to the homepage. We knew the ability to quickly search for packages was a core part of the site, but we wanted to improve the experience by surfacing the most useful tools and libraries. We added sections such as <strong>Flutter favorites</strong> and <strong>Most popular packages</strong> up front, helping you to quickly explore some of the best packages available. We took a close look at the color palette and art direction, incorporating illustrations and making components such as code examples visually consistent with <a href=\"https://dart.dev/\">dart.dev</a> and <a href=\"https://dartpad.dev/\">dartpad.dev</a>.</p><h3>Try pub.dev today</h3><p>We invite you to try the new <a href=\"http://pub.dev\">pub.dev</a> browse and search experience today, and to use the new scoring dimensions and pub points report.</p><p>If you’re a package developer, we encourage you to view the pub points for your packages, looking for opportunities to improve your packages. For further details on how the scoring system works, see the <a href=\"https://pub.dev/help/scoring\">pub.dev scoring help</a>.</p><p>As always, we love feedback. Please leave comments below, or file issues in the <a href=\"https://github.com/dart-lang/pub-dev/issues\">pub.dev issue tracker</a>.</p><p><em>By: Michael Thomsen (Product Manager, Dart) &amp; <br>Jeremy Sie (Visual Designer, Google Developer Studio)</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=747406dcb486\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/pub-dev-redesign-747406dcb486\">Introducing a brand new pub.dev</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-06-30T20:25:58.000Z":{"title":"Dart string manipulation done right ","link":"https://medium.com/dartlang/dart-string-manipulation-done-right-5abd0668ba3e?source=rss----23738d481ce8---4","guid":"https://medium.com/p/5abd0668ba3e","category":["programming-languages","flutter","dart","string-manipulation","developer-experience"],"dc:creator":"Tao Dong","pubDate":"Tue, 30 Jun 2020 20:25:58 GMT","atom:updated":"2020-06-30T21:25:49.744Z","content:encoded":"<p>Like many other programming languages designed before emojis started to dominate our daily communications and the rise of multilingual support in commercial apps, Dart represents a string as <a href=\"https://api.dart.dev/stable/2.8.4/dart-core/String-class.html\">a sequence of UTF-16 code units</a>. The encoding worked fine in most cases, until increased internationalization and the introduction of emojis that go with any language made the encoding’s inherent problems become everybody’s problems.</p><p>Consider this example:</p><figure><img alt=\"The image shows the string “Hello” with a handwaving emoji at the end and it’s UTF-16 code units. The emoji takes two units.\" src=\"https://cdn-images-1.medium.com/max/1024/1*H_-SP7V6x1cQpGM_6DUReg.png\" /></figure><p>In the string “Hello👋”, each user-perceivable character is mapped to a single code unit except the waving hand emoji 👋. An immediate consequence of this mapping is confusion over the length of this string. Will the output of the following line of code be 6 or 7?</p><pre>print(&#39;Hello👋&#39;.length);</pre><p>To the user, there are clearly 6 characters in this string unless you get philosophical. But the Dart String API will tell you that the <a href=\"https://api.dart.dev/stable/dart-core/String/length.html\">length</a> is 7, or to be precise, 7 UTF-16 code units. This difference has all kinds of ramifications, because so many text manipulation tasks involve using character indexes with the String API. For example, &quot;Hello👋&quot;[5] won’t return the 👋 emoji. Instead it will return a malformed character representing the first code unit of the emoji.</p><p>The good news is that Dart has a new package called <a href=\"https://pub.dev/packages/characters\"><em>characters</em></a> that operates on user-perceivable characters instead of UTF-16 code units. However, you, as a Dart programmer, need to know when to use the characters package. Our research indicates that even experienced Dart programmers can easily miss such problems when reading text manipulation code. In this article, I go over some common scenarios where you need to pay extra attention and consider using the characters package instead of Dart String.</p><h3>Scenarios to watch out for</h3><p>In this section, I’ll go over a few common text manipulation scenarios, explain why using Dart’s String API could cause problems in these scenarios, and show how to use the characters package for more reliable results. The use cases below generally assume that we’re dealing with strings entered by human users, which could include emojis or characters in a language the app developer doesn’t expect.</p><h4>Scenario 1: Counting characters in a string</h4><p>Suppose you’re writing a function that checks if the text entered by the user has exceeded a specific number of characters. The function returns a positive number of remaining characters if the limit hasn’t been reached, or a negative number of extra characters if the limit has been exceeded.</p><p>This is pretty straightforward to do using the String API:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/6410317e172b58f70eb9656bfcffecae/href\">https://medium.com/media/6410317e172b58f70eb9656bfcffecae/href</a></iframe><p>However, the following test reveals the problem with this code:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/18de9b3bf7add8cc5ef46031a7cb4e3d/href\">https://medium.com/media/18de9b3bf7add8cc5ef46031a7cb4e3d/href</a></iframe><p>Here are the testing results:</p><pre>Expected: &lt;47&gt;<br>  Actual: &lt;46&gt;</pre><p>We can rewrite this function using the characters package, which provides a convenient extension method on String, to produce the correct number of characters as follows:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/718ee2466da5c6c79bed3060aea24739/href\">https://medium.com/media/718ee2466da5c6c79bed3060aea24739/href</a></iframe><h4>Scenario 2: Extracting a substring</h4><p>In this scenario, we want to implement a function that deletes the last character from a string and returns the result as a new string. Let’s assume this string comes from user input.</p><p>This function is easy to implement using the substring method on String as follows:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/98b6cbbad8b612078ec7a4bd9c24e43e/href\">https://medium.com/media/98b6cbbad8b612078ec7a4bd9c24e43e/href</a></iframe><p>However, a good emoji test can quickly break the code:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/bf5c861e58475e7be957bc3dcc0e5d43/href\">https://medium.com/media/bf5c861e58475e7be957bc3dcc0e5d43/href</a></iframe><p>Here are the testing results:</p><pre>Expected: ‘Hi ’<br>  Actual: ‘Hi 🇩???’<br>    Which: is different. Both strings start the same, but the actual value also has the following trailing characters: 🇩???</pre><p>The characters package can handle this case with ease, as it provides high-level methods such as <a href=\"https://pub.dev/documentation/characters/latest/characters/Characters/skipLast.html\">skipLast(int count)</a><em>. </em>We can rewrite this snippet into the following code:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/0654c324dcfb441f451ab27c7aef923a/href\">https://medium.com/media/0654c324dcfb441f451ab27c7aef923a/href</a></iframe><h4>Scenario 3: Splitting a string on an emoji</h4><p>In the third scenario, we want to split a string on a given emoji. Here is a function doing that using the split method on String:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b3fe33ec3caac7eb31cb363e2035ebc9/href\">https://medium.com/media/b3fe33ec3caac7eb31cb363e2035ebc9/href</a></iframe><p>Would it work? It probably will work just fine 99% of the time, but the test below illustrates an example where the above code produces rather surprising results.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5feed1ff4b1e254f2f65e58985bc0e0f/href\">https://medium.com/media/5feed1ff4b1e254f2f65e58985bc0e0f/href</a></iframe><p>Here are the testing results:</p><pre>Expected: [&#39;abc👨‍👩‍👧‍👦&#39;, &#39;abc&#39;, &#39;abc&#39;, &#39;abc&#39;]<br>  Actual: [&#39;abc👨‍👩‍&#39;,&#39;‍👦&#39;, &#39;abc&#39;, &#39;abc&#39;, &#39;abc&#39;]<br>    Which: was &#39;abc👨‍👩‍&#39; instead of &#39;abc👨‍👩‍👧‍👦&#39; at location [0]</pre><p>So, why did 👨‍👩‍👧‍👦 become two emojis 👨‍👩 when the string was split? It’s because 👨‍👩‍👧‍👦 is actually made of four different emojis: 👨👩👧👦. When the string was split on 👧, “abc👨‍👩‍👧‍👦” got separated into two parts: “abc👨‍👩” and “‍👦”.</p><p>You can avoid this issue by using the <a href=\"https://pub.dev/documentation/characters/latest/characters/Characters/split.html\">split</a> method on the Characters class, as the following code shows:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5b46ad949913fe2e552b96b9e4c481d6/href\">https://medium.com/media/5b46ad949913fe2e552b96b9e4c481d6/href</a></iframe><h4>Scenario 4: Accessing a specific character by its index</h4><p>In text manipulation, it’s common to access a specific character by its index (i.e., position) in the string. For example, the snippet shows a function that returns initials from the first name and the last name entered by the user in two separate text fields:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e371d9b5ab42d9ef00674fbfbe67f1ef/href\">https://medium.com/media/e371d9b5ab42d9ef00674fbfbe67f1ef/href</a></iframe><p>But as we have demonstrated in the beginning of the article, using the index in a UTF-16-based string could be risky. Let’s verify the correctness of the above code with the test case below:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3fb7b86271c5acee8ea01595305b650f/href\">https://medium.com/media/3fb7b86271c5acee8ea01595305b650f/href</a></iframe><p>Here are the test results:</p><pre>Expected: ‘ÉB’<br>  Actual: ‘EB’<br>    Which: is different.</pre><p>Why did the test fail? It’s because the letter “É” could be a combination of “E” and the accent mark. You can use the characters package to easily avoid this problem:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/d12e3814f04779315e029a167f163ab0/href\">https://medium.com/media/d12e3814f04779315e029a167f163ab0/href</a></iframe><h3>Exercise: Omitting text overflow</h3><p>Now, here’s a challenge for you. In this scenario, the app needs to display a list of messages, one per line. You’re asked to review code that implements a function that displays text overflow as an ellipsis when the message’s length exceeds the given character limit.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b1ac207c4ce81aa6ce5de59c7d12645f/href\">https://medium.com/media/b1ac207c4ce81aa6ce5de59c7d12645f/href</a></iframe><p>Can you come up with a test to reveal a potential issue with this code snippet? How would you rewrite it using the characters package? The answer is at the end of this article.</p><h3>Mitigations and possible long-term solution</h3><p>It’s unreasonable to expect Dart users to stay on high alert for the kinds of pitfalls described above. For example, in an experiment we conducted, 53.7% of Dart users were unable to detect the problem illustrated in the first scenario (counting characters), even though they received two pages of information about the characters package and the problem the package was designed to address just a few minutes before. Therefore, we are taking a two-staged approach to helping developers choose the most appropriate API for their text manipulation needs.</p><p>In the short term, we are introducing a set of mitigations in the Flutter framework and the Dart analyzer to make the characters package easier to discover and invoke in Dart UI programming. This involves a few steps:</p><ol><li>Use the characters package in the internal implementation of the TextField widget. See <a href=\"https://github.com/flutter/flutter/pull/53381\">this PR</a> and <a href=\"https://docs.google.com/document/d/1OOFW0PEZf0orBl445YXJ3nfjyKOqZdmeQ6KU3glUh7s/edit\">this design doc</a> for more details.</li><li>Expose the API of the characters package through the Flutter framework. Once this is done, Flutter users will have a higher chance of discovering the API through the extension method <a href=\"https://pub.dev/documentation/characters/latest/characters/StringCharacters.html\">String.characters</a>, which will show up when doing an autocomplete on String. The status of this work is tracked in this issue: <a href=\"https://github.com/flutter/flutter/issues/55593\">https://github.com/flutter/flutter/issues/55593</a>.</li><li>Update the Flutter framework’s API documentation and sample code to suggest using the <a href=\"https://pub.dev/documentation/characters/latest/characters/Characters-class.html\">Characters</a> class when applicable, such as in the callback for <a href=\"https://api.flutter.dev/flutter/material/TextField/onChanged.html\">TextField.onChanged</a>. This work is tracked in <a href=\"https://github.com/flutter/flutter/issues/55598\">https://github.com/flutter/flutter/issues/55598</a> with relevant details in <a href=\"https://docs.google.com/document/d/18SxWeHpds4modnvo997vIOiq01EspeFgsNvPa5ey88w/edit#heading=h.1isiu2jji0ae\">this doc</a>.</li><li>Have the Dart analyzer suggest converting a String object to a Characters object when autocompleting a callback template for handling user-entered text. For example, the IDE could fill out everything in the snippet below after the user autocompletes on onChanged. This work is tracked in <a href=\"https://github.com/dart-lang/sdk/issues/41677\">https://github.com/dart-lang/sdk/issues/41677</a>.</li></ol><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/9932db108b65a8c3696bd2277e886972/href\">https://medium.com/media/9932db108b65a8c3696bd2277e886972/href</a></iframe><p>Those mitigations can help, but they are limited to string manipulations performed in the context of a Flutter project. We need to carefully measure their effectiveness after they become available. A more complete solution at the Dart language level will likely require migration of at least some existing code, although a few options (for example, <a href=\"https://github.com/dart-lang/language/issues/42\">static extension types</a>) <em>might</em> make breaking changes manageable. More technical investigation is needed to fully understand the trade-offs.</p><h3>How you can help</h3><p>Please help us raise awareness of how to fix string issues using the characters package:</p><ul><li>Look for instances of using String.length or String.substring in your own code. If the string might have originated from user input, try to rewrite the code using the characters package.</li><li>Share this post with others in the Dart community.</li><li>Try to update <a href=\"https://stackoverflow.com/search?q=%5Bdart%5D+or+%5BFlutter%5D+String\">existing answers about Dart text manipulation</a> on StackOverflow. If the accepted answers missed this limitation of the String API, remind people of the risk.</li><li>Comment on the GitHub issues listed above to let us know your thoughts and opinions.</li></ul><p>Now, happy coding 😉!</p><h3>Acknowledgments</h3><p>Thanks to <a href=\"https://medium.com/@kathyw_39223\">Kathy Walrath</a>, <a href=\"https://medium.com/@lrhn\">Lasse Nielsen</a>, and <a href=\"https://medium.com/@mit.mit\">Michael Thomson</a> for reviewing this article. I would also like to thank developers who participated in our user research. Their participation helped the Dart and Flutter teams better understand the challenge of dealing with this limitation of the Dart String API.</p><p>— — —</p><p>PS: Here is the solution for the exercise:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/d8e1d13b3627140dbcef720a0fa66faf/href\">https://medium.com/media/d8e1d13b3627140dbcef720a0fa66faf/href</a></iframe><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5abd0668ba3e\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-string-manipulation-done-right-5abd0668ba3e\">Dart string manipulation done right 👉</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-12-07T17:02:58.000Z":{"title":"Why nullable types?","link":"https://medium.com/dartlang/why-nullable-types-7dd93c28c87a?source=rss----23738d481ce8---4","guid":"https://medium.com/p/7dd93c28c87a","category":["programming-languages","developer-experience","dart"],"dc:creator":"Bob Nystrom","pubDate":"Mon, 07 Dec 2020 17:02:58 GMT","atom:updated":"2020-12-07T17:02:57.383Z","content:encoded":"<p>A few weeks ago, we announced Dart null safety beta, a major productivity feature intended to help you avoid null errors. Speaking of null values, in the /r/dart_lang subreddit <a href=\"https://www.reddit.com/r/dartlang/comments/jruhji/why_does_nnbd_dart_still_have_null/gbwi364/\">a user recently asked</a>:</p><blockquote>But why do we even still have/want null values? Why not get rid of it completely? I’m currently also playing around with Rust and it doesn’t have null at all. So it seems to be possible to live without it.</blockquote><p>I love this question. Why <em>not</em> get rid of null completely? This article is an expanded version of what I answered on that thread.</p><p>The short answer is that, yes, it is entirely possible to live without null, and languages like Rust do. But programmers <em>do</em> use null, so before we can take it away, we need to understand why it’s used. What is null usually <em>doing</em> when we use it in languages that do have it?</p><p>It turns out that null is typically used to represent the <em>absence</em> of a value, which is eminently useful. Some people don’t have middle names. Some mailing addresses don’t have apartment numbers. Some monsters don’t have any treasure to drop when you slay them.</p><p>In cases like that, we want a way to express, “This variable could have a value of type X, or it may have no value at all.” The question then is how do we model that?</p><p>One option is to say that a variable can contain a value of the expected type, or it can contain the magic value null. If we try to use the value when it’s null, we get a runtime failure. This is what Dart did before null safety, what SQL does, what Java does for non-primitive types, and what C# does for class types.</p><p>But failing at runtime sucks. It means our users experience the bug. We programmers would rather find those failures before they do. In fact, we’d be happy if we could find the bugs even before <em>we</em> ran our program. So how do we model the absence of a value in a way that the type system understands? In other words, how do we give “potentially absent” values and “definitely present” values different static types?</p><p>There are two main solutions:</p><ol><li>Use an option or maybe type</li><li>Use a nullable type</li></ol><h3>Solution 1: Option types</h3><p>This is what <a href=\"https://en.wikipedia.org/wiki/ML_(programming_language)\">ML</a> and most functional languages derived from ML (including Rust, Scala, and Swift) do. When we know we will definitely have a value, we just use the underlying type. If we write int it means, “There is definitely an integer here.”</p><p>To express a potentially absent value, we <em>wrap</em> the underlying type in an <a href=\"https://en.wikipedia.org/wiki/Option_type\">option type</a>. So Option&lt;int&gt; represents a value that might be an integer or might be nothing at all. It’s like a collection type that can contain zero or one item.</p><p>From the type system’s perspective, there is no direction relationship between int and Option&lt;int&gt;. Treating these as distinct types means we can’t accidentally pass a potentially-absent Option&lt;int&gt; to something expecting a real int. We also can’t accidentally try to use an Option&lt;int&gt; as if it were an integer since it doesn’t support any of those operations. We can’t perform arithmetic on an Option&lt;int&gt; any more than we could on a List&lt;int&gt;.</p><p>To create a value of an option type from a present value of the underlying type (say 3), you construct the option like Some(3). To create an option type when the value is absent, you write something like None().</p><p>In order to use a potentially absent integer stored in an Option&lt;int&gt;, we have to first check and see if the value is there. If so, we can extract the integer from the option and use it, just like reading a value out of a collection. Languages that have option types usually also have nice <a href=\"https://en.wikipedia.org/wiki/Pattern_matching\">pattern matching</a> syntax, which gives us an elegant way to check if the value is there and use it if so.</p><h3>Solution 2: Nullable types</h3><p>The other option (heh), is what Kotlin, TypeScript, and now Dart do. <a href=\"https://en.wikipedia.org/wiki/Nullable_type\">Nullable types</a> are a special case of <a href=\"https://en.wikipedia.org/wiki/Union_type\">union types</a>.</p><p>(Tangent: The naming gets really confusing here. Option types — what ML and friends do above — are a special case of <a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\">algebraic datatypes</a>. Another name for algebraic datatypes is “discriminated unions”. But, despite “union” being in the name, “discriminated unions” are quite different from “union types”. As Phil Karlton said, there are only two hard problems in computer science: cache invalidation and naming things.)</p><p>Similar to the option type approach, we use the underlying type to represent a definitely present value. So int again means we absolutely have an integer. If we want a potentially absent integer, we instead use the int? nullable type. The little question mark is syntactic sugar for writing what is essentially a union type like int | Null.</p><p>Just like with option types, a nullable type does not support the same operations as the underlying type. The type system won’t let us try to perform arithmetic on a nullable int because that isn’t safe. Likewise, we can’t pass a nullable integer to something that requires an actual integer.</p><p>However, the type system is a little more flexible than with option types. The type system understands that a union type is a supertype of its branches. In other words, int is a subtype of int?. That means we <em>can</em> pass a definitely-present-integer to something that expects a maybe-present-integer since that’s safe to do. It’s an upcast, just like we can pass a String to a function that takes Object. Dart only prohibits us from going the other way—from nullable to non-nullable—because that would be a downcast and those could fail.</p><p>When we have a value of a nullable type and we want to see if there is an actual value or null there, we check the value imperatively just like we would naturally do in C or Java:</p><pre>foo(int? i) {<br>  if (i != null) {<br>    print(i + 1);<br>  }<br>}</pre><p>The language then uses <a href=\"https://en.wikipedia.org/wiki/Control-flow_graph\">flow analysis</a> to determine which parts of the program are guarded behind those checks. The analysis determines that code can only be reached if the variable is not null, so inside those regions, the type system tightens the variable’s type to be non-nullable. So, here, it treats i as having type int inside the if statement.</p><h3>Which solution should a language take?</h3><p>So when we on the Dart team decide to make the language handle null in a safer way, how should we go about choosing solution 1 or 2? We can start by observing our users. How do they want to write code that checks for absent values? In functional languages, pattern matching is one of the primary control flow structures, and users there are very comfortable with it. Using option types and pattern matching is natural in that style.</p><p>In imperative languages derived from C, code like my previous example is the idiomatic way to check for null. Using flow analysis and nullable types makes that familiar code work correctly and safely. In fact, with Dart, we’ve found that <em>most existing code is already statically null safe with the new type system</em> because the new flow analysis correctly analyzes the already written code.</p><p>(This is in some ways not a surprise. <em>Most</em> code is already <em>dynamically</em> correct with regards to handling null. If it wasn’t, it would be crashing all the time. Much of the job is simply making the type system smart enough to see that that code is already correct, so that the user’s attention is drawn to the few bits that are <em>not</em>.)</p><p>So if our goal is to maximize familiarity and user comfort (which <em>are</em> important criteria in language design), we should just follow the path that our language’s control flow structures lay out for us.</p><h3>Representing absence and presence</h3><p>There is a deeper way to approach this question based on differences between how option types and nullable types are represented. That representation difference forces a few key trade-offs on us, and those might lean us in one direction or the other.</p><p>With the first approach, a value of option type has a runtime representation distinct from the underlying value. Say we chose option types in Dart, and you created one and then upcast it to Object:</p><pre>var optionalInt = Some(3);<br>Object obj = optionalInt;<br>print(obj is int); // false</pre><p>Note the last line. An Option&lt;int&gt; value, even when present, is <em>not</em> the same kind of thing as a value of the underlying type. Some(3) and 3 are distinct, distinguishable values.</p><p>That’s not how nullable types work:</p><pre>var nullableInt = 3 as int?;<br>Object obj = nullableInt;<br>print(obj is int); // true</pre><p>Nullable types exist in the <em>static type system</em>, but the runtime representation of values uses the underlying type. If you have a “nullable 3”, at runtime it’s just the number 3. If you have an absent value of some nullable type, at runtime you just have the solitary magic value null.</p><p>You can ask if a value is of a nullable type:</p><pre>print(obj is int?);</pre><p>But the is int? expression is equivalent to:</p><pre>print(obj is int || obj is Null);</pre><h3>Nested optionals</h3><p>Since values of option types are different from the underlying type, this gives us an important capability: Option types can nest.</p><p>Let’s say we have some network service that gives out resource strings when given a request with some integer ID. Some resources are not present and the server will respond with no data for that ID. Since hitting the network is slow, we want to locally cache the results of requests we’ve already performed.</p><p>In Dart before null safety, we might use a map like so:</p><pre>Map&lt;int, String&gt; cache;</pre><p>So before making a network request for some ID, we use the subscript operator on the cache map to look up the resource’s ID. That operator is defined on Map to return null if the key is not present. But the key could also be present and associated with a null value. If we do a lookup and get back null, it could mean either:</p><ul><li>The key was not present in the map. This means we haven’t done the request yet, so we should ask the server to look up the resource.</li><li>The key was present and associated with null. This means we already did ask the server, found that the resource wasn’t present, and stored that in the cache. We should use that result and not query the server again.</li></ul><p>Because there’s only a single null value in the entire system, we don’t have a runtime representation that can distinguish these two cases. This is why the Map class has a separate containsKey() method. That API provides a way to distinguish these two cases.</p><p>Now, if Dart were built around option types, the cache would look like:</p><pre>Map&lt;int, Option&lt;String&gt;&gt; cache;</pre><p>And the subscript operator would return an optional value:</p><pre>class Map&lt;K, V&gt; {<br>  Option&lt;V&gt; operator [](K key) =&gt; ...<br>  ...<br>}</pre><p>In the case of our Map&lt;int, Option&lt;String&gt;&gt;, that means the return type is Option&lt;Option&lt;String&gt;&gt;. Note the nesting! Now, when we look up a key in the cache, we can get a few different results:</p><ul><li>A Some(Some(string)) means the resource did exist on the server, and we have it in the cache now.</li><li>A Some(None()) means we did ask the server and the resource was not there, so we have cached the fact that the resource doesn’t exist.</li><li>A None() means the cache does not contain this ID at all.</li></ul><p>We can distinguish the last two cases because options always wrap their underlying value in some extra state. At runtime, we can determine how many layers there are and peel them off individually.</p><p>Nullable types, since they have no explicit runtime representation, are implicitly flattened. So int? and int?? are equivalent types to the type system and have equivalent sets of values at runtime. This is why fans of option types describe them as “more expressive”: because optional types give you a way to represent more kinds of values than nullable types do.</p><h3>Nullable substitution</h3><p>Another way of thinking about “expressiveness” is how much <em>effort</em> it takes for the user to express what they actually want to express. A language is more expressive if the user can reach their goal while jumping through fewer hoops.</p><p>An advantage of having no distinct representation for nullable types is that values can flow from non-nullable to nullable contexts much more easily. Let’s say you have a function that accepts an optional integer parameter. With option types, the signature would look something like:</p><pre>takesMaybeInt(Option&lt;int&gt; optionalInt) {}</pre><p>To call this function with a known integer, it must be wrapped in an option first:</p><pre>takesMaybeInt(Some(3));</pre><p>With nullable types, since there is no representation difference, you can pass a value of the underlying type directly:</p><pre>takesMaybeInt(3);</pre><p>You get this flexibility everywhere in the type system. You can override a method that returns a nullable type to return a non-nullable type. You can pass a List&lt;int&gt; to a function that wants a List&lt;int?&gt;.</p><p>So while nullable types lose the ability to nest and represent multiple distinct <em>kinds</em> of “absence”, in return they make it much easier to work with the one blessed notion of null.</p><h3>Nullability for Dart</h3><p>Dart is an imperative language where people already use if statements to check for absent values at runtime. It’s also an object-oriented language where we already have a special null value with its own runtime representation. So solution 2, nullable types, was the natural answer for us. It lets our users write the kind of code they are familiar with, and takes advantage of how the runtime already represents values.</p><p>For more information about nullability in Dart, check out the <a href=\"https://dart.dev/null-safety#where-to-learn-more\">Where to learn more</a> section of the <a href=\"https://dart.dev/null-safety\">Dart null safety docs</a>.</p><figure><img alt=\"A photo of an all-white jigsaw puzzle with one piece missing, revealing a black background.\" src=\"https://cdn-images-1.medium.com/max/1024/1*ihpy1Ngzg7SczCKkuh_WhQ.jpeg\" /><figcaption>One of these puzzle pieces is null.</figcaption></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7dd93c28c87a\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/why-nullable-types-7dd93c28c87a\">Why nullable types?</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-11-19T16:01:37.000Z":{"title":"Announcing Dart null safety beta","link":"https://medium.com/dartlang/announcing-dart-null-safety-beta-87610fee6730?source=rss----23738d481ce8---4","guid":"https://medium.com/p/87610fee6730","category":["dart","flutter","nullpointerexception","announcements","programming"],"dc:creator":"Michael Thomsen","pubDate":"Thu, 19 Nov 2020 16:01:37 GMT","atom:updated":"2020-11-19T16:01:54.279Z","content:encoded":"<h4>Beginning the journey to migrate packages to a sound, safer state</h4><p><em>Cross-posted here and on the </em><a href=\"https://medium.com/flutter\"><em>Flutter blog</em></a><em>.</em></p><p>Today we’re announcing that <strong>sound null safety is available in beta</strong> for Dart and Flutter. Null safety is our latest major productivity feature, intended to <a href=\"https://dart.dev/null-safety\">help you avoid null errors</a>, a class of bugs that are often hard to spot. If you’re looking for a quick summary of why we’re excited about null safety, check out this new video:</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FiYhOU9AuaFs%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DiYhOU9AuaFs&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FiYhOU9AuaFs%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/34cc7c47f5441fbc839569d7a3cee7be/href\">https://medium.com/media/34cc7c47f5441fbc839569d7a3cee7be/href</a></iframe><p>With null safety graduating to beta, <strong>it’s time to start community migration</strong> of the thousands of packages available on <a href=\"https://pub.dev/\">pub.dev</a>. We’ve migrated the Dart core libraries, the Flutter framework, and <a href=\"https://pub.dev/packages?q=&amp;prerelease-null-safe=1\">more than 40</a> Dart and Flutter packages. With that we hope to see the community embrace null safety by migrating their packages.</p><figure><img alt=\"Timeline of Dart sound null safety support, from Technical Preview 1 to Stable in early 2021\" src=\"https://cdn-images-1.medium.com/max/960/1*kr-aQjGvnhY0JDCx1CGzRg.png\" /></figure><p>With beta, we’re also starting the home stretch before shipping a stable version of the null safety feature. We hope that you’ll use the feature and let us know if parts of it can be improved, if UI messages can be made easier to understand, or if documentation can be made clearer. We’re <strong>really looking forward to </strong><a href=\"https://github.com/dart-lang/sdk/issues/new?title=Null%20safety%20feedback:%20[issue%20summary]&amp;labels=NNBD&amp;body=Describe%20the%20issue%20or%20potential%20improvement%20in%20detail%20here\"><strong>your feedback</strong></a>.</p><h3>Opting in to null safety</h3><p>Before we discuss null safety migration, it’s important to repeat that (as stated in our <a href=\"https://dart.dev/null-safety#null-safety-principles\">null safety principles</a>) you’re in control of when to begin null safety adoption. Apps and packages will only run with null safety if their minimum <a href=\"https://dart.dev/null-safety#enable-null-safety\">Dart SDK constraint</a> is at least a Dart 2.12 prerelease:</p><pre>environment:<br>  sdk: &quot;<strong>&gt;=2.12.0-0</strong> &lt;3.0.0&quot;</pre><p>To experience this, try to create a small null-safe hello app (for example, using dart create) containing code like shown below. You can then try to run the app both before and after changing the SDK constraint and running dart pub get, and experience how the program behavior changes. (Make sure to use an SDK that reports 2.12 in dart --version.)</p><pre><strong><em>bin/hello.dart:<br></em></strong>...<br>void main() {<br>  var hello = &#39;Hello Dart developers&#39;;<br>  if (someCondition) {<br>    hello = null;<br>  }<br>  print(hello);<br>}</pre><pre><strong><em>Before changing the SDK constraint:<br></em></strong>$ dart run</pre><pre>null</pre><pre><strong><em>After changing the SDK constraint (and running dart pub get):<br></em></strong>$ dart run</pre><pre>bin/hello.dart:6:13: Error: Null can&#39;t be assigned to a variable of type &#39;String&#39; because &#39;String&#39; is not nullable.</pre><pre>    hello = null;<br>            ^</pre><h3>Migrating to null safety</h3><p>To migrate a package (or simple app) to null safety, follow these five steps, which are fully documented in the <a href=\"https://dart.dev/null-safety/migration-guide\">migration guide</a> on dart.dev.</p><h4>Step 1: Check if your dependencies are ready</h4><p>We strongly recommend migrating code in order, with the leaves of the dependency graph being migrated first. For example, if C depends on B which depends on A, migrate A to null safety first, then B, then C. This order applies whether A, B, and C are libraries, packages, or apps.</p><figure><img alt=\"Illustration of dependency order vs. migration order\" src=\"https://cdn-images-1.medium.com/max/454/0*fM8TG0L56zVeJVlG\" /></figure><p>Why is the order important? Although you can make some progress migrating code before your dependencies migrate, you risk having to do a second migration pass if your dependencies change their APIs during their migration. If a few of your dependencies aren’t null safe, consider reaching out to the package publishers using the contact details listed for each package on pub.dev.</p><h4><em>Verifying that dependencies are ready</em></h4><p>To verify whether your app or package is ready to begin migration, you can use dart pub outdated in null-safety mode. The example below shows that this app is ready to migrate if it upgrades its dependencies to the prerelease versions of path, process, and pedantic as listed in the <strong>Resolvable</strong> column.</p><figure><img alt=\"Screenshot of `dart pub outdated` output\" src=\"https://cdn-images-1.medium.com/max/1024/0*zrUdYSzsjWZGr7Or\" /></figure><p>If null safety support is available in minor new versions, you’ll see those in the <strong>Upgradable</strong> column. Often null safety support will be available in major new versions; in that case you’ll see the versions listed under <strong>Resolvable</strong> in the outdated output. To upgrade to those, edit your pubspec.yaml file to allow those major versions. For example, you might change<br>process: ^3.0.13 to process: ^4.0.0-nullsafety.</p><p>You can also find packages with null safety support on pub.dev using the new <strong>Null safety</strong> tags on package pages (for example <a href=\"https://pub.dev/packages/collection/versions/1.15.0-nullsafety.5\">collection 1.15</a>) and a new <strong>Advanced</strong> <strong>search</strong> <a href=\"https://pub.dev/packages?q=&amp;prerelease-null-safe=1\">null safety search option</a>.</p><figure><img alt=\"Screenshot of pub.dev search\" src=\"https://cdn-images-1.medium.com/max/1024/1*P2ufPitLRaJRAD__KUfbvg.png\" /></figure><h4>Step 2: Migrate using the migration tool</h4><p>If your dependencies are ready, you can proceed to migrating your app or package using the migration tool, dart migrate.</p><p>The migration tool is interactive, so you can review the nullability properties that the tool has inferred. If you disagree with any of the tool’s conclusions, you can add nullability hints to change the inference. Adding a few migration hints can have a huge impact on migration quality.</p><figure><img alt=\"Screenshot of the migration tool UI\" src=\"https://cdn-images-1.medium.com/max/1024/0*dPlSded52Mt6P5tY\" /></figure><p>We’ve had a small number of Dart package authors test-drive migration using early preview builds of null safety, and their feedback has been encouraging. The migration guide has additional tips on how to use the migration tool.</p><h4>Step 3: Statically analyze your migrated code</h4><p>Update your packages using pub get in your IDE or on the command line. Then use your IDE or the command line to perform static analysis on your Dart code:</p><pre>$ dart pub get<br>$ dart analyze</pre><p>Or on your Flutter code:</p><pre>$ flutter pub get<br>$ flutter analyze</pre><h4>Step 4: Ensure tests pass</h4><p>Run your tests and make sure that they pass. You might need to update tests that expect null values, in case you changed your package code to no longer allow nulls.</p><h4>Step 5: Publish your null-safe package</h4><p>When the migration is complete and tests are passing, you can publish your package as a prerelease. Here’s a brief summary of best practices:</p><ul><li>Increment your version number to the next major version (for example, 2.3.x to 3.0.0). This best practice ensures that users of your package don’t upgrade to it before they’re ready to use null safety themselves, and it gives you the freedom to refactor your APIs to best leverage null safety.</li><li>Version and publish your package as a <a href=\"https://dart.dev/tools/pub/publishing#publishing-prereleases\">prerelease version on pub.dev</a>. (For example, use 3.0.0-nullsafety.0, not 3.0.0.)</li></ul><p>For full details on migration and versioning, see the <a href=\"https://dart.dev/null-safety/migration-guide\">migration guide</a>.</p><h3>The benefits of sound null safety</h3><p>Our previous blog posts for the technical previews of null safety <a href=\"https://medium.com/dartlang/announcing-sound-null-safety-defd2216a6f3\">in Dart</a> and <a href=\"https://medium.com/flutter/null-safety-flutter-tech-preview-cb5c98aba187\">in Flutter</a> have discussed the benefits of null safety via a number of examples. Now that null safety is nearing completion, we’re seeing several real-world examples of this benefit.</p><h4>Safer code</h4><p>Just recently, we <a href=\"https://github.com/flutter/flutter/issues/69863\">discovered a bug</a> in the Flutter master channel where various flutter tool commands would crash on certain machine configurations with a null error: The method &#39;&gt;=&#39; was called on null. The underlying issue was a recent pull request to add support for detecting Android Studio 4.1. That PR added code like this:</p><pre>final int major = version?.major;<br>final int minor = version?.minor;<br>if (globals.platform.isMacOS) {<br>  /// plugin path of Android Studio changed after version 4.1.<br>  if (major &gt;= 4 &amp;&amp; minor &gt;= 1) {<br>    ...</pre><p>Can you spot the error? Because the version may be null, both major and minor may be null also. This bug may seem easy to spot here in isolation, but in practice code like this slips through all the time, even with a rigorous code review process like the one used in the Flutter repo. With null safety, static analysis <a href=\"https://dartpad.dev/0e9797be7488d8ec6c3fca92b7f2740f\">catches this issue immediately</a>:</p><figure><img alt=\"Screenshot of analysis output in an IDE\" src=\"https://cdn-images-1.medium.com/max/1024/0*AwqXx58arqVt6PhL\" /></figure><p>That was a pretty simple error. During our early use of null safety in code internally at Google, we’ve seen much more intricate errors be caught and then resolved via null safety. Here are a few examples:</p><ul><li>An internal team found that they were often checking for null values in code that null safety knew could never be null. This problem was most frequently seen in code using <a href=\"https://developers.google.com/protocol-buffers\">protobuf</a>, where optional fields return a default value when unset, and never null. This caused code to incorrectly check for the default condition, by confusing default values and null values.</li><li>The Google Pay team found bugs in their Flutter code where they would fail when trying to access Flutter State objects outside of the context of a Widget. Before null safety, those would return null and mask the error; with null safety, the sound analysis determined that those properties could never be null, and threw an analysis error.</li><li>The Flutter team found a bug where the Flutter engine could potentially crash if null was passed to the scene parameter in Window.render(). During null safety migration, they added a hint to <a href=\"https://github.com/cbracken/engine/blob/bad869e229a8a02cad6e63d12e80807b33b5c12f/lib/ui/window.dart#L1069\">mark Scene as non-nullable</a>, and were then able to easily prevent potential app crashes that null would have triggered if passed.</li></ul><h4>Leveraging sound null safety during compilation</h4><p>The soundness of Dart’s null safety has another welcome implication: it means the Dart compilers can leverage the nullability information. This can potentially make your programs smaller and faster. We don’t have a lot of real-world apps fully migrated to sound null safety yet (as we’re just now kicking off the ecosystem migration of packages that these apps depend on for soundness), but we’re seeing very encouraging results from the core framework.</p><p>We recently did a test recompilation of the <a href=\"https://github.com/flutter/flutter/blob/master/examples/hello_world/lib/main.dart\">hello_world</a> sample to measure the impact of null safety on app size.This is a minimal example that simply displays “hello world”. In <a href=\"https://gist.github.com/mit-mit/64e160f9dc3bf6c69c7ef2f81384594a\">comparing </a>the overall size of the compiled code, the uncompressed (installed on device) code size shrank by 3.5% without doing anything but recompiling with sound null safety. This was possible, despite this app being just 10 lines of code, because the code size of all included libraries shrank; for example the Flutter framework itself (package:flutter) shrank by 3.9%.</p><p>As for code speed, having to enforce a sound type system potentially adds overhead. However, having fewer null checks also potentially makes the code faster. Our initial analysis of benchmarks shows that performance is on par with previous releases, and that the new additional type information creates the potential for us to do new kinds of performance improvements in the future. We plan on writing more about our performance work in future blog posts.</p><p>In some cases we’ve already seen null safety lead to performance gains, typically when migration to null safety has uncovered a flaw in the code logic. For example, we found an issue in the Flutter web text layout cache. This cache was using a key that was nullable, and then some logic to use TextAlign.start when null. This logic caused a flaw in the cache where elements would look like they had changed even though they still had a default value. As a result, there were frequent cache misses. Adding a non-nullable textAlign getter helped fix the caching flaw, resulting in a <strong>14x increase</strong> of text rendering performance in cases where the text is cached.</p><h3>Get started today!</h3><p>Beta versions of Dart and Flutter that contain null safety are ready today. If you develop with Flutter, you can switch to beta with flutter channel beta followed by flutter upgrade. Otherwise, you can get the standalone Dart SDK from the <a href=\"https://dart.dev/tools/sdk/archive#beta-channel\">Dart SDK archive</a>.</p><p>If you develop packages, we encourage you to read our <a href=\"https://dart.dev/null-safety/migration-guide\">migration guide</a> and plan your migration. Please <a href=\"https://github.com/dart-lang/sdk/issues/new?title=Null%20safety%20feedback:%20[issue%20summary]&amp;labels=NNBD&amp;body=Describe%20the%20issue%20or%20potential%20improvement%20in%20detail%20here\">let us know</a> about any issues or suggestions you have.</p><p>If you’re an app developer, you may prefer to delay migration until the feature is in our stable channels. We plan on addressing the feedback from beta quickly, fixing any remaining issues. It’s hard to state a concrete timeline for when null safety will be in a stable release, but we’re thinking early next year.</p><p>Thanks for your support and feedback as we work to make Dart a more robust language, and Flutter a stronger framework!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=87610fee6730\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-null-safety-beta-87610fee6730\">Announcing Dart null safety beta</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-10-01T15:01:58.000Z":{"title":"Announcing Dart 2.10","link":"https://medium.com/dartlang/announcing-dart-2-10-350823952bd5?source=rss----23738d481ce8---4","guid":"https://medium.com/p/350823952bd5","category":["flutter","null-safety","dart","announcements"],"dc:creator":"Michael Thomsen","pubDate":"Thu, 01 Oct 2020 15:01:58 GMT","atom:updated":"2020-10-01T15:01:56.888Z","content:encoded":"<p><em>A new, unified </em><em>dart tool for all core tasks. Also, an update on null safety timelines and migration principles.</em></p><p><em>By: </em><a href=\"https://medium.com/u/a6d788faa5e5\"><em>Michael Thomsen</em></a><em> &amp; </em><a href=\"https://medium.com/u/441fe70f4b5e\"><em>Kevin Moore</em></a></p><p>Today we’re announcing a new release of Dart, version 2.10 (<em>two-dot-ten</em>). This release features a new, unified Dart developer tool: a single tool for all your developer needs like creating projects, analyzing and formatting code, running tests, and compiling apps. We also have an update on the null safety roadmap and timelines, and a discussion of the principles for migrating existing code to null safety.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*9wrenixSu1viOYLF1nWhAw.jpeg\" /></figure><h3>A new, unified Dart developer tool</h3><p>Dart forms the foundation of the Flutter SDK: it not only provides the language and runtimes that power Flutter apps, but also supports many core developer tasks like formatting, analyzing, and testing code. However, while Flutter has a single, general-purpose developer tool (the flutter command), Dart has historically had many smaller developer tools (for example, dartfmt and dartanalyzer). Dart 2.10 has a new, unified dart developer tool that’s very similar to the flutter tool. This new tool supports all common tasks, such as creating new projects and packages; analyzing and formatting code; and running, compiling, and testing projects. To use the tool, simply run the dart command:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*y-udLgjneGgP-y8UATZrlw.png\" /><figcaption>Learn about the 2.10 dart tool by running dart help.</figcaption></figure><p>Flutter includes this new Dart tool in the Flutter SDK. Starting with today’s <a href=\"https://medium.com/flutter/announcing-flutter-1-22-stable-44f146009e5f\">Flutter 1.22 SDK</a>, the &lt;flutter-sdk&gt;/bin directory (which you likely have in PATH) contains both flutter and dart commands. If you do both Flutter and general-purpose Dart development, you get both developer experiences from a single Flutter SDK, without needing to install anything else.</p><blockquote><strong>Note: </strong>If you want to download and install a second Dart SDK (perhaps because you require a different version), make sure the SDK of the dart tool you wish to default to is at the beginning of your PATH environment variable.</blockquote><p>Over the coming stable releases, we plan to add more to this dart tool and gradually deprecate the smaller tools (dartdoc, dartfmt, dartanalyzer, etc.). Next year we expect to ship Dart SDKs that contain only the single dart tool. We recommend that you switch over to the new tool when running Dart commands now, whether manually in the terminal or in continuous integration (<em>CI</em>) scripts, and <a href=\"https://github.com/dart-lang/sdk/issues/new?labels=area-dart-cli\">give us feedback</a> if anything is missing or not working as intended.</p><h3>Looking forward to null safety</h3><p>We’ve experienced a strong interest in null safety since we launched our <a href=\"https://medium.com/dartlang/announcing-sound-null-safety-defd2216a6f3\">first technical preview</a> a few months back. We’re all looking forward to null safety as a tool for avoiding hard-to-spot null errors, and as an added bonus the performance improvements that we expect to see with sound null safety. If you’re keen to learn more, we recommend our new <a href=\"https://dart.dev/null-safety/understanding-null-safety\">Understanding null safety</a> page. If you prefer a short video, check out <a href=\"https://www.youtube.com/watch?v=ZxSyZHq8gUg&amp;feature=youtu.be&amp;list=PLjxrf2q8roU1rBlI9vz01K2324nzIhYgp&amp;t=322\">the null safety video</a> from the <a href=\"https://events.withgoogle.com/flutter-day/#content\">Flutter Day event</a> a few months ago.</p><p>When might null safety be ready to use? Here is the current timeline:</p><ol><li><strong>Flutter experimentation with <em>technical preview 2</em></strong>: We’ve successfully migrated most parts of Flutter. Soon — likely within the next month — we expect to have the complete Flutter framework migrated, and thus be ready to enable experimental use with Flutter. You’ll be able to try null safety in a Flutter sample, and to do trial migration of your Flutter apps and packages. You’ll need to pass an <a href=\"https://dart.dev/tools/experiment-flags\">experiment flag</a>, shouldn’t use it in production, and shouldn’t publish any migrated packages.</li><li><strong>Early package migration with <em>beta</em></strong>: Later this year, we’ll complete performance tuning and have sufficient test coverage to give us confidence that the feature works as intended, and that backwards compatibility is solid. At that time we’ll publish a beta version of the feature, and you won’t need to pass the experiment flag. We hope to see package owners begin migration of their packages to null safety, with that one last round of validation that the feature is ready for a stable release.</li><li><strong>Production use with <em>stable</em></strong>: Depending on the feedback from the beta launch, we’ll fix any remaining issues and then publish to stable. It’s hard to state a concrete timeline for this, but we’re thinking early next year. Once the feature is stable, we hope to see lots of adoption of null safety, with null-safe apps published to stores, and many null-safe packages published to pub.dev in stable versions.</li></ol><h3>Principles for migrating to null safety</h3><p>We’d like to share our guiding principles for null safety migration.</p><h4>Adopt when you’re ready</h4><p>Null safety is a fundamental change to the Dart typing system. It changes the basics of variable declarations because <a href=\"https://medium.com/dartlang/announcing-sound-null-safety-defd2216a6f3\">we decided</a> to make variables non-nullable by default:</p><pre><strong>Without null safety  </strong>               W<strong>ith null safety</strong></pre><pre>String s; // A String or null.      String s; // A String, not null.</pre><p>Such a fundamental change would be extremely disruptive if we insisted on forced adoption. We want to let <em>you</em> decide when the time is right, so null safety is an opt-in feature: you’ll be able to use the latest Dart and Flutter releases without being forced to enable null safety before you’re ready to do so. You can even depend on packages that have already enabled null safety from an app or package that hasn’t yet.</p><h4>Adopt incrementally, in order</h4><p>We strongly recommend migrating code in order, with the leaves of the dependency graph being migrated first. For example, if C depends on B which depends on A, migrate A to null safety first, then B, then C. This order applies whether A, B, and C are libraries, packages, or apps.</p><p>Why is the order important? Although you can make some progress migrating code before your dependencies migrate, you risk having to do a second migration pass if your dependencies change their APIs during their migration. We will provide tools to help you find out which of your dependencies have migrated. If you’re a package author, then to avoid the risk of breaking your APIs, wait until all of your dependencies have migrated before you publish a null-safe version.</p><h4>Use automated tools to reduce migration cost</h4><p>When your dependencies are ready and you choose to do the migration, you can use our migration tool. The tool works by analyzing all of your existing code, looking for which declarations can be non-nullable (left unchanged), and which must be nullable (need a ? nullability marker on the declaration).</p><p>The migration tool is interactive, so you can review the nullability properties that the tool has inferred. If you disagree with any of the tool’s conclusions, you can add nullability hints to change the inference. For example, if you want to make an API non-nullable even though some refactoring will be needed, you can tell the tool and rerun the migration analysis. Adding a few migration hints can have a huge impact on migration quality.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*wqrweNI-0SK9DB0z\" /></figure><h4>Get full benefit with full use</h4><p>Once <em>all</em> of your code — and the packages it depends on — is migrated, your code can be executed with <em>sound</em> null safety. Before that, your code will continue to run and compile as it does today, but fully sound null safety enables full runtime verification and compiler optimization. Running tests with sound null safety helps you avoid issues with runtime null assertions, and compiling your applications with sound null safety ensures that you get current and future optimizations, such as smaller compiled output and faster execution.</p><h3>Next steps</h3><p>The new dart developer tool is available today in the Dart 2.10 SDK and in the Flutter 1.22 SDK. If you already have a Flutter SDK, you can get a Dart SDK with a dart command simply by running flutter upgrade; this will give you the Flutter 1.22 SDK, which has Dart 2.10 embedded. We recommend that you switch over to the new dart tool immediately, and that you <a href=\"https://github.com/dart-lang/sdk/issues/new?labels=area-dart-cli\">give us feedback</a> if anything is missing or not working as intended.</p><p>We’ll have more news about null safety soon — very likely within the next month, when we expect our friends in the Flutter team to have a null-safety-enabled Flutter framework ready for experimentation. Keep an eye on the <a href=\"https://medium.com/flutter\">Flutter blog</a> for an update. In the meantime you can experiment with null-safe Dart code using <a href=\"https://nullsafety.dartpad.dev/3d9c1769de7912c654bc5d132aff60ac\">DartPad with Null Safety</a>, and learn more about the feature design by reading our <a href=\"https://dart.dev/null-safety\">null safety documentation</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=350823952bd5\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-2-10-350823952bd5\">Announcing Dart 2.10</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-09-15T22:42:00.000Z":{"title":"Exploring collections in Dart","link":"https://medium.com/dartlang/exploring-collections-in-dart-f66b6a02d0b1?source=rss----23738d481ce8---4","guid":"https://medium.com/p/f66b6a02d0b1","category":["dart","data-structures","programming-languages"],"dc:creator":"John Ryan","pubDate":"Tue, 15 Sep 2020 22:42:00 GMT","atom:updated":"2020-09-18T16:30:19.605Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*NLasdGsxG6bBzWYfe_9UJA.jpeg\" /></figure><p>If you have ever called add(), addAll(), map(), or toList() to build a list or map, you might want to check out <em>collection if</em>, <em>collection for</em>, and <em>spreads</em>. Last year, Dart <a href=\"https://medium.com/dartlang/announcing-dart-2-3-optimized-for-building-user-interfaces-e84919ca1dff\">added these features in version 2.3</a>.</p><p>In this article, we’ll look at collections, explore these new features, and see some interesting examples. By mastering these features, you can make your code more succinct and easier to read.</p><h3>Collections</h3><p>First, we need to understand what a collection is. A <a href=\"https://api.dart.dev/stable/dart-core/dart-core-library.html#collections\">collection</a> is an object that contains other objects. For example:</p><ul><li><strong>List</strong>: an ordered collection of objects with a length (also called an <em>array</em>)</li><li><strong>Set</strong>: an unordered collection of unique objects</li><li><strong>Map</strong>: an unordered collection of key-value pairs</li><li><strong>Queue</strong>: an ordered collection that can add/remove objects on both ends</li><li><strong>SplayTreeMap</strong>: an ordered collection of key-value pairs based on a self-balancing binary tree</li></ul><p>These types are available in the <a href=\"https://api.dart.dev/stable/dart-collection/dart-collection-library.html\">dart:collection</a> package. For even more collection types, check out <a href=\"https://pub.dev/packages/collection\">package:collection</a> on pub.dev.</p><p>Each of these collection types implements <a href=\"https://api.dart.dev/stable/dart-core/Iterable-class.html\">Iterable</a>, which provides common behavior like running a function on each object in the collection, getting the first object, determining the length of the collection, and more.</p><h3>Collection literals</h3><p>Dart supports syntax for constructing three types of collections: list literals ([]), map literals ({}) and set literals (also {}).</p><p>Here’s a list literal:</p><pre>List&lt;String&gt; getArtists() {<br>  return [<br>    &#39;Picasso&#39;,<br>    &#39;Warhol&#39;,<br>    &#39;Monet&#39;,<br>  ];<br>}</pre><p>Here’s a map literal:</p><pre>Map&lt;String, String&gt; getArtistsByPainting {<br>  return {<br>    &#39;The Old Guitarist&#39;: &#39;Picasso&#39;,<br>    &#39;Orange Prince&#39;: &#39;Warhol&#39;,<br>    &#39;The Water Lily Pond&#39;: &#39;Monet&#39;,<br>  };<br>}</pre><p>And here’s a set literal, added in Dart 2.3:</p><pre>Set&lt;String&gt; getArtistsSet() {<br>  return {<br>    &#39;Picasso&#39;,<br>    &#39;Warhol&#39;,<br>    &#39;Monet&#39;,<br>  };<br>}</pre><p>If you’re wondering why maps and sets can use the same {} syntax, it’s because Dart uses <a href=\"https://dart.dev/guides/language/type-system#type-inference\">type inference</a> to differentiate. The type system determines the type based on the type of parameters a and b. It can usually determine this based on the contents—for example, {1} is obviously a Set, and {1: 2} is obviously a Map.</p><blockquote><strong>Note:</strong> Using {} constructs a map by default. To create a set, you can use a generic type annotation: &lt;String&gt;{}. Using two generic type parameters creates a map: &lt;String, String&gt;{}.</blockquote><h3>Types of elements</h3><p>Each item in a collection literal is usually a value or an expression, but can also be one of these new features: a <em>collection if</em>, <em>collection for</em>, or <em>spread</em>. All of these are called <em>elements</em>.</p><p>Each element unpacks zero or more items and puts them in the surrounding collection. For example, a string literal (say, &quot;oatmeal&quot;) results in one item, but a <em>collection for</em> unpacks 0 or more items. These features can also be combined in interesting ways, as we’ll explore below.</p><h4>Spreads</h4><p>A <em>spread</em> takes a collection (for example, a list) and puts its contents into the surrounding collection:</p><pre>List&lt;String&gt; combineLists(List&lt;String&gt; a, List&lt;String&gt; b) {<br>  return [<br>    ...a,<br>    ...b,<br>  ];<br>}</pre><p>The preceding code is equivalent to this:</p><pre>List&lt;String&gt; combineLists(List&lt;String&gt; a, List&lt;String&gt; b) {<br>  var list = [];<br>  list.addAll(a);<br>  list.addAll(b);<br>  return list;<br>}</pre><p>You can also use spreads in map and set literals:</p><pre>Map&lt;String, String&gt; combineMaps(Map&lt;String, String&gt; a, Map&lt;String, String&gt; b) {<br>  return {<br>    ...a,<br>    ...b,<br>  };<br>}</pre><pre>Set&lt;String&gt; combineSets(Set&lt;String&gt; a, Set&lt;String&gt; b) {<br>  return {<br>    ...a,<br>    ...b,<br>  };<br>}</pre><p>In both maps and sets, the contents of b overwrite the contents in a when there’s a conflict. For example, calling combineMaps({&#39;foo&#39;: &#39;bar&#39;}, {&#39;foo&#39;: &#39;baz&#39;}) results in a map containing {&#39;foo&#39;: &#39;baz&#39;}.</p><h4>Null-aware spreads (…?)</h4><p>A <em>null-aware spread</em> adds the contents to the collection only if the expression after the operator is non-null:</p><pre>List&lt;String&gt; combineIfExists(List&lt;String&gt; a, List&lt;String&gt; b) {<br>  return [<br>    ...?a,<br>    ...?b,<br>  ];<br>}</pre><pre>void main() {<br>  var result = combineIfExists([&#39;foo&#39;], null);<br>  print(result); // [foo]<br>}</pre><h4>Collection if</h4><p>Use the if, else, and else if keywords to add something to a collection based on a condition. Here’s an example of using <em>collection if</em>:</p><pre>class Article {<br>  String title;<br>  DateTime date;</pre><pre>  Article(this.title, this.date);</pre><pre>  String toString() {<br>    return [<br>      if (title != null) title,<br>      date.toString(),<br>    ].join(&#39;, &#39;);<br>  }<br>}</pre><p>The else keyword can be added on the end:</p><pre>String toString() {<br>  return [<br>     if (title != null) title else &#39;(no title)&#39;,<br>  ].join(&#39;, &#39;);<br>}</pre><p>Notice where the comma is. The comma can’t be after title because the else is part of the same element. Keeping the if and else together before the comma is what keeps them separate from the next element in the collection.</p><p>Adding an else if works too:</p><pre>String toString() {<br>  return [<br>    if (title != null) title else &#39;(no title)&#39;,<br>    if (date == null)<br>      &#39;(no date)&#39;<br>    else if (date.year == DateTime.now().year)<br>      &#39;this year&#39;<br>    else<br>      &#39;${date.year}&#39;,<br>  ].join(&#39;, &#39;);<br>}</pre><h4>Collection for</h4><p>Lastly, use the for keyword to insert a sequence into the collection:</p><pre>class Article {<br>  String title;<br>  DateTime date;<br>  List&lt;String&gt; tags;</pre><pre>  Article(this.title, this.date, this.tags);</pre><pre>  String toString() {<br>    return [<br>      title,<br>      date.toString(),<br>      for (var tag in tags) &#39;tag: $tag&#39;<br>    ].join(&#39;, &#39;);<br>  }<br>}</pre><p>In this example, the for expression adds a string for each item in the tags list. Just like a normal for loop in Dart, the tags expression can be any Iterable.</p><h3>Collections in Flutter code</h3><p>If you’re using Dart, there’s a good chance you’re <a href=\"https://www.zdnet.com/article/googles-flutter-2-million-developers-uptick-in-enterprise-use-new-release-model-revealed/\">using it to build Flutter apps</a>. Since the features described here were <a href=\"https://github.com/munificent/ui-as-code/blob/master/Motivation.md\">designed with Flutter in mind</a>, let’s take a look at some Flutter code.</p><h4>Refactoring a build() method</h4><p>In Flutter, it’s common to build up a list of widgets in a build() method:</p><pre><a href=\"http://twitter.com/override\">@override</a><br>Widget build(BuildContext context) {<br>  var articleWidgets = articles<br>      .map&lt;Widget&gt;((article) =&gt; ArticleWidget(article: article))<br>      .toList();</pre><pre>  return ListView(<br>    children: articleWidgets,<br>  );<br>}</pre><p>This could be rewritten with a spread:</p><pre>Widget build(BuildContext context) {</pre><pre>  return ListView(<br>    children: [<br>      ...articles.map((article) =&gt; ArticleWidget(article:article))<br>    ],<br>  );<br>}</pre><p>Or with a <em>collection for</em>:</p><pre>Widget build(BuildContext context) {<br>  return ListView(<br>    children: [<br>      for (var article in articles)<br>        ArticleWidget(article: article)<br>    ],<br>  );<br>}</pre><p>The first snippet converts the Article class into a collection of ArticleWidget objects using map(), and then applies the spread operator to expand them into the surrounding list. In the second example, the <em>collection for </em>operator lets you express this a little more succinctly.</p><h4>A larger build() method</h4><p>Here’s a more complex example:</p><pre>Widget build(BuildContext context) {<br>  var headerStyle = Theme.of(context).textTheme.headline4;</pre><pre>  return Column(<br>    children: [<br>      if (article.title != null)<br>        Text(article.title, style: headerStyle),<br>      if (article.date != null)<br>        Text(article.date.toString()),<br>      Text(&#39;Tags:&#39;),<br>      for (var tag in article.tags)<br>        Text(tag),<br>    ],<br>  );<br>}</pre><p>The logic to place widgets in the Column is right where a reader might expect, and saves a lot of code. Before these features, the most common way to achieve the same behavior was to create a variable and use normal if statements that call add().</p><h3>Combining these features</h3><p>These features can be combined in interesting ways, as the examples in this section show. Here are a few things to keep in mind:</p><ul><li>Syntactically a <em>collection if</em>, <em>collection for</em>, or <em>spread</em> is a <em>single element</em> — even if it ends up creating multiple objects.</li><li>Any expression can go in the body of a <em>collection if</em> or <em>collection for</em>.</li><li>Any <em>element</em> can go in the body of a <em>collection if</em> or <em>collection for</em>.</li></ul><h4>Using if and for together</h4><p>Here’s some code that creates a list using a <em>collection if</em> inside of a <em>collection for</em>. Here, each article is added to the list if it’s after a certain date:</p><pre>List&lt;Article&gt; recentArticles(List&lt;Article&gt; allArticles) {<br>  var ninetyDaysAgo = DateTime.now().subtract(Duration(days: 90));<br>  return [<br>    for (var article in allArticles)<br>      if (article.date.isAfter(ninetyDaysAgo))<br>        article<br>  ];<br>}</pre><p>If you prefer spreads, the return value could instead be written as ...allArticles.where((article) =&gt; article.date.isAfter(ninetyDaysAgo)).</p><h4>Using collection if and spreads together</h4><p>A <em>collection if</em> takes a single element, but if you want to include more than one you can use a spread:</p><pre>Widget build(BuildContext context) {<br>  return Column(<br>    children: [<br>      if (article.date != null) ...[<br>        Icon(Icons.calendar_today),<br>        Text(&#39;${article.date}&#39;),<br>      ],<br>    ],<br>  );<br>}</pre><h4>Using collection features with async-await</h4><p>You can also combine asynchronous calls with collection literals. For example, a common pattern is to use Future.wait() to trigger a group of asynchronous calls:</p><pre>Future&lt;Article&gt; fetchArticle(String id);</pre><pre>Future&lt;List&lt;Article&gt;&gt; fetchArticles() async {<br>  return Future.wait([<br>    fetchArticle(&#39;1&#39;),<br>    fetchArticle(&#39;2&#39;),<br>    fetchArticle(&#39;3&#39;),<br>  ]);<br>}</pre><p>That code can be improved using a <em>collection for</em>:</p><pre>Future&lt;List&lt;Article&gt;&gt; fetchArticles(List&lt;String&gt; ids) async {<br>  return Future.wait([<br>    for (var id in ids)<br>      fetchArticle(id),<br>  ]);<br>}</pre><p>It’s also possible to put an await in a collection literal, although it will wait for each future in sequence:</p><pre>Future&lt;List&lt;Article&gt;&gt; fetchArticles(List&lt;String&gt; ids) async {<br>  return [<br>    // fetches one at a time<br>    for (var id in ids)<br>      await fetchArticle(id),<br>  ];<br>}</pre><p>The preceding code waits in sequence because it’s equivalent to the following:</p><pre>Future&lt;List&lt;Article&gt;&gt; fetchArticles() async {<br>  return &lt;Article&gt;[<br>    // fetches one at a time<br>    await fetchArticle(&#39;1&#39;),<br>    await fetchArticle(&#39;2&#39;),<br>    await fetchArticle(&#39;3&#39;),<br>  ];<br>}</pre><p>You can also expand a Stream using await for:</p><pre>Stream&lt;String&gt; get idStream =&gt; Stream.fromIterable([&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]);<br>Future&lt;List&lt;String&gt;&gt; gatherIds(Stream&lt;String&gt; ids) async {<br>  return [<br>    await for (var id in ids)<br>      id<br>  ];<br>}</pre><pre>void main() async {<br>  print(await gatherIds(idStream)); // [1, 2, 3]<br>}</pre><p>This is another example of how <em>collection if</em>, <em>collection for</em>, and spreads work with other parts of the language. If you’ve used an await for statement, you might be able to guess the behavior: it listens to the stream for new values and puts the body into the surrounding list.</p><h3>Exploring further</h3><p>Hopefully these tips help you write cleaner Dart code. There are even more ways to use these features than are mentioned here. If you find a nice technique, <a href=\"https://dart.dev/community\">share it with the community</a> or <a href=\"https://twitter.com/dart_lang\">mention <em>@dart_lang</em> on Twitter</a>. For more details, check out <a href=\"https://medium.com/dartlang/making-dart-a-better-language-for-ui-f1ccaf9f546c\">Making Dart a Better Language for UI</a> or the initial <a href=\"https://github.com/dart-lang/language/blob/master/accepted/2.3/unified-collections/feature-specification.md\">language proposal on GitHub</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f66b6a02d0b1\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/exploring-collections-in-dart-f66b6a02d0b1\">Exploring collections in Dart</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2020-09-02T15:51:09.000Z":{"title":"Google Summer of Code 2020 results","link":"https://medium.com/dartlang/google-summer-of-code-2020-results-a38cd072c9fe?source=rss----23738d481ce8---4","guid":"https://medium.com/p/a38cd072c9fe","category":["open-source","flutter","google-summer-of-code","dartlang"],"dc:creator":"Jonas Finnemann Jensen","pubDate":"Wed, 02 Sep 2020 15:51:09 GMT","atom:updated":"2020-09-02T18:22:42.646Z","content:encoded":"<figure><img alt=\"Google Summer of Code\" src=\"https://cdn-images-1.medium.com/max/680/1*5VxyyQ1juWjwtTbSkwzzXA.jpeg\" /></figure><p><a href=\"https://summerofcode.withgoogle.com/\">Google Summer of Code (GSoC)</a> is a global program focused on bringing student developers into open source software development. Students are sponsored by Google to work with a mentoring open source organization on a 3-month programming project during the summer.</p><p>In <a href=\"https://medium.com/dartlang/students-join-a-dart-project-for-google-summer-of-code-2020-655d39b557c2\">February we were thrilled to announce</a> that the Dart team would be a mentoring organization in GSoC 2020. We ended up <a href=\"https://summerofcode.withgoogle.com/organizations/6544944065413120/\">mentoring 5 projects</a>, picked from more than 170 applications from students around the world. Today we’re excited to share our results, as described by the students who worked on the projects.</p><h4>Generating dart:ffi bindings for Dart-C interop with package:ffigen</h4><p><em>By Prerak Mann</em></p><p><a href=\"https://pub.dev/packages/ffigen\">package:ffigen</a> is an FFI generator that greatly reduces the effort of using dart:ffi by generating Dart bindings from C header files (.h).</p><p>To understand the need for this tool, consider <a href=\"https://clang.llvm.org/doxygen/group__CINDEX.html\">LibClang</a> (the C interface to Clang). LibClang’s <a href=\"https://github.com/dart-lang/ffigen/tree/master/third_party/libclang/include/clang-c\">API</a> is about 8,000 lines of code (LOC). If you were to write Dart <a href=\"https://github.com/dart-lang/ffigen/blob/master/example/libclang-example/generated_bindings.dart\">bindings for LibClang</a> by hand, you’d need almost 4,500 LOC. With package:ffigen, all you need to do is pass in a <a href=\"https://github.com/dart-lang/ffigen/blob/master/example/libclang-example/pubspec.yaml#L14\">small YAML configuration file</a> that’s less than 20 LOC, and then you can generate the bindings.</p><p>You can control which C functions to generate, and use simple regular expressions to rename macros, enums, and individual struct members. You can also <a href=\"https://github.com/dart-lang/ffigen#array-workaround\">generate array</a> members nested in structs (which are not fully supported in dart:ffi yet).</p><p>Check out <a href=\"https://github.com/dart-lang/ffigen\">github.com/dart-lang/ffigen</a> for a complete list of <a href=\"https://github.com/dart-lang/ffigen#configurations\">configurations</a>, <a href=\"https://github.com/dart-lang/ffigen#faq\">FAQs</a>, <a href=\"https://github.com/dart-lang/ffigen/blob/master/example/\">examples</a>, and more.</p><h4>Learn testing with a new Flutter sample</h4><p><em>By Abdullah Deshmukh</em></p><p>Have you been using Flutter for a while but still haven’t figured out how to test Flutter apps? Then you might be interested in the sample that we built to demonstrate best practices for testing Flutter apps. You’ll be able to learn testing in Flutter in a quick and easy way.</p><p>The <a href=\"https://github.com/flutter/samples/tree/master/testing_app\">sample</a> shows different types of testing including:</p><ul><li>Unit testing</li><li>Widget testing</li><li>Integration testing</li><li>Performance testing</li><li>State management testing</li></ul><p>As a bonus, we also built a codelab on how to test Flutter apps. You can see a detailed report of the work done under the project in the article <a href=\"https://medium.com/flutter/learn-testing-with-the-new-flutter-sample-gsoc20-work-product-e872c7f6492a\">Learn testing with the new Flutter sample</a>.</p><h4>User-extensible translation file formats</h4><p><em>By Jaime Blasco</em></p><p>The <a href=\"https://pub.dev/packages/intl_translation\">intl_translation</a> package supports only the ARB file format, which is not widely used outside of Dart. The <a href=\"https://pub.dev/packages/intl_translation_format\">intl_translation_format</a> package, created during GSoC 2020, builds on intl_translation, adding a TranslationFormat class that can support widely varying formats. Developers can add support for additional formats in their own packages and in just a few lines create command-line tools for extraction and generation that integrate with the existing tools. With these, existing translations in other formats, even proprietary ones, can be imported into a Dart project easily and new messages originating in Dart code can be integrated into existing translation tools and workflows.</p><p>As a demonstration of these capabilities, the new packages include support for several formats. In addition to ARB, it supports <strong>XLIFF v1.2 (iOS), XLIFF v2.0,</strong> and<strong> JSON with ICU</strong> messages. <a href=\"https://github.com/jamesblasco/intl_translation_format_experiments\">Experimental libraries</a> show how support for other formats, and even translations that can be updated at runtime, could be implemented.</p><h4>Platform channels in a mobile app and a federated plugin</h4><p><em>By Ayush Bherwani</em></p><p>After researching platform channels (the Flutter API for sending messages back and forth from Dart to native code like Swift or Kotlin), we decided to cover the topic with two different samples. One is a <a href=\"https://github.com/flutter/samples/tree/master/platform_channels\">straightforward Android and iOS demo</a>, while the other is a <a href=\"https://github.com/flutter/samples/tree/master/experimental/federated_plugin\">federated plugin</a> capable of building with the master channel for web and desktop as well. Between the two samples, the codebase shows off not only the details of platform channels and the codecs that can be used to move data, but also the APIs for federated plugins and techniques for calling native code on web and desktop (Windows and Linux) APIs.</p><p>If you’re a developer looking to build a plugin or just access a platform API, these samples are a great place to get started learning. For more information about this project, see the article <a href=\"https://medium.com/flutter/platform-channel-examples-7edeaeba4a66\">Platform channel examples</a>.</p><h4>Writing package:yaml_edit to enable `pub add &lt;package&gt;`</h4><p><em>By Garett Tok Ern Liang</em></p><p>Dart projects specify package dependencies in a pubspec.yaml file. <a href=\"https://yaml.org/spec/1.2/spec.html\">YAML</a> is great because it allows us to write comments, but programmatically modifying YAML is a challenge.</p><p>To tackle this challenge, we wrote <a href=\"https://pub.dev/packages/yaml_edit\">package:yaml_edit</a> to easily perform context-aware string manipulations that preserve formatting and comments. The test suite for the package contains more than 40,000 tests, and we think we have a pretty good solution working. Play with it and <a href=\"https://github.com/google/dart-neats/issues\">file bugs</a>!</p><p>Using package:yaml_edit, we added a new pub add &lt;package&gt; subcommand to pub, the package management tool for Dart and Flutter. pub add automatically resolves for the latest compatible version of the target package and adds it to a user’s pubspec.yaml. To put this into perspective, pub add &lt;package&gt; automates the tedium of having to do all of the following:</p><ol><li>Visiting https://pub.dev/packages/&lt;package&gt;</li><li>Choosing a version to add to your package</li><li>Modifying pubspec.yaml</li><li>Running pub get</li><li>Repeating steps 2-4 as many times as needed to get a version compatible with your other dependencies</li></ol><p>A similar command that removes dependencies — pub remove &lt;package&gt;— is also in the works. Keep your eyes peeled for these two commands coming to pub soon!</p><blockquote>Huge thanks to everyone who applied for Google Summer of Code 2020 with Dart, and to the students who completed projects this year, and to the mentors who spent time every week to make this an awesome summer of code. We hope to see many of you students again as contributors throughout the Dart ecosystem.</blockquote><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a38cd072c9fe\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/google-summer-of-code-2020-results-a38cd072c9fe\">Google Summer of Code 2020 results</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-02-16T23:28:19.000Z":{"title":"Preparing the Dart and Flutter ecosystem for null safety","link":"https://medium.com/dartlang/preparing-the-dart-and-flutter-ecosystem-for-null-safety-e550ce72c010?source=rss----23738d481ce8---4","guid":"https://medium.com/p/e550ce72c010","category":["announcements","dart","flutter"],"dc:creator":"Kevin Moore","pubDate":"Tue, 16 Feb 2021 23:28:19 GMT","atom:updated":"2021-02-17T04:31:20.086Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<h4>Null safety is now API stable. Publish your stable packages now!</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VTEwPWrLp7D0teLcI-HALw.png\" /></figure><p>Today we’re announcing a new beta release of Dart. This beta represents a new level of stability and confidence in the new <a href=\"https://medium.com/dartlang/why-nullable-types-7dd93c28c87a\">sound null safety</a> type system, which we’ve been working on for over a year. The updated Dart beta (2.12.0–259.9.beta) is available on <a href=\"https://dart.dev/get-dart\">dart.dev</a> and is also included in the <a href=\"https://flutter.dev/docs/get-started/install\">beta channel of Flutter</a>. We don’t anticipate any more breaking changes between now and the stable release of this feature.</p><p>If you’re a package developer, we invite you to begin publishing stable, null-safe versions of your packages to provide the best experience for users when we ship the stable version of Dart with null safety. We’ve started this process ourselves, publishing stable versions of null-safe packages such as <a href=\"https://pub.dev/packages/args/versions/2.0.0\">args</a>, <a href=\"https://pub.dev/packages/yaml/versions/3.0.0\">yaml</a>, and <a href=\"https://pub.dev/packages/grpc/versions/3.0.0\">grpc</a>. If all of your dependencies are null-safe and published with stable versions (e.g. 1.0.0 instead of 1.0.0-nullsafety.123), now is the time for you to do the same!</p><p>We’ve also added a new feature to pub.dev that tags package versions as <a href=\"https://dart.dev/tools/pub/publishing#publishing-previews\">preview releases</a> when their dependent Dart SDK hasn’t yet been released to stable. Preview releases will automatically be promoted to regular stable versions once a new stable Dart SDK is released.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*GcE_GbN_IrB_dLtq\" /><figcaption><em>pub.dev showing the args package with a 1.6.0 stable version and a 2.0.0 preview version</em></figcaption></figure><p>The <a href=\"https://dart.dev/null-safety/migration-guide\">null safety migration guide</a> has the latest information on how to migrate your packages. Pay close attention to the Dart SDK constraint and versions of your dependencies in the pubspec, as well as the version of the SDK that you’re using in continuous integration (CI) testing.</p><p>The stable, null-safe version of Dart is coming soon! Thanks for helping us make it happen.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e550ce72c010\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/preparing-the-dart-and-flutter-ecosystem-for-null-safety-e550ce72c010\">Preparing the Dart and Flutter ecosystem for null safety</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-01-19T17:02:52.000Z":{"title":"Dart and the performance benefits of sound types","link":"https://medium.com/dartlang/dart-and-the-performance-benefits-of-sound-types-6ceedd5b6cdc?source=rss----23738d481ce8---4","guid":"https://medium.com/p/6ceedd5b6cdc","category":["performance","programming-languages","dart"],"dc:creator":"Vijay Menon","pubDate":"Tue, 19 Jan 2021 17:02:52 GMT","atom:updated":"2021-01-19T17:02:51.999Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<h4>Using soundness and null safety to generate faster, smaller code</h4><figure><img alt=\"3 screenshots of machine code: much code → less code → 3 lines of code.\" src=\"https://cdn-images-1.medium.com/max/722/1*WOmw6jN-nt82uXjGCqRC4g.png\" /><figcaption>Code generated from the same Dart method in Dart 1.24, 2.0, and 2.12 (left to right) has gotten smaller. To see why (and to see the actual generated code), keep reading.</figcaption></figure><p>We’ve strengthened Dart’s type system over the past few years. The original Dart language (Dart 1) had an unsound, optional type system (similar to typed JavaScript dialects such as Microsoft’s TypeScript or Facebook’s Flow). Dart 2 introduced a stricter, <a href=\"https://dart.dev/guides/language/type-system\"><em>sound </em>type system</a>. Over the past two years, we’ve been working on extending the type system further, via <a href=\"https://dart.dev/null-safety\"><em>sound null safety</em></a>.</p><p>While a sound type system provides developers with greater confidence, it also enables our compilers to safely use types to optimize generated code. With soundness, our tools guarantee that types are correct via a combination of static and (when needed) runtime checking. Without soundness, type checking can only go so far, and static types may be incorrect at runtime.</p><p>In practice, soundness allows our compilers to generate smaller and faster code, particularly in an ahead-of-time (AOT) setting, where we ship precompiled native code to clients.</p><h3>An example</h3><p>The following example method demonstrates how sound types can have a dramatic impact on relatively simple code:</p><pre><strong>int getAge(Animal a) {<br>  return a.age;<br>}</strong></pre><p>In our last stable Dart 1 version (1.24.3), this method mapped to <strong>26 native x64 instructions</strong> — and that was only after instrumentation and profile-guided optimization, which slowed initial runtime startup. With sound null safety in Dart 2.12, this code maps to just <strong>3 instructions</strong>, without any need for profile-guided optimization.</p><blockquote>Dart compiles to both ARM32/64 and x86/x64 architectures. In the examples below, we use x64, but results are similar on other targets.</blockquote><p>The full Dart code and context for the example method are shown at the end of this article, but here are the key points:</p><ul><li>The class Animal contains a field age of type int.</li><li>Animal has several subclasses (Cat, Dog, Snake, Hamster).</li><li>The method above is called on many of these types at runtime.</li></ul><h3>Dart object layout</h3><p>The Dart class Animal, when compiled to native (x64) code, has a simple layout:</p><figure><img alt=\"8 bytes of object header, followed by 8 bytes of `age` field, followed by additional subclass fields.\" src=\"https://cdn-images-1.medium.com/max/195/1*GjL59kevCm5NQ5P9Unn_NA.png\" /></figure><p>The first 8 bytes are a header that provides reified type information (that is, the runtime type of the object). The second 8 bytes contain the age field. All subclasses preserve (and potentially add to) this structure: any additional fields are laid out after, preserving the base type’s structure. The getAge method, given an instance of Animal (or any subclass) should load the field from an 8-byte offset and return it.</p><h3>Dart 1: Unsound types</h3><p>In Dart 1, however, static types weren’t sound and were effectively ignored during compilation. At runtime, we couldn’t assume that the static type was correct (and, therefore, the layout was as expected). The access to age might be to a field at a different offset, to a getter that triggered further executable code, or to a non-existent field (triggering a catchable runtime error).</p><p>Dart 1 was designed to rely on a just-in-time compiler and virtual machine on the client device, which optimized the code using runtime type information. In this scheme, we actually compiled each method twice: first, to collect information, and second (for hot methods) to generate more optimized code based on the observed runtime behavior.</p><h4>Dart 1: First compilation</h4><p>The first compilation for getAge produced the following 47 instructions on x64:</p><figure><img alt=\"2 columns full of assembly code.\" src=\"https://cdn-images-1.medium.com/max/1024/1*BmagjRb3ei3C-HjyYfLNyw.png\" /></figure><p>Note that this code is instrumented to determine what happens at runtime. It assumes nothing about the passed object and effectively performs the equivalent of a hash table lookup to correctly find the field, execute a getter, or throw an error.</p><h4>Dart 1: Second compilation</h4><p>In this case, the code is called repeatedly and triggers a second, optimizing compilation that generates the following 26 instructions:</p><figure><img alt=\"2 columns of assembly code (but less than before). Most of the code is blue (prologue/epilogue) or red (various checks).\" src=\"https://cdn-images-1.medium.com/max/1024/1*1bEjUe15A0s47XMsZPqdNQ.png\" /></figure><p>This optimized code is still quite large. It’s based on profile information that found the method was only invoked on instances of Cat, Hamster, and Dog, and is optimized with the assumption that the same will be true going forward.</p><p>The code in <strong>blue</strong> is the prologue and epilogue for the method (to set up and restore the stack frame). The code in <strong>red</strong> checks for the expected cases — that the instance is non-null and is of one of the previously seen types — and invokes a slow path for other cases. The code in <strong>bold</strong> is the actual work to load the field.</p><p>The optimized code may actually be slower if future behavior is different from the past: if getAge is invoked on a new instance (such as a Snake) the code will perform the extra checks but still fall down the slow path.</p><h4>Problems with Dart 1 generated code</h4><p>The generated code above is very similar in structure to that produced today by V8, the JavaScript engine in Chrome, when given a more-or-less equivalent JavaScript/TypeScript/Flow program. While this approach (and the corresponding generated code) can give good performance in many scenarios, it wasn’t suitable as we began (with Flutter in particular) to target a broader set of client platforms, including mobile devices more sensitive to size and memory footprint:</p><ul><li>First, the cost of client-side compilation increased the overall footprint of Dart applications.</li><li>Second, the cost of two-phase speculative compilation was detrimental to application startup.</li><li>Third, just-in-time compilation isn’t allowed on iOS: we’d need an alternative strategy for at least some targets.</li></ul><p>We shifted instead to an ahead-of-time compilation approach, but with Dart 1 it resulted in considerably worse code. Even with sophisticated, whole-program analysis, we couldn’t always determine type information at compilation time, particularly as applications became larger. In addition, the cost of speculation — the red code above — became prohibitive when the entire application was precompiled.</p><h3>Dart 2: Sound types</h3><p>With Dart 2, we introduced soundness, which enabled us to safely compile code based upon type information and reduced our reliance on profiling for performance. With Dart 2, on a single ahead-of-time compile, we generate 10 instructions on x64:</p><figure><img alt=\"Much less code, but still there’s some blue code (prologue/epilogue) and red code (null checks).\" src=\"https://cdn-images-1.medium.com/max/1024/1*x0UcFY8XwG-3vHe5hYxyQw.png\" /></figure><p>This code still performs the null check (in red) and calls a helper method if null is found.</p><h3>Dart 2.12: Sound null safety</h3><p>With sound null safety, the type system is richer, and our compiler can leverage that. The compiler can safely rely upon the (now) non-nullable type and eliminate the code in red above. In Dart 2.12 beta, we generate 3 fewer instructions:</p><figure><img alt=\"Some blue code (prologue/epilogue) but no red code! No null checks needed!\" src=\"https://cdn-images-1.medium.com/max/1024/1*xVdpKVxtt_TtfoXZDlu1Qw.png\" /></figure><p>In fact, as the code has gotten simpler, we’ve also been able to streamline the prologue and epilogue. In our forthcoming stable release, we’ll generate just 3 instructions for the example method:</p><figure><img alt=\"Even less blue code (prologue/epilogue) than before.\" src=\"https://cdn-images-1.medium.com/max/1024/1*JPFuwgxqf2K-7tVD52M5uQ.png\" /></figure><p>With sound null safety, we can reduce the generated code for this method to its essence: a field load. In practice, a call to this method will always be inlined, as it’s now trivial for the compiler to see that inlining is both a performance and code size win. Runtime checking and compensation code are no longer necessary: more of the heavy lifting happens at compile time. We no longer need the startup and memory overhead of client-side compilation. As a result, our users get smaller and faster code.</p><h3>Try it!</h3><p>We encourage you to try out <a href=\"https://dart.dev/null-safety\">null safety</a>. It’s available in Dart 2.12, now in our beta channel. Once your upstream dependencies are migrated, you’ll be able to migrate your own packages and applications. As the example here illustrates, you may not need to change too much.</p><p>Remember, to get the performance benefits of null safety, you’ll need a fully migrated application. Once your application is fully migrated, our compilers will automatically take advantage of null safety to generate better, smaller code.</p><h3>PS: The code</h3><p>Here’s the full Dart code that I compiled to generate all the code in this article. While the example here is contrived, the pattern — a field in a class hierarchy — is quite common.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/0024d1ba3a35bbdf5fedca64d7f309e2/href\">https://medium.com/media/0024d1ba3a35bbdf5fedca64d7f309e2/href</a></iframe><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6ceedd5b6cdc\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-and-the-performance-benefits-of-sound-types-6ceedd5b6cdc\">Dart and the performance benefits of sound types</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-03-03T18:31:28.000Z":{"title":"Announcing Dart 2.12","link":"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87?source=rss----23738d481ce8---4","guid":"https://medium.com/p/499a6e689c87","category":["dart","announcements","programming"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 03 Mar 2021 18:31:28 GMT","atom:updated":"2021-03-03T18:31:26.092Z","content:encoded":"<h4>Sound null safety and Dart FFI ship to the stable channel.</h4><p>Today we’re announcing Dart 2.12, featuring stable versions of <a href=\"https://dart.dev/null-safety\">sound null safety</a> and <a href=\"https://dart.dev/guides/libraries/c-interop\">Dart FFI</a>. Null safety is our latest major productivity feature, intended to help you avoid null errors, a class of bugs that are often hard to spot, as detailed in <a href=\"https://www.youtube.com/watch?v=iYhOU9AuaFs&amp;feature=emb_logo\">this video introduction</a>. FFI is an interoperability mechanism that lets you invoke existing code written in the C programming language, such as calling Windows <a href=\"https://pub.dev/packages/win32\">Win32 APIs</a>. Dart 2.12 is available today.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*Inj4APQIAA4gVCxK\" /></figure><h3>The Dart platform’s unique capabilities</h3><p>Before we look at sound null safety and FFI in detail, let’s discuss how they fit into our goals with the Dart platform. Programming languages tend to share a lot of capabilities. For example, many languages support object-oriented programming or running on the web. What really sets languages apart is their unique combination of capabilities.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*msUXfhSNTNzP4wkf\" /></figure><p>Dart’s unique capabilities span three dimensions:</p><ul><li><strong>Portable</strong>: Efficient compilers generate x86 and ARM machine code for devices, and optimized JavaScript for the web. A <a href=\"https://dart.dev/overview#platform\">wide range of targets</a> are supported — mobile devices, desktop PCs, app backends, and more. An extensive set of libraries and packages provide consistent APIs that work across all platforms, further lowering the cost of creating true multi-platform apps.</li><li><strong>Productive</strong>: The Dart platform supports hot reload, enabling fast, iterative development for both native devices and the web. And Dart offers rich constructs like isolates and async/await for handling common concurrent and event-driven app patterns.</li><li><strong>Robust</strong>: Dart’s sound, null-safe type system catches errors during development. And the overall platform is highly scalable and dependable, with production usage for more than a decade by a large range of apps, including business-critical apps such as Google Ads and Google Assistant.</li></ul><p>Sound null safety makes the type system even more robust, and enables better performance. Dart FFI lets you use existing C libraries for better portability, and gives you the option of using highly tuned C code for performance-critical tasks.</p><h3>Sound null safety</h3><p>Sound null safety is the largest addition to the Dart language since the introduction of the sound type system in <a href=\"https://medium.com/dartlang/announcing-dart-2-80ba01f43b6\">Dart 2.0</a>. Null safety further strengthens the type system, enabling you to catch null errors, which are a common cause of app crashes. By opting into null safety, you can catch null errors during development, preventing crashes in production.</p><p>Sound null safety was designed around <a href=\"https://dart.dev/null-safety#null-safety-principles\">a few core principles</a>. Let’s revisit how these principles impact you as a developer.</p><h3>Non-nullable by default: A fundamental change to the type system</h3><p>The core challenge prior to null safety was that you couldn’t tell the difference between code that anticipated being passed null and code that didn’t work with nulls. A few months ago we discovered a bug in the Flutter master channel where various flutter tool commands would crash on certain machine configurations with a null error: The method &#39;&gt;=&#39; was called on null. The underlying issue was code like this:</p><pre>final int major = version?.major;<br>final int minor = version?.minor;<br>if (globals.platform.isMacOS) {<br>  // plugin path of Android Studio changed after version 4.1.<br>  if (major &gt;= 4 &amp;&amp; minor &gt;= 1) {<br>  ...</pre><p>Can you spot the error? Because version can be null, both major and minor can be null also. This bug might seem easy to spot here in isolation, but in practice code like this slips through all the time, even with a rigorous code review process like the one used in the Flutter repo. With null safety, static analysis catches this issue immediately. (<a href=\"https://dartpad.dev/0e9797be7488d8ec6c3fca92b7f2740f?null_safety=true\">Try it live in DartPad</a>.)</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*jl-o2KmcMjj777Iu\" /><figcaption>Screenshot of analysis output in an IDE</figcaption></figure><p>That was a pretty simple error. During our early use of null safety in code internally at Google, we’ve seen much more intricate errors be caught. Some of these were bugs that were known for years, but where the teams hadn’t been able to find the cause without the additional static checks from null safety. Here are a few examples:</p><ul><li>An internal team found that they were often checking for null values of expressions that could never be null. This problem was most frequently seen in code using <a href=\"https://developers.google.com/protocol-buffers\">protobuf</a>, where optional fields return a default value when unset, and never null. As a result, code incorrectly checked for the default condition, by confusing default values and null values.</li><li>The Google Pay team found bugs in their Flutter code where they would fail when trying to access Flutter State objects outside of the context of a Widget. Before null safety, those objects would return null and mask the error; with null safety, the sound analysis determined that those properties could never be null, and threw an analysis error.</li><li>The Flutter team found a bug where the Flutter engine could crash if null was passed to the scene parameter in Window.render(). During null safety migration, they added a hint to <a href=\"https://github.com/cbracken/engine/blob/bad869e229a8a02cad6e63d12e80807b33b5c12f/lib/ui/window.dart#L1069\">mark Scene as non-nullable</a>, and were then able to easily prevent potential app crashes that null would have triggered.</li></ul><h3>Working with non-nullable by default</h3><p>Once you <a href=\"https://dart.dev/null-safety#enable-null-safety\">enable null safety</a>, the basics of variable declarations change because the default types are non-nullable:</p><pre>// In null-safe Dart, none of these can ever be null.<br>var i = 42; // Inferred to be an int.<br>String name = getFileName();<br>final b = Foo();</pre><p>If you want to create a variable that can contain either a value or null, you need to make that explicit in the variable declaration by adding a ? suffix to the type:</p><pre>// aNullableInt can hold either an integer or null.<br>int? aNullableInt = null;</pre><p>The implementation of null safety is robust, with rich static flow analysis making it easier to work with nullable types. For example, after checking for null, Dart promotes the type of a local variable from nullable to non-nullable:</p><pre>int definitelyInt(int? aNullableInt) {<br>  if (aNullableInt == null) {<br>    return 0;<br>  }<br>  // aNullableInt has now promoted to a non-null int.<br>  return aNullableInt; <br>}</pre><p>We’ve also added a new keyword, required. When a named parameter is marked as required (which happens a lot in Flutter widget APIs) and the caller forgets to provide the argument, then an analysis error occurs:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*U_WEQJAarjskU1k2\" /></figure><h3>Incremental migration to null safety</h3><p>Because null safety is such a fundamental change to our typing system, it would be extremely disruptive if we insisted on forced adoption. So that <em>you</em> decide when the time is right, null safety is an opt-in feature: you can use Dart 2.12 without being forced to enable null safety. You can even depend on packages that have already enabled null safety, whether or not your app or package has enabled null safety.</p><p>To help you migrate existing code to null safety, we’re providing a migration tool and a <a href=\"https://dart.dev/null-safety/migration-guide\">migration guide</a>. The tool starts by analyzing all of your existing code. Then you can interactively review the nullability properties that the tool has inferred. If you disagree with any of the tool’s conclusions, you can add nullability hints to change the inference. Adding a few migration hints can have a huge impact on migration quality.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*srLwqVUDeF49J_B9\" /></figure><p>For now, new packages and apps created with <a href=\"https://dart.dev/tools/dart-tool\">dart create</a> and <a href=\"https://flutter.dev/docs/reference/flutter-cli\">flutter create</a> don’t enable sound null safety. We expect to change that in a future stable release, when we see that most of the ecosystem has migrated. You can easily <a href=\"https://dart.dev/null-safety#create\">enable null safety</a> in a newly created package or app using dart migrate.</p><h3>Status of null safety migration of the Dart ecosystem</h3><p>Over the past year we’ve offered several preview and beta builds of sound null safety, with the goal of seeding the ecosystem with packages that support null safety. This preparation is important, as we recommend <a href=\"https://dart.dev/null-safety/migration-guide#step1-wait\">migrating to sound null safety in order</a> — you shouldn’t migrate a package or app before all its dependencies have already migrated.</p><p>We’ve published null-safe versions of hundreds of packages offered by the <a href=\"https://pub.dev/packages?q=publisher%3Adart.dev&amp;sort=popularity&amp;null-safe=1\">Dart</a>, <a href=\"https://pub.dev/packages?q=publisher%3Aflutter.dev&amp;sort=popularity&amp;null-safe=1\">Flutter</a>, <a href=\"https://pub.dev/packages?q=publisher%3Afirebase.google.com&amp;sort=popularity&amp;null-safe=1\">Firebase</a>, and <a href=\"https://pub.dev/packages?q=publisher%3Amaterial.io&amp;sort=popularity&amp;null-safe=1\">Material</a> teams. And we’ve seen great support from the amazing Dart and Flutter ecosystems, so that pub.dev now has more than a thousand packages supporting null safety. Importantly, the most popular packages have migrated first, so that 98% of the top-100 most popular packages, 78% of the top-250, and 57% of the top-500 already support null safety in time for today’s launch. We look forward to seeing yet more packages with null safety on pub.dev in the coming weeks. <a href=\"https://github.com/dart-lang/sdk/wiki/Null-safety-migration-status\">Our analysis</a> shows that the vast majority of packages on pub.dev are already unblocked and can <a href=\"https://dart.dev/null-safety/migration-guide\">start migration</a>.</p><h3>The benefits of fully sound null safety</h3><p>Once you’ve fully migrated, Dart’s null safety is sound. This means that Dart is 100% sure that expressions that have a non-nullable type cannot be null. When Dart analyzes your code and determines that a variable is non-nullable, that variable is <em>always</em> non-nullable. Dart shares sound null safety with Swift, but not very many other programming languages.</p><p>The soundness of Dart’s null safety has another welcome implication: it means your programs can be smaller and faster. Because Dart is sure that non-nullable variables are never null, <a href=\"https://medium.com/dartlang/dart-and-the-performance-benefits-of-sound-types-6ceedd5b6cdc\">Dart can optimize</a>. For example, the Dart ahead-of-time (AOT) compiler can produce smaller and faster native code, because it doesn’t need to add checks for nulls when it knows that a variable isn’t null.</p><h3>Dart FFI for integrating Dart with C libraries</h3><p>Dart FFI enables you to leverage existing code in C libraries, both for better portability and for integrating with highly tuned C code for performance critical tasks. As of Dart 2.12, <a href=\"https://dart.dev/guides/libraries/c-interop\">Dart FFI</a> is out of the <em>beta</em> stage and is now considered stable and ready for production use. We’ve also added some new features, including nested structs and passing structs by value.</p><h3>Passing structs by value</h3><p>Structs can be passed both by reference and by value in C code. FFI previously only supported passing by reference, but as of Dart 2.12, you can pass structs by value. Here’s a small example of two C functions that pass both by reference and by value:</p><pre>struct Link {<br>  double value;<br>  Link* next;<br>};</pre><pre>void MoveByReference(Link* link) {<br>  link-&gt;value = link-&gt;value + 10.0;<br>}</pre><pre>Coord MoveByValue(Link link) {<br>  link.value = link.value + 10.0;<br>  return link;<br>}</pre><h3>Nested structs</h3><p>C APIs often use nested structs — structs that themselves contain structs, such as this example:</p><pre>struct Wheel {<br>  int spokes;<br>};</pre><pre>struct Bike {<br>  struct Wheel front;<br>  struct Wheel rear;<br>  int buildYear;<br>};</pre><p>As of Dart 2.12, nested structs are supported in FFI.</p><h3>API changes</h3><p>As part of declaring FFI stable, and in support of the features above, we’ve made a few smaller API changes.</p><p>Creating empty structs is now disallowed (breaking change <a href=\"https://github.com/dart-lang/sdk/issues/44622\">#44622</a>) and produces a deprecation warning. You can use a new type, Opaque, to represent empty structs. The dart:ffi functions sizeOf, elementAt, and ref now require compile-time type arguments (breaking change <a href=\"https://github.com/dart-lang/sdk/issues/44621\">#44621</a>). Because new convenience functions in package:ffi have been added, no additional boilerplate around allocating and freeing memory is required for common cases:</p><pre>// Allocate a pointer to an Utf8 array, fill it from a Dart string,<br>// pass it to a C function, convert the result, and free the arg.<br>//<br>// Before API change:<br>final pointer = allocate&lt;Int8&gt;(count: 10);<br>free(pointer);<br>final arg = Utf8.toUtf8(&#39;Michael&#39;);<br>var result = helloWorldInC(arg);<br>print(Utf8.fromUtf8(result);<br>free(arg);</pre><pre>// After API change:<br>final pointer = calloc&lt;Int8&gt;(10);<br>calloc.free(pointer);<br>final arg = &#39;Michael&#39;.toNativeUtf8();<br>var result = helloWorldInC(arg);<br>print(result.toDartString);<br>calloc.free(arg);</pre><h3>Automatically generating FFI bindings</h3><p>For large API surfaces it can be very time consuming to write the Dart bindings that integrate with the C code. To reduce this burden, we’ve built a binding generator for automatically creating FFI wrappers from C header files. We invite you to try it out: <a href=\"https://pub.dev/packages/ffigen\">package:ffigen</a>.</p><h3>FFI roadmap</h3><p>With the core FFI platform completed, we’re turning our focus to extending the FFI feature set with features that layer on top of the core platform. Some of the features we’re investigating include:</p><ul><li>ABI-specific data types like int, long, size_t (<a href=\"https://github.com/dart-lang/sdk/issues/36140\">#36140</a>)</li><li>Inline arrays in structs (<a href=\"https://github.com/dart-lang/sdk/issues/35763\">#35763</a>)</li><li>Packed structs (<a href=\"https://github.com/dart-lang/sdk/issues/38158\">#38158</a>)</li><li>Union types (<a href=\"https://github.com/dart-lang/sdk/issues/38491\">#38491</a>)</li><li>Exposing finalizers to Dart (<a href=\"https://github.com/dart-lang/sdk/issues/35770\">#35770</a>; however note that you can already <a href=\"https://github.com/dart-lang/sdk/issues/35770\">use finalizers from C</a>)</li></ul><h3>Sample uses of FFI</h3><p>We’ve seen many creative uses of Dart FFI to integrate with a range of C-based APIs. Here are a few examples:</p><ul><li><a href=\"https://pub.dev/packages/open_file\">open_file</a> is a single API for opening files across multiple platforms. It uses FFI to invoke native operating system APIs on Windows, macOS, and Linux.</li><li><a href=\"https://pub.dev/packages/win32\">win32</a> wraps most common Win32 APIs, making it possible to call a wide range of Windows APIs directly from Dart.</li><li><a href=\"https://pub.dev/packages/objectbox\">objectbox</a> is a fast database backed by a C-based implementation.</li><li><a href=\"https://pub.dev/packages/tflite_flutter\">tflite_flutter</a> uses FFI to wrap the TensorFlow Lite API.</li></ul><h3>What’s next for the Dart language?</h3><p>Sound null safety is the largest change we’ve made to the Dart language in several years. Next we’re going to look at making more incremental changes to the language and platform, building on our strong foundation. Here’s a quick view into some of the things we’re experimenting with in our <a href=\"https://github.com/dart-lang/language/projects/1\">language design funnel</a>:</p><p><strong>Type aliases</strong> (<a href=\"https://github.com/dart-lang/language/issues/65\">#65</a>): The ability to create type aliases to non-function types. For example you could create a typedef and use it as a variable type:</p><pre>typedef IntList = List&lt;int&gt;;<br>IntList il = [1,2,3];</pre><p><strong>Triple-shift operator</strong> (<a href=\"https://github.com/dart-lang/language/issues/120\">#120</a>): Adding a new, fully overridable &gt;&gt;&gt; operator for doing unsigned bit-shift on integers.</p><p><strong>Generic metadata annotations</strong> (<a href=\"https://github.com/dart-lang/language/issues/1297\">#1297</a>): Extending metadata annotations to also support annotations that contain type arguments.</p><p><strong>Static meta-programming</strong> (<a href=\"https://github.com/dart-lang/language/issues/1482\">#1482</a>): Support for static meta-programming — Dart programs that produce new Dart source code during compilation, similar to Rust <a href=\"https://doc.rust-lang.org/book/ch19-06-macros.html\">macros</a> and Swift <a href=\"https://github.com/apple/swift-evolution/blob/9992cf3c11c2d5e0ea20bee98657d93902d5b174/proposals/XXXX-function-builders.md\">function builders</a>. This feature is still in an early exploration phase, but we think it may enable use cases that today rely on code generation.</p><h3>Dart 2.12 is available now</h3><p>Dart 2.12, with sound null safety and stable FFI, is available today in the <a href=\"https://dart.dev/get-dart\">Dart 2.12</a> and <a href=\"https://flutter.dev/docs/get-started/\">Flutter 2.0</a> SDKs. Please take a moment to review the known null safety issues <a href=\"https://dart.dev/null-safety#known-issues\">for Dart</a> and <a href=\"https://flutter.dev/docs/null-safety#known-issues\">for Flutter</a>. If you find any other issues, please report them in the <a href=\"https://github.com/dart-lang/sdk/issues\">Dart issue tracker</a>.</p><p>If you’ve developed packages published on <a href=\"https://pub.dev\">pub.dev</a>, please review the <a href=\"https://dart.dev/null-safety/migration-guide\">migration guide</a> today, and learn how to migrate to sound null safety. Migrating your package is likely to help unblock other packages and apps that depend on it. We’d also like to extend a big thanks to those that migrated already!</p><p>We’d love to hear about your experience with both sound null safety and FFI. Leave a comment below or tweet us <a href=\"https://twitter.com/dart_lang\">@dart_lang</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=499a6e689c87\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87\">Announcing Dart 2.12</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-03-24T15:06:20.000Z":{"title":"Announcing Dart support for GitHub Actions","link":"https://medium.com/dartlang/announcing-dart-support-for-github-actions-3d892642104?source=rss----23738d481ce8---4","guid":"https://medium.com/p/3d892642104","category":["continuous-integration","github-actions","dart"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 24 Mar 2021 15:06:20 GMT","atom:updated":"2021-03-24T19:24:03.463Z","content:encoded":"<p><a href=\"https://github.com/features/actions\">GitHub Actions</a> is a popular offering for continuous integration (CI) for GitHub repos. Today, we’re announcing an official <a href=\"https://github.com/marketplace/actions/setup-dart-sdk\"><strong>setup-dart</strong> action</a> by the Dart team. This action supports downloading, installing, and configuring the Dart SDK, so you can run Dart build and test jobs with ease on GitHub Actions.</p><p>If you author a Dart package for pub.dev, we encourage you to enable CI testing with Github Actions for your repo, to give you (and package users) a signal about whether your package is healthy. CI jobs on GitHub Actions are <a href=\"https://github.com/pricing\">free for public repos</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5E8_aBC9TBl9oBUwN3jAJw.png\" /></figure><h3>Introducing setup-dart</h3><p>If you have a GitHub repository with a Dart app in it, you can enable CI testing with GitHub Actions and the setup-dart action with just a few clicks. Here we have a new GitHub repo called <a href=\"https://github.com/mit-mit/myapp\">myapp</a>, which contains the starting point for a small application generated with the Dart tool <a href=\"https://dart.dev/tutorials/server/get-started#3-create-a-small-app\">by running</a><br>dart create --template console-full myapp.</p><p>Next, open the GitHub web UI, and click the <strong>Actions</strong> tab:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*IA24lXOJ0Zy1uwXF\" /></figure><p>Just below the the introduction, you should see a section suggesting a workflow for a Dart repository:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*tz1_DLk4qI1MpI4z\" /></figure><p>Click the <strong>Set up this workflow</strong> button, and you’ll be taken to the GitHub UI for adding a new .github/workflow/dart.yml file. This is a YAML file that defines the GitHub Actions workflow to run in the repo. Let’s review each of the components suggested by the template <a href=\"https://github.com/dart-lang/characters/blob/master/.github/workflows/test-package.yml\">workflow</a> file.</p><p>First we define the name of the workflow, which will be shown in the Actions admin UI:</p><pre>name: Dart</pre><p>Next, we define when the workflow should be run (the <a href=\"https://docs.github.com/en/actions/learn-github-actions/introduction-to-github-actions\">event</a> that triggers the workflow). Here the flow is configured to run whenever there is a push to the main branch, or a PR for the main branch. I’ve personally found that when I’m having trouble getting a workflow to run, it’s often because I’ve misspelled the branch name.</p><pre>on:<br>  push:<br>    branches: [ main ]<br>  pull_request:<br>    branches: [ main ]</pre><p>Then follows a list of jobs, each with a name (here test). Each job has its own definition, consisting of a listing of where to run the job (this job runs on Ubuntu Linux) and what steps to take:</p><pre>jobs:<br>  test:<br>    runs-on: ubuntu-latest<br>    steps:</pre><p>As for the specific test, first we check out the repository under test, and then we run the new setup-dart action. This downloads and installs the Dart SDK, and then adds the dart CLI and pub global directory to the path. Here we don’t specify which Dart SDK to install, so the action will install the most recent stable-channel SDK.</p><pre>      - uses: actions/checkout@v2<br>      - uses: dart-lang/setup-dart@v1</pre><p>We can then go ahead and perform our desired tests, like formatting, analysis, and unit tests:</p><pre>      - name: Install dependencies<br>        run: dart pub get</pre><pre>      - name: Verify formatting<br>        run: dart format — output=none — set-exit-if-changed .</pre><pre>      - name: Analyze project source<br>        run: dart analyze</pre><pre>      - name: Run tests<br>        run: dart test</pre><p>For a full example, see our <a href=\"https://github.com/dart-lang/characters/blob/master/.github/workflows/test-package.yml\">workflow for package:characters</a>.</p><h3>Specifying SDK version</h3><p>The setup-dart action supports specifying the version of Dart you wish to install. This can take one of two forms:</p><ul><li>A specific version, e.g. 2.9.0 or 2.12.0–259.12.beta</li><li>The latest version from a <a href=\"https://dart.dev/get-dart#release-channels\">release channel</a>, e.g. stable or beta</li></ul><p>To specify a version use the sdk argument, either directly or as part of a <a href=\"https://docs.github.com/en/actions/learn-github-actions/managing-complex-workflows#using-a-build-matrix\">test matrix</a>:</p><pre>matrix:<br>    os: [ubuntu-latest, macos-latest, windows-latest]<br>    sdk: [2.10.0, stable, beta]<br>    runs-on: ${{ matrix.os }}<br>    steps:<br>      - uses: actions/checkout@v2<br>      - uses: dart-lang/setup-dart@v1.0<br>        with:<br>          sdk: ${{ matrix.sdk }}</pre><p>The result of this matrix is nine separately run jobs:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*Wm1ERed37w-oyoDq\" /></figure><p>Now that everything is passing, you might want to <a href=\"https://docs.github.com/en/actions/managing-workflow-runs/adding-a-workflow-status-badge\">add a status badge</a> to your README.md file to display the test status.</p><h3>Alternative solutions</h3><p>GitHub Actions is one of several popular solutions for continuous integration. Others with support for the Dart SDK include <a href=\"https://docs.travis-ci.com/user/languages/dart/\">Travis</a>, <a href=\"https://www.appveyor.com/\">AppVeyor</a>, and <a href=\"https://documentation.codeship.com/basic/languages-frameworks/dart/\">CodeShip</a>. For testing of <a href=\"https://flutter.dev/\">Flutter</a> apps, options include <a href=\"https://developer.nevercode.io/docs/building-flutter-apps\">Codemagic from Nevercode</a>, <a href=\"https://cirrus-ci.org/examples/#flutter\">Cirrus CI</a>, and <a href=\"https://devcenter.bitrise.io/getting-started/getting-started-with-flutter-apps/\">Bitrise</a>. GitHub Actions for Flutter apps is enabled by community contributed actions, such as <a href=\"https://github.com/marketplace/actions/flutter-action\">flutter-action</a>.</p><p>That’s it for now. We hope you enjoy <a href=\"https://github.com/marketplace/actions/setup-dart-sdk\">this new CI support for Dart</a>, and if you have any feedback or issues with setup-dart, please let us know in <a href=\"https://github.com/dart-lang/setup-dart/issues\">the issue tracker</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3d892642104\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-support-for-github-actions-3d892642104\">Announcing Dart support for GitHub Actions</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-03-17T16:02:19.000Z":{"title":"Dart in Google Summer of Code 2021","link":"https://medium.com/dartlang/dart-in-google-summer-of-code-2021-e89eaf1d177a?source=rss----23738d481ce8---4","guid":"https://medium.com/p/e89eaf1d177a","category":["google-summer-of-code","dartlang","flutter","open-source"],"dc:creator":"Jonas Finnemann Jensen","pubDate":"Wed, 17 Mar 2021 16:02:19 GMT","atom:updated":"2021-03-17T16:02:15.580Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/801/1*RaLW5kA_2I2WmYz5sx0srA.png\" /></figure><p>Google Summer of Code (GSoC) is a global program focused on bringing student developers into open source software development. Students are sponsored by Google to work with a mentoring open source organization on a 10-week programming project during the summer. Over the past 16 years, more than 16,000 students have participated in Google Summer of Code.</p><p>We’re excited to announce that Dart will be a mentoring organization in <a href=\"https://summerofcode.withgoogle.com/\">Google Summer of Code 2021</a>. This will be the second time Dart participates in Google Summer of Code. In 2020, the Dart organization mentored <a href=\"https://medium.com/dartlang/google-summer-of-code-2020-results-a38cd072c9fe\">5 successful students</a>.</p><h3>Are you interested?</h3><p>Get started now by reading <a href=\"https://github.com/dart-lang/sdk/wiki/Dart-GSoC-2021-Project-Ideas\">the list of project ideas</a> to find a match for your skills and interests. Although formal applications <a href=\"https://summerofcode.withgoogle.com/how-it-works/\">open on March 29th</a>, you can discuss and adapt project ideas with prospective mentors today.</p><blockquote>The Dart team expects to have enough mentors to accept only a handful of applications, so also check out the <a href=\"https://summerofcode.withgoogle.com/organizations/\">other mentoring organizations</a>.</blockquote><p>If you have questions specific to Dart and GSoC, ask them on <a href=\"https://groups.google.com/forum/#!forum/dart-gsoc\">our dedicated mailing list</a>.</p><p>For more information about Google Summer of Code, watch the video below. Or read the<a href=\"https://google.github.io/gsocguides/student/\"> student guide for Google Summer of Code</a>.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FS6IP_6HG2QE%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DS6IP_6HG2QE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FS6IP_6HG2QE%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href\">https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href</a></iframe><p>We look forward to hearing from you!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e89eaf1d177a\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-in-google-summer-of-code-2021-e89eaf1d177a\">Dart in Google Summer of Code 2021</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-05-12T19:03:33.000Z":{"title":"AngularDart, Flutter, and the web: Spring update","link":"https://medium.com/dartlang/angulardart-flutter-and-the-web-spring-update-f7f5b8b10001?source=rss----23738d481ce8---4","guid":"https://medium.com/p/f7f5b8b10001","category":["dart","angulardart"],"dc:creator":"Tim Sneath","pubDate":"Wed, 12 May 2021 19:03:33 GMT","atom:updated":"2021-05-12T19:03:32.158Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<h4>Adjusting our investment for Dart’s open source web frameworks</h4><p>Two months ago, we delivered our <a href=\"https://medium.com/flutter/flutter-web-support-hits-the-stable-milestone-d6b84e83b425\">first stable release of web support</a> for Flutter. This was a major milestone for client development as a whole, combining Flutter’s established UI framework, Dart’s industrial-strength JavaScript toolchain, and the underlying power of the web platform to deliver consistency across mobile devices and browsers.</p><p>Since that release, we’ve been excited to see developers start to use Flutter on the web. Even at this early stage, more than 10% of flutter build commands target the web, demonstrating that web apps are already being deployed using Flutter. Inside Google, a number of teams are starting to rely on Flutter’s web support. And we use it heavily ourselves for Flutter development, both for <a href=\"https://dartpad.dev/e0a2e942e85fde2cd39b2741ff0c49e5?null_safety=true\">DartPad</a> and for <a href=\"https://flutter.dev/docs/development/tools/devtools/overview\">DevTools</a>, our suite of performance and debugging tools.</p><p>When we first started adding web support to Flutter a couple of years ago, we were hopeful that it would lead to good results, but it still felt like a moonshot. While much work remains, we’re confident that Flutter’s web support has the potential to fill an important niche with a high-quality solution. So, we’re adjusting our investments for Dart’s open source web tooling to focus on Flutter.</p><p>In changing our focus, we’re also scaling back our external work on AngularDart, a separate web framework that evolved out of the original Angular project. Six months ago, <a href=\"https://groups.google.com/a/dartlang.org/g/announce/c/Kz84KNBcf3U\">we announced a roadmap for AngularDart</a> that included publishing a long-term stable update (<a href=\"https://pub.dev/packages/angular/changelog\">AngularDart 6</a>) and supporting null safety, but prioritized AngularDart engineering work on major internal customers, including <a href=\"https://ads.google.com/\">Google Ads</a> and <a href=\"https://play.google.com/console\">Google Play Console</a>. Although the AngularDart framework itself is relatively easy to open source, Google’s build and release systems are <a href=\"https://sre.google/sre-book/release-engineering/#continuous-build-and-deployment-Yms8u8\">uniquely specialized</a>, resulting in significant divergence that makes it nontrivial to synchronize internal and external releases.</p><p>Focusing on the majority of AngularDart users helps us make the most of our talented engineering resources, and we hope everyone benefits as a result. For projects like Ads and Play Console, we can more directly address their needs without worrying about external implications; for external users, we can put all our energy into giving you a high-quality Flutter product that works across web, desktop, mobile, and embedded scenarios.</p><blockquote>We can put all our energy into giving you a high-quality Flutter product that works across web, desktop, mobile, and embedded scenarios.</blockquote><p>Over the past few months, we’ve been talking with the largest external users of AngularDart to help them with their own roadmaps. For some, Flutter’s web support is a perfect choice; others are happy with the stability and maturity of AngularDart as it stands; yet others are using this opportunity to transition to <a href=\"https://angular.io/\">Angular</a>, Google’s popular TypeScript-based web framework.</p><p>Angular itself continues to grow quickly. In the last year, <a href=\"https://www.npmjs.com/package/@angular/core\">weekly downloads have grown by over 60%</a> and nearly <a href=\"https://github.com/angular/angular/network/dependents?package_id=UGFja2FnZS00NTE2NDYyMzQ%3D\">two million public GitHub repositories depend on it</a>. Its syntax will be familiar to those who are using AngularDart today, and it’s a logical choice for developers looking for a modern web framework.</p><p>For developers who want to use Dart, we think Flutter’s web support will be an exciting choice. As an early example, <a href=\"https://propops.com/en/\">PropOps</a> — a tech startup in the real estate space—has had great success building a line-of-business app with Flutter, as the screenshots below demonstrate:</p><figure><img alt=\"Screenshots of the PropOps web app\" src=\"https://cdn-images-1.medium.com/max/1024/1*TnLjhbuMnphc4ZlsuSdtog.png\" /><figcaption>PropOps: a cloud-based property management tool, built with Flutter’s web support.</figcaption></figure><p>In the next few weeks, we’ll deliver a stable external release of AngularDart with null safety; at that point, it will shift into maintenance mode. If a committed consortium or community group wants to take over leadership of the project and continue to evolve it, we’re interested in hearing from them.</p><p>We’re moving full steam ahead on Flutter’s web support as well as on Angular itself: stay tuned for more on that at next week’s <a href=\"https://events.google.com/io/\">Google I/O event</a>!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f7f5b8b10001\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/angulardart-flutter-and-the-web-spring-update-f7f5b8b10001\">AngularDart, Flutter, and the web: Spring update</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-07-27T18:25:17.000Z":{"title":"Experimenting with Dart and Wasm","link":"https://medium.com/dartlang/experimenting-with-dart-and-wasm-ef7f1c065577?source=rss----23738d481ce8---4","guid":"https://medium.com/p/ef7f1c065577","category":["wasm","dart","webassembly","computer-science","interoperability"],"dc:creator":"Michael Thomsen","pubDate":"Tue, 27 Jul 2021 18:25:17 GMT","atom:updated":"2021-07-28T11:54:54.965Z","content:encoded":"<h4>Compiling Dart to Wasm, and calling Wasm modules from Dart</h4><p><em>By Liam Appelbe &amp; Michael Thomsen</em></p><p><a href=\"https://webassembly.org/\">WebAssembly</a> (commonly abbreviated to Wasm) is <em>“a binary instruction format for a stack-based virtual machine”.</em> Although Wasm was originally designed for running native code on the web, Wasm has since evolved into a general technology for running compiled code across multiple platforms. Dart is already a highly portable and multi-platform language, so we’re very interested in how Wasm might enable us to extend these qualities of Dart.</p><h3>Why experiment with Wasm?</h3><p>Wasm has gained <a href=\"https://webassembly.org/roadmap/\">broad support</a> by browser vendors, such as Chrome, Edge, Firefox, and WebKit. This makes Wasm a very interesting prospect for running binary code in the browser. However, originally Wasm wasn’t designed for programming languages with garbage collection (GC), such as Dart and Java/Kotlin, making it difficult to efficiently compile GC-based languages to Wasm. By engaging with the Wasm project on their recent <a href=\"https://github.com/WebAssembly/gc/blob/master/README.md\">GC proposal</a>, we’re hoping to both provide technical feedback on the proposal, and learn more about what gains we might get from running Dart-based web apps via Wasm code.</p><p>A second quality of Wasm is that the binary Wasm modules are platform independent. This potentially makes interoperability with existing code more practical: If that existing code could be compiled to Wasm, then Dart apps across all platforms could depend on a single, shared binary Wasm module.</p><p>In the remainder of this post we’ll discuss our experiments with Wasm and Dart in two forms:</p><p>1) <strong>Dart to Wasm compilation</strong>: Extending our AOT compilers with support for compiling Dart source code to Wasm binary code (issue <a href=\"https://github.com/dart-lang/sdk/issues/32894\">32894</a>).</p><p>2) <strong>Dart to Wasm interop</strong>: Support for calling from Dart code to compiled Wasm modules (issues <a href=\"https://github.com/dart-lang/sdk/issues/37355\">37355</a> &amp; <a href=\"https://github.com/dart-lang/sdk/issues/37882\">37882</a>).</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/685/1*UqHnD9vyTvndgJpz8gOv7Q.png\" /><figcaption>Illustration of the two potential uses of Wasm with Dart</figcaption></figure><h3>Compiling Dart to Wasm</h3><p>As mentioned, Wasm originated as a way of running native code on the web. The web is traditionally powered by JavaScript code, which is run in a virtual machine (VM) that performs just-in-time (JIT) compilation of the JavaScript code to native code while the web app is running. In current Dart frameworks that target the web, such as <a href=\"https://flutter.dev/web\">Flutter web</a>, the Dart app code is compiled to <a href=\"https://dart.dev/web/deployment\">optimized</a> JavaScript for deployment, and this JavaScript is then JIT-compiled by the web platform to native code when the app is running.</p><p>We’re investigating compilation of Dart code directly to Wasm native code to see if we can get a more direct path to running native code on the web. The Wasm assembly format is low-level and closer than JavaScript to the abstraction level of machine code, which leads to improved startup time and generally a more predictable efficiency.</p><p>Dart’s support for compiling to Wasm is an early stage investigation and the compiler is incomplete, but we’re experimenting to learn. We’ve always had an interest in Wasm as a compilation target for Dart, but its original form doesn’t work well for languages with garbage collection. Wasm lacks built-in garbage collection support, so languages like Dart must include a garbage collection implementation into the compiled Wasm module. Including a GC implementation would be highly complex, would inflate the size of the compiled Wasm code and hurt startup time, and wouldn’t lend itself well to object-level interop with the rest of the browser system.</p><p>Fortunately, an ongoing effort in the WebAssembly community, known as <a href=\"https://github.com/WebAssembly/gc/blob/master/README.md\">Wasm GC</a>, is exploring the possibility of expanding Wasm with direct and performant support for garbage collected languages. Given our longstanding interest in Wasm, we saw an opportunity to engage the community and provide real-world experience by writing a compiler that translates Dart to Wasm GC.</p><p>It’s too early to predict where this might take us, but our initial prototyping is showing very positive results, with initial benchmarks showing both faster time to first frame and faster average frame time / throughput. If you’re interested in learning more about the project, take a look at the <a href=\"https://github.com/askeksa-google/sdk/blob/wasm_prototype/dart2wasm.md\">wasm_prototype</a> source code.</p><h3>Interoperability with Wasm code (package:wasm)</h3><p>Besides compiling to Wasm, we’re also interested in investigating if Wasm can be used for integrating with existing code in a way that is more cross platform. Several languages support compiling to modules that follow the C calling convention, and with <a href=\"https://dart.dev/guides/libraries/c-interop\">Dart FFI</a> you have interoperability with these modules. Dart FFI can be a great way of leveraging existing source code and libraries, rather than having to reimplement the code in Dart.</p><p>However, because C modules are platform specific, distributing shared packages with native C modules is complicated: it requires either a universal build system, or distributing multiple binary modules (one for each desired platform). Distribution would be much easier if a single Wasm binary assembly format could be used across all platforms. Then, rather than compiling your library to platform-specific binary code for every target platform, you could compile it once to a Wasm binary module and run that everywhere. This would potentially open the door to easy distribution on <a href=\"https://pub.dev\">pub.dev</a> of packages that contain native code.</p><p>We’re experimenting with support for Wasm interop in a new package, <a href=\"https://pub.dev/packages/wasm\">package:wasm</a>. This prototype is built on the <a href=\"https://wasmer.io/\">Wasmer</a> runtime, and it supports <a href=\"https://wasi.dev/\">WASI</a> for OS interaction. Note that our current prototype is incomplete and supports only desktop platforms (Windows, Linux, and macOS).</p><h3>Example: Calling into the Brotli compression library</h3><p>Let’s take a look at an example of using package:wasm to leverage the <a href=\"https://github.com/google/brotli\">Brotli compression library</a>, compiled to a Wasm module. In the example, we’ll read an input file, compress it, report its compression ratio, and then decompress it and verify we get the input back. See the GitHub repo for the full <a href=\"https://github.com/dart-lang/wasm/tree/main/example\">sample source code</a>. Because package:wasm is built on top of <a href=\"https://dart.dev/guides/libraries/c-interop\">dart:ffi</a>, you may find the steps familiar if you have experience with FFI.</p><p>There are a few ways of compiling C code to Wasm, but in this case we used <a href=\"https://github.com/wasienv/wasienv\">wasienv</a>. Full details are available in the <a href=\"https://github.com/dart-lang/wasm/blob/main/README.md\">README</a>.</p><p>For this example, we’ll try to call these Brotli functions for compressing and decompressing data:</p><pre>int BrotliEncoderCompress(<br>  int quality, int lgwin, int mode, size_t input_size,<br>  const uint8_t* input_buffer, size_t* output_size,<br>  uint8_t* output_buffer);</pre><pre>int BrotliDecoderDecompress(<br>  size_t encoded_size, const uint8_t* encoded_buffer,<br>  size_t* output_size, uint8_t* output_buffer);</pre><p>The quality, lgwin, and mode arguments are tuning parameters for the encoder. The details aren’t relevant to the example, so we’ll just use default values for these. Another thing to note is that output_size is an in-out parameter. When we call these functions, output_size must be initialized with the size of the output_buffer that we have allocated, and afterwards it will be set to the amount of the buffer that was actually used.</p><p>The first step is to use our compiled Wasm binary to construct a WasmModule object. The binary data should be a Uint8List, which we can get by reading it from a file using file.readAsBytesSync().</p><pre>var brotliPath = Platform.script.resolve(‘libbrotli.wasm’);<br>var moduleData = File(brotliPath.path).readAsBytesSync();<br>var module = WasmModule(moduleData);</pre><p>A very useful debugging tool for making sure our Wasm module has the API we expect is module.describe(). This returns a string listing all of the module’s imports and exports.</p><pre>print(module.describe());</pre><p>For our Brotli library, this is the output:</p><pre>import function: int32 wasi_unstable::fd_close(int32)<br>import function: int32 wasi_unstable::fd_write(int32, int32, int32, int32)<br>import function: int32 wasi_unstable::fd_fdstat_get(int32, int32)<br>import function: int32 wasi_unstable::fd_seek(int32, int64, int32, int32)<br>import function: void wasi_unstable::proc_exit(int32)</pre><pre>export memory: memory<br>export function: int32 BrotliDecoderSetParameter(int32, int32, int32)<br>export function: int32 BrotliDecoderCreateInstance(int32, int32, int32)<br>export function: void BrotliDecoderDestroyInstance(int32)<br>export function: int32 BrotliDecoderDecompress(int32, int32, int32, int32)<br>…<br>export function: int32 BrotliEncoderSetParameter(int32, int32, int32)<br>export function: int32 BrotliEncoderCreateInstance(int32, int32, int32)<br>export function: void BrotliEncoderDestroyInstance(int32)<br>export function: int32 BrotliEncoderMaxCompressedSize(int32)<br>export function: int32 BrotliEncoderCompress(int32, int32, int32, int32, int32, int32, int32)</pre><pre>…</pre><p>We can see that the module imports some WASI functions, and exports its memory and a bunch of Brotli functions. The two functions we’re interested in are exported, but their signature looks a bit different. This is because Wasm only supports 32-bit and 64-bit ints and floats. The pointers have become int32 indexes into the exported memory.</p><p>The next step is to instantiate the module. During instantiation we must fill every import that the module is expecting. Instantiation uses the builder pattern (module.instantiate(). initialization… .build()). Our library only imports WASI functions, so we can just call enableWasi():</p><pre>var instance = module.instantiate().enableWasi().build();</pre><p>If we had additional non-WASI function imports we could use addFunction() to import a Dart function into the wasm library.</p><p>Now that we have a WasmInstance, we can look up any of its exported functions, or inspect its memory:</p><pre>var memory = instance.memory;<br>var compress = instance.lookupFunction(“BrotliEncoderCompress”);<br>var decompress = instance.lookupFunction(“BrotliDecoderDecompress”);</pre><p>The next thing we want to do is use the compress and decompress functions on our input file. But we can’t pass the data directly to these functions. The C functions take uint8_t pointers to the data, but in Wasm code these pointers become int32 indexes into the instance’s memory. Brotli also reports the size of the compressed and decompressed data using size_t pointers, which also become int32s.</p><p>So to pass our data to the functions we have to copy it into the instance’s memory and pass its index to the function. We need 5 regions of memory: the input data, the compressed data, the compressed size, the decompressed data, and the decompressed size. For simplicity we’re just going to grab some unused areas of memory, but you could also export malloc() and free() in your library.</p><p>To make sure we’re putting the data in unused memory, we’re going to grow the instance memory and use the new region for our data:</p><pre>var inputPtr = memory.lengthInBytes;<br>memory.grow((3 * inputData.length /<br>    WasmMemory.kPageSizeInBytes).ceil());<br>var memoryView = memory.view;<br>var outputPtr = inputPtr + inputData.length;<br>var outSizePtr = outputPtr + inputData.length;<br>var decodedPtr = outSizePtr + 4;<br>var decSizePtr = decodedPtr + inputData.length;</pre><p>Our memory regions look like this:</p><pre>[initial instance memory][input][output][output size][decoded][decoded size]</pre><p>Next, we load the input data in the memory, and call our compression function:</p><pre>memoryView.setRange(<br>    inputPtr, inputPtr + inputData.length, inputData);</pre><pre>var status = compress(kDefaultQuality, kDefaultWindow, kDefaultMode,<br>    inputData.length, inputPtr, outSizePtr, outputPtr);</pre><p>The rest of the example works similarly. This is the result:</p><pre>Loading lipsum.txt<br>Input size: 3210 bytes</pre><pre>Compressing…<br>Compression status: 1<br>Compressed size: 1198 bytes<br>Space saving: 62.68%</pre><pre>Decompressing…<br>Decompression status: 1<br>Decompressed size: 3210 bytes</pre><pre>Verifying decompression…<br>Decompression succeeded :)</pre><h3>Trying package:wasm</h3><p>If you’re interested in trying Wasm interop, check out the package:wasm <a href=\"https://pub.dev/packages/wasm\">README</a> for instructions.</p><h3>Roadmap</h3><p>Both Wasm compilation and Wasm interop are experiments. If those experiments prove fruitful, we plan to continue to develop them and eventually productize them into stable, supported versions. However, if we learn that something doesn’t work as intended, or see a lack of interest, we’ll discontinue the experiments.</p><p>We’re making these experiments to learn, with two main components. First, we want to learn about the feasibility of technically supporting Wasm, and what the characteristics of this support might be. Can it make Dart code faster, smaller, or more predictable? Second, we’re interested in exploring what new technical capabilities Wasm might unlock, and what new use cases these might enable for Dart developers. Can we make interop with native code more portable?</p><p>How do you think Wasm might apply to your needs? What do you think you’d use it for? We’d love to hear your thoughts. Please let us know on the <a href=\"https://groups.google.com/a/dartlang.org/g/misc/\">Dart misc discussion group</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ef7f1c065577\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/experimenting-with-dart-and-wasm-ef7f1c065577\">Experimenting with Dart and Wasm</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-06-23T22:14:37.000Z":{"title":"How Dart’s null safety helped me augment my projects","link":"https://medium.com/dartlang/how-darts-null-safety-helped-me-augment-my-projects-af58f8129cf?source=rss----23738d481ce8---4","guid":"https://medium.com/p/af58f8129cf","category":["dart","null-safety","flutter"],"dc:creator":"Waleed Arshad","pubDate":"Wed, 23 Jun 2021 22:14:37 GMT","atom:updated":"2021-06-23T22:14:37.155Z","content:encoded":"<h4>I migrated a running app and a published package to null safety, and it was awesome!</h4><blockquote><strong>About the author:</strong> Waleed Arshad is a core mobile technologist, a passionate cross-platform developer, and the first person from Pakistan to become a Google Developer Expert for Flutter. After graduating from FAST Karachi, he has been working in the industry for more than five years and is currently working in the Developer Experience team for Flutter at Tendermint. He also leads Pakistan’s Flutter community.</blockquote><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HlInW7jXUifJIGBK1YEQEw.jpeg\" /></figure><p>With the launch of Flutter 2, null safety was made available to Flutter’s stable channel. This post talks about my personal experiences with migrating my apps and packages to null safety, along with creating null-safe apps from scratch. In short, the results were amazing!</p><blockquote>If you aren’t aware of Flutter’s null safety feature, check out the <a href=\"https://medium.com/dartlang/announcing-dart-null-safety-beta-87610fee6730\">announcement of null safety</a>. If you want to fully understand null safety, check out <a href=\"https://dart.dev/null-safety/understanding-null-safety\">the Dart documentation for null safety</a>.</blockquote><p>This article describes two of my experiences with null safety:</p><ul><li>Migrating an app and a package</li><li>Writing new code in a null-safe environment</li></ul><h4>Migrating an app and a package</h4><p>When I first upgraded Flutter to version 2.0 (the one that supports null safety) and updated my Dart SDK version to 2.12 in my Flutter app’s pubspec.yaml file, I saw a lot of errors. I wanted to initially try a manual migration to null safety (that is, migrate without the migration tool), so I started to resolve the null safety errors manually — adding question marks and exclamation points all over my code. I did all of that work intentionally, just to understand all the hard work done by the Flutter team on the <a href=\"https://dart.dev/null-safety/migration-guide#migration-tool\">null safety migration tool</a> to automate the process of changing and updating the code! After some experimentation, I reverted all the manual changes I’d made by hand, and I used the magic of the tool to complete the migration of my app.</p><p>The application was an experimental COVID-19 stats app, and its code is fully open sourced. You can find it <a href=\"https://github.com/wal33d006/novel_covid_19\">on GitHub</a>.</p><p>It was really cool to see all the code changes the migration tool did in my project — code changes like adding question marks in nullables and adding exclamation points where the migration tool detected that the value was never going to be null.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*4-Gy0ZFl5Sgn2Cw-LLn2lA.png\" /></figure><p>The following is an example of the migration tool automatically adding question marks and exclamation points . _homeCountry is a nullable property of a class named HomeCountry (which is also nullable). Therefore, to guard access to one of the properties of _homeCountry, the tool added the question mark operator.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/642/1*Cg1Ol3w_bIs6IIh734CBug.png\" /></figure><p>After the migration, some issues in the code became evident, <strong>which is the best part</strong>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*7nfnF2UAdK6zoIhX4wMG9w.png\" /></figure><p>One of the issues was that some nullable strings were being passed as a list to an internal function of the <a href=\"https://pub.dev/packages/shared_preferences\">shared_preferences</a> plugin. Because these values were nullable, the tool made the whole list type &lt;String?&gt;[]<em>, </em>which started giving an error because the function accepted the type &lt;String&gt;[]<em>.</em></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*ahhIw3H8kp5WGMjDmrSzLg.png\" /></figure><p>A simple solution to this problem was to remove the question mark and make the list type match the type of the function parameter. When I did that, the analyzer started saying that a nullable type (String?) can’t be assigned to a non-nullable type (String).</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/872/1*zHYqxaqdHWBdAILhoNMMrQ.png\" /></figure><p>To resolve the problem, I made each property of HomeCountry class non-nullable and added a required keyword in the constructor. That meant it was now necessary to pass the arguments while initializing HomeCountry. I didn’t have to change the setHomeCountry function because the variables being passed to the list were now non-nullable.</p><p>This change prevented me from mistakenly sending a null value to shared preferences in my code, which was very valuable input by the null safety feature!</p><p>Another thing null safety found was a bug that could cause a crash at runtime. See the following code snippet:</p><figure><img alt=\"A screenshot of code for setState() that assumes (but doesn’t check) that list isn’t null.\" src=\"https://cdn-images-1.medium.com/max/1024/1*_uvcdlH2M7GvaW3tpgnTng.png\" /></figure><p>Because list was a nullable variable, reading its index-based elements could cause a crash. After migrating to null safety, I couldn’t compile the app because there was no null check before reading the values in this list.</p><p>Ultimately, I added a null check to make the code compile and to prevent the app from crashing at this place in the code. It’s amazing how migrating helped me find an actual bug!</p><figure><img alt=\"In this code sample, the code for setState is protected by a null check: `if (list != null)`\" src=\"https://cdn-images-1.medium.com/max/686/1*_a3XuVgmXlj9byIGPb-olg.png\" /><figcaption>The code for setState is now valid because list isn’t null.</figcaption></figure><p>I also happened to migrate a very small package, which you can find on <a href=\"https://pub.dev/\">pub.dev</a>, called <a href=\"https://pub.dev/packages/progress_indicators\">progress_indicators</a>. I was astonished to see how the migration tool added late keywords instead of question marks when it concluded that those variables were initialized before being used.</p><figure><img alt=\"A screenshot of source code for a class that has `late` fields.\" src=\"https://cdn-images-1.medium.com/max/1024/1*Nfm_rVVsyCGnCLqWE1pvbQ.png\" /></figure><h4>Writing new code in a null-safe environment</h4><p>Now that Flutter has null safety, creating new apps is a better developer experience. Writing new code in a null-safe environment also provides a better understanding of code flows, along with being able to write crash-safe code. You cannot create compilable code with a class like this now:</p><pre>class MyClass {<br>  String a;<br><br>  MyClass({this.a});<br>}</pre><p>This code causes a compile-time error that says to mark a as nullable, put a required keyword in the constructor, or add an initializer. The code is making sure that a is never null. So, depending on your use case, you might do this:</p><pre>class MyClass {<br>  String? a;<br><br>  MyClass({this.a});<br>}</pre><p>Or you might do this:</p><pre>class MyClass {<br>  String a;<br><br>  MyClass({required this.a});<br>}</pre><blockquote>Notice that you don’t put an at sign (@) before the required keyword, as of Flutter 2 (and Dart 2.12).</blockquote><p>Or you might keep a as optional, but add an initializer giving it a default value if one isn’t passed:</p><pre>class MyClass {<br>  String a;<br><br>  MyClass({this.a = &#39;&#39;});<br>}</pre><p>Also, now you can create nullable variables of your own created classes:</p><pre>class MyClass {<br>  String? a;<br><br>  MyClass({this.a});<br>}</pre><pre>// somewhere in main code</pre><pre>MyClass? myClass;</pre><p>Because myClass has a nullable type, your compiler will give an error if you write something like this:</p><pre>print(myClass.a);</pre><p>Here is the error:</p><blockquote>The property ‘a’ can’t be unconditionally accessed because the receiver can be ‘null’.</blockquote><p>You can fix that error by adding a question mark:</p><pre>print(hello?.a);</pre><p>Dart’s null safety feature makes sure that you write less vulnerable and safer code. Picking up errors related to null variables during compile time is a valuable addition to the development experience. The preceding example shows how the compiler stops you from compiling the code whenever it detects the possibility of a null-pointer exception causing the app to crash at runtime. This clearly means that the compiler tries to write null-safe code as much as possible (unless you use the ! operator to force unwrap everything).</p><p>In conclusion, Dart’s sound null safety is a credible kick starter for building safer, faster, and more reliable apps! The overall coding experience is now highly formulated and more organized. I recommend that you migrate your old Dart apps to null safety to understand how it works. Maybe you’ll be lucky enough to find and fix some bugs in your old code!</p><p>Happy coding! :)</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=af58f8129cf\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/how-darts-null-safety-helped-me-augment-my-projects-af58f8129cf\">How Dart’s null safety helped me augment my projects</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-06-08T19:17:07.000Z":{"title":"Implementing structs by value in Dart FFI","link":"https://medium.com/dartlang/implementing-structs-by-value-in-dart-ffi-1cb1829d11a9?source=rss----23738d481ce8---4","guid":"https://medium.com/p/1cb1829d11a9","category":["programming","dart","compilers","ffi"],"dc:creator":"Daco Harkes","pubDate":"Tue, 08 Jun 2021 19:17:07 GMT","atom:updated":"2021-06-08T19:17:06.970Z","content:encoded":"<h4>A deep dive into API design and native calling conventions</h4><p>In the <a href=\"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87\">Dart 2.12</a> release, we extended our <a href=\"https://dart.dev/guides/libraries/c-interop\">C-interop feature, Dart FFI,</a> with the ability to <a href=\"https://github.com/dart-lang/sdk/issues/36730\">pass structs by value</a>. This article talks about what it took to add this feature to the Dart SDK. If you’re interested in low-level language implementation details or in platform conventions for passing structs by value, keep reading.</p><p>This article talks about both developing the API and figuring out the ABI (Application Binary Interface) for the struct-by-value feature. During the two years we worked on this feature (and other Dart FFI features), we discovered many constraints that required changing the API. The ABI journey was equally interesting, illustrating that you can take multiple approaches to nailing down the details of a hard problem.</p><h3>Pass by value and pass by reference in C/C++</h3><p>Here’s a quick refresher if you don’t write code in C every day. Suppose that we have the following struct and functions in C:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/6e68770c6067afbd626f33493c7c6cd9/href\">https://medium.com/media/6e68770c6067afbd626f33493c7c6cd9/href</a></iframe><p>Then, we can use these functions in some simple C code. Let’s say we have a local variable c1:</p><pre>Coord c1 = {10.0, 10.0, nullptr};</pre><p>If we pass c1 to TranslateByValue, then the argument is passed by value, which makes the callee effectively operate on a copy of the struct:</p><pre>Coord c2 = TranslateByValue(c1);</pre><p>This means that c1 stays unchanged.</p><p>However, if we pass c1 by reference with a pointer to the memory containing c1, then c1 gets mutated in place:</p><pre>TranslateByPointer(&amp;c1);</pre><p>c1.x now contains 20.0.</p><h3>The API design journey</h3><p>The original Dart FFI <a href=\"https://dart-review.googlesource.com/c/sdk/+/80124\">prototype</a> already had support for passing pointers to structs. However, we redesigned the API multiple times to accommodate various use cases and constraints.</p><h4>Initial design</h4><p>Our initial design enabled allocating structs in memory, passing those pointers to C, and modifying the fields of the structs. With that approach, the Struct class extended the Pointer class:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/34db590da63bf3819ca3c32d49ffeb78/href\">https://medium.com/media/34db590da63bf3819ca3c32d49ffeb78/href</a></iframe><p>Dart FFI users wrote the preceding snippet, and Dart FFI internals generated an implementation of sizeOf and getter and setter implementations for x, y, and next.</p><p>However, two years ago we realized that <a href=\"https://github.com/dart-lang/sdk/issues/35840\">this design had an issue</a>. By having the Coordinate extend Pointer, we could not distinguish between Coordinate and Coordinate*.</p><h4>Distinguishing between Coordinate and Coordinate*</h4><p>We <a href=\"https://dart-review.googlesource.com/c/sdk/+/101291\">introduced</a> Struct to Dart FFI and made structs extend this class:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a77f2199817c8f0f7d56b5d70a64325d/href\">https://medium.com/media/a77f2199817c8f0f7d56b5d70a64325d/href</a></iframe><p>Now a Pointer&lt;Coordinate&gt; in Dart represents a Coordinate* in C, and a Coordinate in Dart represents a Coordinate in C.</p><p>This meant that the next field had the type Pointer&lt;Coordinate&gt;, which made the @Pointer annotation redundant. So, we <a href=\"https://dart-review.googlesource.com/c/sdk/+/108415\">got rid of Pointer annotations</a>.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/69f4ff54d9634bd1ceae57af5c676779/href\">https://medium.com/media/69f4ff54d9634bd1ceae57af5c676779/href</a></iframe><p>Because we now represented pointers to structs as Pointer objects, we started using the allocate factory on Pointer:</p><pre>final c = Pointer&lt;Coordinate&gt;.allocate();</pre><p>To get access to the fields of a Pointer&lt;Coordinate&gt;, we need an object of type Coordinate, because that object has the fields x, y, and next. For this, we had the load method on Pointer already.</p><pre>c.load&lt;Coordinate&gt;().x = 10.0;</pre><p>Of course, having to write &lt;Coordinate&gt; on calling load is verbose. (Having to write a type argument was the same for loading a Dart int out of a Pointer&lt;Uint8&gt;.) The reason we need this type argument on load is to specify to the Dart type system the return type of this method.</p><h4>Extension methods to the rescue</h4><p>Dart 2.7 <a href=\"https://medium.com/dartlang/dart-2-7-a3710ec54e97\">introduced</a> extension methods. With extension methods, we could <a href=\"https://dart-review.googlesource.com/c/sdk/+/118992/14/sdk/lib/ffi/ffi.dart\">pattern match</a> on the type argument T in Pointer&lt;T&gt;:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/c9231b9bdecf725c61e3b405cf72785a/href\">https://medium.com/media/c9231b9bdecf725c61e3b405cf72785a/href</a></iframe><p>Pattern matching on the type argument enabled us to <a href=\"https://dart-review.googlesource.com/c/sdk/+/118993/16/tests/ffi/structs_test.dart\">get rid of the verbosity</a> on call sites:</p><pre>c.ref.y = 10.0; // ref is pattern matched to be of type Coordinate.</pre><p>We could also use the extension method pattern matching to make the type argument of Struct&lt;S&gt; redundant, changing the definition of user structs to:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/786de9cbf15369b19f828b793993ba84/href\">https://medium.com/media/786de9cbf15369b19f828b793993ba84/href</a></iframe><p>Before, the type argument &lt;S&gt; constrained the Struct field Pointer&lt;S&gt; addressOf. Instead, we changed the field to an extension getter:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2f678cb89187929eca771c2738bca3ff/href\">https://medium.com/media/2f678cb89187929eca771c2738bca3ff/href</a></iframe><h4>Stop leaking backing storage</h4><p>When returning a struct by value from C to Dart, we don’t want to malloc C memory to save the struct, because that would be slow <em>and</em> burden the user with freeing it. So, instead, the struct is copied to a TypedData, and the Coordinate can have either a Pointer or a TypedData as backing storage.</p><p>However, addressOf, which was introduced in the first redesign, had type Pointer. This type conveyed that it was always backed by C memory, but this was no longer true.</p><p>So, we <a href=\"https://github.com/dart-lang/sdk/issues/40667\">deprecated</a> addressOf.</p><h4>For optimizations</h4><p>The last step is to require invocations of various Dart FFI methods, including the ones related to structs, to have <a href=\"https://github.com/dart-lang/sdk/issues/44621\">compile-time constant type arguments</a>:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/31e20b6edc1a0ce31581e4b28c7cbd03/href\">https://medium.com/media/31e20b6edc1a0ce31581e4b28c7cbd03/href</a></iframe><p>The invocation of methods allows us to better optimize the code and is more aligned with C semantics.</p><p>Note that this last change triggers deprecation notices in Dart 2.12, and the change is enforced in Dart 2.13.</p><h3>The ABI discovery journey</h3><p>Now that the API is in place, the next question is: <em>Where does C expect these structs when passed or returned by value?</em> This is known as the Application Binary Interface (ABI).</p><h4>Documentation</h4><p>The natural thing is to look for documentation. ARM provides <a href=\"https://developer.arm.com/documentation/ihi0042/h\">Procedure Call Standard for the Arm Architecture — ABI 2019Q1 </a>and <a href=\"https://developer.arm.com/documentation/ihi0055/c/\">Procedure Call Standard for the ARM 64-bit Architecture (AArch64)</a>. However, the x86 and x64 official documentation <a href=\"https://stackoverflow.com/questions/18133812/where-is-the-x86-64-system-v-abi-documented\">fell off the internet</a>, resulting in people searching for this information and resorting to unofficial mirrors or <a href=\"https://www.agner.org/optimize/calling_conventions.pdf\">reverse engineering</a>.</p><p>A quick glance at the documentation shows a variety of locations for passing structs by value:</p><ul><li>In multiple CPU and FPU registers.</li><li>On the stack.</li><li>A pointer to a copy. (The copy is on the caller’s stack frame.)</li><li>Partially in CPU registers and partially on the stack.</li></ul><p>When passed on the stack, there are some further questions about what the required alignment is and whether all unused CPU and FPU registers are blocked off or backfilled.</p><p>When returning a struct by value, the struct can be passed back in two locations:</p><ul><li>In multiple CPU and FPU registers.</li><li>Written to a memory location by the callee, in which case the caller passes in a pointer to that memory location. (This reserved memory is also on the caller’s stack frame.)</li></ul><p>When a pointer to the result location is passed in, a further question is whether this conflicts with a normal CPU argument register.</p><h4>Refactor Dart FFI compilation</h4><p>This initial investigation was enough to realize that we had to reengineer a part of the Dart FFI compiler pipeline. We used to reuse the Location type, which was originally intended for compiling Dart code to assembly.</p><p>However, in the Dart ABI, we never use non-word-aligned stack locations or more than two registers at the same time. An experiment trying to extend the Location type to support these extra locations ended in a huge complicated diff because Location is used a lot in the Dart virtual machine.</p><p>So, instead, we <a href=\"https://dart-review.googlesource.com/c/sdk/+/129081\">replaced the compilation pipeline</a> for Dart FFI.</p><h4>Explore the native ABIs</h4><p>Let’s explore the ABIs a bit.</p><p>Suppose that we have the following struct and C function signature:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/df53df3fcf4e22d5c96604daf5c87219/href\">https://medium.com/media/df53df3fcf4e22d5c96604daf5c87219/href</a></iframe><p>How do various ABIs pass these structs in MyFunction?</p><p>In Linux on x64, there are 6 CPU argument registers. The struct is small enough to fit in a single register, so the first 6 arguments go into the 6 CPU argument registers, and the last 2 go on the stack. The stack arguments are aligned to 8 bytes. And, the return value also fits in a CPU register (<a href=\"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct3bytesx10/x64_linux.expect\">larger example</a>).</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/5d9f0d9653b66ab41f518a3582bf3b9c/href\">https://medium.com/media/5d9f0d9653b66ab41f518a3582bf3b9c/href</a></iframe><p>So, what happens on Windows?</p><p>It’s <a href=\"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct3bytesx10/x64_win.expect\">completely different</a>. Windows has only 4 argument registers. However, the first register is used to pass the pointer to the memory location to write the return value to. And, all arguments are passed by pointer to a copy, because the size of the struct is 3 bytes, which is not a power of 2.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b318294f0d3eec6c8e6f8654c22d1a4d/href\">https://medium.com/media/b318294f0d3eec6c8e6f8654c22d1a4d/href</a></iframe><p>Let’s look at another example: ARM32 on Linux and Android. Suppose that we have the following struct and C function signature:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/70667e0168930a389ede2b6097b5e40e/href\">https://medium.com/media/70667e0168930a389ede2b6097b5e40e/href</a></iframe><p>These specific types of structs are called homogeneous composites, because they only contain identical elements. And, homogenous floats with up to 4 members are treated differently from normal structs. In this case, <a href=\"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct16bytesHomogenousx10/arm_linux.expect\">Linux uses floating point registers</a> for the individual floating points in the struct.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/0a64fc30a1ada933273690c2a1a78877/href\">https://medium.com/media/0a64fc30a1ada933273690c2a1a78877/href</a></iframe><p>On Android, SoftFP is used instead of HardFP. This means that floats are passed in integer registers rather than floating point registers. Moreover, we’re passing in a Pointer for the result. This results in a <a href=\"https://github.com/dart-lang/sdk/blob/9d5846b86eed777933b6c7a2a15e41f2b779c650/runtime/vm/compiler/ffi/unit_tests/struct16bytesHomogenousx10/arm_android.expect\">curious situation</a> in which the first argument is partially passed in integer registers and partially passed on the stack.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/4c1ef34fbf0cdae280ae8fb1ac195b5d/href\">https://medium.com/media/4c1ef34fbf0cdae280ae8fb1ac195b5d/href</a></iframe><p>Getting any of this wrong will likely lead to segmentation faults at runtime. So, it’s paramount to get all the corner cases of the ABI on every hardware and OS combination correct.</p><h4>Explore through godbolt.org</h4><p>Because the documentation is very terse, we figured out many corner cases through the compiler explorer <a href=\"https://godbolt.org\">godbolt.org</a>. The compiler explorer shows C code and compiled assembly <a href=\"https://godbolt.org/z/17jzjv\">side by side</a>:</p><figure><img alt=\"A screenshot of godbolt.com showing that the assembly code for sizeof(Struct3Bytes) is returning 3 in the return register.\" src=\"https://cdn-images-1.medium.com/max/1024/0*SfIpbC1E-Ysaewzs\" /></figure><p>The preceding screenshot shows that on Windows x86 sizeof(Struct3Bytes) is 3 bytes, because 3 is moved into the return register eax.</p><p>When we <a href=\"https://godbolt.org/z/r1rG6s\">change</a> the struct slightly, we can inspect whether the size is still 3:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ab004f78cef497468e14e6cfbbd15037/href\">https://medium.com/media/ab004f78cef497468e14e6cfbbd15037/href</a></iframe><p>The size is not 3: mov eax, 4. Because the int16 must be 2-byte aligned, the struct must be 2-byte aligned. That means that when allocating an array of these structs there is a 1-byte padding after every struct to ensure that the next struct is 2-byte aligned. Hence, this struct is 4 bytes in the native ABI.</p><h4>Explore through generated tests</h4><p>Unfortunately, the compiler explorer doesn’t support MacOS and iOS. So, to make exploring manually more efficient (and to have a nice and huge test suite for this feature), we wrote a test generator.</p><p>The main idea is to generate tests in such a way that if they crash it’s possible to use <a href=\"https://www.gnu.org/software/gdb/\">GDB</a> to see what’s wrong.</p><p>One way to make it easier to see what is going wrong when hitting a segmentation fault is to make all arguments have predictable and easy-to-recognize values. For example, the following test uses consecutive integers, so that these integer values can be easily spotted in registers and on the stack:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a78213b01fe8cfc31ce5ab46836fcfaa/href\">https://medium.com/media/a78213b01fe8cfc31ce5ab46836fcfaa/href</a></iframe><p>Another way to make finding problems easier is to add prints everywhere. For example, if we don’t hit a segmentation fault during the transition from Dart to C, but we manage to garble all the arguments, then printing the arguments helps:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/022a59c653ab804970eac4476179232d/href\">https://medium.com/media/022a59c653ab804970eac4476179232d/href</a></iframe><p>Adding a test is as easy as adding a function type in the <a href=\"https://dart-review.googlesource.com/c/sdk/+/168829/6/tests/ffi/generator/structs_by_value_tests_confguration.dart\">configuration file</a>. The ability to add tests quickly has resulted in a <a href=\"https://dart-review.googlesource.com/c/sdk/+/168829\">huge test suite</a>.</p><p>Sure enough, this test suite caught another curious case in a native ABI — this time on iOS-ARM64. Non-struct arguments on the stack on iOS on ARM64 aren’t aligned to word size but to their own size. Structs are aligned to word size, except that if the struct is a homogeneous struct with only floats, then <a href=\"https://github.com/dart-lang/sdk/blob/b6b82dd3ac756b39e7fe9cab21f060fae74e358d/runtime/vm/compiler/ffi/native_type.cc#L180-L182\">it is aligned to the size of the float</a>.</p><h3>Summary</h3><p>This concludes our journey through the API design and ABI discovery. With a good test suite and thorough code reviews, we <a href=\"https://dart-review.googlesource.com/c/sdk/+/140290\">landed support</a> for passing structs by value in Dart FFI in December 2020 on the master branch, and it is available in Dart 2.12! If you’re interested in using Dart FFI, you can get started with the <a href=\"https://dart.dev/guides/libraries/c-interop\">C interop documentation on dart.dev</a>. If you have any questions or comments on the API design and ABI discovery, feel free to leave a comment below. We’d love to hear from you!</p><p><em>Thanks to the Dart language team and the (rest of the) Dart virtual machine team for their contributions to this Dart FFI feature, and thanks to Kathy Walrath and Michael Thomsen for shaping this blog post!</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1cb1829d11a9\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/implementing-structs-by-value-in-dart-ffi-1cb1829d11a9\">Implementing structs by value in Dart FFI</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-05-19T18:32:20.000Z":{"title":"Announcing Dart 2.13","link":"https://medium.com/dartlang/announcing-dart-2-13-c6d547b57067?source=rss----23738d481ce8---4","guid":"https://medium.com/p/c6d547b57067","category":["announcements","dart","programming"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 19 May 2021 18:32:20 GMT","atom:updated":"2021-05-19T18:32:18.582Z","content:encoded":"<h4>New type aliases language feature, improved Dart FFI</h4><figure><img alt=\"A graphic showing highlights of what’s in this post: type aliases, better FFI, null safety, Docker support\" src=\"https://cdn-images-1.medium.com/max/1024/1*qMQKtkRNuvBjORjoJrN2bQ.png\" /></figure><p><em>By Kevin Moore &amp; Michael Thomsen</em></p><p>Today we’re announcing Dart 2.13, featuring <em>type aliases</em> — currently our second most requested language feature. Dart 2.13 also includes improved Dart FFI and better performance, and we have new Docker Official Images for Dart. This post gives an update on the null safety feature introduced in 2.12, discusses the new 2.13 features, has some exciting news about Docker and Google Cloud support for Dart backends, and previews some changes that you can expect to see in future releases.</p><h3>Null safety update</h3><p>We launched <a href=\"https://dart.dev/null-safety\">sound null safety</a> in March in the <a href=\"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87\">Dart 2.12</a> release. Null safety is Dart’s latest major productivity feature, intended to help you avoid null errors — a class of bugs that are often hard to spot. With that launch we encouraged package publishers to start migrating shared packages on pub.dev to null safety.</p><p>We’ve been extremely pleased to see how quickly null safety has been adopted! Just a few months after launch, <strong>93% of the top-500 most popular packages on pub.dev already support null safety</strong>. We’d like to extend our sincere thanks to all package developers for doing this work so quickly, and for helping the entire ecosystem to move forward!</p><p>With so many packages supporting null safety, there’s a good chance that you can begin to migrate your apps to use null safety. The first step is to use dart pub outdated to check your app’s dependencies. For details, see the <a href=\"https://dart.dev/null-safety/migration-guide#step1-wait\">null safety migration guide</a>. We’ve also changed our dart create and flutter create templates so that they now enable null safety by default in new apps and packages.</p><h3>Announcing type aliases</h3><p>Type aliases is a new feature in the 2.13 language. It extends our earlier support, which allowed for creating type aliases of function types, but not any other types. This highly sought-after feature was the second highest <a href=\"https://github.com/dart-lang/language/issues?q=is%3Aissue+is%3Aopen+sort%3Areactions-%2B1-desc\">rated</a> in the language issue tracker.</p><p>Using a type alias you can create a new name for any existing type, which can then be used anywhere the original type could be used. You aren’t really defining a new type, just introducing a short-hand alias. The alias even passes type equality tests:</p><pre>typedef Integer = int;</pre><pre>void main() {<br>  print(int == Integer); // true<br>}</pre><p>So what can you use type aliases for? One common use is to give a shorter or more descriptive name to a type, making your code more readable and maintainable.</p><p>A good example is working with JSON (thanks to GitHub user <a href=\"https://github.com/Levi-Lesches\">Levi-Lesches</a> for this example). Here we can define a new type alias Json, which describes a JSON document as a map from String keys to any value (using the dynamic type). Then we can use that Json type alias when defining our fromJson named constructor and json getter.</p><pre>typedef Json = Map&lt;String, dynamic&gt;;</pre><pre>class User {<br>  final String name;<br>  final int age;</pre><pre>  User.fromJson(Json json) :<br>    name = json[&#39;name&#39;],<br>    age = json[&#39;age&#39;];</pre><pre>Json get json =&gt; {<br>    &#39;name&#39;: name,<br>    &#39;age&#39;: age,<br>  };<br>}</pre><p>You can also call constructors on a type alias that names a class, so the following is perfectly legal:</p><pre>main() {<br>  var j = Json();<br>  j[&#39;name&#39;] = &#39;Michael&#39;;<br>}</pre><p>By using type aliases to give names to complex types, you can make it easier for readers to understand the invariants of your code. For example, the following code defines a type alias to describe maps that contain keys of generic type X and values of type List&lt;X&gt;. By giving the type a name with a single type parameter, the regular structure of the map becomes more apparent to the reader of the code.</p><pre>typedef MapToList&lt;X&gt; = Map&lt;X, List&lt;X&gt;&gt;;<br>void main() {<br>  MapToList&lt;int&gt; m = {};<br>  m[7] = [7]; // OK<br>  m[8] = [2, 2, 2]; // OK<br>  for (var x in m.keys) {<br>    print(&#39;$x --&gt; ${m[x]}&#39;);<br>  }<br>}</pre><pre>=&gt;</pre><pre>7 --&gt; [7]<br>8 --&gt; [2, 2, 2]</pre><p>If you try to use types that don’t match, you’ll get an analysis error:</p><pre>m[42] = [&#39;The&#39;, &#39;meaning&#39;, &#39;of&#39;, &#39;life&#39;];</pre><pre>=&gt;</pre><pre>The element type &#39;String&#39; can&#39;t be assigned to the list type &#39;int&#39;.</pre><p>You can even use type aliases when renaming classes in public libraries. Imagine you have an existing class PoorlyNamedClass in a public library that you want to rename to BetterNamedClass. If you simply rename the class, then your API customers will get sudden compilation errors. With type aliases you can go ahead and do the rename, but then define a new type alias for the old class name, and then add a @Deprecated annotation for the old name. Uses of PoorlyNamedClass will then cause a warning when used, but will continue to compile and work as before, giving users time to upgrade their code.</p><p>Here’s how you might implement BetterNamedClass and deprecate PoorlyNamedClass (in a file named mylibrary.dart):</p><pre>class BetterNamedClass {...}</pre><pre><a href=\"http://twitter.com/Deprecated\">@Deprecated</a>(&#39;Use BetterNamedClass instead&#39;)<br>typedef PoorlyNamedClass = BetterNamedClass;</pre><p>And here’s what happens what someone tries to use PoorlyNamedClass:</p><pre>import &#39;mylibrary.dart&#39;;</pre><pre>void main() {<br>  PoorlyNamedClass p;<br>}</pre><pre>=&gt;</pre><pre>&#39;PoorlyNamedClass&#39; is deprecated and shouldn&#39;t be used. Use BetterNamedClass instead.</pre><p>The type alias feature is available starting with Dart 2.13. To enable it, set the lower Dart SDK constraint in your pubspec to at least 2.13:</p><pre>environment:<br>  sdk: &quot;&gt;=2.13.0 &lt;3.0.0&quot;</pre><p>This feature is backward compatible, thanks to <a href=\"https://dart.dev/guides/language/evolution#language-versioning\">language versioning</a>. Packages with lower SDK constraints under 2.13 can safely refer to type aliases defined in 2.13 packages, even though pre-2.13 packages can’t define their own type aliases.</p><h3>Dart 2.13 FFI changes</h3><p>We also have a couple of new features in Dart FFI, our interop mechanism for calling C code.</p><p>First, FFI now supports structs that have inline arrays (<a href=\"https://github.com/dart-lang/sdk/issues/35763\">#35763</a>). Consider a C struct with an inline array like this:</p><pre>struct MyStruct {<br>  uint8_t arr[8];<br>}</pre><p>You can now wrap that in Dart directly, specifying the element type with a type argument to Array:</p><pre>class StructInlineArray extends Struct {<br>  <a href=\"http://twitter.com/Array\">@Array</a>(8)<br>  external Array&lt;Uint8&gt; arr;<br>}</pre><p>Second, FFI now supports packed structs (<a href=\"https://github.com/dart-lang/sdk/issues/38158\">#38158</a>). Normally structs are laid out in memory so that members fall in address boundaries that are easier to access for the CPU. With <a href=\"http://www.catb.org/esr/structure-packing/\">packed structs</a> some of this padding is omitted to lower overall memory consumption, often in platform-specific ways. With the new @Packed(&lt;alignment&gt;) annotation, you can easily specify the padding. For example, the following code creates a struct that has 4-byte alignment when it’s in memory:</p><pre><a href=\"http://twitter.com/Packed\">@Packed</a>(4)<br>class TASKDIALOGCONFIG extends Struct {<br>  <a href=\"http://twitter.com/Uint32\">@Uint32</a>()<br>  external int cbSize;<br>  <a href=\"http://twitter.com/IntPtr\">@IntPtr</a>()<br>  external int hwndParent;<br>  <a href=\"http://twitter.com/IntPtr\">@IntPtr</a>()<br>  external int hInstance;<br>  <a href=\"http://twitter.com/Uint32\">@Uint32</a>()<br>  external int dwFlags;<br>  ...<br>}</pre><h3>Dart 2.13 performance changes</h3><p>We’re continuing to work on reducing the application size and memory footprint of Dart code. In large Flutter applications, internal structures representing metadata of an AOT-compiled Dart program might occupy a sizable chunk of memory. Most of this metadata is present to enable features like hot reload, interactive debugging, and formatting of human-readable stack traces — features that are never used in deployed applications. Over the previous year we’ve been restructuring the Dart native runtime to eliminate as much of this overhead as possible. Some of these improvements apply to all Flutter applications built in release mode, but some require you to forgo human-readable stack traces by splitting debug information out of AOT-compiled applications using the <a href=\"https://flutter.dev/docs/perf/app-size#reducing-app-size\">--split-debug-info</a> flag.</p><p>Dart 2.13 includes a number of changes that significantly reduce the space occupied by program metadata when --split-debug-info is used. Take as an example the Flutter Gallery app. On Android the release APK is 112.4 MB with debug information, and 106.7 MB without it (a 5% overall reduction). This APK contains a lot of assets. Looking just at the code metadata inside the APK, it was reduced from 5.7MB in Dart 2.12 and only 3.7MB in Dart 2.13 (a 35% reduction).</p><p>If app size and memory footprint are important to you, consider omitting the debug information using the --split-debug-info flag. Note that when doing so you’ll need to use the <a href=\"https://flutter.dev/docs/deployment/obfuscate#reading-an-obfuscated-stack-trace\">symbolize</a> command to make the stack traces human readable again.</p><h3>Official Docker support and Dart on Google Cloud</h3><p>Dart is now available as <a href=\"https://docs.docker.com/docker-hub/official_images/\">Docker Official Images</a>. While Dart has provided Docker images for years, these <a href=\"https://hub.docker.com/_/dart\">new Dart images</a> are tested and validated by Docker to follow best practices. They also support ahead-of-time (AOT) compilation, which can dramatically reduce the size of built containers and can improve the speed of deployment in container environments — like <a href=\"https://cloud.google.com/run\">Cloud Run</a>.</p><p>While Dart remains focused on enabling app frameworks like Flutter to drive beautiful pixels across every screen, we realize that behind most user experiences is at least one hosted service. By making it easy to build backend services with Dart, we support a full stack experience that lets developers extend their application to the cloud using the same language and business logic they use to power widgets on the frontend.</p><p>In general, using Dart for Flutter app backends is an especially good fit for the simplicity and scalability of Google’s managed serverless platform, Cloud Run. This includes scale-to-zero, which means you don’t incur costs when your backend isn’t handling any requests. We work with the Google Cloud team to provide the <a href=\"https://pub.dev/packages/functions_framework\">Functions Framework for Dart</a>, a collection of packages, tools, and examples that make it easy to write Dart functions to deploy instead of full servers for handling HTTP requests and CloudEvents.</p><p>Check out our <a href=\"https://dart.dev/server/google-cloud\">Google Cloud docs</a> to get started.</p><h3>A few words about what’s next</h3><p>We’re already working on some exciting changes for upcoming releases. As always, you can use the <a href=\"https://github.com/dart-lang/language/projects/1\">language funnel</a> tracker to keep an eye on our progress.</p><p>One area we’re working on is a new set of canonical lints for both Dart and Flutter. Lints are a powerful way to configure Dart <a href=\"https://dart.dev/guides/language/analysis-options\">static analysis</a>, but with hundreds of possible lints to toggle on or off, it can be hard to decide on what to choose. We’re currently working on defining two canonical sets of lints that we’ll apply by default in Dart and Flutter projects. We expect this to be enabled by default in the next stable release. If you’d like a preview, checkout the two packages <a href=\"https://pub.dev/packages/lints\">lints</a> and <a href=\"https://pub.dev/packages/flutter_lints\">flutter_lints</a>.</p><p>Finally, if you do deep embedding of the Dart VM runtime, please note that we’re planning to deprecate the existing mechanism for this. We’ll replace it with a faster, more flexible model based on Dart FFI (see tracking issue <a href=\"https://github.com/dart-lang/sdk/issues/45451\">#45451</a>).</p><h3>Dart 2.13 is available now</h3><p>Dart 2.13, with type aliases and improved FFI, is available today in the <a href=\"https://dart.dev/get-dart\">Dart 2.13</a> and <a href=\"https://flutter.dev/docs/get-started/\">Flutter 2.2</a> SDKs.</p><p>If you’ve been waiting for your dependencies to migrate to null safety, you might want to check again, using dart pub outdated. With 93% of the top-500 most popular packages already migrated, there’s a good chance that you’re unblocked. We’d also like to extend a big thanks to developers who’ve already migrated!</p><p>We’d love to hear about your experience with the new features and changes discussed in this blog post. Leave a comment below or tweet us <a href=\"https://twitter.com/dart_lang\">@dart_lang</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c6d547b57067\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-2-13-c6d547b57067\">Announcing Dart 2.13</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-12-08T18:00:39.000Z":{"title":"Announcing Dart 2.15","link":"https://medium.com/dartlang/dart-2-15-7e7a598e508a?source=rss----23738d481ce8---4","guid":"https://medium.com/p/7e7a598e508a","category":["programming","dart","announcements"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 08 Dec 2021 18:00:39 GMT","atom:updated":"2021-12-09T01:38:58.316Z","content:encoded":"<h4>Fast concurrency, constructor tear-offs, improved enums, and more</h4><p>Today we’re releasing version 2.15 of the Dart SDK, featuring fast concurrency with worker isolates, a new constructor tear-off language feature, improved enum support in the dart:core library, new features for package publishers, and more.</p><figure><img alt=\"Graphic listing new 2.15 features\" src=\"https://cdn-images-1.medium.com/max/1024/1*96RfgLO4RYR2ReAs8t6x5w.png\" /></figure><h3>Fast concurrency with worker isolates</h3><p>Just about all modern devices have CPUs with multiple cores, capable of running multiple tasks in parallel. For most Dart programs, how these cores are used is transparent to you as a developer: the Dart runtime system by default runs all your Dart code on a single core, but then uses additional cores for executing systems-level tasks such as async input/output, like writing a file or making a network call.</p><p>But your Dart code itself may need to run concurrently. For example, you may have a continuous animation and a long-running task such as parsing a large JSON file. If the additional task takes too long, that might cause stutter or lag in the UI. By moving those additional tasks to a separate core, the animation can continue to run on the main thread of execution, uninterrupted.</p><p>Dart’s model for concurrency is based on <a href=\"https://dart.dev/guides/language/concurrency\">isolates</a> — independent units of execution that are isolated from one another — to prevent a large class of concurrency programming bugs related to shared memory, such as <a href=\"https://en.wikipedia.org/wiki/Race_condition#In_software\"><em>race conditions</em> like data races</a>. Dart prevents these bugs by not allowing any mutable objects to be shared between isolates, and instead uses a model where isolates exchange state using <a href=\"https://dart.dev/guides/language/concurrency#sending-multiple-messages-between-isolates\"><em>message passing</em></a>. In Dart 2.15 we’ve made a number of substantial enhancements to isolates.</p><p>We started by redesigning and reimplementing how isolates work, introducing a new concept: <em>isolate groups. </em>Isolates in an isolate group share various internal data structures representing the running program<em>. </em>This makes individual isolates in the group much cheaper. It is now more than 100 times faster to start an additional isolate in an existing isolate group as we don’t need to initialize the program structures, and those spawned isolates consume between 10–100 times less memory.</p><p>While isolate groups still prevent shared access to mutable objects between isolates, the group is implemented with a shared heap, which unlocks further capabilities. We can pass objects from one isolate to another, which can be used for worker isolates that perform a task that returns a large piece of memory. An example is a worker isolate that makes a network call to get data, parses that data into a large JSON object graph, and then returns that JSON graph to the main isolate. Before Dart 2.15, that result needed to be deep-copied, which could itself cause UI jank if the copy took longer than the frame budget.</p><p>In 2.15 the worker isolate can call <a href=\"https://api.dart.dev/stable/2.15.0/dart-isolate/Isolate/exit.html\">Isolate.exit()</a>, passing its result as an argument. The Dart runtime then passes the memory containing the result from the worker isolate to the main isolate without copying, and the main isolate can receive the result in constant time. We’ve updated the <a href=\"https://api.flutter.dev/flutter/foundation/compute-constant.html\">compute()</a> utility function in <a href=\"https://medium.com/flutter/whats-new-in-flutter-2-8-d085b763d181\">Flutter 2.8 </a>to take advantage of Isolate.exit(). If you’re already using compute(), then you’ll get these performance gains automatically after upgrading to Flutter 2.8.</p><p>Finally, we’ve reworked how the isolate message passing mechanism is implemented, making passing of small-to-medium sized messages approximately 8 times faster. Sending is significantly faster, and receiving messages is almost always done in constant time. We’ve also expanded the kinds of objects that isolates can send to each other, adding support for function types, closures, and stacktrace objects. For details, see the API docs for <a href=\"https://api.dart.dev/stable/2.15.0/dart-isolate/SendPort/send.html\">SendPort.send()</a>.</p><p>To learn more about how to use isolates, see the new <a href=\"https://dart.dev/guides/language/concurrency\"><em>Concurrency in Dart</em></a> documentation we added for 2.15. We also have a number of <a href=\"https://github.com/dart-lang/samples/tree/master/isolates\">code samples</a> you can check out.</p><h3>New language feature: Constructor tear-offs</h3><p>In Dart you can create a function object, which points to a function on another object, by using the function’s name. In the following example, the second line of the main() method illustrates this syntax when it sets `g` to `m.greet`:</p><pre>class Greeter {<br>  final String name;<br>  Greeter(this.name);<br>  <br>  void greet(String who) {<br>    print(&#39;$name says: Hello $who!&#39;);<br>  }<br>}</pre><pre>void main() {<br>  final m = Greeter(&#39;Michael&#39;);<br>  final g = m.greet; // g holds a function pointer to m.greet.<br>  g(&#39;Leaf&#39;); // Invokes and prints &quot;Michael says: Hello Leaf!&quot;<br>}</pre><p>Such function pointers — also referred to as function <em>tear-offs</em> — appear frequently when using the Dart core libraries. Here’s an example of calling foreach() on an iterable by passing it a function pointer:</p><pre>final m = Greeter(&#39;Michael&#39;);</pre><pre>[&#39;Lasse&#39;, &#39;Bob&#39;, &#39;Erik&#39;].forEach(m.greet);</pre><pre>// Prints &quot;Michael says: Hello Lasse!&quot;, &quot;Michael says: Hello Bob!&quot;,<br>// &quot;Michael says: Hello Erik!&quot;</pre><p>Historically we haven’t supported creating tear-offs from a constructor (language issue <a href=\"https://github.com/dart-lang/language/issues/216\">#216</a>). That’s annoying because in many cases — for example, when building Flutter UIs — a constructor tear-off is what you need. As of Dart 2.15, this syntax is now supported. Here’s an example of building a Column widget containing three Text widgets, by calling .map() and passing it a tear-off to the constructor of Text.</p><pre>class FruitWidget extends StatelessWidget {<br>  @override<br>  Widget build(BuildContext context) {<br>    return Column(<br>        children: [&#39;Apple&#39;, &#39;Orange&#39;].map(Text.new).toList());<br>  }<br>}</pre><p>Text.new refers to the default constructor of the Text class. You can also refer to a named constructor — for example, .map(Text.rich).</p><h3>Related language changes</h3><p>While we were implementing constructor tear-offs, we took the opportunity to fix some inconsistencies in our existing support for function pointers. You can now specialize a generic method to create a non-generic method:</p><pre>T id&lt;T&gt;(T value) =&gt; value;<br>var intId = id&lt;int&gt;; // New in 2.15.<br>int Function(int) intId = id; // Pre-2.15 workaround.</pre><p>You can even specialize a generic function object to create a non-generic function object:</p><pre>const fo = id; // Tear off `id`, creating a function object.<br>const c1 = fo&lt;int&gt;; // New in 2.15; error before.</pre><p>Lastly, we cleaned up type literals involving generics:</p><pre>var y = List; // Already supported.<br>var z = List&lt;int&gt;; // New in 2.15.<br>var z = typeOf&lt;List&lt;int&gt;&gt;(); // Pre-2.15 workaround.</pre><h3>Improved enums in the dart:core library</h3><p>We’ve made a number of convenience additions to the enum APIs in the dart:core library (language issue <a href=\"https://github.com/dart-lang/language/issues/1511\">#1511</a>). You can now get the String value for each enum value using .name:</p><pre>enum MyEnum {<br>  one, two, three<br>}</pre><pre>void main() {<br>  print(MyEnum.one.name);  // Prints &quot;one&quot;.<br>}</pre><p>You can also look up an enum value by name:</p><pre>print(MyEnum.values.byName(&#39;two&#39;) == MyEnum.two);  // Prints &quot;true&quot;.</pre><p>Finally, you can get a map of all name-value pairs:</p><pre>final map = MyEnum.values.asNameMap(); <br>print(map[&#39;three&#39;] == MyEnum.three);  // Prints &quot;true&quot;.</pre><p>For an example of using these new APIs, see <a href=\"https://github.com/flutter/flutter/pull/94496/files\">this Flutter PR</a>.</p><h3>Compressed pointers</h3><p>Dart 2.15 adds support for compressed pointers, a technique where a 64-bit SDK can use a more space-efficient representation of pointers if only a 32-bit address space needs to be supported (up to 4 GB of memory). Compressed pointers result in a significant memory reduction; in our internal testing with the GPay app, we saw an approximately 10% reduction of the Dart heap size.</p><p>Because compressed pointers imply not being able to address any available RAM above 4 GB, the feature is behind a configuration option in the Dart SDK that can only be toggled by embedders of the Dart SDK when the SDK is built. The Flutter SDK version 2.8 has enabled this configuration for Android builds, and the Flutter team is considering also <a href=\"https://github.com/flutter/flutter/issues/94753\">enabling it for iOS</a> builds in a future release.</p><h3>Dart DevTools included in the Dart SDK</h3><p>The <a href=\"https://dart.dev/tools/dart-devtools#\">DevTools suite</a> of debugging and performance tools previously wasn’t in the Dart SDK; you had to download it separately. Starting with Dart 2.15, you now get DevTools when you download the Dart SDK, with no further installation steps required. For more information on using DevTools with Dart command-line apps, see the <a href=\"https://dart.dev/tools/dart-devtools#using-devtools-with-a-command-line-app\">DevTools documentation</a>.</p><h3>New pub features for package publishers</h3><p>Dart 2.15 SDK also has two new features in the dart pub developer command and the <a href=\"https://pub.dev\">pub.dev</a> package repository.</p><p>First, there’s a new security feature for package publishers. The aim is to detect when a publisher accidentally publishes secrets — for example Cloud or CI credentials — inside pub packages. We were inspired to add this leak detection after learning that inside GitHub repositories, thousands of secrets are <a href=\"https://www.ndss-symposium.org/wp-content/uploads/2019/02/ndss2019_04B-3_Meli_paper.pdf\">leaked every day</a>.</p><p>Leak detection runs as part of the pre-publish validation run in the dart pub publish command. If it detects a potential secret in the files about to be published, the publish command exits without publishing, and prints output like this:</p><pre>Publishing my_package 1.0.0 to <a href=\"https://pub.dartlang.org\">https://pub.dartlang.org</a>:<br>Package validation found the following errors:<br>* line 1, column 1 of lib/key.pem: Potential leak of Private Key detected.<br>╷<br>1 │ ┌ - - -BEGIN PRIVATE KEY - - -<br>2 │ │ H0M6xpM2q+53wmsN/eYLdgtjgBd3DBmHtPilCkiFICXyaA8z9LkJ<br>3 │ └ - - -END PRIVATE KEY - - -<br>╵<br>* line 2, column 23 of lib/my_package.dart: Potential leak of Google OAuth Refresh Token detected.<br>╷<br>2 │ final refreshToken = &quot;1//042ys8uoFwZrkCgYIARAAGAQSNwF-L9IrXmFYE-sfKefSpoCnyqEcsHX97Y90KY-p8TPYPPnY2IPgRXdy0QeVw7URuF5u9oUeIF0&quot;;</pre><p>On rare occasions this detection might have false positives, flagging potential leaks for content or files that you do in fact intend to publish. In those cases, you can add the files to an <a href=\"https://dart.dev/go/false-secrets\">allowlist</a>.</p><p>Second, we’ve added another feature for publishers that supports retracting a package version that’s already been published. When a faulty package version is published, we usually recommend publishing a new version with a minor increment that fixes the unintended issue. In rare cases — for example when you don’t have such a fix yet, or where you accidentally published a new major version but intended to publish a new minor version — you can use the new <a href=\"https://dart.dev/go/package-retraction\">package retraction feature</a> as a last resort. This functionality is available in the Admin UI on pub.dev:</p><figure><img alt=\"Screenshot of the package retraction UI\" src=\"https://cdn-images-1.medium.com/max/1024/1*9KDYm1R4x6D4S-mzL-QE2g.png\" /></figure><p>When a package version is retracted, the pub client no longer resolves to that version in pub get or pub upgrade. If any developers have already resolved to the retracted version (and it’s thus in their pubspec.lock file), they’ll see a warning the next time they run pub:</p><pre>$ dart pub get<br>Resolving dependencies…<br>mypkg 0.0.181-buggy (retracted, 0.0.182-fixed available)<br>Got dependencies!</pre><h3>Security analysis for detecting bidirectional Unicode characters (CVE-2021–22567)</h3><p>Recently a general programming language vulnerability was discovered involving bidirectional Unicode characters (<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2021-42574\">CVE-2021–42574</a>). This vulnerability affects most modern programming languages that support Unicode. The following Dart source code illustrates the problem:</p><pre>main() {<br>  final accessLevel = &#39;user&#39;;</pre><pre>  if (accessLevel == &#39;user‮ .⁦// Check if admin⁩ ⁦&#39;) {<br>    print(&#39;You are a regular user.&#39;);<br>  } else {<br>    print(&#39;You are an admin.&#39;);<br>  }<br>}</pre><p>You’d probably think that this program prints <em>You are a regular user.</em>, but it might in fact print <em>You are an admin.</em>! This exploit is possible by using a string containing bidirectional Unicode characters. These are characters that change the direction of the text from left-to-right to right-to-left and back, all within a single line. With bidirectional characters, the text can render onscreen quite differently from the actual text contents. You can see an example of this in <a href=\"https://gist.github.com/mit-mit/7dda00ca6278ce7d2555f78d59d9e67b?h=1\">this GitHub code gist</a>.</p><p>Mitigations against this vulnerability include using tools (editors, code review tools, etc.) that detect bidirectional Unicode characters, so that a developer can be made aware of them, and knowingly accept their use. The GitHub gist file viewer linked to above is one example of a tool that reveals these characters.</p><p>Dart 2.15 introduces one further mitigation (Dart security advisory <a href=\"https://github.com/dart-lang/sdk/security/advisories/GHSA-8pcp-6qc9-rqmv\">CVE-2021–22567</a>): the Dart analyzer now scans for bidirectional Unicode characters, and flags any use of them:</p><pre>$ dart analyze<br>Analyzing cvetest...                   2.6s</pre><pre>info • bin/cvetest.dart:4:27 • The Unicode code point &#39;U+202E&#39;<br>       changes the appearance of text from how it&#39;s interpreted<br>       by the compiler. Try removing the code point or using the <br>       Unicode escape sequence &#39;\\u202E&#39;. •<br>       text_direction_code_point_in_literal</pre><p>We recommend replacing these characters by Unicode escape sequences, so that they’re visible in any text editor or viewer. Alternatively, if you do have a legitimate use of these characters, you can disable the warning by adding an override in the line preceding the use:</p><pre>// ignore: text_direction_code_point_in_literal</pre><h3>Pub.dev credentials vulnerability when using third-party pub servers (CVE-2021–22568)</h3><p>We’re also publishing a second pub.dev-related Dart security advisory: <a href=\"https://github.com/dart-lang/sdk/security/advisories/GHSA-r32f-vhjp-qhj7\">CVE-2021–22568</a>. This advisory is targeted at package publishers who may have published packages to third-party pub package servers, such as private or company-internal package servers. Developers who publish only to the public pub.dev repository (the standard configuration) are <strong>not affected</strong> by this vulnerability.</p><p>If you’ve published to a third-party repository, the vulnerability is that the OAuth2 temporary (one-hour) access token presented for authentication at that third-party repository can be misused to authenticate against the public pub.dev repository. Thus a malicious third-party pub server might use an access token to impersonate you on pub.dev and publish packages there. If you’ve published a package to an untrusted third-party package repository, consider doing an audit of all your account activity on the pub.dev public package repository. You can use the <a href=\"https://pub.dev/my-activity-log\">pub.dev activity log</a> for this purpose.</p><h3>Closing comments</h3><p>We hope that you’ll enjoy the new features in Dart 2.15, <a href=\"https://dart.dev/get-dart\">available today</a>. This is our last release of the year, and we’d like to take the chance to express our gratitude for the wonderful Dart ecosystem. Thanks for all the great feedback, for your continued support as witnessed by our continued growth, and for extending our ecosystem with thousands of packages published on <a href=\"https://pub.dev\">pub.dev</a> over the past year. We can’t wait to get back to it next year, and we have lots of exciting things planned for 2022. Until then, enjoy the holidays!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7e7a598e508a\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-2-15-7e7a598e508a\">Announcing Dart 2.15</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-11-15T17:08:55.000Z":{"title":"Announcing package support for DartPad","link":"https://medium.com/dartlang/announcing-package-support-for-dartpad-66a4b415970b?source=rss----23738d481ce8---4","guid":"https://medium.com/p/66a4b415970b","category":["flutter","firebase","dart","announcements","programming"],"dc:creator":"Zoey Fan","pubDate":"Mon, 15 Nov 2021 17:08:55 GMT","atom:updated":"2021-11-15T17:08:55.239Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<h4>Create robust code snippets with popular packages in DartPad</h4><p>Today we’re excited to announce that package support is now available in <a href=\"https://github.com/dart-lang/dart-pad\">DartPad</a>! DartPad is the open-sourced, web-based playground that runs Dart and Flutter apps directly in your web browser. It allows you to quickly run Dart code to test an idea or code up a technical concept without needing to install the Flutter SDK or any tools on your local system.</p><p>Since the launch of DartPad, one of the <a href=\"https://github.com/dart-lang/dart-pad/issues/901\">most popular requests</a> has been to add support for importing packages, such as <a href=\"https://pub.dev/packages/google_fonts\">Google Fonts</a> or <a href=\"https://pub.dev/packages/firebase_auth\">Firebase Authentication</a>, directly in DartPad’s editor. In this first phase of rollout, you can import from a set of popular packages.</p><p>To help you get started, we’ve created several new examples that you can find using DartPad’s <strong>Samples</strong> menu.</p><h3>Google Fonts example</h3><p>Start using a package by adding an import statement for it at the top of the code editor. For example, to use the Google Fonts package, add this:</p><p>import &#39;package:google_fonts/google_fonts.dart&#39;;</p><p>DartPad handles the pubspec details for you, so all you need is the import statement. You can use suggested completions to change fonts and then rerun the app, just like you would in an IDE.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*5iMRgkKlQGK6fJx3\" /></figure><h3>How package support works</h3><p>Here’s a quick overview of how package support works in DartPad. The DartPad server takes the set of supported packages and uses <strong>flutter pub get</strong> to fetch the latest compatible version of each package. Then the server uses these package versions during analysis and compilation of your DartPad script.</p><p>This release also supports the most popular Firebase packages, so you can access a suite of backend services without ever leaving DartPad. All necessary Firebase JavaScript SDKs are loaded into the output panel before running the compiled app.</p><p>Here’s a <a href=\"https://dartpad.dev/?id=d57c6c898dabb8c6fb41018588b8cf73&amp;null_safety=true\">simple chat app</a> that uses Firebase:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*5QSzuPZeeo3tb0R1\" /></figure><p>This multi-user chat app is implemented with only client-side Dart code running (and written) in the browser, and uses the Firestore database to share messages between users. While it might seem dangerous to open your database directly to users, it’s actually secured by only allowing chat messages that use a very specific set of words. Read the comments in <a href=\"https://gist.github.com/flutterdevrelgists/d57c6c898dabb8c6fb41018588b8cf73\">the code</a> to learn more about how it works.</p><p>To expand the chat app, you could implement sign-in to identify who said what by adding Firebase Authentication. We plan to add many more Firebase features to expand what you can do with Firebase in DartPad.</p><h3>Supported packages</h3><p>This first phase of the rollout supports a defined set of popular packages. To see what packages are available (and in what version), click the info icon at the lower right corner of the screen.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*GiZCsPVISutlBMSG\" /></figure><h3>Give it a try!</h3><p>Give DartPad package support a try today on <a href=\"https://dartpad.dev\">dartpad.dev</a>, and share any <a href=\"https://github.com/dart-lang/dart-pad/issues\">feedback</a> with our team. We’ll continue to expand the list of supported packages over time. If you have any preference regarding which packages you’d like to see added, <a href=\"https://github.com/dart-lang/dart-pad/issues\">search for the issue</a> that contains the desired package name, and give it a 👍 “thumbs up” reaction. If there’s no issue for the package you want, please <a href=\"https://github.com/dart-lang/dart-pad/issues/new?template=everything-else.md\">create an issue</a> and put the package name in the title.</p><p>We hope package support on DartPad empowers you to build and showcase your Flutter designs, ideas, vignettes, and more. We can’t wait to see what you build next!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=66a4b415970b\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-package-support-for-dartpad-66a4b415970b\">Announcing package support for DartPad</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-11-11T17:03:16.000Z":{"title":"Dart diagnostic messages","link":"https://medium.com/dartlang/dart-diagnostic-messages-ae302aa398e8?source=rss----23738d481ce8---4","guid":"https://medium.com/p/ae302aa398e8","category":["dart","programming","tooling"],"dc:creator":"Brian Wilkerson","pubDate":"Thu, 11 Nov 2021 17:03:16 GMT","atom:updated":"2021-11-11T17:03:16.490Z","content:encoded":"<h4>Understanding error and warning messages from the Dart analyzer</h4><p>Have you ever seen an error message and wondered what it means and what you should do about it? There might be more information available to help you answer those questions than you realize.</p><p>Let’s take a fairly common example. There’s a problem in the following code:</p><figure><img alt=\"A simple class with a red squiggly line under the “length” in `values.length`\" src=\"https://cdn-images-1.medium.com/max/300/1*KDUXUtf0E8hb0kZBeIUdSA.png\" /></figure><p>In IntelliJ IDEA, the message is visible in the Dart Analysis view:</p><figure><img alt=\"IntelliJ IDEA screenshot with error message: The property `length` can’t be unconditionally accessed because the receiver can be `null`.\" src=\"https://cdn-images-1.medium.com/max/1024/1*mjwyDt_bsYpTZBPwLbFhwg.png\" /></figure><p>In Visual Studio Code, the problem message appears in the Problems panel:</p><figure><img alt=\"Visual Studio Code with the same error message as in the IntelliJ IDEA screenshot\" src=\"https://cdn-images-1.medium.com/max/1024/1*XTJeTrWGGKzxfQv41qVfug.png\" /></figure><p>It seems odd that there’s a problem because we just checked that values isn’t nullon the line above.</p><p>The message tells us what’s wrong, but it doesn’t really help us understand why the check wasn’t sufficient or how to respond to the error. That extra information is actually available; it just might not be obvious how to find it. The rest of this article shows you how to find the location of this extra information in the output of <a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a>, <a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>, and the dart analyze command-line tool.</p><h4>IntelliJ IDEA</h4><p>If you hover over the highlighted text you can get more information:</p><figure><img alt=\"Screenshot of IntelliJ IDEA, with the contents described in the following text\" src=\"https://cdn-images-1.medium.com/max/1024/1*m2K6XXsAfB7gK0oBPGNwag.png\" /></figure><p>The hover includes the message we saw above (which we call the <em>problem message</em>), but it also includes other useful information:</p><ul><li>A link to <a href=\"https://dart.dev/tools/diagnostic-messages#unchecked_use_of_nullable_value\">external documentation about the diagnostic</a></li><li>A <em>context message</em> that explains why the null comparison wasn’t sufficient to promote the type of the property to be non-nullable</li><li>A <em>correction message</em> that describes some of the things you can do to correct the code</li></ul><p>The context message includes the URL of additional documentation related to type promotion and tells you the line and file on which the field is defined. Unfortunately you can’t navigate to the context location from the hover, but you can from the Dart Analysis view.</p><p>Although the Dart Analysis view displays only the problem message, double-clicking the message navigates you to the text with the red squiggly underline where the problem is being reported. For other useful features, bring up the context menu:</p><figure><img alt=\"A screenshot of the context menu for the error message\" src=\"https://cdn-images-1.medium.com/max/1024/1*KUQaTyshPTkO9eF0Rdxe2w.png\" /></figure><p>With the context menu, you can navigate to either the location where the diagnostic was reported (using <strong>Jump to Source</strong>, which works just like double-clicking the problem message) or to the declaration of values (using the menu item labeled by the context message). Selecting <strong>Open Documentation</strong> opens the external documentation about the diagnostic.</p><h4>Visual Studio Code</h4><p>In Visual Studio Code there are two ways to see the extra information. The first is to expand the entry in the Problems panel:</p><figure><img alt=\"Screenshot of VS Code’s Problems panel\" src=\"https://cdn-images-1.medium.com/max/1024/1*qsXBZQMBgk6W5WaUBOQ_bA.png\" /></figure><p>The first line is the message we saw before (which we call the <em>problem message</em>). Double-clicking either the first or second line navigates you to the text with the red squiggly underline where the problem is.</p><p>The second line is a <em>correction message</em> that describes some of the things you can do to correct the code. It also contains a link, labeled by the ID of the diagnostic, that opens <a href=\"https://dart.dev/tools/diagnostic-messages#unchecked_use_of_nullable_value\">external documentation about the diagnostic</a>.</p><p>The third line is a <em>context message</em> that explains why the null comparison wasn’t sufficient to promote the type to be non-nullable. Double-clicking the context message navigates you to the declaration of values. The context message includes the URL of additional documentation related to type promotion.</p><p>You can also see this information by hovering over the highlighted text, which causes hover text to be opened:</p><figure><img alt=\"Screenshot of VS Code hover text\" src=\"https://cdn-images-1.medium.com/max/1024/1*kUNsHzJZkZNRysNJmbNTdw.png\" /></figure><p>The hover text contains the same information as the Problems panel. It contains a link to take you to the external documentation and another link to navigate to the declaration of values.</p><h4>dart analyze</h4><p>The command-line analyzer dart analyze can display the same information as the IDEs, but you need to use the--verboseflag to see all of it.</p><figure><img alt=\"Screenshot of output from `dart analyze --verbose demo.dart`\" src=\"https://cdn-images-1.medium.com/max/1024/1*GtSPY3IoZDeGkfkolrXO7A.png\" /></figure><h4>Summary</h4><p>I hope this article helps you more easily find the information you need to understand the analyzer’s diagnostics.</p><p>If you find diagnostics that are still hard to understand — because the message isn’t clear, it needs a context message to help you find other related code locations, or the documentation isn’t complete enough — please let us know by <a href=\"https://github.com/dart-lang/sdk/issues/new\">creating a dart-lang/sdk issue</a>. We’re always interested in improving the tools.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ae302aa398e8\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-diagnostic-messages-ae302aa398e8\">Dart diagnostic messages</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-10-14T16:16:44.000Z":{"title":"Google Summer of Code 2021 results","link":"https://medium.com/dartlang/google-summer-of-code-2021-results-e514cce50fc?source=rss----23738d481ce8---4","guid":"https://medium.com/p/e514cce50fc","category":["dartlang","google-summer-of-code","open-source","flutter"],"dc:creator":"Jonas Finnemann Jensen","pubDate":"Thu, 14 Oct 2021 16:16:44 GMT","atom:updated":"2021-10-14T16:43:25.841Z","content:encoded":"<p><a href=\"https://summerofcode.withgoogle.com/\">Google Summer of Code</a> (GSoC) is a global program focused on bringing student developers into open source software development. Students are sponsored by Google to work with a mentoring open source organization on a 10-week programming project during the summer. Over the past 16 years more than 16,000 students have participated in Google Summer of Code.</p><p>2021 is the second time that the Dart organization participated in Google Summer of Code as a mentoring organization. Following our <a href=\"https://medium.com/dartlang/dart-in-google-summer-of-code-2021-e89eaf1d177a\">call for student proposals in March</a> we received 92 project proposals from students around the world, out of which we were thrilled to accept 3 projects. Today, we are excited to share our results, as described by the students who worked on these projects.</p><h3>Cronet-based HTTP client for Dart</h3><p><em>By Soumyadip Mondal</em></p><p>The <a href=\"https://pub.dev/packages/cronet\">cronet</a> package is an HTTP package for Dart Native platforms, backed by <a href=\"https://chromium.googlesource.com/chromium/src/+/refs/heads/main/components/cronet\">Chromium’s network engine</a>.</p><p>You might ask “why add an HTTP package?” when Dart already has HTTP support in dart:io. One reason is that package:cronet can use the QUIC/HTTP3 protocol, which is <a href=\"https://github.com/dart-lang/sdk/issues/38595\">a highly requested</a> community feature. Besides that, package:cronet is <a href=\"https://github.com/google/cronet.dart/blob/main/dart_io_comparison.md#performance-comparison\">faster than </a><a href=\"https://github.com/google/cronet.dart/blob/main/dart_io_comparison.md#performance-comparison\">d</a>art:io in many scenarios.</p><p>A Dart binding of Cronet gives us easy access to its <a href=\"https://www.chromium.org/developers/design-documents/network-stack#TOC-Connection-Management\">features</a>, such as: reusability of sockets, powerful caching and compression algorithms, request prioritization, and <a href=\"https://www.youtube.com/watch?v=YWiRef3wOYY\">more reliable</a> network connections. Various Google products — including YouTube, Chrome, Google Maps, Google Photos, and the Google App — already depend on the Cronet library for their networking needs. With package:cronet, you get access to the Cronet library using an API <a href=\"https://github.com/google/cronet.dart/blob/main/dart_io_comparison.md#api-comparison\">similar</a> to dart:io, with little to no code changes in your existing Dart/Flutter app.</p><p>Check out <a href=\"https://github.com/google/cronet.dart\">github.com/google/cronet.dart</a> for <a href=\"https://github.com/google/cronet.dart/blob/main/dart_io_comparison.md#performance-comparison\">benchmarks</a>, <a href=\"https://github.com/google/cronet.dart/tree/main/example\">examples</a>, and <a href=\"https://github.com/google/cronet.dart/blob/main/dart_io_comparison.md\">comparisons with </a><a href=\"https://github.com/google/cronet.dart/blob/main/dart_io_comparison.md\">d</a>art:io. Also check <a href=\"https://unsuitable001.medium.com/package-cronet-an-http-dart-flutter-package-with-dart-ffi-84f9b69c8a24\">this blog post</a> about package:cronet for a technical overview and discussion of the challenges we faced.</p><h3>Flutter desktop tool</h3><p><em>By Abdullah Deshmukh</em></p><p>After the beta release of desktop support in Flutter 2, we needed a sample app to demonstrate how to write a Flutter app that can run on Windows, macOS, and Linux. I worked on that sample, in the form of a <a href=\"https://github.com/flutter/samples/tree/master/experimental/linting_tool\">Flutter linting tool that </a>helps you manage lint rules for your Flutter projects. The app’s source code shows how you might implement basic desktop app techniques like reading and writing files, implementing a responsive layout, using persistent storage, and even how to work with YAML files. Also the sample might be used to test the distribution of Flutter apps to the various desktop app stores.</p><p>For more details, visit <a href=\"https://medium.com/flutter/gsoc-21-creating-a-desktop-sample-for-flutter-7d77e74812d6\">GSoC ’21: Creating a desktop sample for Flutter</a>.</p><figure><img alt=\"A screenshot of the linting tool, displaying information for always_use_package_imports\" src=\"https://cdn-images-1.medium.com/max/1024/1*QswESHAF6CO9UNYCcRVKXA.png\" /><figcaption>Flutter linting tool</figcaption></figure><h3>License detection for pub.dev</h3><p><em>By Bharat Biradar</em></p><p>A package published on <a href=\"https://pub.dev/\">pub.dev</a> is evaluated on various metrics such as whether it follows Dart file conventions, has a CHANGELOG file, etc. This analysis is done by <a href=\"https://github.com/dart-lang/pana\">pana</a> (Package ANAlysis for Dart). Pana is also responsible for detecting the license identifier under which the package is published.</p><p>Until now the license names displayed on pub.dev were determined through simple regular expression heuristics, and they only supported detection of a few licenses with poor accuracy. The task of this project was to create a license detector for pana to detect <a href=\"https://spdx.org/licenses\">SPDX licenses</a>, in line with the <a href=\"https://spdx.dev/license-list/matching-guidelines/\">SPDX matching guidelines</a>.</p><p>The license detector built for pana uses the same approach as <a href=\"https://github.com/google/licenseclassifier\">v2_licenseclassifier</a>, with modifications made to suit our requirements better.</p><p>Given the LICENSE file from a package, pana uses three steps to detect the SPDX license identifiers:</p><ol><li><strong>Eliminate obvious mismatches from SPDX corpus: </strong>Split the text into tokens (basically words), check whether the LICENSE file has a sufficient number of tokens (at least 50%) as compared to a known license, and eliminate all known licenses that do not satisfy the criteria. This step allows pana to quickly rule out a lot of licenses, allowing for more expensive computations in step 2.</li><li><strong>Find matching substrings in the unknown license and remaining SPDX licenses: </strong>For the remaining known licenses, find the substrings in the unknown text that match a known license text. We look for substrings, because the unknown text might contain multiple licenses. When identifying matching substrings, we ignore sequences with fewer tokens than threshold * number_of_tokens_in_known_license, because such sequences do not have sufficient token density to constitute a match. If no substrings with sufficient token densities are found for a given known license, then we know it isn’t a match.</li><li><strong>Determine confidence scores: </strong>This step<strong> </strong>estimates a confidence score (between [0,1] ) to the substrings found. First the substring is diffed, using <a href=\"https://github.com/google/diff-match-patch/wiki/Line-or-Word-Diffs#word-mode\">levenshtain word diff</a>, against the SPDX corpus license in which it was detected. Then license is considered a match if the confidence calculated as follows is above the set threshold:</li></ol><figure><img alt=\"Confidence = 1 - (levenshtain_word_diff/number_of_tokens_in_known_license)\" src=\"https://cdn-images-1.medium.com/max/573/1*wB7F9CgvSn7yt2Rgoj75pw.png\" /></figure><p>We hope this gives you some idea of the license detection process. If you want to play with the license detector, you can find it in the <a href=\"https://github.com/dart-lang/pana/tree/master/bin\">pana repository</a>.</p><p><em>Huge thanks to everyone who applied for Google Summer of Code 2021 with Dart, to the students who completed projects this year, and to the mentors who helped make this an awesome summer of code. If you’re interested in hearing more about Dart in Google Summer of Code, check out </em><a href=\"https://medium.com/dartlang/google-summer-of-code-2020-results-a38cd072c9fe\"><em>our 2020 post</em></a><em>.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e514cce50fc\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/google-summer-of-code-2021-results-e514cce50fc\">Google Summer of Code 2021 results</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2021-09-08T16:59:41.000Z":{"title":"Announcing Dart 2.14","link":"https://medium.com/dartlang/announcing-dart-2-14-b48b9bb2fb67?source=rss----23738d481ce8---4","guid":"https://medium.com/p/b48b9bb2fb67","category":["dart","announcements","programming"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 08 Sep 2021 16:59:41 GMT","atom:updated":"2021-09-08T16:59:41.218Z","content:encoded":"<h4>Apple Silicon support, and improved productivity with default lints, better tools, and new language features</h4><p>Today we’re releasing version 2.14 of the Dart SDK, the next release in our ongoing journey to make the best platform for building apps through a unique combination of portability, productivity, and robustness. This time around we have better support for Apple Silicon, and a number of productivity enhancements such as standard lints for catching errors as you write your code through code style analysis, a faster pub tool, better formatting of code with cascades, and a few small language features.</p><figure><img alt=\"An illustration with text that summarizes the new 2.14 features\" src=\"https://cdn-images-1.medium.com/max/1024/1*qlsMfajTUkBw1APUpjcCZg.png\" /></figure><h3>Apple Silicon support in the Dart SDK</h3><p>Since Apple announced their new <a href=\"https://support.apple.com/en-us/HT211814\">Apple Silicon</a> processors in late 2020, we’ve worked on updating the Dart SDK to add support for native execution on the new processors. The needed changes have been available in the dev channel for a while, in the beta channel for the past month, and as of Dart 2.14.1 are now available in the Dart stable channel. When you <a href=\"https://dart.dev/get-dart\">download</a> a macOS SDK, make sure to pick the ARM64 option. Note that the Dart SDK bundled in the Flutter SDK doesn’t have these improvements yet.</p><p>The support includes both running the SDK/Dart VM itself on Apple Silicon, and support for compiling executables (with <a href=\"https://dart.dev/tools/dart-compile#exe\">dart compile</a>) that run on Apple Silicon. The Dart command-line tools start much faster now that they are using native Apple Silicon support.</p><h3>Standard lints shared for Dart and Flutter</h3><p>Developers often prefer their code to follow a certain style. Many of these rules aren’t just stylistic preferences (like the well-known tabs vs. spaces discussion), but cover coding styles that are likely to lead to mistakes or introduce bugs. As an example, the Dart style guide requires using curly braces for all control flow structures, such as if-else statements. This prevents the classic <a href=\"https://en.wikipedia.org/wiki/Dangling_else\">dangling else</a> problem, where there is ambiguity over how to interpret several nested if-else statements. Another example is type inference. While it’s fine to use type inference when declaring variables with initial values, it’s important to specify the type when <a href=\"https://dart-lang.github.io/linter/lints/prefer_typing_uninitialized_variables.html\">declaring uninitialized variables</a>, to ensure type safety.</p><p>One option for enforcing good code style is to have some form of human enforcement, often via a code review. However it’s often much more effective to enforce rules via static analysis that runs as you write your code.</p><p>In Dart, this static analysis is highly <a href=\"https://dart.dev/guides/language/analysis-options\">configurable</a>, and we have <a href=\"https://dart.dev/tools/linter-rules\">hundreds of style rules</a> (also known as <em>lints</em>). With this wealth of options, it can be a bit overwhelming to choose which rules to enable. The Dart team maintains a <a href=\"https://dart.dev/guides/language/effective-dart/style\">Dart style guide</a>, which describes what we believe is the best way of writing and styling Dart code, but historically we haven’t had an official set of linter rules that correspond to the style guide.</p><p>Many developers — and the pub.dev site <a href=\"https://pub.dev/help/scoring\">scoring</a> engine — have used the <a href=\"https://github.com/google/pedantic\">pedantic</a> set of lint rules. Pedantic, however, has its origins in the Google-internal style guide for Dart, which for historical reasons differs from the general Dart style guide. Additionally, the Flutter framework never used the pedantic set of rules, and instead had its own set of canonical rules.</p><p>This might sound a bit messy, and indeed it was. But with today’s releases we’re happy to announce that we now have a brand new set of lint collections that implement the style guide, and that the Dart and Flutter SDKs have been updated to use these rule sets by default for new projects. The rule sets are:</p><ul><li><a href=\"https://github.com/dart-lang/lints/blob/main/lib/core.yaml\">package:lints/core.yaml:</a><strong> </strong>The main rules from the Dart style guide that we believe all Dart code should follow. The pub.dev scoring engine has been updated to use these instead of pedantic.</li><li><a href=\"https://github.com/dart-lang/lints/blob/main/lib/recommended.yaml\">package:lints/recommended.yaml</a><strong>:</strong> The core rules, plus additional recommended rules. This set is recommended for all general Dart code.</li><li><a href=\"https://github.com/flutter/packages/blob/master/packages/flutter_lints/lib/flutter.yaml\">package:flutter_lints/flutter.yaml</a>: The core and recommended rules, plus additional Flutter-specific recommended rules. This set is recommended for all Flutter code.</li></ul><p>If you have existing projects, we strongly recommend that you upgrade to these new sets of rules. Upgrading from pedantic takes <a href=\"https://github.com/dart-lang/lints#migrating-from-packagepedantic\">just a few steps</a>.</p><h3>Dart formatter and cascades</h3><p>We made several optimizations to how the Dart formatter formats code with <a href=\"https://dart.dev/guides/language/language-tour#cascade-notation\">cascades</a>. Before, the formatter would in some cases produce confusing formatting. For example, what is doIt() called on in this example?</p><pre>var result = errorState ? foo : bad..doIt();</pre><p>It might look like it’s always called on bad, but actually the cascade applies to the entire ? expression, so the cascade is called on the result of that expression, and not just on the false clause. The new formatter makes this clear:</p><pre>var result = errorState ? foo : bad<br>  ..doIt();</pre><p>Other changes relate to how lines with multiple cascades are formatted, and how far cascades generally are indented. We also greatly increased the speed of formatting code containing cascades; in Dart code generated for <a href=\"https://developers.google.com/protocol-buffers/docs/reference/dart-generated\">protocol buffers</a>, we’re seeing up to a 10x improvement in formatting speed.</p><p>For all the details, see the <a href=\"https://github.com/dart-lang/dart_style/pull/1033\">tracking issue</a>.</p><h3>Pub support for ignoring files</h3><p>Currently when you <a href=\"https://dart.dev/tools/pub/publishing\">publish</a> a package to the <a href=\"https://pub.dev\">pub.dev</a> community repository, pub grabs all the files in that folder with a few exceptions, skipping hidden files (those that begin with a dot: .) and files listed in .gitignore. Several developers have requested the ability to control which files are ignored outside of the list in .gitignore. For example, you might have some internal development tools in a tool/ folder that you use for <em>maintaining</em> your package, but that aren’t relevant to people who <em>use</em> your package.</p><p>The updated pub command in Dart 2.14 supports a new .pubignore file, where you can list the files that you don’t want to upload to pub.dev. This file uses the same format as .gitignore files. For details, see the <a href=\"https://dart.dev/tools/pub/publishing#what-files-are-published\">package publishing documentation</a>.</p><h3>Pub and `dart test` performance</h3><p>While pub is perhaps most used for managing code dependencies, it also has a second important utility: powering tools. One such example is the Dart test tool, exposed via the dart test command. This command is really just a wrapper around the command pub run test:test, which runs the test entrypoint in <a href=\"https://github.com/dart-lang/test/blob/master/pkgs/test/bin/test.dart\">package:test</a>. Before invoking that entrypoint, pub first compiles it to native code that can be run faster.</p><p>Before Dart 2.14, any change to the pubspec (including ones unrelated to package:test) would invalidate this build of test, and you’d see a bunch of output like this containing “Precompiling executable”:</p><pre>$ dart test<br>Precompiling executable... (11.6s)<br>Precompiled test:test.<br>00:01 +1: All tests passed!</pre><p>In Dart 2.14, pub is much smarter about when to invalidate the build step, so the build happens only when the version changes. Further, we improved how we perform that build step using parallelization, so the step itself completes much faster. We’ve seen it take half the time on some packages that we’ve tested.</p><h3>New language features</h3><p>Dart 2.14 also contains a number of small language features. This time we focused on more specific improvements that are perhaps of more narrow utility, but enable more specialized use cases that weren’t previously supported.</p><p>First, we added a new <a href=\"https://github.com/dart-lang/language/issues/120\">triple shift</a> operator (&gt;&gt;&gt;). This is similar to the existing shift operator (&gt;&gt;), but where &gt;&gt; performs an arithmetic shift, &gt;&gt;&gt; performs a logical, or unsigned, shift where zero-bits are shifted into the most significant bit regardless of whether the number being shifted is positive or negative.</p><p>We’ve also removed an old restriction on type arguments, which disallowed using generic function types as a type argument. All of the following were invalid before 2.14, but are now allowed:</p><pre>late List&lt;T Function&lt;T&gt;(T)&gt; idFunctions;<br>var callback = [&lt;T&gt;(T value) =&gt; value];<br>late S Function&lt;S extends T Function&lt;T&gt;(T)&gt;(S) f;</pre><p>And finally, we’ve made a small adjustment to annotation types. (Annotations such as <a href=\"https://api.dart.dev/stable/2.13.4/dart-core/Deprecated-class.html\">@Deprecated</a> are commonly used in Dart code to capture metadata.) Previously annotations couldn’t be passed type arguments, so code like @TypeHelper&lt;int&gt;(42, &quot;The meaning&quot;) wasn’t allowed. This restriction has now been removed.</p><h3>Package and core library changes</h3><p>We’ve made a number of enhancements to core Dart packages and libraries, including:</p><ul><li>dart:core: Added static methods hash, hashAll, and hashAllUnordered to the Object class. These can be used to combine the hash codes of multiple objects in a consistent way (<a href=\"https://api.dart.dev/stable/2.14.0/dart-core/Object/hashAll.html\">hashAll example</a>).</li><li>dart:core: The native DateTime class now better handles local time around daylight saving time changes that aren’t precisely one hour — for example Lord Howe Island, Australia, which uses a 30-minute shift.</li><li><a href=\"https://pub.dev/packages/ffi\">package:ffi</a>: Added support for managing memory using an <a href=\"https://pub.dev/documentation/ffi/latest/ffi/Arena-class.html\">arena</a> allocator (<a href=\"https://github.com/dart-lang/sdk/blob/master/samples/ffi/resource_management/arena_sample.dart\">example</a>). Arenas are a form of <a href=\"https://en.wikipedia.org/wiki/Region-based_memory_management\">region-based memory management</a>, where resources are automatically freed once the arena/region is exited.</li><li><a href=\"https://pub.dev/packages/ffigen\">package:ffigen</a>: Now supports generating Dart typedefs from C typedefs.</li></ul><h3>Breaking changes</h3><p>Dart 2.14 also contains a number of smaller, <a href=\"https://github.com/dart-lang/sdk/blob/master/docs/process/breaking-changes.md\">previously announced</a> breaking changes. These changes are expected to impact just a few specialized use cases.</p><h4><a href=\"https://github.com/dart-lang/sdk/issues/46545\">#46545</a>: Removal of support for ECMAScript5</h4><p><a href=\"https://caniuse.com/es6\">All modern browsers</a> support recent ECMAScript versions, so two years ago we <a href=\"https://groups.google.com/a/dartlang.org/g/announce/c/x7eDinVT6fM/m/ZSFl2a9tEAAJ?pli=1\">announced</a> a plan to deprecate support for ECMAScript 5 (ES5). This enables us to leverage improvements in the latest ECMAScript and generate smaller output. In Dart 2.14 this work is complete, and the Dart web compilers no longer support ES5. As a result, older browsers — such as IE11 — are no longer supported.</p><h4><a href=\"https://github.com/dart-lang/sdk/issues/46100\">#46100</a>: Deprecation of stagehand, dartfmt, and dart2native</h4><p>In the October 2020 <a href=\"https://medium.com/dartlang/announcing-dart-2-10-350823952bd5\">Dart 2.10 blog post</a>, we announced our work to combine all the Dart CLI developer tools into a single, combined dart tool (similar to the flutter tool). As part of that evolution, Dart 2.14 deprecated the former dartfmt and dart2native commands, and discontinued stagehand. These tools all have equivalent replacements in the <a href=\"https://dart.dev/tools/dart-tool\">unified </a><a href=\"https://dart.dev/tools/dart-tool\">dart tool</a>.</p><h4><a href=\"https://github.com/dart-lang/sdk/issues/45451\">#45451</a>: Deprecation of VM Native Extensions</h4><p>We’ve deprecated the Dart VM’s Native Extensions, our older mechanism for calling native code from Dart code. Dart <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI</a> (foreign function interface) is our current mechanism for this use case, and we’re actively <a href=\"https://medium.com/dartlang/announcing-dart-2-13-c6d547b57067\">evolving</a> that to be even more powerful and easy to use.</p><h3>Null safety update</h3><p>We launched sound null safety in March in the <a href=\"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87\">Dart 2.12</a> release. Null safety is Dart’s latest major productivity feature, intended to help you avoid null errors — a class of bugs that are often hard to spot.</p><p>Since our last update, we’ve seen great progress on migrations of existing packages and apps to enable the sound checking benefits of null safety. For packages on pub.dev, 100% of the top-250 packages now support null safety, and 94% of the top-1000 support it. This means that more developers can run their apps with full <a href=\"https://dart.dev/null-safety/unsound-null-safety#sound-and-unsound-null-safety\">sound null safety</a>. Analytics show that 56% of flutter run sessions execute with full soundness. Thanks to all developers in the ecosystem for your migration work!</p><h3>2.14 availability and continued momentum</h3><p>The enhanced Dart SDK containing the above changes is available today in the Dart 2.14.1 and <a href=\"https://medium.com/flutter/whats-new-in-flutter-2-5-6f080c3f3dc\">Flutter 2.5</a> SDKs. We hope you’ll enjoy the new enhancements and features.</p><p>Also, we want to take the opportunity to extend our thanks to the awesome Dart community. As witnessed through a number of recent updates to programming language surveys, the Dart momentum is strong. The well-respected <a href=\"https://redmonk.com/sogrady/2021/08/05/language-rankings-6-21/\">RedMonk ranking</a> mentions <em>“Dart’s remarkable ascent”</em> and places Dart in the top 20 for the first time. StackOverflow’s comprehensive <a href=\"https://insights.stackoverflow.com/survey/2021#technology-most-loved-dreaded-and-wanted\">2021 Developer Survey</a> was equally delightful to read: Dart was reported to be the 7th most Loved programming language by developers. We’re truly delighted to see the Dart platform have continued growth and momentum.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b48b9bb2fb67\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-2-14-b48b9bb2fb67\">Announcing Dart 2.14</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-02-03T18:02:12.000Z":{"title":"Dart 2.16: Improved tooling and platform handling","link":"https://medium.com/dartlang/dart-2-16-improved-tooling-and-platform-handling-dd87abd6bad1?source=rss----23738d481ce8---4","guid":"https://medium.com/p/dd87abd6bad1","category":["announcements","programming","dart"],"dc:creator":"Michael Thomsen","pubDate":"Thu, 03 Feb 2022 18:02:12 GMT","atom:updated":"2022-02-04T08:41:25.701Z","content:encoded":"<h4>Supporting Flutter for Windows with package platform tagging and a new search experience for pub.dev</h4><p>Today the Dart SDK version 2.16 is available. It has no new language features, but a bunch of bug fixes (including a fix for a security vulnerability), improved support for specifying the platforms that Dart packages support, and a brand new search experience for <a href=\"https://pub.dev/\">pub.dev</a>.</p><h3>Dart 2.16</h3><p>The Dart 2.16 SDK, which launches today alongside <a href=\"https://medium.com/flutter/whats-new-in-flutter-2-10-5aafb0314b12\">Flutter 2.10</a>, continues the transition from legacy Dart CLI tools (dartfmt, dartdoc, etc.) to the new combined <a href=\"https://dart.dev/tools/dart-tool\">dart</a> developer tool. The newly deprecated tools are dartdoc (use dart doc) and dartanalyzer (use dart analyze). In Dart 2.17 we plan on fully removing the dartdoc, dartanalyzer, and pub commands (deprecated in Dart 2.15; use dart pub or flutter pub). For details, see <a href=\"https://github.com/dart-lang/sdk/issues/46100\">issue #46100</a>.</p><p>The 2.16 release also includes a fix for one security vulnerability and two small breaking changes:</p><ul><li>The <a href=\"https://github.com/dart-lang/sdk/security/advisories/GHSA-c8mh-jj22-xg5h#:~:text=https%3A//api.dart.dev/dart%2Dio/HttpClient%2Dclass.html\">HttpClient</a> API in dart:io allows you to set optional headers for authorization, www-authenticate, cookie, and cookie2. The implementation of redirection logic in SDKs before Dart 2.16 has a vulnerability where these headers — which can contain sensitive information — are passed on when a cross-origin redirect happens. In Dart 2.16 these headers are dropped. For details, see <a href=\"https://github.com/dart-lang/sdk/security/advisories/GHSA-c8mh-jj22-xg5h\">CVE-2022–0451</a>.</li><li>The Directory.rename API in dart:io has changed behavior on Windows: it no longer deletes an existing directory matching the target name (issue <a href=\"https://github.com/dart-lang/sdk/issues/47653\">#47653</a>).</li><li>The Platform.packageRoot and Isolate.packageRoot APIs — which are left over from Dart 1.x and nonfunctional in Dart 2.x — have been removed (issue <a href=\"https://github.com/dart-lang/sdk/issues/47769\">#47769</a>).</li></ul><p>To find further details about changes in Dart 2.16, see the <a href=\"https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md#2160\">changelog</a>.</p><h3>New support for declaring platform support for pub.dev packages</h3><p>Dart is designed for portability, and we strive to enable code that runs on the largest selection of platforms. However, occasionally you might create and share packages on pub.dev that have been designed for just one, or a few, platforms. You might have a package that relies on an API that’s available only on a particular operating system, or a package that uses a library like dart:ffi that’s supported only on native platforms and not on the web.</p><p>With Dart 2.16 you can now declare the set of supported platforms manually in the pubspec of the package. For example, if your package supports only Windows and macOS, its pubspec.yaml file might look like this:</p><pre>name: mypackage<br>version: 1.0.0</pre><pre>platforms:<br>  windows:<br>  macos:</pre><pre>dependencies:</pre><p>The new platforms tag is intended for cases where you are developing a Dart package, and you want to declare support for a different set of platforms from what pub.dev automatically detects. If you’re developing and sharing a Flutter plugin containing host-specific code (for example, Kotlin or Swift), the <a href=\"https://docs.flutter.dev/development/packages-and-plugins/developing-packages#plugin-platforms\">Flutter plugin tag</a> typically specifies the supported platforms.</p><h3>New pub.dev search UI</h3><p>Responding to developer requests, we’ve created better support for searching for packages on pub.dev. The main goal for the changes launching today is to help you identify, and search for, the set of supported platforms. Here’s a view of the new search experience:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*PJwhbfaIwRq3sSJi\" /><figcaption>Pub.dev search interface with sidebar containing Platforms, SDKs, and Advanced search filters</figcaption></figure><p>The new search UI has a search filter sidebar on the left, which you can use to constrain your package search:</p><ul><li><strong>Platforms</strong>: Select one or more platforms to narrow the search results to only packages that support all those platforms selected.</li><li><strong>SDKs</strong>: Select Dart or Flutter to limit the results to packages that support the Dart SDK or Flutter SDK, respectively.</li><li><strong>Advanced</strong>: Additional search options such as filtering to Flutter Favorite packages.</li></ul><h3>Null safety update</h3><p>It’s been a few releases since we last talked about null safety, the major language addition that launched a year ago in <a href=\"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87\">Dart 2.12</a>. We’ve been astonished by the speed at which the Dart ecosystem has migrated packages to support null safety: As of today, 100% of the top 250 packages — and 96% of the top 1000 — support null safety! Thanks to all package authors who’ve contributed to this great achievement.</p><p>We’ve also seen good progress on apps migrating to sound null safety (the state where the app code and all package dependencies have migrated). From our analytics, 71% of all run sessions in the Flutter tool now have fully sound null safety. If you’re an app developer and still haven’t migrated, now is a great time.</p><h3>Closing comments</h3><p>We hope you find the new pub.dev search UI useful, and we welcome <a href=\"https://github.com/dart-lang/pub-dev/issues/\">any feedback</a> you might have. Stay tuned for the next Dart SDK release, which is scheduled for the second quarter of 2022. We’re working on several <a href=\"https://github.com/dart-lang/language/projects/1\">exciting language features</a> that we hope to release later this year.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dd87abd6bad1\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-2-16-improved-tooling-and-platform-handling-dd87abd6bad1\">Dart 2.16: Improved tooling and platform handling</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-03-04T18:14:07.000Z":{"title":"Quick fixes for analysis issues","link":"https://medium.com/dartlang/quick-fixes-for-analysis-issues-c10df084971a?source=rss----23738d481ce8---4","guid":"https://medium.com/p/c10df084971a","dc:creator":"Brian Wilkerson","pubDate":"Fri, 04 Mar 2022 18:14:07 GMT","atom:updated":"2022-03-04T19:51:29.794Z","content:encoded":"<h4>Resolving diagnostics with a single click</h4><p>If you’re like me, too much of your development time is spent fixing problems (diagnostics) the analyzer finds. If you’ve ever wished it could be easier, then I have some good news for you. Many of the diagnostics the analyzer produces can be fixed automatically using quick fixes.</p><p>A <em>quick fix</em> is an automated edit targeted at fixing the issue reported by a specific diagnostic. In the <a href=\"https://medium.com/dartlang/dart-diagnostic-messages-ae302aa398e8\">Dart diagnostic messages</a> article, we looked at the following code:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/520/0*PHnbrlzf5BzJAyp8\" /></figure><p>The correction message suggests two ways of resolving the problem: “Try making the access conditional (using ‘?.’) or adding a null check to the target (‘!’).”</p><p>If you click in the highlighted region (the area with the red squiggly underline), you’ll see a light bulb icon near the left edge of the editor. If you hover over it, you can then click to open a menu containing the available quick fixes.</p><p>Both of the suggested corrections are available from the menu. Selecting one applies the change to your code. For example, if you select the first fix, it updates the code to the following:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/544/0*kv6ByFzA_oUH-1J-\" /></figure><p>Let’s first take a quick look at how to apply a fix in both <a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a> and <a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>, then look at a more powerful example of what quick fixes can do.</p><h3>IntelliJ IDEA</h3><p>The context actions menu in the editor looks like the following:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/744/0*SSy3gV3OrvEOjqyY\" /></figure><p>You can access the same list by selecting “Show Context Actions” from the context menu in the editor or by using its keyboard equivalent (<strong>Alt+Enter</strong> on Windows and Linux, or <strong>Option+Enter</strong> on macOS).</p><p>You can also invoke these fixes directly from the hover text when you hover over the highlighted region. If there are too many fixes, there’s a <strong>More Actions</strong> item also opens the menu:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*9fUhfo7YYZeSkbwJ\" /></figure><p>If that’s not enough, you can also invoke the available fixes from the context menu in the Dart Analysis view:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*KOFAwRRqF1nxP-X4\" /></figure><h3>Visual Studio Code</h3><p>The code actions menu in the editor looks like the following:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/718/0*6MrUQEB2aHocDDXS\" /></figure><p>The first two items are the quick fixes, the others are refactorings. You can access the same list by using its keyboard equivalent (<strong>Control+.</strong> on Windows and Linux, or <strong>Command+.</strong> on MacOS), or by selecting <strong>Quick Fix …</strong> from the hover text in the editor:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*t9j1bNBN9t_H_vGm\" /></figure><p>You can also invoke them from the context menu in the Problems panel:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/850/0*rD7c_L6FPLusv6lm\" /></figure><h3>Another example</h3><p>While the fix above saves you the time and effort of finding the correction message and then making the edit by hand, adding a single character is admittedly not a huge time-saver. However, some fixes provide a bigger productivity boost. Consider the following code:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/756/0*JudcB_TM8lvc32Ld\" /></figure><p>The diagnostic tells you that “the await expression can only be used in an async function.” Assuming that you don’t want to use synchronous I/O, the correction is to mark the body of the function with the async keyword. Doing that causes another error telling you that the return type of the method needs to be Future, so you’ll also end up updating the return type.</p><p>Fortunately, there’s a quick fix for the original problem:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/752/0*sgdKZfY_KVOLiIJU\" /></figure><p>Selecting this fix not only adds the modifier, but also updates the return type, allowing you to fix the problem in one step:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/850/0*WW-9wW23CnKxWZO2\" /></figure><h3>Summary</h3><p>Not every problem can be fixed automatically, and there isn’t a quick fix for every problem that could have one. Nevertheless, it’s definitely worth checking to see whether there’s an available quick fix the next time you have a diagnostic to fix. And if you don’t see a fix for a diagnostic that ought to have one, please let us know by <a href=\"https://github.com/dart-lang/sdk/issues/new\">creating a dart-lang/sdk issue</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c10df084971a\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/quick-fixes-for-analysis-issues-c10df084971a\">Quick fixes for analysis issues</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-05-11T19:48:43.000Z":{"title":"Dart 2.17: Productivity and integration","link":"https://medium.com/dartlang/dart-2-17-b216bfc80c5d?source=rss----23738d481ce8---4","guid":"https://medium.com/p/b216bfc80c5d","category":["dartlang","dart","programming","productivity","announcements"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 11 May 2022 19:48:43 GMT","atom:updated":"2022-05-11T20:52:04.893Z","content:encoded":"<h4>Language features. Productivity tools. Deeper &amp; broader platform integration.</h4><p>Today at <a href=\"https://io.google/2022/products/flutter/\">Google I/O</a>, we announced a new Dart SDK, version 2.17. This release builds on our core themes of leading productivity and platform portability. It offers new language features: enums with member support, improved parameter forwarding to super classes, and more flexibility for named parameters. We have improved tools with a new major version of package:lints — our tool support for checking Dart code against our best practices — and a broad update of core library API documentation with rich code samples. For improved platform integration we have new templates for using dart:ffi (native C interop) in Flutter plugins, experimental support for RISC-V processors, and support for signing macOS and Windows executables.</p><figure><img alt=\"Dart 2.17 reease banner\" src=\"https://cdn-images-1.medium.com/max/1024/1*eJKM-4rFprGXyxNd5w2m-Q.png\" /></figure><h3>New language features for improved productivity</h3><p>We constantly evolve the Dart language to make you more productive — both by adding new features and by making improvements to existing features. Dart 2.17 adds major new support for members on enums, refines how you can use named arguments in constructors, and makes code for forwarding parameters to superclasses much less verbose and repetitive.</p><h4>Enhanced enums with members</h4><p>Enums are great for representing a discrete set of states. For example, we might model water as enum Water { frozen, lukewarm, boiling }. But what if we want to add some methods on the enum — for example, to convert each of the states to a temperature, and support converting the enum to a String? We could perhaps use extension methods to add a waterToTemp() method, but we’d have to be careful to keep that in sync with the enum. For the String conversion we’d prefer to override toString(), but that hasn’t been supported.</p><p>With Dart 2.17 we now have general support for members on enums. That means we can add fields holding state, constructors that set that state, methods with functionality, and even override existing members. Many of you have been requesting this capability; it was our <a href=\"https://github.com/dart-lang/language/issues?q=is%3Aissue+sort%3Areactions-%2B1-desc+\">third highest voted issue</a> in the language tracker.</p><p>For our water example, we can add an int field holding the temperature and a default constructor that takes an int:</p><pre>enum Water {<br>…<br>  final int tempInFahrenheit;<br>  const Water(this.tempInFahrenheit);<br>}</pre><p>To ensure the constructor is called when the enum is created, we need to invoke it for each enum value:</p><pre>enum Water {<br>  frozen(32),<br>  lukewarm(100),<br>  boiling(212);<br>…<br>}</pre><p>To support the conversion to String, we simply override toString, which enums inherit from Object:</p><pre><a href=\"http://twitter.com/override\">@override</a><br>String toString() =&gt; &quot;The $name water is $tempInFahrenheit F.&quot;;</pre><p>And with that, you have a complete enum that can be easily instantiated and you can invoke methods on:</p><pre>void main() {<br>  print(Water.frozen); // Prints “The frozen water is 32 F.”<br>}</pre><p>A complete example of these two approaches is illustrated below; we find the new Dart 2.17 version much easier to read and maintain.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*hGKUdu4DT9v2IZGj\" /></figure><h4>Super initializers</h4><p>When you have a class inheritance hierarchy, a common pattern is to pass some constructor parameters to the constructor of the superclass. To do that, the sub-class needs to 1) list each parameter in its own constructor, and 2) invoke the super constructor with those parameters. That leads to boilerplate code: lots of repetition, making the code harder to read and more bothersome to maintain.</p><p>Several Dart community members helped make this happen. GitHub user @roy-sianez filed a <a href=\"https://github.com/dart-lang/language/issues/1855\">language issue</a> regarding this about half a year ago; suggesting something similar to what GitHub user <a href=\"http://twitter.com/apps\">@apps</a>-transround had <a href=\"https://github.com/dart-lang/language/issues/493#issuecomment-879624528\">suggested earlier</a>: that we could perhaps resolve this by introducing a new construct to express that a parameter was specified in the super class. We thought that was a great idea, so this has been added to Dart 2.17. As you can see from the following example, this is especially relevant for Flutter widget code. In fact, when we applied the new feature to the Flutter framework, we saw a total reduction of <a href=\"https://github.com/flutter/flutter/pull/100905/files\">nearly two thousand lines of code</a>!</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*ypTj-6zzDBoqnpRL\" /></figure><h4>Named args everywhere</h4><p>Lastly, we’ve refined how named arguments work when you invoke a method. Previously, these had to appear last in the list of arguments to the method. This was annoying in cases where you’d prefer to place a positional argument last to make the code more readable. For example, see the following invocation of the List&lt;T&gt;.generate constructor — before, the growable argument had to be placed last, making it easy to miss below the large positional argument containing the generator itself. Now you can order them as you prefer, allowing you to place the small named arguments first and the generator last.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*gMf1J56vEgV96z1l\" /></figure><p>For further examples of these three features in actions, see our updated samples for <a href=\"https://github.com/dart-lang/samples/blob/master/enhanced_enums/lib/members.dart\">enums</a>, <a href=\"https://github.com/dart-lang/samples/blob/master/parameters/lib/super_initalizer.dart\">super initializers</a>, and <a href=\"https://github.com/dart-lang/samples/blob/master/parameters/lib/named_parameters.dart\">named parameters</a>.</p><h3>Productivity tools</h3><p>Continuing the productivity theme, we have several improvements in our core tools.</p><p>In Dart 2.14 we introduced package:lints, which works with the Dart analyzer to help you write Dart code that prevents errors and uses a canonical style enabling more effective code reviews. Since then a number of new lints have been made available in the analyzer, which we’ve carefully triaged and from that selected <a href=\"https://github.com/dart-lang/lints/blob/main/CHANGELOG.md#200\">ten new lints</a> for all Dart code, and <a href=\"https://github.com/flutter/packages/blob/master/packages/flutter_lints/CHANGELOG.md#200\">two new lints</a> specifically for Flutter code. These include lints for ensuring your imports are included in your pubspec file, preventing the misuse of null checks on type parameters, and ensuring a consistent style for child properties. You can upgrade to the new lints with a simple command:</p><ul><li>For Dart packages:<br>dart pub upgrade —-major-versions lints</li><li>For Flutter packages: <br>flutter pub upgrade —-major-versions flutter_lints</li></ul><p>SecureSockets are commonly used to enable TCP sockets secured with TLS and SSL. Before Dart 2.17, debugging these sockets during development was tricky, as there was no way to inspect the secure data traffic. We’ve now added support for specifying a keyLog file. When specified, a line of text in the <a href=\"https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format\">NSS Key Log Format</a> is appended to the file when new TLS keys are exchanged with the server. This enables network traffic analyzer tools (such as <a href=\"https://gitlab.com/wireshark/wireshark/-/wikis/TLS#tls-decryption\">Wireshark</a>) to decrypt the content sent through the socket. For details, see the API docs for <a href=\"https://api.dart.dev/stable/2.17.0/dart-io/SecureSocket/connect.html\">SecureSocket.connect()</a>.</p><p>API documentation generated by the dart doc tool is a critical asset to most Dart developers learning new APIs. While our <a href=\"https://dart.dev/guides/libraries\">core library APIs</a> have long had rich textual descriptions, many developers have told us they prefer to learn APIs by reading sample code that uses the API. With Dart 2.17, we’ve completely overhauled all major core libraries, adding sample code to the top 200 most viewed pages, so they now have comprehensive sample code. As an example, compare the documentation for dart:convert in <a href=\"https://api.dart.dev/stable/2.16.2/dart-convert/dart-convert-library.html\">Dart 2.16</a> with the updated page for <a href=\"https://api.dart.dev/stable/2.17.0/dart-convert/dart-convert-library.html\">Dart 2.17</a>; hopefully this makes the documentation much easier to consume.</p><p>Productivity gains come not only when we add new features to our platform, but also when we clean up our stack and remove features that are no longer used. This helps keep our surface area small, which is critical especially to new developers. Towards this, we’ve removed <a href=\"https://dart-review.googlesource.com/c/sdk/+/236840\">231 lines of deprecated code</a> from the dart:io library — if you are still using these deprecated APIs, you can upgrade to their replacements with <a href=\"https://dart.dev/tools/dart-fix\">dart fix</a>. We’ve also continued our effort to remove <a href=\"https://github.com/dart-lang/sdk/issues/46100\">deprecated Dart CLI tools</a>, this time removing the dartdoc tool (use dart doc instead), and pub tool (use dart pub or flutter pub).</p><h3>Broadening our platform integration and support</h3><p>A second core theme is platform integration and support. Dart is a true multi-platform language. While we already support a <a href=\"https://dart.dev/overview#platform\">wide range of platforms</a>, we’re constantly evolving to ensure that you can deeply integrate with each supported platform, and also to support emerging platforms.</p><p>Dart FFI — our core mechanism for <a href=\"https://dart.dev/guides/libraries/c-interop\">interop with C/native code</a> — is a popular way of integrating Dart code with existing native platform code. On Flutter, this can be a great way to build <a href=\"https://docs.flutter.dev/development/packages-and-plugins/developing-packages\">plugins</a> that use native APIs from the host platform (such as Windows win32 APIs). In Dart 2.17 and Flutter 3, we’ve added templates to the flutter tool so you can now easily create FFI Plugins that have a Dart API backed by dart:ffi calls into native code. For details, see the updated <a href=\"https://docs.flutter.dev/development/packages-and-plugins/developing-packages#dart-only-platform-implementations\">developing packages and plugins</a> page on flutter.dev.</p><p>To enable use of FFI on platforms that have types specific to their ABI (<a href=\"https://en.wikipedia.org/wiki/Application_binary_interface\">application binary interface</a>), FFI now supports ABI-specific types. For example, you can now use <a href=\"https://api.dart.dev/stable/2.17.0/dart-ffi/Long-class.html\">Long</a> (long in C) to correctly represent a long integer with an ABI-specific size, which might be 32-bit or 64-bit depending on the CPU architecture. For the full list of supported types, see the list of “Implementers’’ in the <a href=\"https://api.dart.dev/stable/2.17.0/dart-ffi/AbiSpecificInteger-class.html\">AbiSpecificInteger</a> API page.</p><p>When deeply integrating with native platforms using Dart FFI, you sometimes need to align the cleanup of memory or other resources (ports, files, and so on) allocated by Dart and the native code. This has historically been very tricky, as Dart is a garbage collected language that automatically handles cleanup. Dart 2.17 solves this by introducing the concept of a Finalizer, which includes a Finalizable marker interface for “tagging” objects that shouldn’t be finalized or discarded too early, and a NativeFinalizer class that can be attached to a Dart object to provide a call-back run when the object is about to be garbage collected. Together these allow for running cleanup code in both native and Dart code. For details, see the description and example in the API documentation for <a href=\"https://api.dart.dev/stable/2.17.0/dart-ffi/NativeFinalizer-class.html\">NativeFinalizer</a>, or the documentation for <a href=\"https://api.dart.dev/stable/2.17.0/dart-core/WeakReference-class.html\">WeakReferences</a> and <a href=\"https://api.dart.dev/stable/2.17.0/dart-core/Finalizer-class.html\">Finalizer</a> for similar support in regular Dart code.</p><p>Our support for compiling Dart to native code is a core enabler of making Flutter apps have great startup performance and fast rendering. A second use case is the ability to compile Dart to executables with <a href=\"https://dart.dev/tools/dart-compile\">dart compile</a>. These executables can run standalone on any machine without needing the Dart SDK to be installed. Another new capability in Dart 2.17 is support for <a href=\"https://dart.dev/tools/dart-compile#exe\">signing of executables</a>, which enables deployment on Windows and macOS where signing is often required.</p><p>We’re also continuing to broaden our set of supported platforms by staying at the forefront of new emerging platforms. <a href=\"https://riscv.org/about/\">RISC-V</a> is a new innovative instruction set for processors. RISC-V International, a global non-profit organization, owns the RISC-V specification, making the instruction set free and open. This is still an emerging platform, but we’re excited about its potential, so our 2.17.0–266.1.beta Linux release (or later from our <a href=\"https://dart.dev/get-dart/archive#beta-channel\">beta channel)</a> includes experimental support for it. We’d love to hear your feedback, so please <a href=\"https://github.com/dart-lang/sdk/issues\">file an issue</a> or <a href=\"https://groups.google.com/a/dartlang.org/g/misc\">post</a> about your experience!</p><h3>Get started with Dart 2.17!</h3><p>We hope that today’s Dart 2.17 release excites you, improves your productivity, and enables even more platform integration for your apps. To get started, you can directly download the Dart<a href=\"https://dart.dev/get-dart\"> 2.17</a> release, or get it embedded as part of today’s <a href=\"https://docs.flutter.dev/get-started/install\">Flutter 3</a> SDK release.</p><p>We also invite you to check out <a href=\"https://io.google/2022/products/flutter/\">the new content</a> we’ve made available for Google I/O!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b216bfc80c5d\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-2-17-b216bfc80c5d\">Dart 2.17: Productivity and integration</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-05-05T22:41:38.000Z":{"title":"Bulk application of fixes","link":"https://medium.com/dartlang/bulk-application-of-fixes-e6add333c3c1?source=rss----23738d481ce8---4","guid":"https://medium.com/p/e6add333c3c1","category":["linter","analyzer","dart","dartlang"],"dc:creator":"Brian Wilkerson","pubDate":"Thu, 05 May 2022 22:41:38 GMT","atom:updated":"2022-05-16T18:19:03.143Z","content:encoded":"<h4>Fixing multiple analysis issues in one step</h4><p>In <a href=\"https://medium.com/dartlang/quick-fixes-for-analysis-issues-c10df084971a\">Quick fixes for analysis issues</a> we looked at support for automatically fixing individual diagnostics while editing. Sometimes even that’s too slow and you’d really like to fix multiple diagnostics all at once. Fortunately, there’s support for that too, which we cover in this article.</p><p>There are several ways to fix multiple diagnostics, depending on just how many diagnostics you want to fix, and we’ll look at each one separately.</p><h3>Fixing multiple occurrences of the same diagnostics</h3><p>Have you ever refactored your code by moving a class to a different file? If so, it’s fairly likely that some imports were only needed because of references in the class being moved, which leaves you with unused imports:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/460/0*URmNnWSjGRGOorjv\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/444/0*3QaE0FunXWpPp2Az\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><p>For any fix that can be applied more than once within the same file, the tooling offers an option to apply it everywhere in the file.</p><p>These fixes show up in the same places as other fixes and are usually labeled similarly to the single location fixes, but with some phrase like “in file” added. For example, here’s how this fix appears in your IDE:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/658/0*p2Pf06L6A4JSX7IS\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/658/0*S4UnOqdx-h0U55jU\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><p>Selecting the “in-file” fix does exactly what you’d expect — it removes all unused imports in the file:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/430/0*dHw4rjdxTR0liZX8\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/352/0*Wk6qnyUlNr3qN0GQ\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><h3>Fixing all the diagnostics in a file</h3><p>That’s great, but it only fixes a single kind of diagnostic, and it requires you to find the place where the diagnostic is being reported (either in the editor or in the problems view) to invoke the fix. It seems like the tooling could do more.</p><p>And in <a href=\"https://code.visualstudio.com/\">Visual Studio Code</a>, it can. You can apply fixes for all the diagnostics within a single file. To see how, we’ll use the same example as above:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/460/0*mr1A2XnnRCaamU22\" /></figure><p>If you right click to open the context menu, you’ll see the following:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/0*3klKEJk5p40lCPbO\" /></figure><p>If you select <strong>Source Action…</strong>, it opens a second menu:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/536/0*iRZIzPrwKl7jEYNY\" /></figure><p>Selecting <strong>Fix All </strong>causes fixes to be applied to all the diagnostics in the editor, producing the following:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/430/0*FDf16dDPwfPg_dET\" /></figure><p>You can also invoke the <strong>Fix All</strong> command from the command palette, which you can open by selecting <strong>Command Palette… </strong>from the <strong>View</strong> menu, or by using the keyboard shortcut (F1 on any platform, Control+Shift+P on Windows and Linux, or Command+Shift+P on macOS). You can filter the list by typing the name of the command. The command palette looks something like this:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*Jrz3MRfYVtcXrb9C\" /></figure><h3>Fixing all the diagnostics in a directory</h3><p>The most complete tool we have for fixing diagnostics is the <a href=\"https://dart.dev/tools/dart-fix\">dart fix</a> command-line tool. It can fix all the diagnostics in a given directory, which means that you can use it to fix everything in your package or application.</p><p>Of course, there are a couple of caveats. It doesn’t fix every diagnostic, because it applies the same quick fixes that are available in the IDE, and there aren’t quick fixes for every diagnostic. It also doesn’t apply quick fixes for diagnostics when there are multiple equally valid ways of fixing the problem, because it can’t know which fix you prefer to apply. These caveats also apply to the <strong>Fix All</strong> command described in the previous section.</p><p>While the need for this tool doesn’t come up often (which is one reason you might not know about it), there are a couple of situations where it’s especially useful.</p><p>First, consider the case where you want to enable a new lint, or even a set of lints, such as one of the <a href=\"https://github.com/dart-lang/lints/blob/main/lib/core.yaml\">core</a>, <a href=\"https://github.com/dart-lang/lints/blob/main/lib/recommended.yaml\">recommended</a>, or <a href=\"https://github.com/flutter/packages/blob/master/packages/flutter_lints/lib/flutter.yaml\">flutter</a> rule sets. Chances are good that there are at least a few violations of the lint rules in your package. If there’s a fix associated with the lint, then it’s convenient to apply that fix everywhere in one step rather than applying the fix to each violation individually.</p><p>Second, consider the case where you’re updating from one release of Flutter to another. If there have been API changes between the two releases, there’s a good chance that there’s a fix to upgrade your code to conform to the latest release. Again, it’s convenient if all of those changes are applied in a single operation.</p><p>That’s where the <a href=\"https://dart.dev/tools/dart-fix\">dart fix</a> command comes in. It can apply quick fixes for multiple diagnostics in multiple files.</p><p>The command has two modes. The <em>dry-run </em>mode tells you how many changes it can apply and which diagnostics it can fix, but without modifying any files. The <em>apply </em>mode applies the changes.</p><p>You can provide the path to the directory containing the files to be fixed, but if you omit the directory it recursively fixes all the files in the current directory and its subdirectories.</p><p>Let’s assume that you’ve enabled the prefer_single_quotes lint, and that you have a file containing the following:</p><pre>import &#39;package:logging/logging.dart&#39;;</pre><pre>void main() {<br>  var logger = Logger(&quot;myApp&quot;);<br>  logger.info(&quot;Entering myApp&quot;);<br>  // Do stuff.<br>  logger.info(&quot;Exiting myApp&quot;);<br>}</pre><p>Running the <a href=\"https://dart.dev/tools/dart-fix\">dart fix</a> command with the --dry-run option from the directory containing this file produces the following output:</p><pre>$ dart fix --dry-run<br>Computing fixes in __bin__ (dry run)... 4.3s</pre><pre>3 proposed fixes in 1 file.</pre><pre>demo.dart<br>  prefer_single_quotes • 3 fixes</pre><p>The tool has found three violations of the lint and reports that it’s able to fix all three, but it doesn’t modify the file.</p><p>Running the <a href=\"https://dart.dev/tools/dart-fix\">dart fix</a> tool again, but this time with the --apply option, produces almost the same output:</p><pre>$ dart fix --apply<br>Computing fixes in __bin__... 5.3s<br>Applying fixes...         0.0s</pre><pre>3 proposed fixes in 1 file.</pre><pre>demo.dart<br>  prefer_single_quotes • 3 fixes</pre><pre>3 fixes made in 1 file.</pre><p>But this time the file is updated to contain the following:</p><pre>import &#39;package:logging/logging.dart&#39;;</pre><pre>void main() {<br>  var logger = Logger(&#39;myApp&#39;);<br>  logger.info(&#39;Entering myApp&#39;);<br>  // Do stuff.<br>  logger.info(&#39;Exiting myApp&#39;);<br>}</pre><p>Because the dry-run mode doesn’t produce any kind of diff output that allows you to see the actual changes that are being proposed, <strong>consider committing your changes before running the tool using the </strong><strong>--apply option</strong>. That way it’s easier to see what changes the tool has actually made and to revert any changes you don’t like.</p><p>If you don’t want to commit before running the tool, and you’re using IntelliJ IDEA, you can use the <strong>File-&gt;Local History</strong> feature to compare the state before and after applying the fixes. (For more information see <a href=\"https://www.jetbrains.com/help/idea/local-history.html#label-local-history-revisions\">Add labels to specific states Local History</a>.)</p><p>The <a href=\"https://dart.dev/tools/dart-fix\">dart fix</a> command can’t fix every problem, but when it can, it’s much easier than manually applying the fix everywhere.</p><h3>Summary</h3><p>Being able to apply multiple fixes in a single operation not only increases the power of quick fixes, but might also make it easier to make larger scale changes, such as enabling a new lint rule or upgrading to the latest version of Flutter.</p><p>As always, if you have ideas for how to improve these tools, please let us know by <a href=\"https://github.com/dart-lang/sdk/issues/new\">creating a dart-lang/sdk issue</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e6add333c3c1\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/bulk-application-of-fixes-e6add333c3c1\">Bulk application of fixes</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-04-14T11:32:14.000Z":{"title":"Dart asynchronous programming: Streams","link":"https://medium.com/dartlang/dart-asynchronous-programming-streams-dab952023ed7?source=rss----23738d481ce8---4","guid":"https://medium.com/p/dab952023ed7","category":["dartlang","flutter","asynchronous-programming","programming-languages","programming"],"dc:creator":"Flutter Devrel Medium","pubDate":"Thu, 14 Apr 2022 11:32:14 GMT","atom:updated":"2022-04-14T11:32:14.397Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/272/0*yUEX9fxMxoG63vi0.gif\" /><figcaption>A simple Flutter app that displays data from a stream</figcaption></figure><p>This article covers one of the fundamentals of reactive programming: streams, which are objects of type <a href=\"https://api.dart.dev/stable/dart-async/Stream-class.html\">Stream</a>.</p><p>If you’ve read our <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137\">previous articles on futures</a>, you might remember that <strong>each future represents a single value </strong>(either an error or data) delivered <strong>asynchronously</strong>. Streams work similarly, only instead of a single thing, <strong>a</strong> <strong>stream</strong> <strong>can deliver zero or more values and errors </strong>over <strong>time</strong>.</p><blockquote>This article was first published in <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-streams-2569a993324d\">February 2020</a>. This version updates the included code to null safety.</blockquote><blockquote>This article is the third one based on the <em>Flutter in Focus</em> video series <em>Asynchronous Programming in Dart</em>. The first article, <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a\">Isolates and event loops</a>, covers the foundations of Dart’s support for background work. The second one, Futures, discusses the Future class.</blockquote><blockquote>If you prefer to learn by watching or listening, everything in this article is covered in the following video.</blockquote><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FnQBpOIHE4eE%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DnQBpOIHE4eE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FnQBpOIHE4eE%2Fhqdefault.jpg&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/19f7572c0ed7e65b2b45fc00703972c6/href\">https://medium.com/media/19f7572c0ed7e65b2b45fc00703972c6/href</a></iframe><blockquote><strong>Note</strong>: The code in this article has been updated to reflect best practices and changes to the Dart language (including null safety), which occurred after the video was released on June 28, 2019.</blockquote><p>If you think about the way a single value relates to an <a href=\"https://dart.dev/codelabs/iterables\">iterator</a> of the same type, that’s how a future relates to a stream: a future represents a single request with a single response, where a stream represents a single request with multiple responses.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/429/0*e0Lz6RaBIx2uK5R4.png\" /></figure><p>Just like with futures, the key is deciding in advance what to do 1) when a piece of data is ready, 2) when there’s an error, and 3) when the stream completes. As with futures, in this process the Dart event loop is still running the show.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/proxy/0*tYShCv7ndeKeJFsv\" /><figcaption>Streams work with the Dart event loop.</figcaption></figure><h4><strong>Event loop pinch</strong></h4><p>If you’re using the File class’s<a href=\"https://api.dart.dev/stable/dart-io/File/openRead.html\">openRead</a>() method to read data from a file, for example, this method returns a stream.</p><p>Chunks of data are read from disk and arrive at the event loop. The Dart library looks at them and says, “Ah, someone is waiting for this,” adds the data to the stream, and sends it to your app.</p><p>When another piece of data arrives — in it goes, and out it comes. Timer-based streams and streaming data from a network socket work with the event loop too, using clock and network events.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/429/0*4NRFcYLryiLlUIrT\" /><figcaption>The event loop sorts the data.</figcaption></figure><h4><strong>Listening to streams</strong></h4><p>The next thing to understand is how to work with data provided by a stream.</p><p>Say you have a class that gives you a stream that emits a new integer once every second (1, 2, 3, 4, 5…). You can use the <a href=\"https://api.dart.dev/stable/dart-async/Stream/listen.html\">listen</a>()method to subscribe to the stream. The only required parameter is a function.</p><pre>final myStream = NumberCreator().stream;</pre><pre>final subscription = myStream.listen(<br>    (data) =&gt; print(‘Data: $data’),<br>);</pre><p>Every time a new value is emitted by the stream, the function gets called and prints the value:</p><pre>Data: 1<br>Data: 2<br>Data: 3<br>Data: 4<br>...</pre><p>That’s how listen()works.</p><blockquote><strong>Important:</strong> By default, streams are set up for single subscription. They hold onto their values until someone subscribes, and they only allow a single listener for their entire lifespan. If you try to listen to a stream twice, you’ll get an exception.</blockquote><blockquote>Fortunately Dart also offers broadcast streams. You can use the <a href=\"https://api.dart.dev/stable/dart-async/Stream/asBroadcastStream.html\">asBroadcastStream()</a> method to make a broadcast stream from a single subscription one. Broadcast streams work the same as single subscription streams, but they can have multiple listeners.</blockquote><blockquote><strong>Another difference of broadcast streams: </strong>if nobody’s listening when a piece of data is ready, that data is tossed out.</blockquote><pre>final myStream = NumberCreator().stream;</pre><pre>final subscription = myStream.listen(<br>  (data) =&gt; print(‘Data: $data’),<br>);</pre><pre>final subscription2 = myStream.listen(<br>  (data) =&gt; print(‘Data again: $data’),<br>);</pre><p>Let’s go back to that first listen()call, because there are a couple more things to talk about.</p><p>As mentioned earlier, streams can produce errors just like futures can. By adding an <a href=\"https://api.dart.dev/stable/2.16.2/dart-async/StreamSubscription/onError.html\">onError</a> function to the listen() call, you can catch and process any errors.</p><p>There’s also a cancelOnError<em> </em>property that’s true by default, but can be set to false to keep the subscription going even after an error.</p><p>You can add the <a href=\"https://api.dart.dev/stable/2.16.2/dart-async/StreamSubscription/onDone.html\">onDone</a> function to execute some code when the stream is finished sending data, such as when a file has been completely read.</p><p>With all four of those parameters combined — onError, onDone, cancelOnError, and the required parameter (<a href=\"https://api.dart.dev/stable/2.16.2/dart-async/StreamSubscription/onData.html\">onData</a>) — you can be ready in advance for whatever happens.</p><pre>final myStream = NumberCreator().stream;</pre><pre>final subscription = myStream.listen(<br>  (data){<br>    print(‘Data: $data’);<br>},<br>onError: (err) {<br>  print(‘Error!’);<br>},<br>cancelOnError: false,<br>onDone: () {<br>  print(‘Done!’):<br> },<br>);</pre><blockquote><strong>Tip:</strong> The object that listen() returns has some useful methods of its own. It’s called a StreamSubscription, and you can use it to pause, resume, and even cancel the flow of data.</blockquote><pre>final subscription = myStream.listen(…);</pre><pre>subscription.pause();<br>subscription.resume();<br>subscription.cancel();</pre><h4><strong>Using and manipulating streams</strong></h4><p>Now that you know how to use listen() to subscribe to a stream and receive data events, let’s talk about what makes streams really cool: manipulating them.</p><p>Once you’ve got data in a stream, there are a lot of operations that suddenly become fluent and elegant.</p><p>Let’s go back to that number stream from earlier.</p><p>Using a method called <a href=\"https://api.dart.dev/stable/dart-async/Stream/map.html\">map</a>()<em>,</em> you can take each value from the stream and convert it on the fly into something else. Give map() a function to do the conversion, and it returns a new stream, typed to match the return value of the function.</p><p>Instead of a stream of integers, now there is a stream of strings. Throw a listen()call on the end, pass it the <a href=\"https://api.dart.dev/stable/2.16.2/dart-async/Zone/print.html\">print</a>()function, and now it prints strings directly off the stream — asynchronously, as they arrive.</p><pre>NumberCreator().stream<br>    .map((i) =&gt; ‘String $i’)<br>    .listen(print) ;</pre><pre>String 1<br>String 2<br>String 3<br>String 4<br>*/</pre><p>There are many methods you can chain up like this. If you only want to print the even numbers, for example, you can use where() to filter the stream. Give it a test function that returns a boolean for each element, and it returns a new stream that only includes values that pass the test.</p><pre>NumberCreator().stream<br>    .where((i) =&gt; i % 2 == 0)<br>    .map((i) =&gt; ‘String $i’)<br>    .listen(print) ;</pre><pre>String 2<br>String 4<br>String 6<br>String 8</pre><p>The <a href=\"https://api.dart.dev/stable/dart-async/Stream/distinct.html\">distinct</a>() method is another good one. With an app that uses a Redux store, that store emits new app state objects in an <a href=\"https://api.dart.dev/stable/2.16.2/dart-html/Document/onChange.html\">onChange</a> stream.</p><p>You can use map() to convert the stream of state objects to a stream of view models for one part of the app. Then you can use the distinct() method to get a stream that filters out consecutive identical values (in case the store kicks out a change that doesn’t affect the subset of data in the view model).</p><p>You can then listen and update the UI whenever you get a new view model.</p><pre>myReduxStore.onChange<br>    .map((s) =&gt; MyViewModel(s))<br>    .distinct()<br>    .listen( /* update UI */ )</pre><p>There are additional methods built into Dart that you can use to shape and modify your streams. Plus, when you’re ready for more advanced features, there’s the <a href=\"https://pub.dev/packages/async\">async package</a> maintained by the Dart team and available on <a href=\"https://pub.dev/\">pub.dev</a>. It has classes that can merge two streams together, cache results, and perform other types of stream-based wizardry.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*x-uuwOB-kV_dlw80Gx5kkA.png\" /><figcaption>Try the async package for more stream-based wizardry.</figcaption></figure><p>For even more stream magic, take a look at the <a href=\"https://pub.dev/packages/stream_transform\">stream_transform package</a>.</p><h4><strong>Creating streams</strong></h4><p>Finally, one more advanced topic that deserves a mention here is how to create streams of your own.</p><p>Just like with futures, most of the time you’re going to be working with streams created for you by network libraries, file libraries, state management, and so on, but you can make your own using a <a href=\"https://api.dart.dev/stable/dart-async/StreamController-class.html\">StreamController</a>.</p><p>Let’s go back to that NumberCreator example we’ve been using so far. Here’s the actual code for it:</p><pre>class NumberCreator {<br>  NumberCreator() {<br>    Timer.periodic(const Duration(seconds: 1), (timer) {<br>      _controller.sink.add(_count);<br>     _count += 1;<br>   });<br> }</pre><pre> final _controller = StreamController&lt;int&gt;();<br> var _count = 0;<br> Stream&lt;int&gt; get stream =&gt; _controller.stream;<br>}</pre><p>As you can see, it keeps a running count and uses a timer to increment that count each second. The interesting bit, though, is the stream controller.</p><p>A <a href=\"https://api.dart.dev/stable/2.16.2/dart-async/StreamController-class.html\">StreamController</a> creates a brand new stream from scratch and gives you access to both ends of it. There’s the stream end itself, where data arrives. (We’ve been using that one throughout this article.)</p><p>Stream&lt;int&gt; get stream =&gt; _controller.stream;</p><p>And there’s the sink end, which is where new data gets added to the stream:</p><p>_controller.sink.add(_count);</p><p>NumberCreator uses both of them. When the timer goes off, it adds the latest count to the controller’s sink, and then it exposes the controller’s stream with a public property so other objects can subscribe to it.</p><h4><strong>Building Flutter widgets using streams</strong></h4><p>Now that we’ve covered creating, manipulating, and listening to streams, let’s talk about how to put them to work building widgets in Flutter.</p><p>If you read the previous article on <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137\">Futures</a>, you may remember <a href=\"https://api.flutter.dev/flutter/widgets/FutureBuilder-class.html\">FutureBuilder</a>. You give it a future and a builder method, and it builds widgets based on the state of the future.</p><p>For streams, there’s a similar widget called <a href=\"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html\">StreamBuilder</a>. Give it a stream like the one from number creator and a builder method, and it rebuilds its children whenever a new value is emitted by the stream.</p><pre>StreamBuilder&lt;String&gt;(<br>  stream: NumberCreator().stream.map((i) =&gt; ‘String $i’),<br>  builder: (context, snapshot) {<br>    // Build some widgets<br>    throw UnimplementedError(“Case not handled yet”);<br>  },<br>);</pre><p>The snapshot parameter is an <a href=\"https://api.flutter.dev/flutter/widgets/AsyncSnapshot-class.html\">AsyncSnapshot</a>, just like with FutureBuilder.</p><pre>StreamBuilder&lt;String&gt;(<br>  stream: NumberCreator().stream.map((i) =&gt; ‘String $i’),<br>  builder: (context, snapshot) {<br>    if (snapshot.connectionState == ConnectionState.waiting) {<br>      return const Text(‘No data yet.’);<br>  }<br>  throw UnimplementedError(“Case not handled yet”);<br>},</pre><pre>);</pre><p>You can check its connectionState property to see if the stream hasn’t yet sent any data, or if it’s completely finished.</p><pre>StreamBuilder&lt;String&gt;(<br>   stream: NumberCreator().stream.map((i) =&gt; &#39;String $i&#39;),<br>   builder: (context, snapshot) {<br>      if (snapshot.connectionState == ConnectionState.waiting) {      <br>        return const Text(&#39;No data yet.&#39;);<br>      } else if (snapshot.connectionState == ConnectionState.done){<br>        return const Text(&#39;Done!&#39;);<br>      }<br>      throw UnimplementedError(&quot;Case not handled yet&quot;);<br>    },<br> );</pre><p>You can use the hasError property to handle data values and see if the latest value is an error.</p><pre>StreamBuilder&lt;String&gt;(<br>  stream: NumberCreator().stream.map((i) =&gt; ‘String $i’),<br>  builder: (context, snapshot) {<br>    if (snapshot.connectionState == ConnectionState.waiting) {<br>      return const Text(‘No data yet.’);<br>    } else if (snapshot.connectionState == ConnectionState.done) {<br>      return const Text(‘Done!’);<br>    } else if (snapshot.hasError) {<br>      return const Text(‘Error!’);<br>    } else {<br>      return Text(snapshot.data ?? ‘’);<br>    } <br>  },<br>);</pre><p>The main thing is to make sure your builder knows how to handle all possible states of the stream. Once you’ve got that, it can react to whatever the stream does. (For more information, including a DartPad instance that you can play with, see the <a href=\"https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html\">StreamBuilder</a> API page.)</p><h3>Summary</h3><p>This article has covered what streams represent, how to get values from a stream, ways to manipulate those values, and how StreamBuilder helps you use stream values in a Flutter app.</p><p>You can learn more about streams from the Dart and Flutter documentation:</p><ul><li>On <a href=\"https://dart.dev/\">dart.dev</a>, see the <a href=\"https://dart.dev/tutorials/language/streams\">streams tutorial</a>, the <a href=\"https://dart.dev/tutorials/server/cmdline\">command-line app tutorial</a>, and the <a href=\"https://dart.dev/guides/libraries/library-tour#stream\">stream section</a> of the library tour.</li><li>On <a href=\"https://flutter.dev/\">flutter.dev</a>, see <a href=\"https://flutter.dev/docs/cookbook/networking/web-sockets\">Work with WebSockets</a>, which features an example that uses StreamBuilder.</li></ul><p><strong>Stay tuned</strong> for more articles coming in this series. Next up we’ll be talking about async and await. These are two keywords Dart offers to help you keep your asynchronous code concise and easy to read.</p><p>In the meantime you can <strong>watch the next video series</strong> on <em>Asynchronous Programming in Dart </em>our YouTube channel, or <strong>head over to our websites</strong> for more info on <a href=\"https://dart.dev/\">Dart</a> and <a href=\"https://flutter.dev/\">Flutter</a>.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FSmTCmDMi4BY%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DSmTCmDMi4BY&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FSmTCmDMi4BY%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/924c442a7c91b7366476ddd092178bfe/href\">https://medium.com/media/924c442a7c91b7366476ddd092178bfe/href</a></iframe><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/740/0*IGPMOenc2CSAeOFH.png\" /></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dab952023ed7\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-asynchronous-programming-streams-dab952023ed7\">Dart asynchronous programming: Streams</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-04-07T09:23:41.000Z":{"title":"Contributors for Google Summer of Code 2022","link":"https://medium.com/dartlang/contributors-for-google-summer-of-code-2022-17e777f043f0?source=rss----23738d481ce8---4","guid":"https://medium.com/p/17e777f043f0","category":["dartlang","google-summer-of-code","open-source","flutter"],"dc:creator":"Jonas Finnemann Jensen","pubDate":"Thu, 07 Apr 2022 09:23:41 GMT","atom:updated":"2022-04-07T09:23:41.356Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/406/1*YkWeEU6ii0k_DW0bmrD0Ig.png\" /></figure><p><a href=\"https://summerofcode.withgoogle.com/\">Google Summer of Code</a> (GSoC) is a global program focused on bringing student developers into open source software development. Students are sponsored by Google to work with a mentoring open source organization on a 12+ week programming project during the summer. Over the past 17 years, more than 18,000 students have participated in Google Summer of Code.</p><p>We’re excited to announce that Dart is a mentoring organization (for the third time!) in Google Summer of Code 2022. Check out the results posts to learn more about the great projects from <a href=\"https://medium.com/dartlang/google-summer-of-code-2020-results-a38cd072c9fe\">2020</a> and <a href=\"https://medium.com/dartlang/google-summer-of-code-2021-results-e514cce50fc\">2021</a>.</p><h4>Are you interested?</h4><p>Get started now by reading <a href=\"https://github.com/dart-lang/sdk/wiki/Dart-GSoC-2022-Project-Ideas\">the list of project ideas</a> to find a match for your skills and interests. Formal applications must be submitted before April 19th, but prospective applicants are encouraged to submit early drafts and ask for feedback.</p><blockquote>The Dart team expects to have enough mentors to accept only a handful of applications, so also check out the <a href=\"https://summerofcode.withgoogle.com/organizations/\">other mentoring organizations</a>.</blockquote><p>If you have questions specific to Dart and GSoC, ask them on <a href=\"https://groups.google.com/g/dart-gsoc\">our dedicated mailing list</a>.</p><p>For more information about Google Summer of Code, watch the video below. Or read the <a href=\"https://google.github.io/gsocguides/student/\">contributor guide for Google Summer of Code</a>.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FS6IP_6HG2QE%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DS6IP_6HG2QE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FS6IP_6HG2QE%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href\">https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href</a></iframe><p>We look forward to hearing from you!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=17e777f043f0\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/contributors-for-google-summer-of-code-2022-17e777f043f0\">Contributors for Google Summer of Code 2022</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-03-31T21:47:06.000Z":{"title":"Gradual null safety migration for large Dart projects","link":"https://medium.com/dartlang/gradual-null-safety-migration-for-large-dart-projects-85acb10b64a9?source=rss----23738d481ce8---4","guid":"https://medium.com/p/85acb10b64a9","category":["migration","flutter","dart","null-safety","flutter-app-development"],"dc:creator":"Polina C","pubDate":"Thu, 31 Mar 2022 21:47:06 GMT","atom:updated":"2022-05-15T23:33:48.335Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6-SfhIoFLl1NPaNi8Ld8Og.png\" /></figure><p><a href=\"https://dart.dev/null-safety/migration-guide\">Dart null-safety migration</a> is a 1-2 hour effort for a simple, small package but can be a months-long marathon for a large project. Ideally, you want to migrate your project gradually — during the marathon you want to keep your project growable, maintainable, and easy to release.</p><p>I’ve migrated a large project to null safety and decided to put together steps and tips on how to make the process reliable and efficient, with the hope that it saves you time.</p><h3>Step 1: Convert to unsound null-safety</h3><p>First, migrate your project to <a href=\"https://dart.dev/null-safety/unsound-null-safety\"><em>unsound</em> null safety</a>.</p><p>Start with upgrading your dependencies to null-safe versions. Unsound null safety doesn’t require having all dependencies to be null-safe. However, waiting until all of your upstream dependencies are migrated is strongly recommended since migrating a dependency might force you to revisit migration decisions in your own code. For packages that are mutually dependent, you might be forced to migrate out of order, or to migrate the packages concurrently (many packages that are mutually dependent mostly refer to each other only in tests). Follow <a href=\"https://dart.dev/null-safety/migration-guide#update-dependencies\">the guidance on dart.dev</a> to upgrade as many dependencies as you can before migrating your code.</p><p>Next, update the Dart SDK for your package and mark each non-migrated library as legacy using the following steps:</p><ol><li>Make sure that your IDE (VSCode, IntelliJ / Android Studio) has the Dart plugin installed.</li><li>Open your package in the IDE and make sure there are no compilation errors.</li><li>Update the dart_sdk dependency in the pubspec.yaml file to require the version range: ‘&gt;=2.12.0 &lt;3.0.0’.</li><li>The IDE will highlight null-safe related errors in libraries that are not yet null safe. Remove the errors by adding the comment ‘// @dart=2.9’ on the top of each affected file. Add the comment to your main.dart file even if it does not have errors, to keep the app running in unsound mode until you are ready to switch.</li><li>Verify that all tests pass, and submit the changes to your main branch. If your tests are already null-safe, you will need the command line flag --no-sound-null-safety to suppress null-safe errors.</li></ol><p>Make sure that you see Running with unsound null-safety in the console when starting the application.</p><p>Now you are ready to migrate your project to sound null safety one library at a time.</p><h3>Step 2: Iterate towards sound null-safety</h3><p>Choose a library or a set of libraries to migrate.</p><blockquote><strong>Pro tip</strong>: If the library you selected is large, you might want to break it into smaller libraries before migrating.</blockquote><p>Use dart pub deps to create a dependency graph of your project. It’s best to migrate packages from the bottom up; start with the leaves in the dependency tree and then iterate up to the root. However, if your project has dependency cycles, this might not be possible and it’s ok not to follow this order.</p><p>Migrate the library (or set of libraries) by <a href=\"https://dart.dev/null-safety/migration-guide\">using the migration tool</a>:</p><ol><li>Start the interactive migration tool by running dart migrate --skip-import-check. You may want to cd to the directory with the selected libraries to ease navigation in the tree.</li><li>Deselect everything by deselecting the roots of the file view tree in the left panel. (If interested, vote for a <a href=\"https://github.com/dart-lang/sdk/issues/48314\"><strong>Deselect All</strong> button</a>.)</li><li>Use Control+F to find the file(s) that you want to migrate.</li><li>Select the file(s) and click <strong>Apply Migration</strong>. There are two options how you can make adjustments: (1) use comments to adjust the tools’s choices before applying migration or (2) use an IDE to evaluate the nullability of fields, parameters, and variables after applying migration.</li><li>Open the package in the IDE. Fix errors, and search the files for cases where the tool might be inaccurate (see a list of potential issues below). Make corrections and use lint warnings to interactively clean up upstream and downstream code.</li></ol><p>You will not be able to fix two lint errors:</p><ol><li>import_of_legacy_library_into_null_safe (in migrated libraries)</li><li>avoid_redundant_argument_values (in legacy libraries)</li></ol><p>For now, disable these errors with comments. You’ll clean these up later, after migration is done.</p><p>What potential tool inaccuracies to watch for:</p><ol><li>Added types dynamic or num. Most likely you know which specific type should be used instead.</li><li>In most cases, bool? can become bool with a default value.</li><li>Type casts (search for ‘ as ‘) might mean that the tool didn’t add a generic type parameter. After adding it, a lint indicates that the cast has become unnecessary and can be removed.</li><li>In some cases, the tool makes the bound on a generic parameter nullable when it might be better to make it non-nullable (search for ?&gt; and ?,).</li><li>The tool might make things nullable that could be better expressed using late or late final, or that could be refactored to allow initialization in the constructor’s initializer list. (If interested, vote for a <a href=\"https://github.com/dart-lang/linter/issues/3267\">lint</a>.)</li><li>Using a null-assert operation ! without first checking for a null value might mean that the variable or parameter should actually be non-nullable. (If interested, vote for a <a href=\"https://github.com/dart-lang/linter/issues/3266\">lint</a>.)</li><li>The tool adds casting for collections in the form collection as Iterable&lt;TheType&gt;. Sometimes, this change just makes a cast explicit that was already implicit. However, in other cases, these casts might introduce <a href=\"https://stackoverflow.com/questions/72252891\">runtime errors</a> because of mismatches in the nullability of the generic arguments. If in doubt, consider replacing the cast with an explicit per element conversion (for example, collection.cast&lt;TheType&gt;()), or consider using <a href=\"https://pub.dev/documentation/collection/latest/collection/IterableNullableExtension/whereNotNull.html\">the </a><a href=\"https://pub.dev/documentation/collection/latest/collection/IterableNullableExtension/whereNotNull.html\">whereNotNull extension method from </a><a href=\"https://pub.dev/documentation/collection/latest/collection/IterableNullableExtension/whereNotNull.html\">package:collection</a>.</li><li>If a variable, field, or parameter is nullable, but the nullability is used only in the tests, perhaps the code should be refactored to remove nullability for that identifier.</li></ol><p>(Thanks to <a href=\"https://github.com/kenzieschmoll\">Kenzie Davisson</a>, who helped me identify these cases.)</p><h3>Step 3: Cleanup</h3><p>After migrating all of your libraries, do some final cleanup:</p><ol><li>Clean up the disabling comments for the lints.</li><li>Upgrade the remaining dependencies to null safe versions.</li><li>Ensure that there are no `//@dart = 2.9` comments remaining in your app. At this point, you should see Running with sound null-safety in the console when starting the app. If you don’t see this, you either have libraries that aren’t yet migrated (search for `// @dart = 2.9`), or a dependency that has not been migrated.</li><li>Ensure that the app still runs correctly and that the tests pass. Since sound mode enables stronger runtime guarantees, it’s possible (though unlikely) that you will see new runtime errors which you need to fix when you enable sound null safety. Usually this is the result of casting a nullable collection (like List&lt;int?&gt;) to a non-nullable collection type (like List&lt;int&gt;).</li></ol><p>Have a happy migration!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=85acb10b64a9\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/gradual-null-safety-migration-for-large-dart-projects-85acb10b64a9\">Gradual null safety migration for large Dart projects</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-03-16T16:03:25.000Z":{"title":"Hosting a private Dart package repository","link":"https://medium.com/dartlang/hosting-a-private-dart-package-repository-774c3c51dff9?source=rss----23738d481ce8---4","guid":"https://medium.com/p/774c3c51dff9","category":["jfrog-artifactory","cloudsmith","package-repository","dart"],"dc:creator":"Jonas Finnemann Jensen","pubDate":"Wed, 16 Mar 2022 16:03:25 GMT","atom:updated":"2022-03-17T10:30:26.573Z","content:encoded":"<h4>Improvements in Dart 2.15 for secure enterprise package hosting</h4><p>Our recent Dart 2.15 release added support for private package repositories. A package repository is a server that hosts Dart packages for consumption by the dart pub client. This post discusses how to use private package repositories alongside <a href=\"https://pub.dev\">pub.dev</a>, leveraging the new token authentication mechanism introduced in Dart 2.15.</p><p>This feature has already been adopted by <a href=\"https://help.cloudsmith.io/docs/dart-repository\">Cloudsmith</a> and <a href=\"https://jfrog.com/blog/how-to-use-pub-repositories-in-artifactory/\">JFrog Artifactory</a> who offer custom package repositories as a service:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/800/1*-xVF9afKxXP0_RTKs1pyxA.png\" /><figcaption>Private Dart repositories are now offered by both Cloudsmith and JFrog Artifactory.</figcaption></figure><h3>Why use a custom package repository?</h3><p>The default package repository, <a href=\"https://pub.dev\">pub.dev</a>, is operated by the Dart team. It facilitates publication of Dart packages for public use, and allows any Dart developer to consume those packages simply by adding the name of the package to their pubspec file. This enables a rich collection of Dart packages to be created by an active ecosystem. However, a custom package repository might be useful in the following scenarios:</p><ol><li>Sharing private packages within an organization. This could be an organization looking to share internal proprietary packages among the members of the organization, and not with the general public.</li><li>Tight control of dependencies in enterprise environments. Some corporations want to explicitly create allow-lists for specific <em>package versions</em> approved for usage. This might be done to enforce code review policies or license compliance.</li><li>Secure environments without public internet access. Some organizations operate in a regulatory environment where connections to the public internet, and by extension <a href=\"https://pub.dev\">pub.dev</a>, are not allowed. This typically applies to government agencies/contractors and some banking service providers.</li></ol><p>Organizations that just need to share a few proprietary packages (scenario 1) might use <a href=\"https://dart.dev/tools/pub/dependencies#git-packages\">git-dependencies</a>. This is a powerful mechanism because thedart pub client command invokes the git client for cloning git-dependencies — this way you might authenticate cloning a dependency using your SSH key, and manage permissions using GitHub/GitLab teams. With <a href=\"https://www.yubico.com/blog/github-now-supports-ssh-security-keys/\">GitHub support for SSH using Yubikeys</a> this setup works well in some cases.</p><p>However, git-dependencies in dart pub have some limitations when it comes to version solving. When using a git-dependency, dart pub just clones the tag / branch / ref specified in pubspec.yaml, because there is no mechanism for trying multiple versions of the dependency. Thus, using a private custom package repository can be attractive because a custom package repository can supply the dart pub client with a list of versions, allowing the <a href=\"https://nex3.medium.com/pubgrub-2fb6470504f&#39;\">version solver</a> to pick a compatible version and avoid conflicts. It also makes it easy to upgrade both private and public dependencies using dart pub outdated and dart pub upgrade --major-versions.</p><p>Git dependencies doesn’t support organizations looking for <em>tighter control around dependencies</em> (scenario 2) or using <em>a secure environment without internet access</em> (scenario 3), as a lot of packages have to be mirrored. In these scenarios it’s almost always preferable to simply have a custom package repository mirroring an allow-listed subset of <a href=\"https://pub.dev\">pub.dev</a>.</p><h3>Using a custom package repository</h3><p>Starting with Dart 2.15, you can depend on a package from a custom package repository using the <em>short-form hosted dependency</em> syntax:</p><pre>dependencies:<br>  foo:<br>    hosted: https://dart-packages.example.com<br>    version: ^1.4.0<br>environment: <br>  sdk: &gt;=2.15.0 &lt;3.0.0</pre><p>The short-form syntax requires an SDK constraint &gt;=2.15.0, because older versions of the Dart SDK don’t support this syntax. If you don’t want to worry about syntax, you can also just use the dart pub add command to add a dependency from a custom package repository:</p><pre>$ dart pub add foo --hosted https://dart-packages.example.com<br>Resolving dependencies... <br>+ foo 1.4.0<br>Changed 1 dependency!</pre><p>Using the hosted-dependency syntax, it’s possible to mix dependencies from custom package repositories with dependencies from the official package repository. The following example depends on package foo from the dart-packages.example.com repository, and package retry from pub.dev:</p><pre>dependencies:<br>  retry: ^3.0.0<br>  foo:<br>    hosted: https://dart-packages.example.com<br>    version: ^1.4.0<br>environment: <br>  sdk: &gt;=2.15.0 &lt;3.0.0</pre><p>This is useful when sharing private packages using a custom package repository (scenario 1). But for <em>tighter control of dependencies</em> (scenario 2) or working in <em>a secure environment without internet access</em> (scenario 3), it might be preferable to override the default package repository.</p><h4>Overriding the default package repository</h4><p>By default, dart pub get fetches dependencies from pub.dev unless the hosted-dependency syntax is used to specify a custom package repository. However, it’s possible to override the <em>default package repository</em> using the environment variable PUB_HOSTED_URL. This approach is particularly useful when mirroring a subset of pub.dev (scenario 2 or 3), as there is no need to update the pubspec.yaml file to reference the custom package repository URL. For example, it’s sufficient to write the following:</p><pre>dependencies:<br>  retry: ^3.0.0<br>  foo: ^1.0.0</pre><p>If allow-listed versions of packages retry and foo are copied to the custom package repository, and the environment variable PUB_HOSTED_URL points to the custom package repository URL, pub get can work as follows:</p><pre>$ export PUB_HOSTED_URL=https://dart-packages.example.com<br>$ dart pub get<br>Resolving dependencies... <br>+ retry 3.1.0<br>+ foo 1.4.0<br>Changed 2 dependencies!</pre><p>This works best when the build server sits behind a corporate firewall that disallows outgoing network connections in order to avoid accidental injection attacks when someone forgets to set PUB_HOSTED_URL. Similarly, it’s also advisable to set publish_to: &lt;hosted-url&gt; in pubspec.yaml to avoid accidental publishing to pub.dev (when PUB_HOSTED_URL isn’t defined).</p><h4>Authentication against custom package repositories</h4><p>Most custom package repositories are likely to be private package repositories that require authentication. Dart 2.15 introduced the <a href=\"https://dart.dev/tools/pub/cmd/pub-token\">dart pub token</a> command for managing authentication tokens. Requests to a custom package repository are authenticated using a secret token. You obtain the secret token from your custom package repository and pass it to dart pub token add &lt;hosted-url&gt;, which prompts for the token as shown below:</p><pre>$ dart pub token add https://dart-packages.example.com<br>Enter secret token: [enter secret token]<br>Requests to &quot;dart-packages.example.com&quot; will now be authenticated using the secret token.</pre><h4>Authentication from CI environments</h4><p>When running in CI it’s often possible to <a href=\"https://docs.github.com/en/actions/security-guides/encrypted-secrets#about-encrypted-secrets\">store secrets in environment variables</a>, and while it’s possible to pass secrets using echo $TOKEN | dart pub token add &lt;hosted-url&gt;, it’s also possible to tell dart pub to read a secret from an environment variable when talking to a specific custom repository:</p><pre>$ dart pub token add https://dart-packages.example.com --env-var MY_SECRET_TOKEN<br>Requests to &quot;https://dart-packages.example.com&quot; will now be authenticated using the secret token stored in the environment variable &quot;MY_SECRET_TOKEN&quot;.</pre><p>This ensures that dart pub doesn’t actually store the secret in its configuration file, instead it merely stores the fact that it should read the secret from the environment variable $MY_SECRET_TOKEN. This allows secrets to only be stored in environment variables when operating in a CI environment, and reduces the risk that secrets are accidentally leaked if the execution environment is shared between CI jobs.</p><h3>Publishing to custom package repositories</h3><p>To publish a package to a custom package repository, you specify publish_to: &lt;hosted-url&gt; in pubspec.yaml, and run dart pub publish. This uses the same token for authentication as is used by dart pub get. At a minimum, your pubspec.yaml file should look something like the following:</p><pre>name: mypkg<br>version: 1.0.0<br>publish_to: https://dart-packages.example.com<br>dependencies:<br>  meta: ^1.7.0<br>environment:<br>  sdk: &gt;=2.15.0 &lt;3.0.0</pre><p>When running dart pub publish it is important to review the information given. Before confirming the publishing action you should always do the following:</p><ul><li>Check the URL where the package will be published.</li><li>Review the list of files to be included in the package.</li><li>Consider the package validation recommendations. For example:</li></ul><pre>$ dart pub publish<br>Publishing mypkg 1.0.0 to https://dart-packages.example.com<br>|-- CHANGELOG.md<br>|-- LICENSE<br>|-- README.md<br>|-- lib<br>|   &#39;-- mypkg.dart<br>&#39;-- pubspec.yaml<br>Package validation found the following potential issue:<br>* It&#39;s strongly recommended to include a &quot;homepage&quot; or &quot;repository&quot; field in your pubspec.yaml<br>...</pre><p>For publishing to custom repositories the recommendations <em>might not</em> be important, but providing metadata for a package is often useful. On pub.dev, packages with proper metadata and documentation score more <a href=\"https://pub.dev/help/scoring\">pub points</a>.</p><p>It’s possible to publish to custom repositories by overriding the <em>default package repository</em> using the environment variable PUB_HOSTED_URL but, if you do this, it’s strongly recommended that you specify publish_to: &lt;hosted-url&gt; in your pubspec.yaml file; this prevents you from accidentally publishing your proprietary packages to the public repository. And if you don’t want to publish your proprietary packages to <em>any</em> package repository, specify publish_to: none to prevent accidental publication.</p><h3>Get a Custom Package Repository</h3><p>As previously mentioned, custom package repositories are available as a service from multiple commercial vendors, alleviating you from the overhead of hosting and maintaining your own custom package repository.</p><h4>Token authentication in Cloudsmith</h4><p>Cloudsmith has been offering private and public Dart package repositories since 2020. <a href=\"https://cloudsmith.com/resources/blog/improvements-to-dart-package-support\">Cloudsmith recently announced</a> support for token authentication with their Dart package repository offering. For more information, check out the <a href=\"https://help.cloudsmith.io/docs/dart-repository\">Cloudsmith documentation</a>.</p><figure><a href=\"https://help.cloudsmith.io/docs/dart-repository\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/454/1*hv1Nujq4-g2-y2uLuLYVqA.png\" /></a><figcaption>A private Dart package repository hosted by Cloudsmith.</figcaption></figure><h4>Dart support in JFrog Artifactory</h4><p>JFrog Artifactory recently <a href=\"https://jfrog.com/blog/how-to-use-pub-repositories-in-artifactory\">announced support for custom Dart package repositories</a>, including support for layered repositories and mirroring packages from the public package repository on <a href=\"https://pub.com\">pub.dev</a>. For more information, check out the <a href=\"https://www.jfrog.com/confluence/display/JFROG/Pub+Repositories\">JFrog Artifactory documentation</a>.</p><figure><a href=\"https://www.jfrog.com/confluence/display/JFROG/Pub+Repositories\"><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/454/1*JeK8mYxYCn-XoeHUCJlPEg.png\" /></a><figcaption>A custom Dart package repository managed by JFrog.</figcaption></figure><h4>Closing comments</h4><p>For those who would like to write their own custom package repository, we’ve published a <a href=\"https://github.com/dart-lang/pub/blob/master/doc/repository-spec-v2.md\">specification for serving Dart package repositories</a>. It’s fairly simple, but feel free to open issues on the <a href=\"https://github.com/dart-lang/pub-dev/issues\">pub.dev repository</a> if aspects are unclear, or if you have any suggestions for improvements.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=774c3c51dff9\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/hosting-a-private-dart-package-repository-774c3c51dff9\">Hosting a private Dart package repository</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-08-30T18:21:05.000Z":{"title":"Dart 2.18: Objective-C & Swift interop","link":"https://medium.com/dartlang/dart-2-18-f4b3101f146c?source=rss----23738d481ce8---4","guid":"https://medium.com/p/f4b3101f146c","category":["null-safety","interop","announcements","dart"],"dc:creator":"Michael Thomsen","pubDate":"Tue, 30 Aug 2022 18:21:05 GMT","atom:updated":"2022-08-30T18:21:04.704Z","content:encoded":"<h4>Enhanced interoperability, platform-specific networking, improved type inference, and an important update on our null safety language roadmap</h4><p><em>Dart 2.18 is available today. This release features a preview of Objective-C &amp; Swift interoperability and a new iOS/macOS networking package built on top of this interop. It also contains improved type inference for generic functions, performance improvements to async code, new pub.dev features, and cleanup of our tools and core libraries.</em></p><p><em>Finally, we have the latest null safety migration status numbers and an important roadmap update on our path towards a fully null safe Dart. Please read to the end!</em></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*byFoNx1wnEaO0S6N\" /></figure><h3>Introducing Dart to Objective-C &amp; Swift interop</h3><p>We previewed the Dart foreign function interface (FFI) for calling native C APIs in 2020 and released it in Dart 2.12 in March 2021. Since that release, a large selection of packages have taken advantage of this feature to integrate with existing native C APIs. A few examples include <a href=\"https://pub.dev/packages/file_picker\">file_picker</a>, <a href=\"https://pub.dev/packages/printing\">printing</a>, <a href=\"https://pub.dev/packages/win32\">win32</a>, <a href=\"https://pub.dev/packages/objectbox\">objectbox</a>, <a href=\"https://pub.dev/packages/realm\">realm</a>, <a href=\"https://pub.dev/packages/isar\">isar</a>, <a href=\"https://pub.dev/packages/tflite_flutter\">tflite_flutter</a>, and <a href=\"https://pub.dev/packages/dbus\">dbus</a>.</p><p>The Dart team wants Dart to support interoperability with all the primary languages on the platforms where Dart runs. Dart 2.18 meets the next milestone toward that goal. Your Dart code can call Objective-C and Swift code, as typically used for APIs on the macOS and iOS platforms. Dart supports this interop mechanism in any app from the CLI app to backend code to a Flutter UI.</p><p>This new mechanism utilizes the fact that Objective-C and Swift code can be exposed as C code based on API bindings. The Dart API wrapper generation tool, <a href=\"https://pub.dev/packages/ffigen\">ffigen</a>, can create these bindings from API headers. Let’s take a look at an example.</p><h3>Time Zone example using Objective-C</h3><p>macOS has an API for querying time zones information exposed on the <a href=\"https://developer.apple.com/documentation/foundation/nstimezone?language=objc]\">NSTimeZone class</a>. You can query this API for the time zone and <a href=\"https://www.w3.org/International/core/2005/09/timezone.html#:~:text=What%20is%20a%20%22zone%20offset,or%20%22%2D%22%20from%20UTC.\">UTC time zone offset</a> that the user has configured for their device.</p><p>The following example Objective-C app uses this timezone API to get the system time zone and the GMT offset:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ef61d2b1be6fec154cb754b81df23efd/href\">https://medium.com/media/ef61d2b1be6fec154cb754b81df23efd/href</a></iframe><p>The app imports Foundation.h, which contains the API headers for the Apple Foundation library. Next, inside the main method, it calls the systemTimeZone method from the NSTimeZone class. This method returns an NSTimeZone instance with the selected time zone on the device. Finally, the app outputs two lines to the console containing the name of the time zone and the UTC offset in hours.</p><p>If you run this app, it should return something resembling the following, depending on your location:</p><pre>Timezone name: Europe/Copenhagen<br>Timezone offset GMT: 2 hours</pre><h3>Time Zone example using Using Dart</h3><p>Let’s replicate this result with Dart using the new Objective-C interop.</p><p>First create a new Dart CLI app:</p><pre>$ dart create timezones</pre><p>Then edit your pubspec file to contain the ffigen configuration. This configuration points to the header file and lists which Objective-C interfaces should generate wrappers:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e141b727eb67254416b12f761a2541ea/href\">https://medium.com/media/e141b727eb67254416b12f761a2541ea/href</a></iframe><p>This selects Objective-C bindings for the headers in NSTimeZone.h and includes just the APIs in the NSTimeZone interface. To generate the wrappers, run ffigen:</p><pre>$ dart run ffigen</pre><p>This command creates a new file, foundation_bindings.dart, that contains a bunch of generated API bindings. Using this binding file, we can write our Dart main method. This method mirrors the Objective-C code:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/fcabe4d8611fcf5c13288ab24c2d2cf0/href\">https://medium.com/media/fcabe4d8611fcf5c13288ab24c2d2cf0/href</a></iframe><p>That’s it! This new support is available in an experimental state starting with today’s Dart 2.18. This boosts Dart’s general interop support to call macOS and iOS APIs directly. This, in turn, supplements Flutter’s plugins, with new support that works in any Dart app, and that allows you to call macOS and iOS APIs directly from Dart code.</p><p>We welcome your feedback. Let us know what worked, what might be changed, or what problems you experienced by commenting in the <a href=\"https://github.com/dart-lang/sdk/issues/49673\">feedback issue</a> on GitHub. To learn more about this interoperability, see the <a href=\"https://dart.dev/guides/libraries/objective-c-interop\">Objective-C and Swift interoperability guide</a>.</p><h3>Platform-specific http libraries</h3><p>Dart includes a general, multi-platform http library. This library allows you to write code without concern for platform specifics. On occasion, you might want to write code specific to a particular host platform’s networking APIs.</p><p>For example, Apple’s networking library <a href=\"https://developer.apple.com/documentation/foundation/nsurlsession\">NSURLSession</a> allows specifying WiFi-only networking or that it requires a VPN. To support these use cases, we’ve created a new networking package intended for the macOS and iOS platforms, <a href=\"https://pub.dev/packages/cupertino_http\">cupertino_http</a>. This builds on the new Objective-C interop mentioned in the previous section. It uses a large set of API wrappers <a href=\"https://github.com/dart-lang/http/blob/master/pkgs/cupertino_http/ffigen.yaml\">generated</a> from Apple’s networking APIs in Foundation.</p><h3>Cupertino http library example</h3><p>The following example sets a Flutter app’s http client to use the cupertino_http library on macOS and iOS and Dart’s regular http library from dart:io on other platforms:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/c5b78357f8d02897d6f62881f94496d0/href\">https://medium.com/media/c5b78357f8d02897d6f62881f94496d0/href</a></iframe><p>After this initial configuration, the app makes any subsequent networking calls on the specific client. For example, an http get() request now resembles this:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/f29598f412d315b09cb2dc3ecfaa9bb2/href\">https://medium.com/media/f29598f412d315b09cb2dc3ecfaa9bb2/href</a></iframe><p>When you cannot use the common client interface, you can call Apple’s networking APIs directly using the cupertino_http library:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/1f7339c1448fce84f5837bb3bca0f1a8/href\">https://medium.com/media/1f7339c1448fce84f5837bb3bca0f1a8/href</a></iframe><h3>Platform-specific networking in multi-platform apps</h3><p>As we designed this feature, the goal remained to keep apps as multi-platform as possible. To meet this goal, we kept our general multi-platform http API set for basic http operations, and allowed for configuring per-platform which networking library to use. You can minimize the amount of platform-specific code that you need to write by using the <a href=\"https://pub.dev/documentation/http/latest/http/Client-class.html\">package:http Client API</a>. This API can be configured per-platform but used in a platform-independent manner.</p><p>Dart 2.18 offers experimental support of two platform-specific http libraries that support the package:http <a href=\"https://pub.dev/documentation/http/latest/http/Client-class.html\">Client API</a>:</p><ul><li><a href=\"https://pub.dev/packages/cupertino_http\">cupertino_http</a> based on <a href=\"https://developer.apple.com/documentation/foundation/nsurlsession\">NSURLSession</a> for macOS/iOS.</li><li><a href=\"https://pub.dev/packages/cronet_http\">cronet_http</a> based on <a href=\"https://developer.android.com/guide/topics/connectivity/cronet\">Cronet</a>, the networking library popular on Android.</li></ul><p>Combining a common client API with several HTTP implementations gives you the best of both worlds. You can get platform-specific behavior while still maintaining your apps from a single set of shared sources for all your platforms. We’d love to hear your feedback on this <a href=\"https://github.com/dart-lang/http/issues/764\">GitHub issue</a>.</p><h3>Improved type inference</h3><p>Dart uses many generic functions. Consider the <a href=\"https://api.dart.dev/stable/2.17.6/dart-core/Iterable/fold.html\">fold</a> method, which reduces a collection of elements to a single value. The following example calculates the sum of a list of integers:</p><pre>List&lt;int&gt; numbers = [1, 2, 3];<br>final sum = numbers.fold(0, (x, y) =&gt; x + y);<br>print(‘The sum of $numbers is $sum’);</pre><p>With Dart 2.17 or earlier, this method returns a type error:</p><pre>line 2 • The operator ‘+’ can’t be unconditionally invoked because the receiver can be ‘null’.</pre><p>Dart’s type inference couldn’t flow information between the arguments. This resulted in uncertainty of the type of x. To remedy the potential error, you needed to specify the type:</p><pre>final sum = numbers.fold(0, (int x, int y) =&gt; x + y);</pre><p>Dart 2.18 improves type inference. The previous example passes static analysis and can infer that both x and y are non-nullable ints. This change allows you to write more concise Dart code while retaining the full soundness properties of the strongly inferred types.</p><h3>Async performance improvements</h3><p>This version of Dart improves how the Dart VM applies the async method and the async*/sync* generator functions. This reduces code size. On two large internal Google apps, we saw a reduction of the AOT snapshot size of around 10%. We also saw a performance increase across our microbenchmarks.</p><p>These changes include additional small behavior changes; to learn more, see <a href=\"https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md#dart-vm\">the changelog</a>.</p><h3>pub.dev improvements</h3><p>In conjunction with the 2.18 release, we’ve made two changes on the pub.dev package repository.</p><p>Individuals often maintain packages published on pub.dev in their spare time. This can be costly, both in terms of time and finances. To facilitate sponsorships we now support a new funding tag in the pubspec, which can be used by package publishers to list links to one or more ways of sponsoring the package. These links are then shown on pub.dev in the sidebar:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/420/0*FteRd2cVBg3Zq7JO\" /></figure><p>To learn more, see the <a href=\"https://dart.dev/tools/pub/pubspec#funding\">pubspec documentation</a>.</p><p>Furthermore, we’d like to encourage a rich ecosystem of open source packages. To highlight this, the automated package scoring on pub.dev awards an additional 10 points for packages that use an <a href=\"https://opensource.org/licenses\">OSI approved license</a>.</p><h3>A few breaking changes</h3><p>Dart has a strong focus on simplicity and learnability. We’re constantly trying to keep a careful balance when adding new capabilities. One method to keep things simple is to remove historic functionality and APIs with little use or better replacements. Dart 2.18 cleans up items in this category, including a few smaller breaking changes:</p><ul><li>We added the unified dart CLI developer tool back in October 2020. In 2.18, we completed the transition. This release removes the last two deprecated tools dart2js (use dart compile js) and dartanalyzer (use dart analyze).</li><li>With the introduction of language versioning, pub generates a new resolution file: .dart_tool/package_config.json. The previous file, .packages, used a format that couldn’t contain versions. We discontinued using the .packages file. If you have any .packages files, you can delete them.</li><li>Mixins of classes that don’t extend Object can’t be used (breaking change <a href=\"https://github.com/dart-lang/sdk/issues/48167\">#48167</a>). This behavior was never intended.</li><li>The uri property of dart:io’s RedirectException has been changed to nullable (breaking change <a href=\"https://github.com/dart-lang/sdk/issues/49045\">#49045</a>).</li><li>Constants in dart:io’s networking APIs following the SCREAMING_SNAKE convention have been removed (breaking change <a href=\"https://github.com/dart-lang/sdk/issues/34218\">#34218</a>; previously deprecated). Use the corresponding lowerCamelCase constants instead.</li><li>The Dart VM no longer restores the initial terminal settings upon exit. Programs that change the Stdin settings lineMode and echoMode are now responsible for restoring the settings upon program exit (breaking change <a href=\"https://github.com/dart-lang/sdk/issues/45630\">#45630</a>).</li></ul><h3>Null safety update</h3><p>We’re very pleased to see the wide usage of null safety since its beta release in November 2020 and the <a href=\"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87\">Dart 2.12</a> release in March 2021.</p><p>First, app developers of most all the popular packages on pub.dev migrated to null safety. Analysis shows that 100% of the top-250 and 98% of the top-1,000 most used packages support null safety.</p><p>Second, most app developers work in codebases with full null safety migration. This is crucial. Dart’s full <a href=\"https://dart.dev/null-safety/understanding-null-safety\">sound null safety</a> doesn’t kick in until you migrate all code and all dependencies (including transitive). We’re tracking this via telemetry from flutter run commands.</p><p>The following graph shows the unsound vs. sound null safety executions of flutter run. Before the introduction of null safety, there were none of either. A rapid growth of unsound null safety followed. As apps started migrating to null safety, the developers made a partial migration. Some parts still needed to be migrated. Over time, we see a very healthy growth of sound null safety sessions. By the end of last month, there were four times more sound null safety sessions compared to unsound ones. We hope that, over the next few quarters, we’ll see the sound null safety approach 100%!</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/0*emVp4pmfOhLhiBJ4\" /></figure><h3>An important null safety roadmap update</h3><p>Supporting both unsound and sound null safety adds overhead and complexity.</p><p>First, Dart developers need to learn and understand both modes. Whenever reading a piece of Dart code, check the <a href=\"https://dart.dev/guides/language/evolution#language-versioning\">language version</a> to see if types are non-null by default (Dart 2.12 and later) or nullable by default (Dart 2.11 and earlier).</p><p>Second, supporting both modes in our compilers and runtimes slows down evolving the Dart SDK to support new features.</p><p><strong><em>Based on the overhead of unsound null safety and the very positive adoption numbers mentioned in the previous section, it’s our aim to transition to only supporting sound null safety and discontinue non-null safety and unsound null safety modes. We’ve tentatively slated this for release by mid-2023.</em></strong></p><p>This would mean that discontinuing support for Dart 2.11 and earlier. Pubspec files with an SDK constraint having a lower bound of less than 2.12 would no longer resolve in Dart 3 and later. In source code containing language markers, those would fail if set to less than 2.12 (such as// @dart=2.9).</p><p>If you’ve migrated to sound null safety, your code will work with full null safety in Dart 3. If you haven’t, please migrate now! To learn more about these changes, see <a href=\"https://github.com/dart-lang/sdk/issues/49530\">this GitHub issue</a>.</p><h3>Summary</h3><p>The new support for interop, networking, type inference, and pub.dev is available today. To get started, you can directly download the <a href=\"https://dart.dev/get-dart\">Dart 2.18 release</a>, or get it embedded as part of today’s <a href=\"https://medium.com/flutter/announcing-flutter-3-3-at-flutter-vikings-6f213e068793\">Flutter 3.3</a> SDK release.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f4b3101f146c\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-2-18-f4b3101f146c\">Dart 2.18: Objective-C &amp; Swift interop</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-07-13T18:44:39.000Z":{"title":"Quick assists for editing","link":"https://medium.com/dartlang/quick-assists-for-editing-453f051fb28c?source=rss----23738d481ce8---4","guid":"https://medium.com/p/453f051fb28c","category":["dartlang","analyzer","dart","linter"],"dc:creator":"Brian Wilkerson","pubDate":"Wed, 13 Jul 2022 18:44:39 GMT","atom:updated":"2022-07-13T18:44:39.631Z","content:encoded":"<p>Do you spend too much time performing repetitive tasks while coding? If so, then I have some good news for you. Many of the repetitive tasks can be performed automatically using a feature we call quick assists.</p><p>A <em>quick assist</em> is an automated edit targeted at making a common change to the code. Unlike a quick fix, which we looked at in <a href=\"https://medium.com/dartlang/quick-fixes-for-analysis-issues-c10df084971a\">Quick fixes for analysis issues</a> and <a href=\"https://medium.com/dartlang/bulk-application-of-fixes-e6add333c3c1\">Bulk application of fixes</a>, the presence of a quick assist isn’t a suggestion that you should change your code, it’s simply there to make your work easier.</p><p>Let’s look at a couple of examples.</p><h3>Declaring local variables</h3><p>You likely spend a fair bit of time declaring and initializing local variables. The tools can help with some of that. If you type the initializer expression then you can use a quick assist to create a local variable to capture the value of the expression.</p><p>If you start with the code below and place the cursor anywhere in the expression, then the lightbulb icon appears near the left edge of the editor. If you hover over it you can then click to open a menu containing the available quick assists.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/622/0*V2JRi49yUj_MkFjS\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/586/0*SH7NIMTeCdgyE2Uf\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><p>Choosing the assist inserts a variable declaration, using the expression as the initializer, and selects the name of the variable so that you can either choose one of the suggested names or type your own name:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/546/0*zkIBfG56juJk2AuT\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/532/0*jfAvjus6m7-TCP4S\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><p>Pressing the enter/return key accepts the entered name.</p><h3>Function body styles</h3><p>If you frequently use expression bodied functions, then you’ve likely needed to convert one into a block bodied function at some point. There’s an assist for that too. For example, if you have code like the following and you place the cursor inside the arrow, you’ll see the following options:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/974/0*hp1u0YSRQsoNMaJl\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/922/0*Ca5bRUzZ-Y4dHkw2\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><p>Selecting “Convert to block body” rewrites the function body to look like this:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/658/0*mU7Y97eTeCILB1sr\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/568/0*miez1wvKHge96Ggl\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><p>And, yes, there’s another assist that converts from a block body to an expression body.</p><h3>Rewriting if statements</h3><p>Assists can also help with bigger restructurings. If you’ve ever written code structured like this:</p><pre>void f(int a, int b, int c, int d) {<br>  if (a == b) {<br>    if (a == c || a == d) {<br>      print(0);<br>    }<br>  }<br>}</pre><p>and realized that you could combine the two conditions, there’s an assist for that. Put the cursor on the inner if and open the menu:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/734/0*6C745jOIAaB-k0f-\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/698/0*9mRjNGVqm82qAeg0\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><p>Selecting “Join ‘if’ statement with outer ‘if’ statement” rewrites the code to look like this:</p><pre>void f(int a, int b, int c, int d) {<br>  if (a == b &amp;&amp; (a == c || a == d)) {<br>    print(0);<br>  }<br>}</pre><p>The assist also shows up if you put the cursor on the outer if, though the menu then reads “Join ‘if’ statement with inner ‘if’ statement”.</p><h3>Using newer language features</h3><p>There are also assists to help you convert to newer language features. For example, if you have a class like this:</p><pre>class A {<br>  A({int? x, int? y});<br>}</pre><pre>class B extends A {<br>  B({int? x, int? y}) : super(x: x, y: y);<br>}</pre><p>where the constructor in the subclass passes some parameters to the superclass without modifying them, there’s a cleaner way to write the code. Put the cursor on the name of the constructor B and open the menu:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/740/0*PGLOLXQPGGTZFTCE\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/668/0*pfrf--11lE_B1oTf\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><p>Selecting “Convert to using super parameters” rewrites the code to look like this:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/484/0*Lr2HLGu31CqL5JLd\" /><figcaption><a href=\"https://code.visualstudio.com/\">Visual Studio Code</a></figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/386/0*nHsQKP9Wtm1UZn6-\" /><figcaption><a href=\"https://www.jetbrains.com/idea/\">IntelliJ IDEA</a></figcaption></figure><p>There are more assists available than we can cover in a single article. The next time you find yourself about to perform an edit that you do all the time, check out the context actions to see whether there’s an assist to make the task easier.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=453f051fb28c\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/quick-assists-for-editing-453f051fb28c\">Quick assists for editing</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-11-03T22:01:47.000Z":{"title":"Google Summer of Code 2022 Results","link":"https://medium.com/dartlang/google-summer-of-code-2022-results-a3ce1c13c06c?source=rss----23738d481ce8---4","guid":"https://medium.com/p/a3ce1c13c06c","category":["google-summer-of-code","flutter","dartlang","open-source"],"dc:creator":"Jonas Finnemann Jensen","pubDate":"Thu, 03 Nov 2022 22:01:47 GMT","atom:updated":"2022-11-15T12:48:14.829Z","content:encoded":"<p>The <a href=\"https://summerofcode.withgoogle.com/\">Google Summer of Code</a> (GSoC) program focuses on engaging new developers worldwide with open source software development. Google sponsors students to work with a mentoring open source organization on a 12-week programming project during the summer. Over the past 17 years, more than 18,000 contributors have participated in Google Summer of Code.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/674/1*tzmsHv4_tAl7Nil6XZaANw.png\" /></figure><p>In 2022, Dart have participated as mentoring organization in Google Summer of Code for a third consecutive year. Following our <a href=\"https://medium.com/dartlang/contributors-for-google-summer-of-code-2022-17e777f043f0\">call for proposals in March</a>, we received 50 project proposals from prospective participants around the world. Today, we spotlight some of the projects we mentored this summer. The contributors describe their projects in this post.</p><h3>JNI Interop for Dart</h3><p><em>By Mahesh Hegde</em></p><p>Android platform uses Java as its official language. To access its rich ecosystem would add great value to Dart, so I developed a Java Native Interface (JNI) interop for Dart as my GSoC project.</p><p><a href=\"https://pub.dev/packages/jnigen\"><em>package:jnigen</em></a> generates bindings to enable using Java classes and methods from Dart. jnigen generates C bindings that wrap Java libraries, and Dart bindings that call those C bindings. The support library <a href=\"https://pub.dev/packages/jni\">package:jni</a> provides the common functions to initialize and access JNI<em>.</em></p><p>In considering the complexity of both Java and JNI, JNI interop for Dart remains experimental. The interop can wrap basic features of the Java language, such as constructors, static and instance methods and field getters. Exceptions in Java get “rethrown” in Dart along with original stack traces. The interop cannot subclass a Java class from Dart or pass callbacks. After GSoC, we plan to improve the binding generation pipeline and implement more Java language features.</p><p>The technical complexity of the project proved challenging. We knew there hadn’t been any Java interop attempt for a natively-compiled, high-level language using JNI. We often had to find workarounds when something didn’t work as expected, like dynamic library loading and JNI exceptions. I ended up writing several tools to aid the project. These included one to get Java sources from maven and another to build shared libraries. I learned a lot about time management, prioritization, testing, and writing neat, readable and understandable code.</p><h3>Flutter Community admin dashboard</h3><p><em>By Abdelrahman Amer</em></p><p>For GSoC’22, I designed and built an <a href=\"https://github.com/fluttercommunity/admin_dashboard\">admin dashboard for Flutter Community repositories on GitHub</a>. The dashboard assists Flutter Community admins through aggregating the latest activities on repositories, maintainers, levels of access, and more. It contains a trigger to build and deploy to <a href=\"https://pub.dev/\">pub.dev</a>. I implemented the project using Flutter for the frontend and Firebase for the backend.</p><p>During the project, I developed interesting reusable components, including:</p><ol><li>A Firebase abstraction layer</li><li>A MVC widget and associated data structure classes to display any tabular information sortable by any field</li><li>A MVC widget and data structure classes to display graphical 2D data</li></ol><p>The admin dashboard lacks some features, but the core functionalities have been implemented. I look forward to continuing work on more features after the GSoC period.</p><p>The GSoC experience taught me valuable development skills, especially in Flutter. I am very grateful for the opportunity, the great work environment, the experience I gained, and the mentoring I received from <a href=\"https://github.com/mhadaily\">Majid</a>.</p><h3>Detecting incorrect version constraints</h3><p><em>By Arseny Uskov</em></p><p>A package maintainer must assign an appropriate version to each Dart package release. They must decide whether they have introduced breaking changes to the users depending on their package. Dependent packages also assume what an appropriate version range would be for each of <em>their</em> dependencies.</p><p>Bugs can arise from incorrect assumptions in these areas. My project sought to identify and investigate a subset of these bugs.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/415/1*87NMdHXboVklByFDhR9d2Q.png\" /><figcaption>An incorrect dependency constraint caused by improper versioning of `package:foo`</figcaption></figure><p>The project provides tools that summarize a portion of the public API of a given version of a given package. This summary identifies any other packages dependent on the given package that might have an incorrect version constraint. Our use case covered where a package used a symbol defined in one of its dependencies, but the same symbol did not include the lowest allowed version of that dependency.</p><p>The public API summary model allows for a range of other interesting static analysis applications. We did not have time to explore them during GSoC. To learn more, refer to the <a href=\"https://arseny.uk/posts/gsoc2022/\">API Analysis blog post</a> about the project, challenges we faced, results gathered from running analysis on the pub.dev ecosystem, bugs we found in real packages, and a starting point for hacking on the project yourself.</p><p><em>Huge thanks to everyone who applied for Google Summer of Code 2022 with Dart, to the contributors who completed projects this year, and to the mentors who helped make this an awesome summer of code. If you’re interested in hearing more about Dart in Google Summer of Code, check out </em><a href=\"https://medium.com/dartlang/google-summer-of-code-2021-results-e514cce50fc\"><em>our 2021 post</em></a><em>.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a3ce1c13c06c\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/google-summer-of-code-2022-results-a3ce1c13c06c\">Google Summer of Code 2022 Results</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-10-06T18:11:55.000Z":{"title":"Partnering with GitHub on supply chain security for Dart packages","link":"https://medium.com/dartlang/partnering-with-github-on-an-supply-chain-security-485eed1fc388?source=rss----23738d481ce8---4","guid":"https://medium.com/p/485eed1fc388","category":["gi̇thub","dart","dartlang","security"],"dc:creator":"Michael Thomsen","pubDate":"Thu, 06 Oct 2022 18:11:55 GMT","atom:updated":"2022-10-06T18:11:55.328Z","content:encoded":"<p>Starting today, GitHub supports Dart in its <a href=\"https://github.com/advisories\">Advisory Database</a>, <a href=\"https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph\">dependency graph</a>, and <a href=\"https://docs.github.com/en/code-security/dependabot/dependabot-alerts/about-dependabot-alerts\">Dependabot</a>. This means GitHub now offers comprehensive support for supply chain security for Dart and Flutter apps.</p><p>To learn about these new capabilities, check out the <a href=\"https://github.blog/2022-10-06-githubs-supply-chain-security-features-now-support-dart\">GitHub blog post</a>. To learn what this means to you as a Dart developer, keep reading.</p><blockquote>“With Dart now in our supply chain security ecosystem, GitHub extends its support for a fast-growing segment of the open source community,” <em>Courtney Claessens, Senior Product Manager for GitHub, said.</em> “And by moving security left, we help not only developers, but the millions of users who rely on apps developed in Dart.”</blockquote><h3>Learning about package security issues</h3><p>Imagine you’re building a fantastic new Flutter app. You’re using lots of really good packages in your pubspec (such as something <a href=\"https://github.com/gskinnerTeam/flutter-wonderous-app/blob/master/pubspec.yaml\">like this</a>) and shipping your app to multiple stores. What would happen if one of them had an important update to fix a security vulnerability? How would you find out about that? You can’t, short of manually checking theCHANGELOG for each of the tens of packages on a regular basis. This is a real challenge.</p><p>This is where Dependabot comes in. If you manage your source code in GitHub repository, the dependency graph and Dependabot monitor your pubspec dependencies and lets you know if you’re missing an update. The Dependabot submits a pull request to update pubspec.yaml to the latest version of the package on your behalf. This all comes about through new Dart-specific improvements in GitHub.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*MdOSko9W_PJA0KwuQ_mu6w.png\" /><figcaption>Dependabot sending a PR to bump (update) a package dependency to a more recent version.</figcaption></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*AVm9C0qX5t-FhYp8lJzU4Q.png\" /><figcaption>Dependency Graph showing the set of dependencies for a Dart package.</figcaption></figure><h3>An advisory database for Dart packages</h3><p>This scenario relies on a high quality, open database of security advisories that lists known vulnerabilities in Dart packages. For this feature, we partnered with GitHub to add Dart support to their popular <a href=\"https://github.com/advisories\">GitHub Advisory Database</a>. This database already contains thousands of advisories for other ecosystems like npm, NuGet, and Maven.</p><p>Starting today, you can now select the <strong>Pub</strong> ecosystem when creating advisories for published Dart packages.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*oPBNmrTaMOB_etyNOp9JJA.png\" /><figcaption>Creating a new security advisory for a Dart package published on pub.dev</figcaption></figure><p>If you publish packages on <a href=\"https://pub.dev/\">pub.dev</a>, we recommend two new best practices.</p><ol><li>Use GitHub’s <a href=\"https://docs.github.com/en/code-security/repository-security-advisories/creating-a-repository-security-advisory\">security advisory</a> feature to create new advisories in your GitHub repo. GitHub ingests these advisories into the central GitHub Advisory database.</li><li>Configure your <a href=\"https://docs.github.com/en/code-security/getting-started/adding-a-security-policy-to-your-repository\">security policy</a> including detailing how users can report vulnerabilities.</li></ol><h3>Secure your Dart repositories today</h3><p>The new security features are available today. If your source code resides in a public repository, Dependabot has started monitoring for security issues. If your source lives in a private GitHub repo, you need a bit more <a href=\"https://github.blog/2022-10-06-githubs-supply-chain-security-features-now-support-dart\">configuration</a> to enable this feature.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=485eed1fc388\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/partnering-with-github-on-an-supply-chain-security-485eed1fc388\">Partnering with GitHub on supply chain security for Dart packages</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2022-12-08T14:02:03.000Z":{"title":"The road to Dart 3: A fully sound, null safe language","link":"https://medium.com/dartlang/the-road-to-dart-3-afdd580fbefa?source=rss----23738d481ce8---4","guid":"https://medium.com/p/afdd580fbefa","category":["dartlang","null-safety","dart"],"dc:creator":"Michael Thomsen","pubDate":"Thu, 08 Dec 2022 14:02:03 GMT","atom:updated":"2022-12-08T15:25:01.228Z","content:encoded":"<h4>Preparing for the next major release, where Dart only supports sound null safety</h4><p>Over the last four years, we’ve evolved Dart into a fast, portable, and modern language. Our next release, Dart 3, completes the journey to a <strong>fully sound null safe language</strong>. As the last step of that journey, we’re removing several historical Dart language and SDK artifacts, including <strong>removing support for running without sound null safety</strong>. This makes Dart easier to learn, and enables us to evolve the Dart SDK to support new features with greater speed. To learn about the main changes in Dart 3 and how to best prepare your apps and packages, keep reading!</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*5XfWLgEBx4iJvuqA\" /><figcaption>The road to Dart 3. <em>(Photo by</em><a href=\"https://unsplash.com/@ohlrogge?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\"><em> Niklas Ohlrogge</em></a><em> on</em><a href=\"https://unsplash.com/s/photos/road-denmark?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText\"><em> Unsplash</em></a><em>)</em></figcaption></figure><h3>Why sound null safety?</h3><p>Many modern programming languages support null safety (also known as <a href=\"https://en.wikipedia.org/wiki/Void_safety\">void safety</a>). This avoids null dereferencing issues, which Tony Hoare coined a billion-dollar mistake: <em>“This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years” </em>(<a href=\"https://web.archive.org/web/20090119110704/http://qconlondon.com/london-2009/presentation/Null+References%3A+The+Billion+Dollar+Mistake\"><em>Hoare 2009</em></a>). To resolve this, languages like Swift, C#, and Kotlin support a type system where you can declare variables to either be <em>non-null</em> (can <em>never</em> hold a null value), or <em>nullable</em> (can hold a value or null). This type system can be combined with static analysis to detect any assignment of null to non-nullable variables. The null safety support in the Dart language uses a similar model, making variables non-nullable by default, and only allowing nulls when explicitly declared.</p><p>Taking it one step further, <strong>Dart introduces <em>sound null safety</em> in an existing language</strong>. A sound system guarantees that a non-nullable variable <em>never</em> contains a null value. During the early planning of Dart null safety, <a href=\"https://github.com/dart-lang/language/blob/master/accepted/2.12/nnbd/roadmap.md\">we explored</a> this topic, and the tradeoffs other languages had taken. The Swift design included soundness from the beginning. TypeScript is inherently unsound, as its underlying type system allows for viewing any object as any static type. As you can see in <a href=\"https://www.typescriptlang.org/play?#code/MYGwhgzhAECyCeAVeAHApgHkQPmgbwChpoA3MEAVzWgC5pEBuI6YAewDsIAXAJwuC6seACgD6ZStTqIAlPi4ALAJYQAdBKrQAvNHHkqDAL4FjBAGYV2ApR2hgAJvYCC7eIqXsA5hgCi2YWA8PGDwdE5BIb7YADTQaCBoALZo7Fx0PnKExMSBwfCqKBQQCsLxSSlcMkymZDykAIx0CMjoGOwUiQBGaHUAPtDtICC4OuxoAO5wSKhowgAsAExVBLWkC9oNTGycrAmqIKyewgAGAMSNDdAq0AAkeCT16vpohrEk69d370+ShscyBAISjM0GEDx+mgAhKMKENMswAPQI6AAETQoEC1AAHnYYOwOABaQbgToJWKdChcaDjajAMDsaDcJRDXEQJSeBnE6CCK5pZjfDTUGFDJjEVY4ujtLo9DbgwUMYjMbYQXZofaHE6nBaSwlcnEqOh3LF-AGmJHQJzQEAqKmsEH49hE2EgaAASVSahWgWgiXgABkbWEIvA2h1ujwRtAANr1WILWKLAC6TAI5qcjjsA2dqgt7HsmYdTulPBzAAUeB4qYpqDw0BBYVxVAQHM5XO4vMJfQHuLFicsWy43MovBgAPKdABW6K4-i7NtiACJEMoYNd8VS0CQUgWwz0F8tlar1UcF6cAMx0a3cK4QGgL2Jz7jLIA\">this TypeScript example</a>, we can assign a null value to a non-null variable. For both ergonomic reasons and to avoid migration of all existing code, C# has several <a href=\"https://devblogs.microsoft.com/dotnet/nullable-reference-types-in-csharp/#avoiding-dereferencing-of-nulls\">exceptions</a> to their null checks. Kotlin has several unsound <a href=\"https://kotlinlang.org/docs/null-safety.html#nullable-types-and-non-null-types\">exceptions</a>, in part due to its goal to interoperate with Java. As you can see in this Kotlin example, <a href=\"https://play.kotlinlang.org/embed?short=yOc5EY5E8&amp;theme=darcula\">generic types</a> can trigger cases where null values can flow into a list declared as holding non-null elements.</p><p>For Dart, we chose the path of sound null safety. This involved a tradeoff. In a few cases, this made migrating to null safety a bit more expensive but results in a sound type system with complete trust in the non-null type annotations. We can make implementation <a href=\"https://medium.com/dartlang/dart-and-the-performance-benefits-of-sound-types-6ceedd5b6cdc\">optimizations</a> in our compilers and runtimes based on the nullability aspect of the type system. We <em>know</em> exactly when a variable isn’t null. We think these were the right set of tradeoffs for Dart.</p><h3>In Dart 3, all Dart code will use sound null safety</h3><p><em>Tracking issue: </em><a href=\"https://github.com/dart-lang/sdk/issues/49530\"><em>SDK #49530</em></a><em>.</em></p><p>It’s been three years since we introduced null safety to the Dart language in <a href=\"https://dart.dev/guides/language/evolution#dart-212\">Dart 2.12</a>. As mentioned in the previous section, we recognize the impact needed to migrate existing Dart packages and apps. To help migration, Dart has supported running your app code in three ways. It can run without null safety, in a mixed mode with partial null safety, or with full sound null safety. Full sound null safety occurs when 100% of the code, including all dependencies, has been migrated. This gave Dart developers time to migrate existing code one step at a time. However, having support for several modes added overhead and complexity.</p><p>First, Dart developers need to be aware of all three modes. Whenever you read a piece of Dart code, you must check the language version to see if types are non-null by default, nullable by default, or some combination thereof.</p><p>Second, supporting all three modes in our compilers and runtimes slows down evolving the Dart SDK. This support increases the cost and complexity of adding new features.</p><p>In Dart 3, sound null safety will be, as <a href=\"https://medium.com/dartlang/dart-2-18-f4b3101f146c\">mentioned</a> and <a href=\"https://groups.google.com/a/dartlang.org/g/announce/c/P3UygvbXPgY\">announced</a> earlier, the <a href=\"https://github.com/dart-lang/sdk/issues/49530\">only supported mode</a>. Pubspec files with an SDK constraint having a lower bound of less than 2.12 will <strong>stop resolving</strong> in Dart 3 and later. Any source code containing language markers, will fail when you set the constraint to less than 2.12 (e.g. // @dart=2.9).</p><p>From our telemetry, we believe that around 85% of all executions of flutter run use sound null safety at this time. If you have apps or packages in the remaining 15%, please <a href=\"https://dart.dev/null-safety/migration-guide\">migrate</a> before Dart 3 ships, which we expect around mid-2023.</p><p>We understand that migrations of large codebases can take some time. We believe you will find the migration worth the effort. BMW recently migrated their main MyBMW app, <a href=\"https://www.press.bmwgroup.com/global/article/detail/T0328610EN/the-my-bmw-app:-new-features-and-tech-insights-for-march-2021?language=en\">a very large app</a> created by a team of around 300 developers:</p><p><em>“While the migration to null-safety was certainly not easy for a large-scale codebase like the MyBMW app, Google’s tools gave us great assistance in the migration process. After having the migration completed we enjoy having a less error-prone codebase.”, Christian Schmid, BMW AG</em></p><p>To learn more about migration, see the following video, or check out the <a href=\"https://dart.dev/null-safety/migration-guide\">migration guide</a>.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FeBr5tlumwlg%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DeBr5tlumwlg&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FeBr5tlumwlg%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/029eecf1ffddaf22c5f9ed315de99cef/href\">https://medium.com/media/029eecf1ffddaf22c5f9ed315de99cef/href</a></iframe><h3>Breaking language and API changes</h3><p>Alongside the null safety change, we’re making a few other changes to remove historical artifacts in the Dart language and core library APIs. These changes include removing discontinued core library APIs (<a href=\"https://github.com/dart-lang/sdk/issues/49529\">#49529</a>), removing a historical syntax for default parameter values (<a href=\"https://github.com/dart-lang/language/issues/2357\">#2357</a>), and requiring tear-offs to be explicit (<a href=\"https://github.com/dart-lang/language/issues/2399\">#2399</a>).</p><p>We believe these changes to have low impact on code migrated to use null safety. When we release the first Dart 3 alpha build, you will be able to quickly test if any of these smaller breaking changes apply to your packages or apps.</p><h3>New Dart 3 features and capabilities</h3><p>Dart 3 is also expected to contain a number of new capabilities, including improved interoperability with other programming languages and new language features. We’ll talk much more about this topic at our next major event, <a href=\"https://flutter.dev/events/flutter-forward\">Flutter Forward</a> on January 25, 2023.</p><p>Let’s take a sneak preview at one language feature, called <strong><em>patterns</em></strong>. Patterns make the Dart language much more expressive, add support for more structured data, and enable a more functional style with algebraic data types.</p><p>The following code shows an example of using multiple return values on a function, paired with the ability to <em>destructure</em> these into individual variables:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b9195dbdb4f1c0698fa26659c5af0c08/href\">https://medium.com/media/b9195dbdb4f1c0698fa26659c5af0c08/href</a></iframe><p>We’ll share many more details about this new feature early next year. To see a sneak preview, you can check out the <a href=\"https://github.com/dart-lang/language/blob/master/accepted/future-releases/0546-patterns/feature-specification.md\">language specification</a></p><h3>Beyond Dart 3</h3><p>We work on a multitude of potential new features in parallel, moving from ideation to experimentation to potential launch. As a consequence, some current work will be completed after Dart 3.</p><p>First, as we <a href=\"https://medium.com/dartlang/experimenting-with-dart-and-wasm-ef7f1c065577\">mentioned last year</a>, we’re working on support for compiling Dart code to WebAssembly (<strong>Wasm</strong>). Wasm enables Flutter Web apps to run as full native code in browsers. This is a large undertaking, requires work, beyond updating the Dart compilers. It requires collaborating with the W3C and browser vendors on adding support for garbage collected languages in Wasm via the <a href=\"https://github.com/WebAssembly/gc/blob/master/proposals/gc/Charter.md\">WasmGC</a> extension.</p><p>Second, we’re working on <strong>macros</strong>. These enable <a href=\"https://github.com/dart-lang/language/blob/master/working/macros/feature-specification.md\">static metaprogramming</a>. This powerful mechanism allows a piece of code (a macro) to modify and extend the source code of a program during compilation of the program. For example, this can reduce the boilerplate needed to deserialize JSON or to create data classes.</p><p>You should expect these features, and other exciting ones, after Dart 3.</p><h3>The road to Dart 3</h3><p>As mentioned in previous sections, if you haven’t migrated to sound null safety, that is the first step. We recommend that you do so now!</p><p>Next, Dart 3 will be rolled out in a series of milestones. Our current expectations revolve around these dates:</p><ul><li><strong>Around January/February 2023</strong>: Dart 3 alpha released. It focuses on enabling early Dart 3 compatibility testing. We expect that you’ll be able to run static analysis (dart analyze / flutter analyze). It’s our goal that any app or package which passes static analysis with Dart 3 alpha should support Dart 3 stable.</li><li><strong>Around March/April 2023</strong>: Dart 3 beta released. This release previews the new features in Dart 3. You can use this to experiment with the new features and give feedback on issues or suggestions for improvements.</li><li><strong>Around mid 2023</strong>: Dart 3 stable released. Sound null safety becomes the only supported mode.</li></ul><h3>Summary</h3><p>The Dart 3 release is scheduled for launch around mid 2023. It will contain several breaking changes, primarily the discontinuation of running without sound null safety. We hope to have a Dart 3 alpha build ready around January or February 2023, which you can use for Dart 3 compatibility testing.</p><p>To prepare your apps:</p><ul><li>Complete any outstanding <a href=\"https://dart.dev/null-safety/migration-guide\">null safety migrations</a></li><li>Verify that your code doesn’t use any deprecated APIs</li><li>Run <a href=\"https://dart.dev/tools/dart-fix\">dart fix</a>.</li></ul><p>Dart 3 will also contain several new powerful features, such as patterns. We hope to have a Dart 3 beta release in the spring which demonstrates all the new functionality.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=afdd580fbefa\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/the-road-to-dart-3-afdd580fbefa\">The road to Dart 3: A fully sound, null safe language</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2023-02-09T16:02:34.000Z":{"title":"Introducing Realm for Dart & Flutter","link":"https://medium.com/dartlang/introducing-realm-for-dart-flutter-e30cb05eb313?source=rss----23738d481ce8---4","guid":"https://medium.com/p/e30cb05eb313","category":["realm","dart"],"dc:creator":"Michael Thomsen","pubDate":"Thu, 09 Feb 2023 16:02:34 GMT","atom:updated":"2023-02-09T16:02:34.109Z","content:encoded":"<h4>A case study in using Dart platform primitives to build a rich multi-platform library for Dart and Flutter apps.</h4><p>We’re excited to see MongoDB announce the general availability (GA) of Realm for Dart and Flutter today! Realm is a reactive, object-oriented, cross-platform database, popular among app developers. In other words, perfect for Dart and Flutter. So, over the past year we’ve collaborated with MongoDB to bring Realm to Dart and Flutter. Checkout the <a href=\"https://www.mongodb.com/developer/products/realm/announcing-realm-flutter-sdk/\">blog post</a> by MongoDB for details on what Realm offers, how it’s improved from their earlier previews, and what they have planned for the future. We think Realm will be a great match for Dart &amp; Flutter developers.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/530/1*cAi4WO4IfN5Sp6WE6Ex8Ig.png\" /><figcaption>Writing books to a Realm data store using Dart</figcaption></figure><p>In this companion post, we’ll take a peek behind the scenes to learn how Realm for Dart &amp; Flutter is built, as a practical example of how to build new Dart-based developer SDKs.</p><h3>Realm example</h3><p>Before we dig into the implementation of the Realm SDK, let’s start with a quick tour of how to use the SDK as a developer working on a Dart <a href=\"https://dart.dev/tutorials/server/cmdline\">terminal app</a> (<em>note</em>: the steps for a Flutter app are slightly different; see <a href=\"https://www.mongodb.com/docs/realm/sdk/flutter/install/\">the documentation</a> for details).</p><p>First, you define a data model. This is done using regular Dart classes with some added Realm annotations. Here’s a sample data class for a book:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ca8542a6b2438d675c7f3e20e8b3f36f/href\">https://medium.com/media/ca8542a6b2438d675c7f3e20e8b3f36f/href</a></iframe><p>With the model defined, and the data model fully generated (see below), you can go ahead and write some books to a Realm data store:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e5eb95b84ad9ff3cb9e777f037b9135f/href\">https://medium.com/media/e5eb95b84ad9ff3cb9e777f037b9135f/href</a></iframe><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b25a09e353d2cdfa327fa45d7c3f1c4e/href\">https://medium.com/media/b25a09e353d2cdfa327fa45d7c3f1c4e/href</a></iframe><h3>How Realm for Dart and Flutter was built</h3><p>Now that we’ve covered the basics, let’s see how the MongoDB team built Realm for Dart and Flutter utilizing a number of Dart libraries and tools. We’ll take a look at what happens when the Realm SDK is initialized, how the Realm SDK is built on top of a shared native C++ library, how the Realm terminal tool was built, and how Realm models are generated.</p><h3>Initializing the Realm SDK</h3><p>Dart and Flutter developers will start by adding Realm to their existing app, and then running the installer:</p><pre>dart pub add realm_dart<br>dart run realm_dart install</pre><p>The first step simply adds the Realm SDK to pubspec.yaml to <a href=\"https://dart.dev/tools/pub/dependencies\">register it as a dependency</a> of the app. The second step runs the Realm terminal tool, asking it to install the SDK. If we look inside the <a href=\"https://github.com/realm/realm-dart/blob/main/lib/src/cli/install/install_command.dart\">source code for the install command</a>, we can see install determines what operating system we are developing on, and then downloads the Realm SDK binaries for that operating system.</p><p>But why is the install command downloading a binary? The Realm SDK is a very comprehensive offering, available across a large range of operating systems and developer frameworks. To avoid having to build a large number of instantiations of the Realm SDK, the Realm team decided to implement the core Realm SDK as a shared <a href=\"https://github.com/realm/realm-core\">realm-core C++ library</a>. So, what the install command really does is download compiled versions of this core library for all platforms the app supports.</p><h3>Calling into the realm-core SDK</h3><p>Users of the Realm SDK writing Dart or Flutter apps get nice, strongly typed Dart APIs, as illustrated in the beginning of this post. How do those APIs correspond to the <a href=\"https://github.com/realm/realm-core\">realm-core</a> C++ library?</p><p>If we peek inside the lib directory of the Realm SDK we find <a href=\"https://github.com/realm/realm-dart/blob/main/lib/src/native/realm_bindings.dart\">realm_bindings.dart</a>, which starts with:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/9354147dc5966ded3adbb95280d03a06/href\">https://medium.com/media/9354147dc5966ded3adbb95280d03a06/href</a></iframe><p>Mystery solved: The Realm SDK uses Dart’s support for interoperability with native APIs via the dart:ffi library to call into realm-core. To avoid having to write FFI bindings manually for the very large set of available Realm APIs, the bindings are auto generated using Dart’s <a href=\"https://pub.dev/packages/ffigen\">ffigen</a>tool. This is a pattern we’re seeing rapid growth of across the Dart team.</p><h3>The Realm terminal tool</h3><p>Let’s turn to the Realm terminal tool itself. Above, we ran the install command, but we can also run the tool without specifying a command:</p><pre>$ dart run realm_dart<br>Realm commands for working with Realm Flutter &amp; Dart SDKs.<br><br>Usage: dart run realm|realm_dart &lt;command&gt; [arguments]<br><br>Global options:<br>-h, --help    Print this usage information.<br><br>Available commands:<br>  generate   Generate Realm objects from data model classes<br>  install    Download &amp; install Realm native binaries into a Flutter or Dart project<br>  metrics    Report anonymized builder metrics to Realm<br><br>Run &quot;dart run realm|realm_dart help &lt;command&gt;&quot; for more information about a command.</pre><p>You may notice that this output looks a lot like the output from the core dart and flutter tool. This is no coincidence; all three tools are built using the same Dart foundation libraries for terminal tools from <a href=\"https://pub.dev/packages/args\">package:args</a>:</p><ul><li>The <a href=\"https://pub.dev/documentation/args/latest/args/args-library.html\">args</a> library has rich support for parsing raw command line arguments into options and flags</li><li>The <a href=\"https://pub.dev/documentation/args/latest/command_runner/command_runner-library.html\">command_runner</a> libraryprovides a structure for commands supported by the tool (e.g. install)</li></ul><h3>Generating the Realm model</h3><p>The generate command is especially interesting because it generates the full Realm model from the annotated Dart model classes that we defined in the “Realm example” section:</p><pre>dart run realm_dart generate</pre><p>How does the generate command work? It relies on the Realm <a href=\"https://github.com/realm/realm-dart/blob/main/generator/README.md\">generator</a>, which is built on top of Dart’s <a href=\"https://pub.dev/packages/build_runner\">build_runner</a>, a framework for generators that takes a set of input files and then creates new output files. Typically — as in the Realm case — the inputs are Dart source code files with annotations, and the output files are additional generated Dart source code.</p><h3>Closing thoughts</h3><p>We hope you enjoyed this peek behind the curtain of how a large developer framework can be built from a set of reusable Dart libraries. If you are a framework developer, hopefully this can give you some inspiration for your next Dart-based framework.</p><p>For Dart and Flutter app developers, Realm is a great new offering from the MongoDB team. We invite you to check out the <a href=\"https://www.mongodb.com/docs/realm/sdk/flutter/\">Realm SDK documentation</a>, and today’s <a href=\"https://www.mongodb.com/developer/products/realm/announcing-realm-flutter-sdk/\">Realm blog post</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e30cb05eb313\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/introducing-realm-for-dart-flutter-e30cb05eb313\">Introducing Realm for Dart &amp; Flutter</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2023-01-25T16:01:06.000Z":{"title":"Introducing Dart 3 alpha","link":"https://medium.com/dartlang/dart-3-alpha-f1458fb9d232?source=rss----23738d481ce8---4","guid":"https://medium.com/p/f1458fb9d232","category":["dartlang","dart","flutter"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 25 Jan 2023 16:01:06 GMT","atom:updated":"2023-01-25T16:16:39.369Z","content:encoded":"<h4>Preview the most productive, portable, <em>and</em> approachable version of Dart yet. Now available for early testing and experimentation.</h4><p>In December, we gave a glimpse into the future with our first blog post discussing Dart 3. Today — live from the <a href=\"https://flutter.dev/events/flutter-forward\">Flutter Forward</a> developer event in Nairobi, Kenya — we’re sharing the broader vision for Dart’s next major release, and our first preview build, <strong>Dart 3 alpha</strong>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*evGHZJd_7cahb08X\" /></figure><p>Our mission for Dart is to create the best programming language for building high-quality apps across any app platform. Dart is <strong>approachable</strong>, easy to learn, avoids unnecessary complexity, and is internally consistent. Dart is <strong>productive; </strong>app developers are under constant pressure to deliver apps with ever changing requirements, in less time, yet with uncompromised quality and finish. So, we built Dart with a deep focus on enabling fast development, rapid iteration, and high quality. And Dart is <strong>portable</strong>, spanning the widest set of platforms, to enable you to deploy apps to the devices of today and tomorrow.</p><p>We’ve worked on establishing these qualities over many years. With Dart 3, we intend to take another big step, refining and expanding on approachability, productivity, and portability in significant ways.</p><p>Dart 3 is a new <em>major</em> release. Partly to signify the large step forward in new functionality, and partly because it’s a <em>breaking release</em> in terms of semantic versioning: We’re changing the type system to <em>only</em> support <strong>sound null safety</strong> (in Dart 2.12 and later this was <em>opt-in</em>), and have made the corresponding breaking changes in Dart’s core libraries. Let’s dive into the details!</p><h3>Dart 3 productivity enhancements</h3><h4>A more expressive Dart language: Records, patterns, and access controls</h4><p>We’ve evolved the Dart language at a rapid pace the past few years, <a href=\"https://dart.dev/guides/language/evolution\">adding 23 new features</a> since 2.0. In Dart 3 we expect to add two new major features, records and patterns, with the goal of making working with structured data more productive.</p><p>Records allow you to efficiently and concisely create anonymous composite values from any existing data, without the conceptual overhead of needing to declare a class to hold the values. With records, you can easily build new data structures that combine existing data. For example, to return a pair of values:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/48ec715500e82fc4ad0b1bc258c065a4/href\">https://medium.com/media/48ec715500e82fc4ad0b1bc258c065a4/href</a></iframe><p>Where records allow you to combine data, patterns can destructure composite data into its constituents. For example, to destructure the return value of geoLocation above (a record consisting of a pair of ints) into two individual int variables, lat and long, you can use a pattern declaration like this:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3dc96b054ae108d6a466671adc318c8f/href\">https://medium.com/media/3dc96b054ae108d6a466671adc318c8f/href</a></iframe><p>Patterns are fully type safe, and checked during development.</p><p>You can also pattern match on the type of values, for example from a hierarchy of classes. A switch can use patterns that match on the type, and the individual fields of each type, as in the body of calculateArea here:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/c7af90ec13ca17f4eb7489f20c3a6fa3/href\">https://medium.com/media/c7af90ec13ca17f4eb7489f20c3a6fa3/href</a></iframe><p>Overall, we’re adding a large selection of patterns that, when combined, make Dart much more expressive for structured data.</p><p>In conjunction with patterns, we’re also adding <a href=\"https://github.com/dart-lang/language/blob/master/accepted/future-releases/class-modifiers/feature-specification.md\">capability controls</a> to classes, via several new modifiers:</p><ul><li><strong>interface class</strong>: Cannot be extended.</li><li><strong>base class</strong>: Disables the implicit interface, so cannot be implemented.</li><li><strong>final class</strong>: Cannot extend, implement, or mix in the class (outside the current library).</li><li><strong>sealed class</strong>: Same as abstract + final + the type is considered the root of a sealed type family for exhaustiveness checking. As an example, take the Shape class hierarchy above. In switch statements on the Shape type (like the calculateArea function), the analyzer will trigger errors if the switch statement does not handle all possible subtypes of the sealed type.</li><li><strong>mixin class:</strong> A class which may be used as a mixin.</li></ul><p>Every new feature adds complexity to the language. To ensure Dart remains approachable, classes default to be fully permissive just like today, with the small exception that classes intended to be used as mixins must now use the mixin keyword.</p><h4>Productive platform integration via direct platform library interop</h4><p>We’re working on expanding Dart language interoperability for <strong>calling platform libraries directly from Dart</strong>. On Apple platforms, we’re building on our work on <a href=\"https://dart.dev/guides/libraries/c-interop\">FFI for C interoperability</a>, which supports calling any C module that follows the C calling convention from Dart. This has so far supported languages such as C, Go, and Rust. Now, we’re adding support for Swift and Objective-C on <a href=\"https://dart.dev/guides/libraries/objective-c-interop\">iOS/macOS</a>. On Android, you can call into Jetpack libraries written in Kotlin and Android libraries written in Java by leveraging FFI and Android’s Java Native Interface (JNI).</p><p>Powered by new tools, Dart can automatically create bindings that have a Dart interface and behind those cross-language interop code based on the header/interface files of the original C/ObjC/Swift/Java/Kotlin code. For a demonstration of using this to call into Apple’s <a href=\"https://developer.apple.com/documentation/coremotion\">Core Motion API</a> and Android’s <a href=\"https://developer.android.com/guide/health-and-fitness/health-connect\">HealthConnect API</a>, checkout <a href=\"https://github.com/flutter/samples/blob/main/experimental/pedometer/README.md\">the sample app</a>.</p><p>These new interop mechanisms are currently experimental, but we hope that they will reach at least beta quality in Dart 3.0 stable. Feedback is appreciated in the issue trackers for <a href=\"https://github.com/dart-lang/jnigen\">Java/Kotlin</a>, or <a href=\"https://github.com/dart-lang/ffigen\">C/ObjectiveC/Swift</a>. Finally, we’re also working on improved Dart to JavaScript interop; we’ll have more news about that in a future blog post.</p><h3>Portability advancements</h3><p>Dart already supports a wide range of target platforms with our native and web compilers. On the Web, we currently compile to JavaScript. On native devices, we currently support the Intel 32-bit and 64-bit, and ARM 32-bit and 64-bit architectures. There are a number of emerging devices and standards we’re working on adding support for, to ensure Dart is ready for the devices of the future.</p><p>For the web, we’re working on support for <a href=\"https://webassembly.org/\">WebAssembly</a> (Wasm), which has been growing in maturity as a platform-neutral binary instruction format across <a href=\"https://caniuse.com/wasm\">all modern browsers</a>. It’s our hope Wasm can enable Dart web apps to start as fast as apps on native devices.</p><p>Another platform architecture growing in interest is <a href=\"https://en.wikipedia.org/wiki/RISC-V\">RISC-V</a>, an open standard instruction set architecture (ISA) designed for broad usage. The Android team recently gave a talk on <a href=\"https://www.youtube.com/watch?v=70O_RmTWP58\">their work to support RISC-V</a>, and we think it will have broad applicability for embedded devices, too. Support for RISC-V is available to preview in Dart 3 alpha.</p><p>Finally, we’re working on expanding our current support for ARM devices to also encompass ARM64 support on Windows.</p><h3>Dart 3 breaking changes</h3><p>With the new Dart 3 capabilities covered, let’s turn to the breaking changes we’re making in the spirit of a more consistent and approachable Dart.</p><h4>Dart 3 type system: 100% sound null safety</h4><p>We introduced sound null safety in <a href=\"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87\">Dart 2.12</a> in 2021. In a sound typing system, you can trust the types, meaning a variable is <em>never</em> null when the types state that it isn’t. This raises productivity by catching issues during development rather than in production, and enables the Dart compilers to produce <a href=\"https://medium.com/dartlang/dart-and-the-performance-benefits-of-sound-types-6ceedd5b6cdc\">smaller and more optimized code</a>. As we <a href=\"https://medium.com/dartlang/the-road-to-dart-3-afdd580fbefa\">discussed in December</a>, Dart is unique in introducing 100% sound null safety to an existing language.</p><p>Since Dart 2.12, null safety has been a configuration option that could either be <em>on</em> or <em>off</em>. <strong>In Dart 3, all code runs with sound null safety <em>on</em></strong>. It is no longer possible to run apps without null safety or in a mixed mode with partial null safety.</p><p>We realize that discontinuing support for running without null safety can pose issues for existing apps and packages. However, we feel now is the right time to move forward with this change. Having a single type system, where null safety is always on, reduces overhead and complexity. Whenever developers read a piece of Dart 3 code, they can rest assured that all variables are non-null by default. On the implementation side, Dart’s compilers and runtimes can focus on supporting a single way of running Dart code, which lowers the cost and complexity of adding new features.</p><p>The Dart ecosystem has demonstrated a strong dedication and willingness to migrate existing code to null safety. As of today,</p><ul><li>100% of the top-250 packages on pub.dev support null safety</li><li>98% of the top-1000 packages on pub.dev support null safety</li><li>Only 14% of flutter run sessions still run without null safety</li></ul><p>Thank you to the ecosystem for the migration effort!</p><h4>Cleanup of Dart 3 core libraries and language</h4><p>As the Dart language and type system have evolved, several of the APIs in our core libraries have become redundant or suboptimal. To ensure Dart remains approachable, we’ve made a number of breaking changes to clean up unnecessary APIs. For details, see the GitHub issues, <a href=\"https://github.com/dart-lang/sdk/issues/34233\">#34233</a> and <a href=\"https://github.com/dart-lang/sdk/issues/49529\">#49529</a>. We’ve also removed a historical syntax for default parameter values (<a href=\"https://github.com/dart-lang/language/issues/2357\">#2357</a>).</p><p>With Dart 3 alpha done, our attention has now turned to Dart 3 beta. There, we hope to further refine the Dart core libraries by adding a number of new APIs. You can offer input on this in the <a href=\"https://github.com/dart-lang/sdk/issues/49928\">feedback issue</a>.</p><h4>Preparing your code for Dart 3 stable</h4><p>Generally, we believe most code that has already migrated to use null safety, using Dart 2.12 or later, will work with Dart 3. However, some small subset of packages and apps may be impacted by the breaking changes discussed above. So, to give you time to prepare for the Dart 3 stable release later this year, we have not planned any further breaking changes to the Dart language and core libraries after Dart 3 alpha.</p><p>To leverage code that has already migrated to use null safety, we’ve implemented backwards compatibility in Dart 3 that will allow migrated packages to resolve with pub get in Dart 3 despite having a SDK version constraint like &gt;=2.12 &lt;3.0.0, as long as they don’t depend on other discontinued core library APIs or language features. For more details, including how to test with a locally installed <a href=\"https://dart.dev/get-dart/archive#dart-3-alpha\">Dart 3 alpha SDK</a>, see our <a href=\"https://dart.dev/null-safety#dart-3-and-null-safety\">Dart 3 null safety documentation</a>.</p><p>For packages published on the <a href=\"https://pub.dev/\">pub.dev</a> repository, we’ve run analysis with Dart 3 alpha, and tagged packages that pass with a <strong>“Dart 3 ready”</strong> tag. This signifies that the package is likely to work with Dart 3 when it launches to stable later this year.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*dB-NsWj2y3JljZZh\" /></figure><h4>Dart 3 tools cleanup</h4><p>Leading up to Dart 3, we made <a href=\"https://github.com/dart-lang/sdk/issues/46100\">a number of changes</a> to move all our terminal developer tools into a unified dart developer tool, which made Dart a lot more approachable for new developers. We’re planning on making <a href=\"https://github.com/dart-lang/sdk/issues/50707\">additional tools changes</a> over the coming months to further cleanup. Hopefully these changes won’t be too disruptive, but some minor breakage should be expected for tooling in Dart 3 beta.</p><h3>Next steps</h3><p>Dart 3 alpha <a href=\"https://dart.dev/get-dart/archive#dart-3-alpha\">is available today</a> in the Dart dev channel and in the Flutter master channel. We invite you to try it out, whether it’s to experiment with the new language features like records &amp; patterns, try our new direct access platform interop, or test your apps &amp; packages for <a href=\"https://dart.dev/null-safety#dart-3-and-null-safety\">Dart 3 compatibility</a>.</p><p>We’ll continue to refine Dart 3 over the coming months, and hope to have a complete Dart 3 stable release later this year. Note that most of the features are still undergoing development, and therefore subject to change until the stable release. Until then, have fun with your Dart code!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f1458fb9d232\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-3-alpha-f1458fb9d232\">Introducing Dart 3 alpha</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2023-01-24T19:46:19.000Z":{"title":"Better isolate management with Isolate.run()","link":"https://medium.com/dartlang/better-isolate-management-with-isolate-run-547ef3d6459b?source=rss----23738d481ce8---4","guid":"https://medium.com/p/547ef3d6459b","category":["dart","dartlang","concurrency","asynchronous-programming","flutter"],"dc:creator":"Marya Belanger","pubDate":"Tue, 24 Jan 2023 19:46:19 GMT","atom:updated":"2023-01-26T01:21:02.743Z","content:encoded":"<h4>Dart 2.19 introduces a new function that makes implementing concurrency as simple as a single line of code.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/597/0*Bt-V4nlGjNKquFhK\" /><figcaption>A benchmark test showcasing the speed of the new Isolate.run() function</figcaption></figure><p>All Dart code runs in isolates. Whether you implement multiple isolates to enable <a href=\"https://dart.dev/guides/language/concurrency\">concurrency</a> in your Dart programs is up to you. <em>How</em> you can implement multiple isolates is up to us on the Dart team, and in Dart 2.19, we’ve made a huge upgrade to the process that we’re excited to share. Meet Isolate.run()!</p><p>run() takes all of the complexity of setting up and managing isolates and completely abstracts it into a single function call. It’s been possible to use isolates with a handful of primitives for a while now. But, even with all <a href=\"https://medium.com/dartlang/dart-2-15-7e7a598e508a#:~:text=publishers%2C%20and%20more.-,Fast%20concurrency%20with%20worker%20isolates,-Just%20about%20all\">the recent performance improvements</a> for isolates, the process was at best, tedious, and at worst, error-prone.</p><p>To appreciate how much of an improvement run() is, this article breaks down the previous method of building out the functionality piece-by-piece from low-level primitives. Then, we’ll contrast that to using Isolate.run(), and show you how it works on the inside. Even if you’ve never used isolates before, we’re sure that run() will get you excited to try them out!</p><h4>Isolates</h4><p>Isolates are a fairly straightforward concept. An <a href=\"https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a\">isolate</a> is essentially a single thread of execution in Dart. They let you execute parts of your code in parallel. You can start new parallel executions (as many as you want) and tell them what to do, right from main (the main thread, or <a href=\"https://dart.dev/guides/language/concurrency#the-main-isolate\">main isolate</a>). Isolates don’t share memory; instead, they pass messages back and forth to communicate. So, you don’t have to worry about typical multithreading problems, like race conditions, or mutexes and locks.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/613/0*eCogwJXZtpbg5Hbq.png\" /></figure><p>Sounds great! But how do you use them? Before Isolate.run(), that’s where things became tricky.</p><p><a href=\"https://api.dart.dev/stable/dart-isolate/Isolate-class.html\">The isolate API</a> is made up of low-level primitives that provide a wide range of functionality. Granularity like that is great when you need to customize your isolates’ functionality. Granularity is not so great, though, when it’s necessary to use isolates <em>at all</em>. Especially since almost all of the use cases for isolates require the same basic configurations for setup and management. This basically meant exposing every implementation detail for you, Dart’s users, to handle yourselves.</p><p>Let’s take a look at a typical isolate setup to better understand the tedious process that Isolate.run() solves.</p><h4>Using Isolates (before)</h4><p>You can think of <a href=\"https://api.dart.dev/stable/dart-isolate/Isolate/spawn.html\">Isolate.spawn()</a> as the old starting point for isolates. Flutter’s compute function was built off of spawn(). It takes a method to invoke as its entrypoint argument, plus any arguments for that method, and other configurations for the isolate itself. In the past, this entrypoint could only be a top-level or static method.</p><p>Isolate.spawn(_readAndParseJson, filename);</p><p>Isolate created, all done! Just kidding. Not even close.</p><p>Calling spawn won’t return anything to actually work with. It only returns an isolate object, which simply confirms the isolate has started.</p><p>The main isolate and the spawned isolate (the isolate created by spawn()) can’t communicate directly, beyond the initial arguments passed on creation. Realistically, even if you don’t need any computation results back from the spawned isolate, you would still want some kind of verification that the computation succeeded, so you’re always going to want a message back.</p><p>To enable communication, you have to set up ports. You create a ReceivePort object before calling spawn. The sendPort member of the ReceivePort object goes to the spawned isolate as another argument for spawn.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a4077fd46ce2a68512e9f71114184b0d/href\">https://medium.com/media/a4077fd46ce2a68512e9f71114184b0d/href</a></iframe><p>This means the function you pass to spawn has to be <em>specifically</em> configured to do something with that sendPort. In other words, you can’t just reuse existing functions with isolates. So instead of passing spawn a regular function that just reads and parses a JSON file, you would create something like:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3c3916b9af5918d16e89f9437412f5be/href\">https://medium.com/media/3c3916b9af5918d16e89f9437412f5be/href</a></iframe><p>Your special, isolate-friendly, JSON-decoding function can simply “return result” and you’re all done, right? Not quite. The result needs to be sent through responsePort. That’s how isolates communicate with ports. You can use another primitive, <a href=\"https://api.dart.dev/stable/dart-isolate/Isolate/exit.html\">Isolate.exit()</a> to return the result efficiently and close the spawned isolate at the same time:</p><p>Isolate.exit(responsePort, result);</p><p>The exit() function <em>transfers</em> the memory that holds the message in the spawned isolate to the main isolate (as opposed to copying it over) and safely closes the isolate.</p><p>Let’s string this all together. Since result in this example is parsed JSON , you’d probably want to destructure it a little to actually use it. For the sake of clean code, instead of planting those three lines that create the receivePort and the isolate, and await their response, right into main(), we should put them in their own function.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/6f6acb3dc6833cf9b34ee4a65fd474b9/href\">https://medium.com/media/6f6acb3dc6833cf9b34ee4a65fd474b9/href</a></iframe><p>What’s being accomplished is relatively straightforward. It’s the exposure of implementation details that makes it <em>feel</em> complicated, like ports for message passing, and needing a dedicated function for dealing with ports that’s otherwise isolate-agnostic.</p><h4>Error handling</h4><p>The example so far <em>still</em> isn’t really a “complete”, production-ready implementation. You’d be doing yourself a disservice to leave out any kind of error handling, but it’s commonly forgotten as an additional step in an already substantial process. Without any error handling, if an uncaught async error were to crash your isolate, for example, you wouldn’t know what happened to cause the error, or even be alerted that <em>anything had happened at all</em>.</p><p>Covering every error handling possibility for isolates would be extensive, but in general it would involve a few more additions to the code.</p><p>You could, as a minimum, add the errorsAreFatal, onExit, and onError parameters to the spawn call:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/b60a3ddf74c038ebee17f3be498ea7d0/href\">https://medium.com/media/b60a3ddf74c038ebee17f3be498ea7d0/href</a></iframe><p>This ensures that resultPort receives a message even if the spawned isolate terminates without sending a result, or if it has any uncaught errors. Making errors fatal means uncaught errors exit the isolate as a safety precaution, to ensure it terminates at all.</p><p>The onExit argument makes the isolate send null to the port upon exiting. The onError argument makes an uncaught error send a list of two strings to the port (the toString of both the error and stack trace).</p><p>Reusing the result port lets you avoid creating more ports, so you only have to look for messages in one place. But it also means you need to distinguish the onExit and onError messages from the result value. Here, we assume that the JSON must be a Map, so it cannot be a list or null. Otherwise you’d also have to wrap the result in something recognizable. You would have to create a (trivial) message protocol on top of the port messages.</p><p>Beyond that minimum, you could then check response for specific errors. One such case would be checking if resultPort is null, meaning the isolate terminated without sending results:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/1f9685110e29257f5f98445596375d34/href\">https://medium.com/media/1f9685110e29257f5f98445596375d34/href</a></iframe><p>Another would be checking if the result is a list, meaning an uncaught error occurred:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/72f7164fb07f16c509283dadd6b23501/href\">https://medium.com/media/72f7164fb07f16c509283dadd6b23501/href</a></iframe><p>Then, finally, handle an actual result:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/01681a8643cf50c9bc1c0956bf05ac27/href\">https://medium.com/media/01681a8643cf50c9bc1c0956bf05ac27/href</a></iframe><p>In any case, you’d want to put spawn in a try block to check if sending the entrypoint to the new isolate failed. If it did, the result port won’t get any message, and needs to be closed:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3e3b35ae765e1ef261a74858b73e2d49/href\">https://medium.com/media/3e3b35ae765e1ef261a74858b73e2d49/href</a></iframe><p>Providing a bare minimum of error handling ensures that the result port is always closed, and _spawnAndReceieve always completes, no matter how the spawned isolate exits. You could also make things <em>nicer</em>, for example, by catching and sending errors and stack traces back as actual objects, not just strings like the onError handler.</p><p>Error handling obviously introduces a lot of variation, and with it the mental overhead of deciding how to approach it and what to factor for. It’s understandable that it’s commonly left out of primitive isolate setup.</p><h4>Using Isolates (after)</h4><p>Isolate.run() sets up all parts of isolate implementation with the primitives you previously had to use yourself, in a single function call:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/27ee342686cba4d9546ef2a49a0dbfd9/href\">https://medium.com/media/27ee342686cba4d9546ef2a49a0dbfd9/href</a></iframe><p>No ports, no separate spawning, exiting, or error handling, and no special return structure. Perhaps the best part, the entrypoint you pass to run can be any existing function:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/20a0d24ac90487ddb8d0cc1cf66a71be/href\">https://medium.com/media/20a0d24ac90487ddb8d0cc1cf66a71be/href</a></iframe><p>This example shows an <em>asynchronous</em> function, but run could just as easily execute a <em>synchronous</em> function. The run function itself always returns asynchronously, which is all that matters.</p><p>The entrypoint can also be a <em>function expression</em>, written directly inline wherever you call run. Isolates, and any higher-level APIs written on top, are no longer limited to running only static or top-level functions.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/c270b53649cac8d66aaea6af997502dd/href\">https://medium.com/media/c270b53649cac8d66aaea6af997502dd/href</a></iframe><p>The additional message parameter is no longer necessary, and you can avoid packing and unpacking arguments in data structures like lists.</p><p>You don’t have to think much about error handling at all. The run function combines local and remote error capturing, handling and cross-isolate communication, and exposes the result as a single normal (asynchronous) error that you can catch in a standard try/catch. You can forget isolates, and treat it as a normal function.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/e9bf5b788a505cbf800d506948ba838d/href\">https://medium.com/media/e9bf5b788a505cbf800d506948ba838d/href</a></iframe><p>Isolate.run() enables much cleaner and ergonomic code. Flutter’s compute function even switched over to using run instead of spawn!</p><h4>Inside Isolate.run()</h4><p>Take a look at the <a href=\"https://api.dart.dev/dev/3.0.0-125.0.dev/dart-isolate/Isolate/run.html#implementation:~:text=isolate%20for%20debugging.-,Implementation,-%40Since(%222.19\">implementation of </a><a href=\"https://api.dart.dev/dev/3.0.0-125.0.dev/dart-isolate/Isolate/run.html#implementation:~:text=isolate%20for%20debugging.-,Implementation,-%40Since(%222.19\">run</a> itself. It digs into all the low-level isolate-related APIs (which would’ve been your job to implement before) to construct a “perfect”, comprehensive isolate setup. It takes the method to execute, computation, and sets up all the ports and their returns to account for efficient message passing between isolates.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/4ca8d776662ead618f17933fb574dc36/href\">https://medium.com/media/4ca8d776662ead618f17933fb574dc36/href</a></iframe><p>There’s <em>thorough</em> error handling for every potential case. The run function checks whether an isolate dies before it’s done computing. If the computation throws, the isolate terminates and throws the same error to the main isolate.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2f15aa7cd2ffcaec4c1c64f9f57f22be/href\">https://medium.com/media/2f15aa7cd2ffcaec4c1c64f9f57f22be/href</a></iframe><p>If an uncaught asynchronous error occurs, the isolate terminates and reports the error asynchronously to the main isolate. If the main isolate terminates first, the spawned isolate terminates and treats the situation as an uncaught async error.</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/87593ee587c105fb32549fe1368bb783/href\">https://medium.com/media/87593ee587c105fb32549fe1368bb783/href</a></iframe><p>Lastly, run always uses exit to safely shut down. That means data is efficiently transferred from isolate to isolate without actually copying it.</p><h4>Summary</h4><p>The run function is ideal for starting one computation and waiting for the results. The primitives are still there if you want to build out your own isolate setup for something that run doesn’t cover, like a <a href=\"https://github.com/dart-lang/samples/blob/master/isolates/bin/long_running_isolate.dart\">long-running isolate</a> that can send and receive messages multiple times. For most cases though, replacing spawn and all its supporting configurations with a single run statement should be used over any other configuration.</p><p>If you’d never tried isolate management before run, it would be hard to believe all this functionality previously had to be implemented by the user! Isolate.run() — available in Dart 2.19 and Flutter 3.7 — makes code so much more ergonomic, and makes isolates so much easier to use. What will you do with all the time run saves you?</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=547ef3d6459b\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/better-isolate-management-with-isolate-run-547ef3d6459b\">Better isolate management with Isolate.run()</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2023-01-18T18:00:55.000Z":{"title":"Screenshots and automated publishing for pub.dev","link":"https://medium.com/dartlang/screenshots-and-automated-publishing-for-pub-dev-9bceb19edf79?source=rss----23738d481ce8---4","guid":"https://medium.com/p/9bceb19edf79","category":["package-management","pubdev","package","dartlang","github-actions"],"dc:creator":"Jonas Finnemann Jensen","pubDate":"Wed, 18 Jan 2023 18:00:55 GMT","atom:updated":"2023-01-18T18:00:55.875Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<p>We have a couple of new features available on pub.dev starting today: You can now declare screenshots for a package, enabling a more visual approach to search. And the publishing flow can now be fully automated, powered by GitHub Actions.</p><h3>Adding screenshots to pub.dev</h3><p>One of the core objectives of pub.dev is to make it easy to find the right package for a given purpose. When you search for widgets or other visual components, images play an important role. We are now showing screenshots in package search results, to make it easier than ever to find a package.</p><h4>Screenshots in package search and on the package page</h4><p>Thumbnails of screenshots now appear in the search results and you can also filter the search to only list packages with screenshots.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*B2bqbwEtObMoGQTm8B-FVQ.png\" /></figure><p>The screenshot thumbnail is also shown on the package page, and clicking the thumbnail triggers an image carousel with all the screenshots.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*69KfhhHmmvZ6BLvypXjx2A.png\" /></figure><h4>Declaring screenshots in `pubspec.yaml`</h4><p>Adding screenshots to a package is really simple. Declare the files in pubspec.yaml under the screenshots field with a description and a path. Below is an example from the animations package.</p><pre>name: animations<br>...<br>screenshots:<br> - description: &#39;Examples of the container transform pattern.&#39;<br>   path: example/screenshots/container_transform_lineup.webp<br> - description: &#39;Examples of the fade pattern.&#39;<br>   path: example/screenshots/fade_lineup.webp<br>   ...</pre><p>For more details see <a href=\"https://dart.dev/tools/pub/pubspec#screenshots\">dart.dev/tools/pub/pubspec#screenshots</a>.</p><h3>Automated publishing for pub.dev</h3><p>Thousands of Dart community members publish packages on pub.dev, for the benefit of all Dart and Flutter developers. Traditionally, these package publishers have published to pub.dev by running a local terminal command, dart pub publish, and authenticating with their Google account. Behind the scenes a <em>refresh token</em> was stored in a configuration file on their development machine, which enabled them to publish a new version without authenticating again. This flow is simple and easy to understand, but requires a number of manual steps. We’re happy to introduce a new automated publishing flow, that enables publishing new pub.dev versions directly from a GitHub Action. This has several benefits:</p><ul><li>Each release is automatically tagged with consistent release tags in GitHub</li><li>It’s easy to configure a review and approval flow for publishing new versions.</li><li>The publishing process is authenticated by a token signed by GitHub, ensuring no credentials have to be stored on disk.</li></ul><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*dqxBy1vvLW108xdpqLLZ5Q.png\" /></figure><h4>Making automated publishing secure</h4><p>Currently, some users have resorted to storing the pub-credentials.json configuration file containing the <em>refresh token</em> in a secret environment variable on GitHub Actions. This way, they could write a GitHub Action workflow that recovered the configuration file and used it to publish a new version of the package. While this flow technically works, the tooling wasn’t designed with this in mind and the flow has multiple downsides:</p><ul><li>The pub-credentials.json files can be used to publish any package the author has permission to publish, not just the one package published from the configured flow.</li><li>If leaked, the pub-credentials.json can be used to publish new versions and new packages, impersonating the user who created the pub-credentials.json file.</li><li>The <a href=\"https://myaccount.google.com/permissions\">UI for revoking</a> the <em>refresh token</em> in pub-credentials.json is not easy to find.</li></ul><p>Indeed, it has happened more than once that a package was published and it accidentally included the author’s pub-credentials.json file, because the author extracted the file inside a CI job. Publishing a package along with the credentials required to update the package is a pretty severe security vulnerability and we eventually <a href=\"https://dart.dev/go/false-secrets\">implemented leak detection</a> in dart pub publish.</p><p>Our new automated publishing support mitigates these issues, making it possible to authenticate to pub.dev using one of the following:</p><ul><li>A temporary <a href=\"https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect\">OIDC token signed by Github Actions</a>.</li><li>A GCP service account that can be used from most GCP resources like Google Cloud Build or other cloud environments, such as Azure or AWS.</li></ul><p>These flows enable automated publishing relying on long-lived secret tokens that can easily be abused, if leaked by accident. If deploying your publishing flow to a custom machine, you can, of course, rely on exported service account keys, but great care must be taken to properly secure such keys.</p><h4>Enabling secure publishing</h4><p>You can enable automated publishing from GitHub with just a few steps — see <a href=\"http://dart.dev/go/automated-publishing\">dart.dev/go/automated-publishing</a> for all the details.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9bceb19edf79\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/screenshots-and-automated-publishing-for-pub-dev-9bceb19edf79\">Screenshots and automated publishing for pub.dev</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2023-08-16T18:00:21.000Z":{"title":"Dart 3.1 & a retrospective on functional style programming in Dart 3","link":"https://medium.com/dartlang/dart-3-1-a-retrospective-on-functional-style-programming-in-dart-3-a1f4b3a7cdda?source=rss----23738d481ce8---4","guid":"https://medium.com/p/a1f4b3a7cdda","category":["dartlang","announcements","dart","releases","functional-programming"],"dc:creator":"Marya Belanger","pubDate":"Wed, 16 Aug 2023 18:00:21 GMT","atom:updated":"2023-08-16T18:00:20.900Z","content:encoded":"<h4>Pattern matching and exhaustive switches come together to enable functional style data models that blend seamlessly with Dart’s object-oriented core.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*IWd8aRO__OzDkJVsjfoe2A.png\" /><figcaption>Diff of a Dart 3 refactor using functional style features within Dart’s internal code base</figcaption></figure><p><em>Today we’re releasing Dart 3.1, our first stable release since the major </em><a href=\"https://medium.com/dartlang/announcing-dart-3-53f065a10635\"><em>Dart 3.0</em></a><em> release in May. Dart 3.1 contains a handful of minor updates and a few API adjustments to further use class modifiers introduced in 3.0 (which you can read more about in the </em><a href=\"https://github.com/dart-lang/sdk/blob/main/CHANGELOG.md#310\"><em>changelog</em></a><em>). Mostly, though, we’ve been spending our time on new roadmap items that we hope to see reach beta and stable over the coming releases. Stay tuned for more about that in the future!</em></p><p><em>So, in place of a traditional release post, we’re revisiting a subset of Dart 3’s major features to talk about how they can completely change, and in some cases, greatly improve the way you write and structure your Dart code.</em></p><h3>How do you model data?</h3><p>Object-oriented (OO) and functional languages differ in many ways, but it’s arguable that <em>how each paradigm models data</em> is the defining characteristic that separates them. Specifically, the question of modeling different variations of related data and the operations on those variants.</p><p>But <em>“how should I model this data?”</em> is usually not something we consciously give much thought to when starting a new project. We tend to default to whatever data modeling paradigm is common to the type of language we’re using, as opposed to the inverse of choosing the language based on the model that makes the most sense for our data.</p><p>If you’re using an OO language, you’ll model data with class hierarchies and operations on subtypes. If you’re using certain functional languages, the equivalent to the class hierarchy model is the <a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\">algebraic data type</a> model, whose equivalent to operating on subtypes is switching over them with <a href=\"https://en.wikipedia.org/wiki/Pattern_matching\">pattern matching</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*mA116alArq7XKrm_PSCjyw.png\" /><figcaption>Simplified side-by-side comparison of the object-oriented class hierarchy model and the functional algebraic data type model</figcaption></figure><p>Dart is an object-oriented language, but has been steadily incorporating functional features over time, allowing for a more multi-paradigm approach to data modeling. Most recently, Dart 3 added <a href=\"https://dart.dev/language/patterns\">pattern matching</a>, new functionality on <a href=\"https://dart.dev/language/patterns#switch-statements-and-expressions\">switch</a>, and <a href=\"https://dart.dev/language/class-modifiers#sealed\">sealed types</a>. These features make it possible to implement algebraic data types in Dart, allowing you to write functional style code while continuing to maximize the capabilities of Dart’s object-oriented core.</p><p>Multi-paradigm languages like Dart give you the tools and the opportunity to choose how you design anything from a single line expression, to entire class hierarchies. You can consider which model makes the most sense for your project, or even just for your personal preference. To help you make the best decision, this article summarizes the structure and strengths of each paradigm separately, and then teaches you how to use new features in Dart 3 to refactor some classic object-oriented designs that most benefit from being written in a functional style.</p><h4>Object-oriented approach</h4><p>When you have operations specific to different data types, the standard organization approach in OO languages is to create a method on a base class, and a set of subclasses that override the base class to define their unique behavior. Each subclass has its data and operations together in one place inside its declaration.</p><p>Take this (high-level pseudocode) example of modeling recipes. It makes sense to have recipe objects, coupling ingredients and steps together with the recipe. The recipe base class would probably have some functions for the cooking methods that each recipe overrides with their unique requirements:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/3a6f22bcd1ef1ff84f0fe4b47689a631/href\">https://medium.com/media/3a6f22bcd1ef1ff84f0fe4b47689a631/href</a></iframe><p>Class hierarchies with instance methods make it easy to add new subclasses without having to touch any existing code. This works perfectly for some domains, like Flutter, where you have countless widgets that all extend the Widget class. Each widget can uniquely extend and override any necessary behavior directly inside their definition. You <em>definitely</em> don’t need to know how every widget subtype defines its methods to add specialized behavior to your own widgets.</p><h4>Functional approach (algebraic data types)</h4><p>You can think of functional style architecture as the inverse of OO architecture. Instead of having all the code for <em>one type in one place</em> (OO instance methods in subclass declarations), you have all the code for <em>one operation in one place</em> (functional switching over types to define behavior).</p><p>Which begs the question, when <em>does</em> it make sense to know how every subtype in a hierarchy defines an operation? It could be for a few reasons:</p><ul><li>When adding, maintaining, and understanding variants of the same operation’s behavior across types is easier to do when they’re all side by side in the code.</li><li>When you can’t modify the subclasses yourself, but you want to define new behavior that is specific to each of them.</li><li>When the variations of an operation’s behavior for different types are more related to each other than they are to the types that they’re operating on<em>.</em></li></ul><p>Sometimes it’s obvious, but mostly it’s just a perspective shift. Think about the recipe example again. From the point of view of, say, an oven manual, it would make a lot more sense to group bake instructions together in one place for each recipe:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/fce49155327bfd44fd1f78a4ca589728/href\">https://medium.com/media/fce49155327bfd44fd1f78a4ca589728/href</a></iframe><p>In this example, the program structure is focused on the bake operation. Whatever types bake operates on are simply different possible outputs of the same function; bake is independent of the types it operates on.</p><p>This is the <strong>algebraic data type model </strong>(named “algebraic” after mathematical set theory). It’s the core organizational model of functional languages, in the same way class hierarchies are core to OO languages. Algebraic data types separate behavior from data by grouping behavior for all types together by operation.</p><p>And now, it’s possible to cohesively implement algebraic data types with Dart 3!</p><h3>Modeling object oriented algebraic data types</h3><p>Functional languages generally implement <a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\">algebraic data types</a> by pattern matching over the cases in a <a href=\"https://en.wikipedia.org/wiki/Tagged_union\">sum type</a> to assign behavior to each variant. Dart 3 achieves the same with <a href=\"https://dart.dev/language/patterns#switch-statements-and-expressions\">pattern matching</a> in switch cases, and takes advantage of the fact that OO subtyping already naturally models sum types. This allows us to implement truly <a href=\"https://dart.dev/language/patterns#algebraic-data-types\">multi-paradigm algebraic data types</a> using objects that blend into Dart seamlessly.</p><p>The following sections show you how to design algebraic data type models in Dart, alongside pre-Dart 3 examples of the same functionality.</p><ul><li>First, we’ll explain how to group type-based variants of an operation together by switching over <a href=\"https://dart.dev/language/pattern-types#object\">object patterns</a>.</li><li>Then, we’ll take a step back and look at how to architect the subclasses themselves with the new <a href=\"https://dart.dev/language/class-modifiers#sealed\">sealed</a> class modifier, to ensure the switch defines behavior for <a href=\"https://dart.dev/language/branches#exhaustiveness-checking\">all possible subtypes the object might take</a>.</li></ul><h4>Grouping behaviors across types</h4><p>Individual parts of the Dart language (like statements, classes, and literals) each have their own definitions in class hierarchies, but are all subject to operations from multiple systems (such as parser, formatter, and compiler operations). Imagine how confusing the language implementation would be if every function that applied to every language element had to be defined inside those elements’ declarations! It would look something like this:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ffb98bc8686a75e1c08e1459a68267a0/href\">https://medium.com/media/ffb98bc8686a75e1c08e1459a68267a0/href</a></iframe><p>Dart’s internal code already naturally leans towards the functional approach of separating functions from type definitions for this reason. Take the <a href=\"https://github.com/dart-lang/sdk/blob/main/pkg/analyzer/lib/src/error/annotation_verifier.dart\">annotation_verifier</a> library in Dart’s analyzer. It contains functions that define behavior for annotations (like @override or @deprecated) depending on the part of code the annotation is attached to (like how @override affects a class as opposed to a field).</p><p>But assigning behavior per type is not as straightforward as making the decision to separate the behavior out in the first place. The standard way to define behaviors by type uses chained if-else statements, which you see a lot in the annotation verifier. Take the following verification function written without using any Dart 3 features. It verifies the behavior of the <a href=\"https://github.com/dart-lang/sdk/commit/4079a47cc4fb8f88e2dd9b7faff3bd587931a379\">recently contributed</a> @visibleOutsideTemplate annotation that opts out of the cascading effects of another annotation, @visibleForTemplate:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/a3c434f36ddd91f30755438674324b2b/href\">https://medium.com/media/a3c434f36ddd91f30755438674324b2b/href</a></iframe><p>The function uses elaborate chained if-else statements, testing whether the grandparent of the annotation is a certain kind of declaration (either ClassDeclaration, EnumDeclaration, or MixinDeclaration), and then defining its behavior based on the type.</p><p>With Dart 3, you can use object patterns in switch cases to significantly refactor this structure to a more declarative style, making it shorter and easier to read. And the original author <a href=\"https://github.com/dart-lang/sdk/blob/4079a47cc4fb8f88e2dd9b7faff3bd587931a379/pkg/analyzer/lib/src/error/annotation_verifier.dart#L417-L426\">did just that</a>! 16 lines of chained if-else statements are pared down to a 7-line switch statement:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/80466ddfaaece549a847e51911950a0b/href\">https://medium.com/media/80466ddfaaece549a847e51911950a0b/href</a></iframe><p>Each case here is an <a href=\"https://dart.dev/language/pattern-types#object\">object pattern</a> that matches against the static type of grandparent. Instead of saying if (object is Type &amp;&amp; object.property != null), each case checks if the object’s pattern matches the pattern Type(propertyOfType). Plus, when an object matches an object pattern, it implicitly requires that it’s not null, so there’s no need for an explicit null check!</p><p>Object patterns can also contain nested <a href=\"https://dart.dev/language/pattern-types#variable\">variable patterns</a> that allow you to extract (or <a href=\"https://dart.dev/language/patterns#destructuring\"><em>destructure</em></a>) property values from an object in the same line of code you’re matching against. The syntax (:var metadata) just means “match and declare a new variable with the same name as this getter”. This is how the variable metadata comes into scope for the final for loop. Pretty concise!</p><p>Notice that the for loop is now common between each case. Each type’s declaredElement property is actually a different subtype of another type, InterfaceElement (either a classElement, enumElement, or mixinElement). So, the pre-Dart 3 chained if-else statement iterated over metadata in each if clause separately, to ensure final annotation would be type safe for each of the possible types that metadata could take.</p><p>Now, the refactored structure uses deeply nested object patterns for each case, to upcast metadata to its supertype, InterfaceElement. This makes a single shared for loop iterating over metadata type safe across the cases.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/986/1*qYQb8DZyeJDFD-VKEb4P6Q.png\" /><figcaption>Annotated depiction of the syntax for a deeply nested object and variable patterns</figcaption></figure><p>Switching over object patterns matters to Dart’s algebraic data type implementation because of its ability to concisely test subtypes and destructure values. A nice side effect is the simultaneous assurances that can be provided by a single line of code. To reiterate, each case pattern in this refactor is simultaneously verifying:</p><ul><li>The object is one of the types ClassDeclaration, EnumDeclaration, or MixinDeclaration.</li><li>The object has the property declaredElement.</li><li>declaredElement has the property metadata.</li><li>metadata is of type InterfaceElement.</li><li>None of the objects or properties in question are null.</li></ul><p>This is the perfect example of how thoroughly Dart 3 implements patterns to account for so many nuances of OO languages, and really make object-oriented algebraic data types a realistic design option in Dart.</p><p>Type tests over object patterns are great for separating behavior from types. But its missing one feature of OO subtyping, where the compiler lets you know if you declare a new subtype but don’t define behavior for one of its supertype’s abstract methods. How can Dart’s algebraic data type model implement the same safety assurances when we’re no longer dealing with instance methods on type declarations? The answer is <em>exhaustiveness checking</em>.</p><h4>Exhaustiveness checking</h4><p>Functional languages’ implementations of algebraic data types use enumerable sum types, which means the compiler is always aware of all the possible variations of the type being switched over. The compiler can then let you know if your switch is missing a case, and therefore that it’s possible some values might fall through that switch without being addressed.</p><p>This is called <a href=\"https://dart.dev/language/branches#exhaustiveness-checking\">exhaustiveness checking</a>. It has technically always existed in Dart for enumerable types like enums and booleans. Those types have a set of possible values that cannot change, and if you’re switching over them, the compiler knows when you’ve missed one and warns you. Using a default clause is another kind of pseudo exhaustiveness. Since default matches all cases not explicitly accounted for, it causes the compiler to consider a switch exhaustive without knowing if all potential types are actually accounted for.</p><p>As mentioned, we wanted to use subtypes instead of sum types for Dart’s version of algebraic data type modeling. But since classes in Dart can be extended from any library, it would be impossible for the compiler to exhaustively enumerate subtypes of a class since it can’t know if any subclasses are declared in external libraries.</p><p>To get around this and complete Dart’s algebraic data type implementation, we added the <a href=\"https://dart.dev/language/class-modifiers#sealed\">sealed class modifier</a> to Dart 3. A sealed class cannot be extended or implemented from any library but its own (<a href=\"https://dart.dev/language/libraries\">the file that contains its definition</a>). This ensures the compiler is always aware of any and all possible subtypes, making them fully enumerable.</p><p>Here’s an example of an actual refactor that went into the Dart SDK as part of the 3.1 release: <a href=\"https://github.com/dart-lang/sdk/commit/c3e815bc7ad488eddf00344ab4106485a9d1ba32#diff-e98c6de423bf7e0b5b961cd10efed50330004229243aa87c18ad6314fef054b0L879-R879\">sealing </a><a href=\"https://github.com/dart-lang/sdk/commit/c3e815bc7ad488eddf00344ab4106485a9d1ba32#diff-e98c6de423bf7e0b5b961cd10efed50330004229243aa87c18ad6314fef054b0L879-R879\">FileSystemEvent</a> so its subtypes can be exhaustively switched over. Brace yourself, refactors are hard…</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/ebbec98bf5109bbc14be7867a3b4c117/href\">https://medium.com/media/ebbec98bf5109bbc14be7867a3b4c117/href</a></iframe><p>Just kidding, that wasn’t hard at all! It should be noted, though, that sealing an existing class hierarchy is a breaking change. Code targeting older versions of Dart won’t be able to implement or extend the class, so always check dependencies and alert any users that might be subtyping your classes elsewhere.</p><p>Sealing FileSystemEvent allows the events produced by FileSystemEntity.watch, which correspond to the subtypes of FileSystemEvent, to be exhaustively switched over. It’s typical to listen to this stream of events and use <a href=\"https://github.com/dart-lang/sdk/issues/52273\">chained </a><a href=\"https://github.com/dart-lang/sdk/issues/52273\">if-else</a> statements to determine an action based on the type of the events that occur.</p><p>But sealing the base class doesn’t only allow you to switch over object patterns, like the _checkVisibleOutsideTemplate example in the previous section. It also ensures that while doing so, you’re accounting for every possible value that could arise for that type, without the need for a default case:</p><iframe src=\"\" width=\"0\" height=\"0\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/9618c7e18185c98dcb4e4cf9968759f9/href\">https://medium.com/media/9618c7e18185c98dcb4e4cf9968759f9/href</a></iframe><p>If a new subtype was ever added that extends FileSystemEvent, perhaps FileSystemSyncEvent for example, the compiler would be aware of it because it could only be added to the <a href=\"https://github.com/dart-lang/sdk/blob/main/sdk/lib/io/file_system_entity.dart\">same library</a> as FileSystemEvent. Since the class hierarchy is sealed, the compiler requires any switch over its instances to be exhaustive, and will generate <a href=\"https://dart.dev/tools/diagnostic-messages#non_exhaustive_switch_expression\">an error</a> to alert the user (who wrote the switch, not the library owner) of unhandled cases:</p><pre>The type &#39;FileSystemEvent&#39; is not exhaustively matched by the switch cases since it doesn&#39;t match &#39;FileSystemSyncEvent&#39;</pre><p>Combining sealed classes and switches over object patterns enables a complete, object-oriented algebraic data type style of program architecture in Dart.</p><h4>Bonus functional features</h4><p>The exhaustive switch example above includes even more functional features from Dart 3 than just the ones that facilitate algebraic data types.</p><p>Notice that the switch is to the right of the _fileListener function’s return statement—that’s Dart 3’s new <a href=\"https://dart.dev/language/branches#switch-expressions\">switch expression</a>. General emphasis on expressions and functions is a key element of functional languages. Dart 3 made switch expressions that can produce a value and go anywhere an expression is allowed.</p><p>And what is _fileListener returning in the previous example, anyway? That’s a <a href=\"https://dart.dev/language/records\">record</a>, another new Dart 3 feature also related to functional programming. Records let you return multiple heterogeneous values from a function, extending the usefulness of functions in Dart, and moving further away from reliance on custom classes (which would be the only other way to return multiple values of different types without losing their types in the process).</p><h3>Summary</h3><p>You can model algebraic data types in Dart by:</p><ul><li>Writing a function that switches <em>on</em> an instance of a sealed class, and <em>over</em> its subtypes,</li><li>And defining variances in the behavior of each subtype in the switch cases.</li></ul><p>Switching over object patterns allows you to keep all the operations together in a succinct way, and exhaustiveness checking ensures the compiler will alert you if you’re missing behavior definitions for any types. And it’s all built on top of the object-oriented classes Dart already uses.</p><p>The best part is, you don’t have to pick either an object-oriented or functional style; the two paradigms blend together and you can use whichever style best fits the operation you’re defining.</p><p>You can make existing class hierarchies more functional with minor modifications, and even mix the use of instance methods with algebraic data types within the same class hierarchy. Whether it makes sense to couple behavior closely to a type, or group behavior for different types in one function, you can use the style that makes the most sense.</p><p>We hope this introduction piques your interest in functional programming and trying out the new Dart 3 features. Who knows, maybe we’ll see the first fully-functional-style Dart program from one of you soon!</p><h4>Resources</h4><p><em>To learn more about functional programming in and around Dart, check out these resources:</em></p><ul><li>The official Dart documentation on <a href=\"https://dart.dev/language/patterns\">patterns</a> and <a href=\"https://dart.dev/language/branches#exhaustiveness-checking\">exhaustiveness checking</a>.</li><li>The <a href=\"https://codelabs.developers.google.com/codelabs/dart-patterns-records#0\">patterns and records codelab</a> about refactoring Flutter code with Dart 3.</li><li>This <a href=\"https://www.droidcon.com/2023/08/07/the-joy-of-functional-programming-in-dart/\">community talk</a> from FlutterCon about functional programming in Dart.</li><li>This <a href=\"https://journal.stuffwithstuff.com/2023/08/04/representing-heterogeneous-data/\">blog post</a> about modeling heterogeneous data from the personal blog of Bob Nystrom (who wrote <a href=\"https://github.com/dart-lang/language/blob/main/accepted/3.0/patterns/feature-specification.md\">the design for patterns in Dart</a>!).</li></ul><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a1f4b3a7cdda\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-3-1-a-retrospective-on-functional-style-programming-in-dart-3-a1f4b3a7cdda\">Dart 3.1 &amp; a retrospective on functional style programming in Dart 3</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2023-06-12T21:38:43.000Z":{"title":"Dart DevTools: Analyzing application performance with the CPU Profiler","link":"https://medium.com/dartlang/dart-devtools-analyzing-application-performance-with-the-cpu-profiler-3e94a0ec06ae?source=rss----23738d481ce8---4","guid":"https://medium.com/p/3e94a0ec06ae","category":["dart","flutter","dart-devtools","flutter-devtools","cpu-profiling"],"dc:creator":"Ben Konyi","pubDate":"Mon, 12 Jun 2023 21:38:43 GMT","atom:updated":"2023-06-13T14:44:08.831Z","content:encoded":"<p>Whether you’re a backend developer writing a command line tool using Dart, or a UX engineer building applications with Flutter, program performance is critical to the success of your project. Command line tools should minimize latency and apps should be responsive and snappy with no dropped frames. As developers, we try our best to write performant code but sometimes it’s not clear why our code isn’t performing as well as we would expect.</p><p>Tracking down performance issues in a code base can be a daunting task. There are multiple ways to write Flutter code such that it runs slower than it should. Some are glaringly obvious and others nefariously subtle. For example, perhaps you used the wrong API or data structure for a particular situation.</p><p>This article works through a simple case study examining the performance of a slow Dart command-line interface (CLI) application. You’ll learn about:</p><ul><li>General CPU profilers and their importance.</li><li>The sampling CPU profiler that ships with Dart and Flutter.</li></ul><p>With this new understanding of CPU profiling, we’ll debug the performance of our program. We’ll do so using the Dart DevTools CPU Profiler and dart:developer’s UserTag functionality to pinpoint the inefficient code. We’ve got lots to cover, so let’s get started!</p><p><em>Note: Dart DevTools is also referred to as Flutter DevTools, but shouldn’t be confused with Chrome DevTools.</em></p><h3>Case Study: Implementing grep in Dart</h3><p>Consider the following simple Dart CLI application:</p><pre><br>// filename: grep.dart<br>import &#39;dart:io&#39;;<br><br>/// Finds and prints all instances of [pattern] in the [file].<br>void grep(File file, String pattern) {<br>  // Open the file and read its contents.<br>  final lines = file.readAsLinesSync();<br><br>  String output = &#39;&#39;;<br>  int lineNum = 1;<br>  // Check each line to see if it matches `pattern`.<br>  for (final line in lines) {<br>    final matcher = RegExp(pattern);<br>    if (matcher.hasMatch(line)) {<br>      final foundMessage = &#39;$lineNum:$line&#39;;<br>      output += foundMessage;<br>    }<br>    lineNum++;<br>  }<br>  stdout.writeln(output);<br>}<br><br>void main(List&lt;String&gt; arguments) { <br>  if (arguments.length != 2) {<br>    print(&#39;Usage: dart grep.dart &lt;path&gt; &lt;pattern&gt;&#39;);<br>    exitCode = 64;<br>    return;<br>  }<br>  final path = arguments[0];<br>  final pattern = arguments[1];<br><br>  final file = File(path);<br>  if (!file.existsSync()) {<br>    stderr.writeln(&quot;Error: unable to open file &#39;$path&#39;&quot;);<br>    exitCode = 64;<br>    return;<br>  }<br><br>  grep(file, pattern);<br>}</pre><p>The grep.dart program implements a version of the common Unix tool. It allows users to search files for the occurrence of a string of characters that matches a specified pattern. For example, given a file names.txt containing:</p><pre>$ cat names.txt<br>Frank<br>Bob<br>Franny<br>June<br>Ben<br>Francis</pre><p>Let’s find all lines containing the string &#39;Fran&#39;:</p><pre>$ dart grep.dart names.txt &#39;Fran&#39;<br>1:Frank<br>3:Franny<br>6:Francis</pre><p>Excellent! We should expect this output from grep. That said, names.txt is a <em>small</em> file. Let’s try and find all the instances of &#39;Hummingbird&#39; in a larger text document. What if we ran the same program on a 437,000 line, 147 MiB file about hummingbirds?</p><pre>$ dart grep.dart hummingbird_encyclopedia.txt &#39;Hummingbird&#39;</pre><p>Huh… it doesn’t complete, even after <strong>two minutes</strong>. How does Unix grep perform?</p><pre>$ grep -n &#39;Hummingbird&#39; hummingbird_encyclopedia.txt<br>16:&#39;&#39;&#39;Hummingbirds&#39;&#39;&#39; are [[bird]]s native to the…<br>22:Hummingbirds have the highest…<br>24:Hummingbirds split from their [[Sister taxon|sister group]]…<br>// Output continues</pre><p>Unix’s grep searched the entire file and returned all lines containing Hummingbird in about 45 seconds. Clearly there’s something strange in our code that we should investigate. But how can we identify the cause of our performance issues? The <strong>CPU Profiler</strong> shipped with Dart DevTools is a great place to start!</p><h3>What is a CPU profiler?</h3><p>CPU profiling tools track where a program spends its time when executing. To provide the most computationally efficient CPU profiling experience, the Dart virtual machine (VM), powering Dart CLI and Flutter applications, uses a <strong>sampling</strong> CPU profiler. When used with tools like Dart DevTools, you can identify performance bottlenecks in Dart programs.</p><p>A sampling CPU profiler takes a statistical approach to collecting application performance data. It collects samples by interrupting threads at regular intervals and taking a snapshot of the current call stack and other relevant execution state. These samples can be processed to gain insights into approximately how much time is spent executing specific functions, and how frequently functions appear on different call stacks.</p><p>The frequency that samples are collected is known as the <strong>sampling rate</strong> and is measured in samples per second (otherwise known as hertz or Hz). Most sampling profilers have sampling rates of 1000 Hz or higher. Higher sampling rates result in more detailed CPU profiles, at the expense of higher sampling overhead in the target process. At reasonable sampling rates, sampling CPU profilers are efficient and have little to no impact on the performance characteristics of the profiled application. As an added bonus, the collected data is typically less computationally expensive to process for analysis when compared to tracing profilers.</p><h3>Deep Dive: How does a sampling profiler work?</h3><p><em>This section goes into detail about how the Dart VM’s sampling CPU profiler works. You don’t need to know these details when analyzing CPU profiles. If you don’t care about the nitty gritty details of sampling CPU profilers, skip this section.</em></p><p>The Dart VM’s sampling CPU profiler has three important components: the thread interrupter, the sample collector, and the sample processor.</p><h4>Thread Interrupter</h4><p>The <a href=\"https://github.com/dart-lang/sdk/blob/main/runtime/vm/thread_interrupter.cc\"><strong>thread interrupter</strong></a> runs on a dedicated thread and triggers the CPU sample collection on each thread that the VM manages. The thread interrupter is typically inactive, only waking up once per sampling interval. After each sampling interval, the interrupter iterates over the list of threads, informing each thread that it should pause and collect a sample. The thread interrupter has slightly different behavior on different platforms due to operating system specific details.</p><p>On most platforms which support <a href=\"https://en.wikipedia.org/wiki/Signal_(IPC)\">signal-based control flow</a> (Android and Linux), the <a href=\"https://www.gnu.org/software/libc/manual/html_node/Alarm-Signals.html\">SIGPROF</a> signal is sent to each thread. This triggers an <a href=\"https://en.wikipedia.org/wiki/Interrupt\">interrupt</a> that invokes a signal handler registered by the CPU profiler on the target thread that then collects the CPU sample before resuming its work.</p><p>On other platforms which don’t support signals (Windows and Fuchsia) or have poor performance in some situations when using SIGPROF (MacOS and iOS), the thread interrupter uses system calls to explicitly pause and resume each thread after collecting the CPU sample. In this case, sample collection is done on the thread interrupter thread rather than on the thread being sampled.</p><h4>Sample collection</h4><p>Once a thread has been interrupted, the CPU profiler <a href=\"https://github.com/dart-lang/sdk/blob/bbacf39e9c1085650b5f2a180285792ad0dd76d9/runtime/vm/profiler.cc#L1311\">collects a sample</a> of the thread’s current execution state. Each <a href=\"https://github.com/dart-lang/sdk/blob/bbacf39e9c1085650b5f2a180285792ad0dd76d9/runtime/vm/profiler.h#L195\">sample</a> includes metadata such as:</p><ul><li>thread and isolate identifiers</li><li>active <a href=\"https://api.dart.dev/stable/dart-developer/UserTag/UserTag.html\">user tag</a> for the thread</li><li>collection timestamps</li><li>current stack trace of the sampled thread</li></ul><p>The collected stack trace consists of a list of program counters (PCs), which correspond to the return addresses of each Dart and native function found on the stack. These PCs are collected through a process known as “walking the stack”. While performing a <a href=\"https://github.com/dart-lang/sdk/blob/bbacf39e9c1085650b5f2a180285792ad0dd76d9/runtime/vm/profiler.cc#L208\">stack walk</a>, the stack walker uses the top frame’s frame pointer (FP) and the known layout of each stack frame to find and record the PC associated with the function as well as the FP of the previous stack frame. The stack walker repeats this process, using the previous frame’s FP as a starting point, until it reaches the end of the stack as shown in Figure 1.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*manGRq62JBgJER8ufYlAfA.png\" /><figcaption><strong><em>Figure 1: An example of stack trace collection on an ARM64 system. The stack walker starts at </em></strong><strong><em>FP(N+1), retrieves the program counter (PC) from address FP(N+1) + 0x10, and adds it to the stack trace as Frame 0. The stack walker then looks up FP(N) from address FP(N+1) + 0x8, repeating the same procedure using FP(N) to look up details for Frame 1.</em></strong></figcaption></figure><p>Each collected sample is stored in the VM’s sample buffer, a <a href=\"https://en.wikipedia.org/wiki/Circular_buffer\">circular buffer</a> that can store a limited number of CPU samples. This allows for the VM to avoid the need for additional allocations at runtime, which can negatively impact performance or <a href=\"https://en.wikipedia.org/wiki/Signal_(IPC)#Risks\">cause bad things to happen if done in the signal handler</a>.</p><p>The size of the sample buffer is fixed at runtime and, once full, old samples will be overwritten with new samples by the profiler. The rate at which the sample buffer fills up depends on the sampling rate and average stack depth of each sample. For example, higher sampling rates and deeper stacks cause the buffer to wrap around more quickly. In DevTools, developers can control how quickly the sample buffer wraps around by <a href=\"https://docs.flutter.dev/tools/devtools/cpu-profiler#cpu-sampling-rate\">choosing</a> between low (1000 Hz), medium (4000 Hz), and high (20,000 Hz) sampling rates.</p><h4>Sample processing</h4><p>When a client sends a request for a CPU sample profile via the <a href=\"https://github.com/dart-lang/sdk/blob/main/runtime/vm/service/service.md#getcpusamples\">VM service protocol</a>, the CPU profiler needs to process the collected samples before sending them to the client. The profiler:</p><ol><li>Iterates over the sample buffer, using filters to only retrieve samples for the isolate and time period specified by the client.</li><li><em>Symbolizes</em>, or maps PCs to function names, each stack frame in the set of samples.</li><li>Serializes the entire processed sample buffer to JSON.</li><li>Sends the JSON back to the client.</li></ol><p>Even after processing done by the profiler, the <a href=\"https://github.com/dart-lang/sdk/blob/main/runtime/vm/service/service.md#cpusamples\">CPU samples response</a> is low-level and requires additional processing by developer tooling to be useful. For example, Dart DevTools can convert the list of CPU samples into various structural representations that allow for identifying expensive functions (<a href=\"https://docs.flutter.dev/tools/devtools/cpu-profiler#bottom-up\">Bottom Up</a>) and costly call paths (<a href=\"https://docs.flutter.dev/tools/devtools/cpu-profiler#call-tree\">Call Tree</a> and <a href=\"https://docs.flutter.dev/tools/devtools/cpu-profiler#flame-chart\">CPU Flame Chart</a>), and inspecting caller and callee statistics (<a href=\"https://docs.flutter.dev/tools/devtools/cpu-profiler#method-table\">Method Table</a>) for individual methods.</p><h3>Using Dart DevTools to Profile Dart and Flutter Applications</h3><p>Now that you’re familiar with what sampling CPU profilers are and how they work, let’s debug the performance of our grep implementation. Let’s run the code again with --observe and open up the Dart DevTools CPU Profiler tab:</p><p><strong><em>Note:</em></strong><em> You don’t need to use the </em><em>--observe flag when testing a Flutter app in DevTools.</em></p><pre>$ dart — observe grep.dart hummingbird_encyclopedia.txt &#39;Hummingbird&#39;<br>The Dart VM service is listening on http://127.0.0.1:8181/omxEtsCtW9k=/<br>The Dart DevTools debugger and profiler is available at: http://127.0.0.1:8181/omxEtsCtW9k=/devtools?uri=ws://127.0.0.1:8181/omxEtsCtW9k=/ws<br>// At this point, the terminal hangs with no output.</pre><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*4btaxCBW8Btx71RM\" /></figure><p>Yikes! Of all the samples collected in a period of 11.6 seconds, the isolate spent more than 90% of its CPU time executing _StringBase.+. It’s likely that this is related to our performance issues, but it might not be obvious what block of code in our grep function is the source of the slowdown. Luckily, we can further narrow down the location of the expensive calls to _StringBase.+ using <strong>user tags.</strong></p><h3>Categorizing CPU samples with User Tags</h3><p>When the Dart CPU profiler interrupts a thread to collect a new sample, it records the current user tag set for the isolate. The <a href=\"https://api.dart.dev/stable/dart-developer/dart-developer-library.html\">dart:developer</a> library provides the <a href=\"https://api.dart.dev/stable/dart-developer/dart-developer-library.html\">UserTag</a> class that allows you to specify and set custom tags for sections of code that you’re interested in profiling.</p><p>To better understand where we’re spending time in our grep implementation, we can instrument the function with user tags:</p><pre>// filename: grep.dart<br>import &#39;dart:developer&#39;;<br>import &#39;dart:io&#39;;<br><br>/// Finds and prints all instances of [pattern] in the [file].<br>void grep(File file, String pattern) {<br>  final defaultTag = getCurrentTag();<br>  final fileReadTag = UserTag(&#39;File Read&#39;);<br>  final textMatchTag = UserTag(&#39;Text Matching&#39;);<br>  final printTag = UserTag(&#39;Print Output&#39;);<br><br>  // Set the &#39;File Read&#39; tag as the current user tag.<br>  fileReadTag.makeCurrent();<br><br>  // Open the file and read its contents.<br>  final lines = file.readAsLinesSync();<br><br>  // Set the &#39;Text Matching&#39; tag as the current user tag.<br>  textMatchTag.makeCurrent();<br>  String output = &#39;&#39;;<br>  int lineNum = 1;<br>  // Check each line to see if it matches `pattern`.<br>  for (final line in lines) {<br>    final matcher = RegExp(pattern);<br>    if (matcher.hasMatch(line)) {<br>      final foundMessage = &#39;$lineNum:$line&#39;;<br>      output += foundMessage;<br>    }<br>    lineNum++;<br>  }<br><br>  // Set the &#39;Print Output&#39; tag as the current user tag.<br>  printTag.makeCurrent();<br>  stdout.writeln(output);<br><br>  // Reset the user tag to the tag set when grep was invoked.<br>  defaultTag.makeCurrent();<br>}</pre><p>Now, let’s re-run our program and open up the CPU Profiler. To see our categorized profile, select the <strong>Group by: User Tag</strong> option from the dropdown:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*zxcsj31nCh14rLYa\" /></figure><p>When we expand the <strong>Text Matching</strong> tag, we confirm that the _StringBase.+ method is called in our text-matching loop:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*ai9S8-Y8c_94rr6p\" /></figure><p>With this information, we should be able to take a closer look at our code and identify the issue:</p><pre>  // Set the ‘Text Matching’ tag as the current user tag.<br>  textMatchTag.makeCurrent();<br>  String output = &#39;&#39;;<br>  int lineNum = 1;<br>  // Check each line to see if it matches `pattern`.<br>  for (final line in lines) {<br>    final matcher = RegExp(pattern);<br>    if (matcher.hasMatch(line)) {<br>      final foundMessage = &#39;$lineNum:$line&#39;;<br>      // Ahah! This is our call to _StringBase.+!<br>      output += foundMessage;<br>    }<br>    lineNum++;<br>  }</pre><p>There it is! We’ve made the classic mistake of appending content to a <a href=\"https://api.dart.dev/stable/dart-core/String-class.html\">String</a> multiple times rather than using a <a href=\"https://api.dart.dev/stable/dart-core/StringBuffer-class.html\">StringBuffer</a>. Appending content to a String creates a new string to store the result of the _StringBase.+ method. As a result, we copy output + foundMessage into a new string each time we find a match.</p><p>As output gets longer, appending data to it becomes more expensive, taking O(m*n) to perform the copies, where m is the average number of characters in a match and n is the total number of characters in the final string. If we use a StringBuffer, we don’t copy output each time we append to it, instead concatenating the matches in a single O(n) operation at the end of the function.</p><p>Now that our app uses <a href=\"https://api.dart.dev/stable/dart-core/StringBuffer/writeln.html\">StringBuffer.writeln</a> instead of appending to a String, let’s look at our function:</p><pre>// filename: grep.dart<br>import ‘dart:developer’;<br>import &#39;dart:io&#39;;<br><br>/// Finds and prints all instances of [pattern] in the [file].<br>void grep(File file, String pattern) {<br>  final defaultTag = getCurrentTag();<br>  final fileReadTag = UserTag(‘File Read’);<br>  final textMatchTag = UserTag(‘Text Matching’);<br>  final printTag = UserTag(‘Print Output’);<br><br>  // Set the ‘File Read’ tag as the current user tag.<br>  fileReadTag.makeCurrent();<br><br>  // Open the file and read its contents.<br>  final lines = file.readAsLinesSync();<br><br>  // Set the ‘Text Matching’ tag as the current user tag.<br>  textMatchTag.makeCurrent();<br>  final output = StringBuffer();<br>  int lineNum = 1;<br>  // Check each line to see if it matches `pattern`.<br>  for (final line in lines) {<br>    final matcher = RegExp(pattern);<br>    if (matcher.hasMatch(line)) {<br>      final foundMessage = &#39;$lineNum:$line&#39;;<br>      // Add the match to the buffer without creating a copy.<br>      output.writeln(foundMessage);<br>    }<br>    lineNum++;<br>  }<br><br>  // Set the ‘Print Output’ tag as the current user tag.<br>  printTag.makeCurrent();<br>  // output.toString() concatenates each entry in the buffer<br>  // into a new String, only performing a single allocation of<br>  // size `output.length`. <br>  stdout.writeln(output);<br><br>  // Reset the user tag to the tag set when grep was invoked.<br>  defaultTag.makeCurrent();<br>}</pre><p>Let’s run our test again to see if there’s any improvement:</p><pre>$ dart grep.dart hummingbird_encyclopedia.txt &#39;Hummingbird&#39;<br>16:‘’’Hummingbirds’’’ are [[bird]]s native to the…<br>22:Hummingbirds have the highest…<br>24:Hummingbirds split from their [[Sister taxon|sister group]]…<br>// Output continues</pre><p>Using StringBuffer, we can find all the instances of &#39;Hummingbird&#39; in about <strong>45 seconds</strong>. That’s much better and almost the same as the Unix grep implementation! Let’s take another look at the CPU profiler to see if we can improve performance further:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*dL9EpPsSbaU-Bem-\" /></figure><p>A quick glance at the profile tells us that we spend most of our time printing matches and that the actual matching only takes about 200ms. We should focus on the code that falls under the &#39;Print Output&#39; tag:</p><pre>  // Set the ‘Print Output’ tag as the current user tag.<br>  printTag.makeCurrent();<br>  // output.toString() concatenates each entry in the buffer<br>  // into a new String, only performing a single allocation of<br>  // size `output.length`. <br>  stdout.writeln(output);</pre><p>There doesn’t seem much we can do as we are only making a single call to <a href=\"https://api.dart.dev/stable/dart-io/stdout.html\">stdout.writeln</a>, a member of the core <a href=\"https://api.dart.dev/stable/dart-io/dart-io-library.html\">dart:io</a> library. Looking at the <a href=\"https://docs.flutter.dev/tools/devtools/cpu-profiler#flame-chart\">CPU flame chart in the profiler</a>, we see that this code is in the SDK and that we can make no more performance gains in our code.</p><p>With that, we’re done!</p><h3>Summary</h3><p>We’ve accomplished a lot since the beginning of this article. We:</p><ul><li>Wrote a simple grep tool in Dart.</li><li>Identified our program had poor performance.</li><li>Learned about CPU profilers and explored the Dart VM’s sampling CPU profiler.</li><li>Used the Dart DevTools’ <a href=\"https://docs.flutter.dev/tools/devtools/cpu-profiler\">CPU Profiler</a> to identify and fix our program’s performance issues.</li></ul><p>Having a good understanding of performance tooling is an important skill and, as we’ve shown in this article, can help you identify potentially subtle performance issues in your code. The CPU Profiler is only one of many tools shipped with <a href=\"https://docs.flutter.dev/tools/devtools/overview\">Dart DevTools</a> that can help you better understand the behavior and performance of your Dart CLI and Flutter applications.</p><p>In future articles, we’ll explore other ways to use Dart DevTools to debug and optimize your apps, including:</p><ul><li>Analyzing memory usage through the <a href=\"https://docs.flutter.dev/tools/devtools/memory\">Memory</a> screen</li><li>Examining execution timelines through the <a href=\"https://docs.flutter.dev/tools/devtools/performance\">Performance</a> screen</li><li>Inspecting HTTP traffic through the <a href=\"https://docs.flutter.dev/tools/devtools/network\">Network</a> screen</li></ul><p>Until then, happy hacking!</p><p><em>If you feel so inclined, </em><a href=\"https://github.com/bkonyi\"><em>follow me on GitHub</em></a><em> to keep up with my work on Flutter and the Dart virtual machine, as well as my other pet projects.</em></p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3e94a0ec06ae\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-devtools-analyzing-application-performance-with-the-cpu-profiler-3e94a0ec06ae\">Dart DevTools: Analyzing application performance with the CPU Profiler</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2023-05-10T13:35:19.000Z":{"title":"Announcing Dart 3","link":"https://medium.com/dartlang/announcing-dart-3-53f065a10635?source=rss----23738d481ce8---4","guid":"https://medium.com/p/53f065a10635","category":["dartlang","dart","releases"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 10 May 2023 13:35:19 GMT","atom:updated":"2023-05-10T19:53:24.414Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<h4>100% sound null safety. Records, patterns, and class modifiers. And a peek into the future.</h4><p>Hello from Google I/O 2023. Today, live from Mountain View, we’re announcing Dart 3 — the largest Dart release to date! Dart 3 contains three major advancements. First, we’ve completed the journey to 100% sound null safety. Second, we’ve added major new language features for records, patterns, and class modifiers. Third, we’re giving a preview of the future, where we broaden our platform support with native code for the web via Wasm compilation. Let’s get into the details.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*2XwxNKHrKb3SGaWEyqg2nA.png\" /></figure><h3>100% sound null safety</h3><p>Over the last four years, we’ve evolved Dart into a fast, portable, and modern language. Now with Dart 3, it is a 100% sound null safe language! As we’ve <a href=\"https://medium.com/dartlang/the-road-to-dart-3-afdd580fbefa\">discussed before</a>, we don’t believe any other programming language has ever added sound null safety to an existing language. So, it’s been quite a journey.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/960/1*KPbxBAjFYPCSk2OqwjKs7A.png\" /></figure><p>With 100% null safety in Dart, we have a <em>sound</em> type system. You can trust that if a type says a value isn’t null, then it never can be null. This avoids certain classes of coding errors, like null pointer exceptions. It also allows our compilers and runtimes to optimize code in ways it couldn’t without null safety. This design choice involved a tradeoff. Though migrations became a bit harder, we believe we made the right choice for Dart.</p><h4>Migrating to Dart 3</h4><p>A critical part in achieving sound null safety has been the unwavering support from the Dart community: 99% of the top 1000 packages on pub.dev support null safety!</p><p>Given this, we expect the vast majority of packages and apps that have been migrated to null safety to work with Dart 3. In just a few cases, a smaller amount of related cleanup in Dart 3 might impact some code. Some legacy core library APIs have been removed (<a href=\"https://github.com/dart-lang/sdk/issues/34233\">#34233</a>, <a href=\"https://github.com/dart-lang/sdk/issues/49529\">#49529</a>) and some tools have been adjusted (<a href=\"https://github.com/dart-lang/sdk/issues/50707\">#50707</a>). Should you experience any issues migrating to using the Dart 3 SDK, please consult the <a href=\"https://dart.dev/resources/dart-3-migration\">Dart 3 migration guide</a>. Other than that, we hope you’ll enjoy the new rationalized core libraries and tools.</p><h3>Major language features — Record, patterns, and class modifiers</h3><p>Dart 3 isn’t just about changing the existing language. It’s also about adding significant new features and capabilities! These include records, patterns, and class modifiers.</p><h4>Building up structured data with records</h4><p>Traditionally, a Dart function could only return a single value. As a result, functions that needed to return multiple values had to either package these into other data types such as maps or lists or to define new classes that could hold the values. Using untyped data structures weakened type safety. Having to define new classes just to carry data adds friction during the coding process. You made this pretty clear to us: the language request for multiple return values is our <a href=\"https://github.com/dart-lang/language/issues?q=is%3Aissue+sort%3Areactions-%2B1-desc+\">fourth highest rated</a> issue.</p><p>With records, you can build up structured data with a nice and crisp syntax. Consider this function. It reads out the name and age of a JSON blob and returns them both in a record:</p><pre>(String, int) userInfo(Map&lt;String, dynamic&gt; json) {<br>  return (json[&#39;name&#39;] as String, json[&#39;height&#39;] as int);<br>}</pre><p>This should look familiar to all Dart developers. A record looks like a list literal such as [‘Michael’, ‘Product Manager’] but uses parentheses instead of brackets. In Dart, records are a general feature. They can be used for more than function return values. You also store them in variables, put them into a list, use them as keys in a map, or create records containing other records. You can add both unnamed fields, like we did in the prior example, and named fields like (42, description: ‘Meaning of life’).</p><p>Records are value types and don’t have an identity. This enables our compilers to completely erase the record object in some cases. Records also come with an automatically defined == operator and hashCode functions. The <a href=\"https://dart.dev/language/records\">records documentation</a> has more details.</p><h4>Working with structured data with patterns and pattern matching</h4><p>Records simplify how you build up structured data. This does not replace using classes to build up more formal type hierarchies. It just offers another option. In either case, you might want to break that structured data into its individual elements to work with them. This is where pattern matching comes into play.</p><p>Consider a basic form of a pattern. The following record pattern destructures a record into two new variables name and height. These variables can then be used like any other variable, such as in a call to print:</p><pre>var (String name, int height) = userInfo({&#39;name&#39;: &#39;Michael&#39;, &#39;height&#39;: 180});<br>print(&#39;User $name is $height cm tall.&#39;);</pre><p>Similar patterns exist for lists and maps. For all of these, you can skip individual elements with the underscore pattern:</p><pre>var (String name, _) = userInfo(…);</pre><p>Patterns shine when used in a switch statement. Dart has had limited support for switch since the beginning. In Dart 3 we’ve broadened the power and expressiveness of the switch statement. We now support pattern matching in these cases. We’ve removed the need for adding break at the end of each case. We also support logical operators to combine cases. The following example shows a nice and crisp switch statement that parses a character code:</p><pre>switch (charCode) {<br>  case slash when nextCharCode == slash:<br>    skipComment();<br><br>  case slash || star || plus || minus:<br>    operator(charCode);<br><br>  case &gt;= digit0 &amp;&amp; &lt;= digit9:<br>    number();<br><br>  default:<br>    invalid();<br>}</pre><p>The switch statement provides a great help when you need one or more statements for each case. In some cases, all you want to do is to calculate a value. For that use case, we provide a very succinct switch <em>expression</em>. This resembles the switch <em>statement</em>, but uses different syntax that’s fine tuned for expressions. The following sample function returns the value of a switch expression to calculate a description of today’s weekday:</p><pre>String describeDate(DateTime dt) =&gt;<br>  switch (dt.weekday) {<br>      1 =&gt; &#39;Feeling the Monday blues?&#39;,<br>      6 || 7 =&gt; &#39;Enjoy the weekend!&#39;,<br>      _ =&gt; &#39;Hang in there.&#39;<br>  };</pre><p>A powerful feature of patterns is the ability to check for “exhaustiveness”, This feature ensures that the switch handles all the possible cases. In the previous example, we’re handling all possible values of weekday, which is an int. We exhaust all possible values through the combination of match statements for the specific values 1, 6 or 7, and then using a default case _ for the remaining cases. To enable this check for user-defined data hierarchies, such as a class hierarchy, use the new sealed modifier on the top of the class hierarchy as in the following example:</p><pre>sealed class Animal { … }<br>class Cow extends Animal { … }<br>class Sheep extends Animal { … }<br>class Pig extends Animal { … }<br><br>String whatDoesItSay(Animal a) =&gt;<br>    switch (a) { Cow c =&gt; &#39;$c says moo&#39;, Sheep s =&gt; &#39;$s says baa&#39; };</pre><p>This returns the following error, alerting us that we missed handling the last possible subtype, Pig:</p><pre>line 6 • The type &#39;Animal&#39; is not exhaustively matched by the switch cases<br>since it doesn&#39;t match &#39;Pig()&#39;.</pre><p>Finally, if statements can use patterns too. In the next example, we’re using <em>if-case</em> matching against a map-pattern to destructure the JSON map. Inside that, we’re matching against constant values (strings like &#39;name&#39; and &#39;Michael&#39;) and a type test pattern int h to read out a JSON value. If the pattern matches fail, Dart executes the else statement.</p><pre>final json = {&#39;name&#39;: &#39;Michael&#39;, &#39;height&#39;: 180};<br><br>// Find Michael&#39;s height.<br>if (json case {&#39;name&#39;: &#39;Michael&#39;, &#39;height&#39;: int h}) {<br>  print(&#39;Michael is $h cm tall.&#39;); <br>} else { <br>  print(&#39;Error: json contains no height info for Michael!&#39;);<br>}</pre><p>This just touches on all the things you can do with patterns. We believe they will become pervasive across all Dart code. To learn more, check out the <a href=\"http://dart.dev/language/patterns\">patterns documentation</a> and <a href=\"https://codelabs.developers.google.com/codelabs/dart-patterns-records\">patterns codelab</a>.</p><h4>Fine grained access controls for classes with class modifiers</h4><p>A third Dart 3 language feature is class modifiers. Unlike records &amp; patterns that we expect every Dart developer to use, this is more of a power-user feature. It addresses the needs of Dart developers crafting large API surfaces or building enterprise-class apps.</p><p>Class modifiers enable API authors to support only a specific set of capabilities. The defaults remain unchanged though. We want Dart to remain simple and approachable. So, like before, regular classes can be <em>constructed</em>, <em>extended</em> and <em>implemented</em>, as shown in the following examples:</p><pre>class Vehicle {<br>  String make; String model;<br>  void moveForward(int meters) { … }<br>}<br><br>// Construct.<br>var myCar = Vehicle(make: &#39;Ford&#39;, model: &#39;T&#39;,);<br><br>// Extend.<br>class Car extends Vehicle {<br>  int passengers;<br>}<br><br>// Implement.<br>class MockVehicle implements Vehicle {<br>  @override void moveForward …<br>}</pre><p>Class modifiers support adding restrictions to this. Consider some sample uses cases:</p><ul><li>With an interface class, you can define a contract for others to implement. An interface class cannot be extended.</li><li>With a base class, you can ensure that all of the subtypes of your class inherit from it, instead of implementing its interface. This ensures that private methods are available on all instances.</li><li>With a final class, you can close the type hierarchy preventing any subclasses outside of your own library. As a sample benefit, this allows the API owner to add new members without risking breaking changes to the consumers of the API.</li></ul><p>For details, see the new <a href=\"https://dart.dev/language/class-modifiers\">class modifiers documentation</a>.</p><h3>A view towards the future</h3><p>Dart 3 is not just a significant step forward in terms of new features you can use today. We’re also giving you a preview of what’s next.</p><h4>Dart language</h4><p>Records, patterns, and class modifiers are very large new features, so it’s possible that there are parts of their design that could be improved. We’ll continue to monitor <a href=\"https://github.com/dart-lang/language/issues\">your feedback</a>, and see if updates are needed in minor releases following Dart 3.</p><p>We’re also looking at some smaller, more incremental features that are entirely non-breaking and focused on increasing developer productivity without migration cost. Two examples we’re exploring are <a href=\"https://github.com/dart-lang/language/issues/2727\">inline classes</a> for wrapping existing types with zero-cost “wrappers”, and <a href=\"https://github.com/dart-lang/language/issues/2364\">primary constructors</a>; a feature that introduces a much more concise syntax for defining classes with a few fields and a primary constructor.</p><p>We’ve previously discussed macros (also referred to as <a href=\"https://github.com/dart-lang/language/blob/main/working/macros/feature-specification.md\">meta-programming</a>). We’re in particular focused on this for enabling better deserialization of JSON (and similar), and for enabling data classes. Given the size and inherent risk in metaprogramming, we’re taking a very thorough approach, and we thus have no concrete timeline to share, even for finalizing design decisions.</p><h4>Native interop</h4><p>Apps on mobile and desktop typically rely on lots of APIs provided by the native platform, whether it’s notifications, payments, or getting the phone’s location. Traditionally in Flutter these are accessed by building plugins, which require writing both Dart code for the API and a bunch of platform-specific code to provide the implementation.</p><p>We already support interop with code that compiles to C libraries with <a href=\"https://dart.dev/guides/libraries/c-interop\">dart:ffi</a>. We’re currently working on expanding this to support <a href=\"https://dart.dev/guides/libraries/java-interop\">Java and Kotlin interop</a> on Android, and <a href=\"https://dart.dev/guides/libraries/objective-c-interop\">Objective C and Swift interop</a> on iOS/macOS. For an introduction to the Android interop, checkout the new Google I/O 23 <a href=\"https://io.google/2023/program/2f02692d-9a41-49c0-8786-1a22b7155628/\">Android interoperability video</a>.</p><h4>Compilation to WebAssembly — targeting the web with native code</h4><p><a href=\"https://webassembly.org/\">WebAssembly</a> (abbreviated Wasm) has been growing in maturity as a platform-neutral binary instruction format across <a href=\"https://caniuse.com/wasm\">all modern browsers</a>. The Flutter framework has used Wasm for a while. It’s how we deliver the SKIA graphics rendering engine, written in C++, to the browser via a Wasm compiled module. We’ve long had an interest in using Wasm to deploy Dart code too, but we’ve been blocked. Dart, like many other object oriented languages, uses garbage collection. Over the past year, we’ve collaborated with several teams across the Wasm ecosystem to add a new WasmGC feature to the WebAssembly standard. This is now near-stable in the Chromium and Firefox browsers.</p><p>Our work on compiling Dart to Wasm modules has two high-level goals for web apps:</p><ul><li><strong>Load time:</strong> we hope that we can deliver deployment payloads with Wasm that the browser can load faster, thus improving the time it takes to get to the point where the user can interact with the web app.</li><li><strong>Performance: </strong>Web apps powered by JavaScript require just-in-time compilation to achieve good performance. Wasm modules are more low-level and closer to machine code, so we think they can deliver higher performance with less jank and more consistent frame rates.</li><li><strong>Semantic consistency</strong>: Dart takes pride in being highly consistent between our supported platforms. However, on the web, there are a few exceptions to this. For example, Dart web currently differs in how<a href=\"https://dart.dev/guides/language/numbers\"> numbers are represented</a>. With Wasm modules, we’d be able to treat the web like a “native” platform with semantics similar to other native targets.</li></ul><p>We’re excited to announce the first preview of Dart to Wasm compilation today! Our initial focus is on Flutter web support. It’s still early, and we have lots of work to complete, but we <a href=\"https://flutter.dev/wasm\">invite you to experiment </a>and see if this has you as excited as we are.</p><h3>Closing</h3><p>Thanks for reading until the end. We hope this post has made you excited about Dart 3, available today in both the stand-alone <a href=\"https://dart.dev/get-dart\">Dart SDK</a> and in the <a href=\"https://medium.com/flutter/whats-new-in-flutter-3-10-b21db2c38c73\">Flutter 3.10 SDK</a>.</p><p>We’ve completed a major overhaul of the Dart language with sound null safety, and core library and tools cleanup. There are major new language features that make Dart more expressive and crisp with records and patterns. For large API surfaces, class modifiers enable detailed control. We’re also including a preview of the future with our coming support for WebAssembly.</p><p>With all of these features, we think Dart 3 illustrates our long-term vision: <em>To build the most productive programming language for building fast apps on any platform</em>. We hope you think so too!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=53f065a10635\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/announcing-dart-3-53f065a10635\">Announcing Dart 3</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2023-11-15T21:44:57.000Z":{"title":"Announcing Dart 3.2","link":"https://medium.com/dartlang/dart-3-2-c8de8fe1b91f?source=rss----23738d481ce8---4","guid":"https://medium.com/p/c8de8fe1b91f","category":["dartlang","dart"],"dc:creator":"Michael Thomsen","pubDate":"Wed, 15 Nov 2023 21:44:57 GMT","atom:updated":"2024-01-09T09:16:58.486Z","content:encoded":"<h3>Improved language &amp; developer experience, and an update on web apps &amp; Wasm</h3><p>By: <a href=\"https://medium.com/u/441fe70f4b5e\">Kevin Moore</a> &amp; <a href=\"https://medium.com/u/a6d788faa5e5\">Michael Thomsen</a></p><p>Today we’re announcing Dart 3.2, featuring a new language feature for non-null promotion of private final fields, improved developer experience with new interop capabilities, support for extensions in DevTools, and an update on our web roadmap including support for Wasm (aka WebAssembly).</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*u5YRn1uMmXf94b2aPbcLRQ.png\" /></figure><h3>Non-null promotion for private final fields</h3><p>It’s been a few years since we introduced <a href=\"https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87\">sound null safety</a> in Dart 2.12. With null safety, you can declare which types are nullable (may contain a value, or null) and which are non-nullable (always contain a value). Null safety combined with <a href=\"https://dart.dev/null-safety/understanding-null-safety#flow-analysis\">flow analysis</a> detects when nullable variables can be “promoted” to their safer, non-null types:</p><pre>int definitelyInt(int? aNullableInt) {<br>  if (aNullableInt == null) {<br>    return 0;<br>  }<br>  // If flow analysis reaches this point, <br>  // aNullableInt can safely promote to a non-null int.<br>  return aNullableInt; <br>}</pre><p>Type promotion has been a core part of null safety since Dart 2.12, but was limited to local variables. Fields or top-level variables couldn’t be promoted, such as in a case like this:</p><pre>class Container {<br>  final int? _fillLevel;<br>  Container(this._fillLevel);<br>  check() {<br>    if (_fillLevel != null) {<br>      int i = _fillLevel; // Prior to Dart 3.2, causes an error.<br>    }<br>  }<br>}</pre><p>This limitation was due to several complex cases where flow analysis could not safely determine when or how a field might change. In the case of field promotion on a class, for example, it could be an issue if a subclass overrides a field with a getter, which sometimes returns null.</p><p>In Dart 3.2, we’ve improved our flow analysis engine and are now able to type promote <strong>private final fields</strong>. Now, the code snippet above passes without errors. This leverages the understanding that for a private &amp; final field, the value never changes after the initial assignment, so checking it just once is considered safe. Private final field promotion is available starting with Dart 3.2, and will be applied to projects that have a Dart SDK <a href=\"https://dart.dev/guides/language/evolution#language-versioning\">lower bound</a> of 3.2 or higher.</p><h3>New code analysis options in package:lints 3.0</h3><p>Speaking of code analysis, we’ve also made a number of improvements to our standard code analysis rules in <a href=\"https://pub.dev/packages/lints\">package:lints</a>. This package contains the default &amp; recommended set of static analysis rules that comes with any new project created by dart create or flutter create (via <a href=\"https://pub.dev/packages/flutter_lints\">package:flutter_lints</a> — an extension of package:lints).</p><p>A new major version of this lint set, version 3.0, is now available. This revision added six lints to the core set and two lints to the recommended set. It features lints for validating pubspec URLs, validating that collection methods are invoked with the correct arguments, and more. For the full list of changes, check out the <a href=\"https://github.com/dart-lang/lints/blob/main/CHANGELOG.md#300\">changelog</a>. Version 3.0 will be the default for new projects in the coming release. For existing projects, you can <a href=\"https://github.com/dart-lang/lints#upgrading-to-the-latest-lints\">upgrade now</a>.</p><h3>Dart interoperability update</h3><p>Multi-platform support across a <a href=\"https://dart.dev/overview#platform\">wide range of platforms</a> has always been a core principle of Dart. But even though a line of Dart code can run unchanged across all those platforms, large apps still often have a need to interop with existing code. That could mean code from older projects, or APIs available in other libraries or system APIs. We’ve made a number of investments in this area, starting with FFI for <a href=\"https://dart.dev/guides/libraries/c-interop\">interop with native C APIs</a>. We’re currently working on expanding this to support interop with <a href=\"https://dart.dev/guides/libraries/java-interop\">Java and Kotlin</a> and <a href=\"https://dart.dev/guides/libraries/objective-c-interop\">Objective C and Swift</a>. For exciting updates on JS interop, check out the Dart web section further down.</p><p>As of Dart 3.2, we’ve made a number of improvements to native interop:</p><ul><li>We’ve introduced the <a href=\"https://api.dart.dev/stable/dart-ffi/NativeCallable/NativeCallable.isolateLocal.html\">NativeCallable.isolateLocal</a> constructor for C FFI, which creates a C function pointer from an arbitrary Dart function. This is an extension of functionality provided by <a href=\"https://api.dart.dev/stable/dart-ffi/Pointer/fromFunction.html\">Pointer.fromFunction</a>, which can only create function pointers from top-level functions.</li><li>We’ve updated the Objective-C bindings generator to make use of <a href=\"https://api.dart.dev/stable/dart-ffi/NativeCallable/NativeCallable.listener.html\">NativeCallable.listener</a>, which we added in Dart 3.1. The generator can now automatically handle APIs which contain asynchronous callbacks, like <a href=\"https://developer.apple.com/documentation/coremotion\">Core Motion</a>, for example. Such APIs previously required writing some of the bindings code by hand.</li><li>We’ve continued to improve <a href=\"https://dart.dev/guides/libraries/java-interop\">package:jnigen</a> for Java and Kotlin interop. This allowed us to migrate <a href=\"https://pub.dev/packages/cronet_http\">package:cronet_http</a> — a wrapper around Android’s Cronet HTTP client — away from handwritten bindings code to an automatically <a href=\"https://github.com/dart-lang/http/blob/master/pkgs/cronet_http/jnigen.yaml\">generated</a> wrapper.</li><li>We’ve made significant progress on the <a href=\"https://github.com/dart-lang/sdk/issues/50565\">Native Assets</a> feature, which aims to resolve a number of issues associated with the distribution of Dart packages that depend on native code. It does so by providing uniform hooks for integrating with various build systems involved in building Flutter and standalone Dart applications. For a preview, check out the <a href=\"http://dart.dev/guides/libraries/c-interop#native-assets\">documentation</a>.</li></ul><h3>DevTools extensions for Dart packages</h3><p>Dart <a href=\"https://dart.dev/tools/dart-devtools\">DevTools</a> is a suite of debugging and performance tools that supports both pure-Dart and Flutter apps. In Dart 3.2 &amp; Flutter 3.16 <a href=\"https://medium.com/p/c8bc1aaf8e5f/\">we’re announcing</a> a new <a href=\"https://pub.dev/packages/devtools_extensions\">extensions framework</a> which enables package authors to build custom tooling for their package, surfaced directly in DevTools. This allows pub.dev packages that contain frameworks to offer custom tools specific to their use cases. For example, the authors of <a href=\"https://pub.dev/packages/serverpod\">Serverpod</a> have been hard at work building developer tools for their package and are excited to be shipping a DevTools extension in their upcoming <a href=\"https://github.com/orgs/serverpod/projects/4\">1.2 release</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*N6ZSt1McXO_opQU7\" /><figcaption><em>A DevTools extension planned for the upcoming ServerPod 1.2 release</em></figcaption></figure><h3>Dart web and Wasm update</h3><p>Wasm (also known as <a href=\"https://webassembly.org/\">WebAssembly</a>) is an exciting new instruction format for web browsers, which provides a portable, platform-neutral, binary code format for execution in modern browsers. High-level managed languages like Dart use garbage collection, which is being added to the Wasm standard. As of Chrome 119, <a href=\"https://developer.chrome.com/blog/wasmgc/\">garbage collection support for Wasm</a> (known as Wasm-GC) is enabled by default. Wasm-GC support is also coming in Firefox 120, their next stable release. So what’s the status with Dart, Flutter, and Wasm-GC?</p><p>The Dart-to-Wasm compiler is almost feature complete. The team is very happy with performance and compatibility. Our focus now is on edge cases to make sure our output is fast across a broad range of scenarios.</p><p>For Flutter web, we’ve completed a new “Skwasm” rendering engine. To maximize performance, Swasm connects the compiled application code directly to a custom <a href=\"https://skia.org/docs/user/modules/canvaskit/\">CanvasKit Wasm module</a> with a wasm-to-wasm binding. It’s also the first iteration of multi-threaded rendering support for Flutter web, which further improves frame times.</p><p>There are still a few things left before Flutter web with Wasm is ready to graduate out of its current experimental status:</p><ul><li><strong>Dual compile</strong>: Generating both Wasm and JavaScript outputs and enabling feature detection at runtime to support browsers with and without Wasm-GC support.</li><li><strong>Modern JavaScript-interoperability</strong>: A new JS interop mechanism based on <a href=\"https://github.com/dart-lang/language/issues/2727\">extension types</a> to enable concise, type-safe calling between Dart code, browser APIs, and JS libraries, when targeting JavaScript and Wasm.</li><li><strong>Browser APIs with Wasm support</strong>: A new package:web, replacing dart:html (and related libraries), based on the modern JS interop mechanism. This will provide easy access to browser APIs with support on both JS and Wasm targets.</li></ul><p>We are starting to migrate a number of internal projects to package:web and the new JS interop mechanism, and expect to have more updates in the next stable release. In the meantime, you can get the latest details at our <a href=\"https://flutter.dev/wasm\">Support for WebAssembly</a> page.</p><h3>Closing</h3><p>That’s all we have for today. Dart 3.2 is available now from <a href=\"https://dart.dev/get-dart\">dart.dev</a>, or as part of today’s <a href=\"https://medium.com/flutter/whats-new-in-flutter-3-16-dba6cb1015d1\">Flutter 3.16</a> release. Until next time, have fun with Dart!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c8de8fe1b91f\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-3-2-c8de8fe1b91f\">Announcing Dart 3.2</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2024-05-14T20:36:15.000Z":{"title":"Announcing Dart 3.4","link":"https://medium.com/dartlang/dart-3-4-bd8d23b4462a?source=rss----23738d481ce8---4","guid":"https://medium.com/p/bd8d23b4462a","category":["webassembly","dart","wasm","dartlang"],"dc:creator":"Michael Thomsen","pubDate":"Tue, 14 May 2024 20:36:15 GMT","atom:updated":"2024-05-14T21:19:25.869Z","content:encoded":"<p>Dart 3.4 is out today! This release showcases the joint efforts of Dart and Flutter together in the <a href=\"https://medium.com/flutter/io24-5e211f708a37\">Flutter 3.22 / Dart 3.4 / IO24</a> post, so make sure to get the full scoop there. This post introduces our support for WebAssembly, and then details one of the major roadmap items for the Dart language this year: <em>macros.</em></p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*hAcsCFLU0Ze7pej6\" /></figure><h3>WebAssembly updates</h3><p>Today, we’re delighted to announce complete support for WebAssembly (Wasm) is available for <a href=\"https://docs.flutter.dev/platform-integration/web/wasm\">Flutter Web apps</a> with the latest Flutter 3.22 stable release!</p><p>This has been a multi-year investment across Dart &amp; Flutter. If you’ve been following the developments, you’ve seen our incremental developments:</p><ul><li>Standardizing the <a href=\"https://developer.chrome.com/blog/wasmgc/\">WasmGC</a> proposal,</li><li>Adding a brand new Dart compiler backend to generate WasmGC code, and</li><li><a href=\"https://dart.dev/interop/js-interop\">Revamping</a> our web and JavaScript interop offerings to best support Wasm.</li></ul><p>We’ll continue to invest in WebAssembly. Our next effort will enable full support for Wasm in pure Dart apps, and completing a few missing features (e.g. deferred loading). The end-to-end tooling for Wasm compilation in Dart is still under development, but you can <a href=\"http://dart.dev/web/wasm\">try the preview</a> in stable now with some temporary steps. Later, we also hope to support Wasm in Dart <a href=\"https://github.com/dart-lang/sdk/issues/53884\">outside of JS-environments</a>, such as standard Wasm run-times like wasmtime and wasmer.</p><h3>Dart macros: Raising the development abstraction level</h3><p>We’ve invested many years into designing the Dart macros system. To improve the development experience in Dart, macros provide a metaprogramming solution, like code generation. This solution is built into the Dart language to give developers maximum performance, efficiency, and productivity. Now, we’re ready to offer a preview of this experience!</p><p>A long standing pain point for Dart developers has been the trivial yet tedious pattern of serializing and deserializing JSON data. Crafting a reusable, sufficiently powerful solution is a challenge in Dart, as it doesn’t support runtime reflection for performance reasons. As an alternative, we’ve relied on code generation solutions like <a href=\"https://docs.flutter.dev/data-and-backend/serialization/json#serializing-json-using-code-generation-libraries\">JsonSerializable</a>. These depend on external tools that run before the code itself, complicating the developer experience.</p><p>Today, we’re announcing a preview of a radical new approach for JSON serialization and deserialization: the <a href=\"https://dart.dev/go/json-codable\">JsonCodable</a> macro.</p><p>A macro is a type of code that generates <em>more</em> code through introspecting <em>other</em> code at compile time. For example, here’s a Dart class Vehicle with the new JsonCodable macro applied:</p><pre>@JsonCodable()<br>class Vehicle {<br>  final String description;<br>  final int wheels;<br>  Vehicle(this.description, this.wheels);<br>}<br>void main() {<br>  final jsonString = Vehicle(&#39;bicycle&#39;, 2).toJson();<br>  print(&#39;Vehicle serialized: $jsonString&#39;);<br>}</pre><p>So, how does it work? Where did the toJson() method (and the companion fromJson() constructor) come from? This is an experimental implementation of our new macro system designed to simplify developer experience. When the Dart compiler sees the @JsonCodable() annotation, it immediately locates the definition of the JsonCodable macro in real time and starts executing it. This causes the macro to:</p><ol><li>Create a new “<a href=\"https://github.com/dart-lang/language/blob/main/working/augmentation-libraries/feature-specification.md\">augmentation class</a>”; a new language construct which enables adding new declarations to existing classes.</li><li>Read the developer’s definition of the Vehicle class to determine it has two fields, description and wheels.</li><li>Add a new toJson method signature to the augmentation class.</li><li>Fill in the body of the toJson method to handle the serialization of the description and wheels fields.</li></ol><p>All this happens without delay. The integrated experience supports our existing developer workflows, such as hot reload, as this screencast illustrates:</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/896/0*aOAKYwKdjXURuZN9\" /><figcaption>Screencast showing the experience of using a macro: Initially no toJson code completion exists, but after adding <a href=\"http://twitter.com/JsonCodable\">@JsonCodable</a> to the class, the toJson code completion shows up immediately.</figcaption></figure><h3>Long term macro goals</h3><p>The eventual goal is to enable the community to create their own macros. This raises the abstraction level of Dart programming. Take data classes, for example, the <a href=\"https://github.com/dart-lang/language/issues?q=is%3Aissue+is%3Aopen+sort%3Areactions-%2B1-desc\">highest voted</a> Dart language feature. We looked at adding built-in support for data classes in Dart, but learned that the opinions varied significantly on what such a construct should support to set a standard ourselves. Should the fields be immutable? Should it support equals? What about hashCode? Maybe toString too? We concluded that supporting a macro system would be the better approach. The community can create their own kinds of abstractions, allowing for more scalable experimentation and variety.</p><p>Designing and implementing such a powerful macro system is a substantial undertaking. We’re determined to do it in a way that doesn’t have a detrimental performance impact on core Dart developer use cases, such as code assistance and completions, code analysis, and hot reload. With that in mind, we’re taking a staged approach:</p><ul><li>In today’s release, we’re making a preview of a single macro, JsonCodable, available so users can start familiarizing themselves with the developer experience of using a macro.</li><li>If the roll-out of this macro goes well, then we hope to graduate the JSON macro to stable in a later release.</li><li>Concurrently, we’re working on completing the design and implementation of the underlying macro system. Once we feel confident in its performance and stability, the eventual goal will be to enable the Dart developer community to define their own macros.</li></ul><p>A lot of work remains to complete these stages. In the meantime, you can read the documentation to learn more about <a href=\"https://dart.dev/go/macros\">the Dart macro system</a>, and try out a preview of <a href=\"https://dart.dev/go/json-codable\">the JsonCodable macro</a> today.</p><h3>Other improvements</h3><p>As always, this release contains all of the continuous developments that go into providing the best version of Dart possible. In this release, we made the following improvements:</p><ul><li>Resolved over 50% of analyzer code completion bugs. (Please keep filing <a href=\"https://github.com/dart-lang/sdk/labels/analyzer-completion-correctness\">issues</a>!)</li><li>Improved the alignment of the type analysis of conditional expressions, if-null expressions, and switch expressions with the language spec (<a href=\"https://github.com/dart-lang/sdk/blob/main/CHANGELOG.md#language-1\">changelog</a>).</li><li>Removed incomplete and inconsistent tooling from the dart:cli library to pay down technical debt in the Dart VM.</li><li>Addressed a handful of inadequacies to improve the new<em> </em>dart:js_interop library.</li></ul><p>Check out the <a href=\"https://github.com/dart-lang/sdk/blob/main/CHANGELOG.md#340\">Changelog</a> for the full story! Don’t forget to read the joint <a href=\"https://medium.com/flutter/io24-5e211f708a37\">Dart and Flutter blog post</a> for this release for the full story of our joint efforts!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bd8d23b4462a\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-3-4-bd8d23b4462a\">Announcing Dart 3.4</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2024-03-28T15:01:12.000Z":{"title":"History of JS interop in Dart","link":"https://medium.com/dartlang/history-of-js-interop-in-dart-98b06991158f?source=rss----23738d481ce8---4","guid":"https://medium.com/p/98b06991158f","category":["interoperability","dart","dartlang"],"dc:creator":"Sigmund Cherem","pubDate":"Thu, 28 Mar 2024 15:01:12 GMT","atom:updated":"2024-03-28T15:01:11.571Z","cc:license":"http://creativecommons.org/licenses/by/4.0/","content:encoded":"<h4>Support for Wasm just landed in the current Flutter beta, thanks to an exciting JavaScript interop milestone reached in Dart 3.3. To celebrate, we’re taking a look back at the decade-long journey of Dart and JS interoperability.</h4><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*dhBQqKXU46sGKjx36LNf0w.jpeg\" /><figcaption>AI Image generated by Gemini</figcaption></figure><p>Interoperability has been a core focus from the beginning of Dart. When Dart was first released in 2011, it was designed to be <em>embeddable</em> and <em>multi-platform</em>. It ran on a standalone virtual machine, embedded in a browser, and compiled to JavaScript. When Flutter came along in 2015, we were ready to embed it there, too. Now, we’re excited to <a href=\"https://docs.flutter.dev/platform-integration/web/wasm\">target WasmGC runtimes</a>, as well.</p><p>At first, we worked quickly to expose the capabilities of each platform where Dart was embedded. That’s how our SDK platform-specific libraries emerged: <a href=\"https://api.dart.dev/stable/dart-io/dart-io-library.html\">dart:io</a> exposed the file system on the VM, <a href=\"https://api.dart.dev/stable/dart-html/dart-html-library.html\">dart:html</a> exposed the browser APIs on the web, and so on. These libraries looked and felt like regular Dart libraries, but behind the scenes hid some sophisticated low-level, native primitives to make them work. This was the very first form of interop we ever invented. It was expressive, but restricted to only SDK libraries.</p><p>On the web, developers needed access to more than just browser APIs. So we started looking at ways to open interoperability to cover more targets. As a starting point, we introduced <a href=\"https://codereview.chromium.org//15782009\">dart:js</a> in 2013 to enable access to JavaScript libraries.</p><pre>// Short example JavaScript code to illustrate Dart/JS interop<br>window.myTopLevel = {<br>  field1: 0,<br>  method2() {<br>    return this.field1;<br>  }<br>}</pre><pre>// Access via `dart:js` (2013)<br>import &#39;dart:js&#39; as js;<br><br>void main() {<br>  // This line has a typo! oops :(<br>  var object = js.context[&#39;myTopLevl&#39;];<br>  object[&#39;field1&#39;] = 1;<br>  // This call fails with a noSuchMethod because method2<br>  // returns an int, oops<br>  object.callMethod(&#39;method2&#39;, []).substr(1);<br>}</pre><p>We knew then that dart:js was not the programming model we wanted. You had to use strings to access names from JavaScript — forget about finding issues at compile-time, and don’t even think about code completion! The implementation was expensive, too. It heavily relied on boxes and deep copies for most operations. So we continued <a href=\"https://github.com/dart-archive/js-interop-deprecated\">drafting</a> ideas in 2014 and 2015 until v0.6 of package:js was released.</p><pre>// Access via `package:js` (2015)<br>import &#39;package:js/js.dart&#39;;<br><br>// Magic annotations allow us to declare API signatures:<br>@JS()<br>class MyObject {<br>  external int get field1;<br>  external void set field1(int value);<br>  external String method2();<br>}<br><br>@JS()<br>external MyObject get myTopLevel;<br><br>void main() {<br>  // Access to code is less error prone: analyzer can check that<br>  // these symbols match a declaration, and we get code-completion too!<br>  var object = myTopLevel;<br>  object.field1 = 1;<br>  // But types are not checked, this unsoundly invokes substring on an int<br>  object.method2().substring(1);<br>}</pre><p>With <a href=\"https://pub.dev/documentation/js/latest/\">package:js</a> we finally had an open API that was efficient and user friendly. You could sprinkle some annotations on abstract classes, and <em>voila, </em>you had access to JavaScript APIs. It all worked like magic, until it didn’t. There was a lot you couldn’t do with package:js: accessing browser APIs directly, renaming members, conversions, attaching Dart logic, and <a href=\"https://github.com/dart-lang/sdk/issues/35084\">more</a>. To compensate, we also shipped <a href=\"https://codereview.chromium.org/2150313003/\">dart:js_util</a> — a lightweight and efficient low-level API similar to dart:js, as a fallback. All the limitations in package:js really bothered us, but our hands were tied. We needed more from the Dart language to do better.</p><p>Around that time, we were already working on the biggest change to the language we have ever made — we were making Dart <a href=\"https://dart.dev/language/type-system#what-is-soundness\">sound</a>. Ironically, when we released the new type system with Dart 2.0 in 2018, interoperability got <em>worse</em>! Beyond those early limitations, that magic that made package:js special had a dark side — it couldn’t check the validity of types. This meant that our interoperability was a source of unsoundness in our otherwise sound language.</p><p>Then, our journey changed to focus on improving both Dart and JS-interop as a concerted effort. With clear principles (be idiomatic, expressive, compositional, precise, approachable, pragmatic, non-magical, and complete) we steered towards a design that anchored on typing and static dispatching, and that challenged the Dart language. What followed was a side-by-side evolution.</p><ul><li>In 2019, Dart 2.7 added static extension methods. You could attach custom Dart logic to a JS-interop class and convert values, like a JS Promise into a Dart Future, without using wrappers.</li><li>In 2021, we released @staticInterop with package:js v0.6.4. At last, JS-interop was expressive enough — you could expose browser APIs that previously were exclusively managed by SDK libraries like dart:html.</li><li>In 2023, when we dropped unsound null safety in Dart 3.0, we could finally see the progress we had made, our designs and @staticInterop work made it clear we were ready to address the soundness gap we had for so long.</li></ul><p>That year, we introduced compilation to WasmGC and leveraged JS-interop to run rich frameworks like <a href=\"https://medium.com/flutter/whats-next-for-flutter-b94ce089f49c\">Flutter web</a> on it. This sparked work on <a href=\"https://dart.dev/interop/js-interop/js-types\">JS Types</a> to clearly define the Dart and JS boundary in the programming model and find a consistent way to work with JS in both Wasm and JS compilation targets. We also started the <a href=\"https://dart.dev/language/extension-types\">extension types</a> language experiment — a feature launched in Dart 3.3 that bridges the gap between the Dart language and JS-interop. For years, JS-interop had behaviors, like type erasure, that didn’t match anything else in Dart. With extension types, JS-interop could finally be idiomatic and get the support it deserves in Dart development tools.</p><p>Despite the many shifts and turns along the way, one thing remained consistent throughout the entire decade: the active engagement of our Dart community. Community members took early steps testing and contributing to dart:js, then later influencing the design of package:js. They wrote tools to address feature gaps (<a href=\"https://github.com/a14n/dart-js-wrapping\">package:js_wrapping</a>), and experimented with ways to improve productivity by autogenerating Dart APIs (<a href=\"https://github.com/dart-archive/js_facade_gen\">package:js_facade_gen</a>, <a href=\"https://pub.dev/packages/js_bindings\">package:js_bindings</a>, <a href=\"https://pub.dev/packages/typings\">package:typings</a>). Each contribution helped make Dart’s interop design better. To each of you out there, thank you for making this such an exciting adventure!</p><p>Finally, here we are in 2024. We released <a href=\"https://dart.dev/interop/js-interop\">dart:js_interop</a> in Dart 3.3 together with <a href=\"https://dart.dev/interop/js-interop/package-web\">package:web</a>, the newest solutions for JS interop in Dart that make compiling <a href=\"https://docs.flutter.dev/platform-integration/web/wasm\">Flutter to Wasm</a> possible.</p><pre>// Access via `dart:js_interop` (2024)<br>import &#39;dart:js_interop&#39;;<br><br>// Declarations use extension types, which are very similar to package:js<br>// declarations. The main difference: they are statically dispatched.<br>extension type MyObject._(JSObject _) implements JSObject {<br>  external int get field1;<br>  external void set field1(int value);<br>  external String method2();<br>}<br><br>@JS()<br>external MyObject get myTopLevel;<br><br>void main() {<br>  var object = myTopLevel;<br>  object.field1 = 1;<br>  // At last, access is sound - this line fails with a type error<br>  // when returning from method2.<br>  object.method2().substring(1);<br>}</pre><ul><li>dart:js_interop is a static, sound, idiomatic, expressive, and consistent form of interop based on extension types that is capable of exposing any JavaScript or browser APIs.</li><li>package:web uses dart:js_interop to do what dart:html once did 13 years ago, but in a way that is supported both in JavaScript and WasmGC.</li></ul><p>Today, we are excited to celebrate a new form of Dart/JS interop and the future it enables. Knowing our past, we are certain this isn’t the end of the journey, but an exciting point in our history.</p><p>We can’t wait to see what you’ll build with it!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=98b06991158f\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/history-of-js-interop-in-dart-98b06991158f\">History of JS interop in Dart</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2024-03-05T09:02:06.000Z":{"title":"Dart in Google Summer of Code 2024","link":"https://medium.com/dartlang/dart-in-google-summer-of-code-2024-8ca45fb6dc4e?source=rss----23738d481ce8---4","guid":"https://medium.com/p/8ca45fb6dc4e","category":["google-summer-of-code","flutter","open-source","dartlang"],"dc:creator":"Jonas Finnemann Jensen","pubDate":"Tue, 05 Mar 2024 09:02:06 GMT","atom:updated":"2024-03-05T09:02:05.695Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/801/1*69jdaJUqgu_phIVF4w-7_A.png\" /></figure><p>The Google Summer of Code (GSoC) program focuses on bringing student developers from around the world into open source software development. Google sponsors students to work with a mentoring open source organization on a 12 week (or longer) programming project during the summer. Over the past 19 years, more than 20,000 contributors have participated in Google Summer of Code.</p><p>We’re excited to announce that the Dart project will mentor contributors (for the fifth time!) in Google Summer of Code 2024.</p><h4><strong>Are you interested?</strong></h4><p>To get started now, read <a href=\"https://github.com/dart-lang/sdk/wiki/Dart-GSoC-2024-Project-Ideas\">the list of project ideas</a> to find a match for your skills and interests. Formal applications must be submitted before April 2. We encourage prospective applicants to submit early drafts and ask for feedback.</p><blockquote><em>The Dart team expects to have enough mentors to accept only a handful of applications, so also check out </em><a href=\"https://summerofcode.withgoogle.com/programs/2024/organizations\"><em>the other mentoring organizations</em></a><em>.</em></blockquote><p>If you have questions specific to Dart and GSoC, ask them on <a href=\"https://groups.google.com/g/dart-gsoc\">our dedicated mailing list</a>.</p><p>To learn more about Google Summer of Code, watch the following video or read <a href=\"https://google.github.io/gsocguides/student/\">the contributor guide for Google Summer of Code</a>.</p><iframe src=\"https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FS6IP_6HG2QE%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DS6IP_6HG2QE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FS6IP_6HG2QE%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube\" width=\"854\" height=\"480\" frameborder=\"0\" scrolling=\"no\"><a href=\"https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href\">https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href</a></iframe><p>We look forward to hearing from you!</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8ca45fb6dc4e\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-in-google-summer-of-code-2024-8ca45fb6dc4e\">Dart in Google Summer of Code 2024</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2024-02-15T19:01:49.000Z":{"title":"New in Dart 3.3: Extension Types, JavaScript Interop, and More","link":"https://medium.com/dartlang/dart-3-3-325bf2bf6c13?source=rss----23738d481ce8---4","guid":"https://medium.com/p/325bf2bf6c13","category":["javascript","webassembly","dart-programming-language"],"dc:creator":"Kevin Moore","pubDate":"Thu, 15 Feb 2024 19:01:49 GMT","atom:updated":"2024-02-15T19:01:48.538Z","content:encoded":"<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*p4TBp0I66rJTq0LvnSuE7g.png\" /></figure><p><strong>Dart 3.3 has landed, and it’s a game-changer for performance and cross-platform development!</strong> Get ready to supercharge your apps with <strong>Extension Types</strong>, revolutionizing performance optimization and how you interact with native code. Plus, our revamped <strong>JavaScript interop</strong> model introduces robust type safety and a developer-friendly way to tap into the power of the web platform. All this paves the way for <strong>WebAssembly</strong> support. Oh, and <strong>Google AI in your Dart apps</strong>? Yes, please! It’s all here in Dart 3.3. Let’s dive in!</p><h3>Introducing Extension Types</h3><p>Extension types introduce zero-cost wrappers for types. Use them to optimize performance-sensitive code, especially when interoperating with host platforms. Extension types provide the convenience of custom types with specific members while eliminating the typical wrapper allocation overhead.</p><pre>extension type Wrapper(int i) {<br>  void showValue() {<br>    print(&#39;my value is $i&#39;);<br>  }<br>}<br><br>void main() {<br>  final wrapper = Wrapper(42);<br>  wrapper.showValue(); // Prints &#39;my value is 42&#39;<br>}</pre><p>The previous example defines <strong>Wrapper</strong> as an extension type, but uses it like a trivial Dart type. You can instantiate it and invoke functions. The key difference that Dart compiles it as a normal Dart <strong>int</strong>. Extension types allow the convenience of creating a type with unique members without the indirection cost of allocating a typical wrapper type. So, while the <a href=\"https://dart.dev/language/extension-methods\">extension members</a> feature (available in Dart since 2.7) allows adding functions and properties to an existing type, the extension type feature can do the same, <em>and also</em> allows defining a new API that hides the underlying representation.</p><p>This is particularly useful for interoperability with host platforms. Native types can be used directly without the cost of creating wrappers and the associated indirection while still providing a clean, production Dart API. Learn more in the <a href=\"http://dart.dev/language/extension-types\">new documentation on extension types</a>.</p><h3>Evolving JavaScript Interop</h3><p>Dart 3.3 introduces a new model for interoperating with JavaScript libraries and the web. It starts with a new set of APIs for interacting with JavaScript: the <a href=\"https://api.dart.dev/dart-js_interop/dart-js_interop-library.html\">dart:js_interop</a> library. Now Dart developers have access to a typed API for interacting with JavaScript. This API clearly defines the boundary between the two languages with static enforcement. This eliminates an entire class of issues <em>before</em> compile time. In addition to new APIs to access JavaScript code, Dart now includes a new model for representing JavaScript types in Dart using extension types.</p><pre>import &#39;dart:js_interop&#39;;<br><br>/// Represents the `console` browser API.<br>extension type MyConsole(JSObject _) implements JSObject {<br>  external void log(JSAny? value);<br>  external void debug(JSAny? value);<br>  external void info(JSAny? value);<br>  external void warn(JSAny? value);<br>}</pre><p>The syntax, based on extension types, allows for more expression and soundness than extension members. This simplifies leveraging JavaScript APIs from Dart. Learn more in the <a href=\"https://dart.dev/interop/js-interop\">new documentation on JS interop</a>.</p><h3>Improving browser libraries</h3><p>Since version 1.0, the Dart SDK has included a comprehensive set of browser libraries. These include the core <a href=\"https://api.dart.dev/dart-html/dart-html-library.html\">dart:html</a> library along with libraries for SVG, WebGL, and others.</p><p>The improved JavaScript interop model offered the chance to reimagine these libraries. Going forward, our browser library support will focus on <a href=\"https://pub.dev/packages/web\">package:web</a>. This simplifies versioning, accelerates updates, and aligns with <a href=\"https://developer.mozilla.org/\">MDN</a> resources.</p><p>This chain of improvements leads to the next big thing: compiling Dart to <a href=\"https://webassembly.org/\">WebAssembly</a>.</p><h3>Start today to enable a WebAssembly future</h3><p>With Dart 3.3, package and application authors can lay the groundwork for web applications compiled to <a href=\"https://webassembly.org/\">WebAssembly</a>. While WebAssembly support in Flutter Web remains experimental, the team is working hard to stabilize the implementation. To run Flutter applications on the web using WebAssembly, you need to migrate all code — from the application and all dependencies — to use the new JavaScript Interop mechanism and the <a href=\"https://pub.dev/packages/web\">package:web</a>. The legacy JavaScript and browser libraries remain unchanged and supported for compiling to JavaScript code. However, compiling to WebAssembly requires a migration.</p><p>We’ve created a<a href=\"https://dart.dev/go/package-web\"> migration guide</a> to help authors start including Wasm. We hope that the most popular packages support Wasm by the time we include it in a stable release.</p><h3>One more thing: Introducing the Google AI Dart SDK</h3><p>Google has released the Google AI Dart SDK to beta. You can build generative AI features into your Dart or Flutter app. These apps use Gemini, Google’s latest family of AI models. Take a look at the <a href=\"https://pub.dev/packages/google_generative_ai\">package:google_generative_ai</a>. Learn how to build with the Google AI Dart SDK in <a href=\"https://medium.com/flutter/harness-gemini-in-your-dart-and-flutter-apps-00573e560381\">this blog post</a> or jump straight into the <a href=\"https://ai.google.dev/tutorials/dart_quickstart\">quickstart</a>.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*0DiCLVhk_ipZIHKd\" /></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=325bf2bf6c13\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-3-3-325bf2bf6c13\">New in Dart 3.3: Extension Types, JavaScript Interop, and More</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"},"2024-08-06T18:02:40.000Z":{"title":"Announcing Dart 3.5, and an update on the Dart roadmap","link":"https://medium.com/dartlang/dart-3-5-6ca36259fa2f?source=rss----23738d481ce8---4","guid":"https://medium.com/p/6ca36259fa2f","dc:creator":"Michael Thomsen","pubDate":"Tue, 06 Aug 2024 18:02:40 GMT","atom:updated":"2024-08-06T18:02:39.459Z","content:encoded":"<p>It’s time for another of our quarterly Dart SDK releases. We have improvements in interoperability, new features in our pub.dev package manager, and we’ve graduated our new web integration APIs to stable and version 1.0.</p><p>A large portion of our time has been dedicated to larger, multi-quarter efforts, so with that we also have an update on our Dart roadmap, with details on what we hope to make progress on in the coming quarters.</p><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*PVj9TIzP50I00tavJqAg_Q.gif\" /><figcaption>Dart 3.5 release image.</figcaption></figure><h3>New capabilities in Dart 3.5</h3><p>Dart 3.5 features a number of new capabilities discussed below. There are also a smaller number of changes to core library APIs, and about 10 very minor breaking changes, covered in the <a href=\"https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md#350\">changelog</a>.</p><h3>Web platform and JS interoperability</h3><p>In Dart 3.4 and Flutter 3.22 we introduced support for <a href=\"https://docs.flutter.dev/platform-integration/web/wasm\">compiling Flutter Web apps to WebAssembly</a>. Compilation to WebAssembly requires using our new <a href=\"https://dart.dev/interop/js-interop\">Dart to JS interop model</a>, which previously was in preview. As of Dart 3.5 it is now considered stable and complete, and we’ve updated the browser API bindings in <a href=\"https://pub.dev/packages/web\">package:web</a> (which replaces the older dart:html library) to version 1.0.</p><p>We’d like to encourage all web package authors to <a href=\"https://dart.dev/interop/js-interop/package-web\">migrate to package:web</a>. We plan on deprecating the old interop APIs (dart:html, dart:js, package:js, etc.) in our next Dart release, and fully discontinuing them later next year. We invite you to offer feedback on this plan in <a href=\"https://github.com/dart-lang/sdk/issues/56358\">the tracking issue</a>. We also plan on updating the <a href=\"https://pub.dev/help/scoring\">scoring</a> on the pub.dev package manager to award points for web packages that support the new interop model.</p><p>We’ve also added <a href=\"https://dart.dev/tools/linter-rules/invalid_runtime_check_with_js_interop_types\">a new lint</a>, which validates that your code uses the new JS interop types correctly. We recommend that you add this lint to your analysis_options.yaml file as part of migrating your web packages.</p><h3>Dart native interoperability</h3><p>We’ve also made a range of improvements to our native interoperability, which supports calling directly from Dart into C, Java, Kotlin, Objective-C, and Swift.</p><p>C interop is enabled by our <a href=\"https://dart.dev/interop/c-interop\">FFI</a> (Foreign Function Interface) library, which we’ve supported for several years. In Dart 3.5, we’ve made incremental improvements to support passing a pointer from Dart TypedData objects directly to FFI, avoiding having to first copy the memory from Dart to Native (<a href=\"https://github.com/dart-lang/sdk/issues/44589\">details</a>).</p><p>Java &amp; Kotlin interop is enabled by the <a href=\"https://pub.dev/packages/jnigen\">JNIgen</a> generator (currently in preview), which automates the creation of the bindings code to call from Dart into Java &amp; Kotlin via the Java Native Interface (<a href=\"https://developer.android.com/training/articles/perf-jni\">JNI</a>). We’ve improved performance and added support for Java exceptions and Kotlin top-level functions. We’ve also discontinued the former <a href=\"https://github.com/dart-lang/native/issues/660\">C-based bindings</a>, as the alternate Dart-only bindings now have comparable performance and features, and are much easier to use, For details, see the <a href=\"https://pub.dev/packages/jnigen/changelog\">changelog</a>.</p><p>Objective-C interop builds on top of FFI and our <a href=\"https://pub.dev/packages/ffigen\">FFIgen</a> generator (currently in preview). We’ve added support for Objective-C protocols, and common types such as NSString. For a large example of a package built with FFIgen, see <a href=\"https://github.com/dart-lang/http/tree/master/pkgs/cupertino_http\">cupertino_http</a> which interoperates with Apple’s URL Loading System networking library.</p><p>We’ll continue to invest in further interoperability — both in terms of completing the above mentioned libraries, and in terms of supporting Swift — over the coming releases. See the roadmap section below for details.</p><h3>Pub.dev package repository</h3><p>Pub.dev is our package repository where the community can share and find packages with a wealth of functionality. We’ve made a number of improvements here. First we’ve refined the support for <a href=\"https://dart.dev/tools/pub/pubspec#topics\"><strong>topics</strong></a>: the mechanism by which package authors can tag their packages with the category that they belong to (such as widget). We now <a href=\"https://github.com/dart-lang/pub-dev/blob/master/doc/topics.yaml\">consolidate</a> common topics that cover the same category but use slight variations in their phrasing (for example widgets vs widget).</p><p>Second, we’ve added a new pub unpack command. This offers a quick and easy way to download a package to your file system. This can be used, for example, if you want to run the example program of a package on your local machine:</p><pre>$ dart pub unpack path<br>Downloading path 1.9.0 to `./path-1.9.0`...<br><br>$ cd path-1.9.0/example/<br><br>$ dart run example.dart<br>Current path style: posix<br>Current process path: /Users/mit/tmp/path-1.9.0/example</pre><p>Third, we’ve added a new pub downgrade --tighten command. This can be used to check all the version constraints in a package’s dependencies. When run, it updates the lower constraint to the lowest version for which pub was able to do a resolution.</p><h3>Dart roadmap update</h3><p>In addition to the completed features above, we’ve also done work across a large number of areas to make progress on our long-term roadmap.</p><h3>IDE and analyzer performance for large monorepos</h3><p>A ‘monorepo’ is a common way of structuring the source code for a set of related packages and apps in a single repository, for example as in Flutter’s <a href=\"https://github.com/flutter/packages/tree/main\">packages repo</a>. A monorepo isn’t just about the convenience of having all the source code “close together”, but can also be a critical tool to ensure that the individual packages &amp; apps in the repo are mutually compatible.</p><p>We’ve heard consistent feedback from developers that work in large monorepos, that the performance of our tools, and specifically the analyzer, can be lacking. Our analysis of these issues suggests that the root issue is that we end up loading multiple overlapping analysis contexts for each package and ALL of its dependencies, leading to several copies of the analysis of each package in the monorepo in memory at the same time. We believe the fundamental solution is to create a single, shared resolution of the versions of each dependency in such repos, and are working on such a capability via a new pub feature called <a href=\"https://github.com/dart-lang/sdk/issues/53875\">workspaces</a>. We’ll have much more to share about this in our next Dart release, but for now you can go ahead and see how this was <a href=\"https://github.com/flutter/engine/pull/54157/files\">recently applied</a> to the Flutter engine repo.</p><h3>Pub.dev package repository</h3><p>Users of the pub.dev package repository have long requested improved metrics for <a href=\"https://github.com/dart-lang/pub-dev/issues/2714\">how used/downloaded</a> each package is. This can be helpful both for package authors as a signal of how many users are deriving benefit from their work, and for package consumers as a signal of what packages other developers are consuming. We’re happy to share that we’re making good progress on this capability, and hope to have it in preview by end of year.</p><h3>Dart native interop</h3><p>For the Java and Kotlin interop with JNIgen, we expect to wrap up the core support and graduate from experimental to a stable version 1.0 over the next two quarters. For details, see the <a href=\"https://github.com/orgs/dart-lang/projects/69/\">JNIgen tracker</a>. For ObjectiveC interop, we have a similar goal; see the <a href=\"https://github.com/orgs/dart-lang/projects/87\">Objective-C tracker</a>.</p><p>Next up we’re investigating direct interop with Swift code. The initial experimentation looks promising, and we hope to have experimental support added early next year.</p><h3>Native interop and bundling of native source code</h3><p>In many cases direct interop is used to call into APIs that are present in the operating system, which means the APIs are always available on those host platforms. However, in some cases the code that Dart is interoperating with is native <em>source code</em> not included directly on the host, which presents a practical challenge for package authors who use such interop: How do you get that native source code bundled and built without having to push a bunch of manual steps onto the consumers of the package? To support this, we’re exploring a <a href=\"https://github.com/dart-lang/sdk/issues/50565\">native assets system</a>, which could support publishing Dart packages that contain native source code, along with a standardized protocol for enabling the dart and flutter CLI tools to automate the building and bundling of that source code. We envision that this will enable a new set of interoperability use cases, while at the same time offering an uncomplicated user experience for developers who use packages that rely on native source code.</p><h3>Dart language &amp; macros</h3><p>Most of our time in the Dart language and compiler teams is currently spent on making progress on the very large language feature macros, which we introduced in the <a href=\"https://medium.com/dartlang/dart-3-4-bd8d23b4462a\">Dart 3.4 blog post</a>. As we said at the time, this is a huge undertaking, with the potential to cause regressions in some of our core use cases such as hot reload, so we’re taking a thorough approach, and will likely need several quarters of further work before we can share details of the next step.</p><p>In addition to macros, we’re also concurrently exploring a number of other smaller language features, as documented in the <a href=\"https://github.com/orgs/dart-lang/projects/90/views/1\">Dart language funnel</a>.</p><p>Since last fall, we have been rewriting the Dart formatter. The old design worked well for many years, but with the success of Flutter, we want to move to <a href=\"https://github.com/dart-lang/dart_style/issues/1253\">a new style</a> that better works for the kind of declarative code that Flutter users often write. The old formatter wasn’t able to produce that kind of output. The rewrite is close to being done and will ship soon. If you’d like to try it out, pass the experiment flag tall-style (<a href=\"https://dart.dev/tools/experiment-flags\">flag instructions</a>). We welcome <a href=\"https://github.com/dart-lang/dart_style/issues\">feedback</a> if you see weird output.</p><h3>Closing</h3><p>That’s all we have for today. We welcome your feedback, both on the roadmap items discussed, and on the new features in Dart 3.5, available from <a href=\"https://dart.dev/get-dart\">Dart.dev</a> or bundled in today’s <a href=\"https://medium.com/flutter/whats-new-in-flutter-3-24-6c040f87d1e4\">Flutter 3.24 release</a>.</p><img src=\"https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6ca36259fa2f\" width=\"1\" height=\"1\" alt=\"\"><hr><p><a href=\"https://medium.com/dartlang/dart-3-5-6ca36259fa2f\">Announcing Dart 3.5, and an update on the Dart roadmap</a> was originally published in <a href=\"https://medium.com/dartlang\">Dart</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>"}}