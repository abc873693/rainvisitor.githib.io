<!DOCTYPE html>
<html lang="zh-tw,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rainvisitor.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/page/13/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.rainvisitor.me/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-tw'
  };
</script>

  <title>RainVisitor Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RainVisitor Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">RainVisitor</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/ba93ff4f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/ba93ff4f.html" class="post-title-link" itemprop="url">【文章翻譯】Deprecation Lifetime in Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-18 00:06:01" itemprop="dateCreated datePublished" datetime="2020-11-18T00:06:01+08:00">2020-11-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Flutter-中的棄用生命週期"><a href="#Flutter-中的棄用生命週期" class="headerlink" title="Flutter 中的棄用生命週期"></a>Flutter 中的棄用生命週期</h2><p>新的一年即將到來，Flutter 團隊正在為 2021 年的全新開始做好準備。</p>
<p>為此，我們將從 Flutter 架構中移除一些已棄用的 API。</p>
<p>在 Flutter 架構中移除棄用並非新鮮事。我過去也曾經 <a href="https://github.com/flutter/flutter/pull/57065">自己處理過</a>。<a href="https://github.com/flutter/flutter/pulls?q=is:pr+is:closed+issues:+66020+64483+57065+51240+24115+67478">快速搜尋</a> 結果顯示，過去移除棄用沒有定義的時間軸或排程，因為我們的 <a href="https://github.com/flutter/flutter/wiki/Tree-hygiene#deprecation">棄用策略</a> 並沒有規定何時移除它們。由於我們希望為使用者提供一致且可靠的體驗，因此我們決定為棄用建立標準生命週期。</p>
<p>本文將討論我們目前針對重大變更和棄用的策略，以及這些策略如何付諸實行，以及如何發展以為使用者提供更好的體驗。</p>
<h3 id="Flutter-中的重大變更"><a href="#Flutter-中的重大變更" class="headerlink" title="Flutter 中的重大變更"></a>Flutter 中的重大變更</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*kp3Y8CnUirX421Fi" />
<figcaption>Photo by <a href="https://unsplash.com/@chuttersnap?utm_source=medium&amp;utm_medium=referral">CHUTTERSNAP</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption>
</figure>

<p>在 Flutter 中棄用程式碼的流程始於我們的 <a href="https://github.com/flutter/flutter/wiki/Tree-hygiene#handling-breaking-changes">重大變更策略</a>。棄用被視為重大變更，這意味著它們必須遵循 <a href="https://flutter.dev/docs/resources/design-docs">公開設計文件</a> 指南，該指南要求一段時間用於討論。（此提案的設計文件為 <a href="https://docs.google.com/document/d/1Gc3ecrMghzc7WU4pgzKB8uBaTPpRdWfozn0otBbxR7s/edit">實作棄用生命週期</a>。) 除了提供設計文件外，我們還會在 <a href="https://github.com/flutter/flutter/wiki/Chat">Flutter 貢獻者 Discord</a> 和受歡迎的社群，例如 <a href="https://groups.google.com/g/flutter-announce">flutter-announce</a> 和 <a href="https://groups.google.com/g/flutter-dev">flutter-dev</a> 上發佈訊息，所有這些都在進行任何變更之前。這是我作為工程師最喜歡的流程之一：我能夠聽到您的意見。我們很棒的社群在這個流程中非常活躍，這也讓我們變得更好。在多次場合中，我看到一個功能的設計在透過這些管道發佈後有了很大的改進，這全都是因為社群的回饋。</p>
<p>重大變更的作者會遷移受重大變更影響的客戶程式碼。在我們重大變更策略的最後一次更新中，我們 <a href="https://groups.google.com/g/flutter-announce/c/Z09a317E21o">邀請</a> 您將測試提交到我們的 <a href="https://github.com/flutter/tests">客戶測試儲存庫</a>。這些測試是我們標誌著變更會造成中斷的訊號，我們承諾會在進行變更之前與測試作者合作遷移他們的程式碼。</p>
<p>我們還為我們的重大變更提供 <a href="https://flutter.dev/docs/release/breaking-changes">遷移指南</a>。這些指南旨在幫助使用者在更新到最新版本的 Flutter 後遷移他們的程式碼。如果您看過我們的 <a href="https://medium.com/flutter/announcing-flutter-1-22-44f146009e5f">發行公告</a> 之一，我們也會在特定版本中指出中斷，並引導使用者到有用的資源，幫助他們更新應用程式。</p>
<p>在 <a href="https://medium.com/flutter/insights-from-flutters-first-user-survey-of-2019-3659b02303a5">過去的調查</a> 中，我們詢問使用者他們對重大變更的偏好。我們了解到使用者認為重大變更使程式碼更乾淨，對他們很有價值，這就是為什麼我們通常更喜歡重大變更而不是棄用的原因。根據研究：</p>
<p>總體而言，78% 的人表示他們更喜歡導致最乾淨的 API 的重大變更；這也使 API 更易於學習和使用。</p>
<p>我們的重大變更策略基於此研究。與所有規則一樣，總是會有例外。我最近 <a href="https://github.com/flutter/flutter/pull/67947">棄用了一些非常受歡迎的方法</a>，改用新的 Widget。如果我們知道特定變更會造成重大中斷，影響許多使用者，我們就會棄用。棄用允許遷移緩衝期，同時仍然提供重大變更策略所產生所有工具。</p>
<h3 id="日漸老舊的棄用"><a href="#日漸老舊的棄用" class="headerlink" title="日漸老舊的棄用"></a>日漸老舊的棄用</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*n5eFBwWfgtkuLtDf" />
<figcaption>Photo by <a href="https://unsplash.com/@dilja96?utm_source=medium&amp;utm_medium=referral">Dilyara Garifullina</a> on <a href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral">Unsplash</a></figcaption>
</figure>

<p>遷移緩衝期從棄用在 <a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=windows">穩定頻道</a> 上發佈時開始。緩衝期結束的時間軸為 1 個日曆年或 4 個穩定版本，取較長者。為了制定出我們認為舒適的時間軸，我們查看了我們的成長率和採用率，並評估了一些已公開發佈的 Flutter 應用程式和套件。</p>
<p>我們希望使用者能夠預期這個排程，而不是擔心下一個版本是否會因為棄用消失而帶來意外的升級障礙。我們還希望確保我們提前通知這些變更，並且我們承諾在開始移除棄用之前，會宣布棄用即將結束生命週期。本著這種精神，我想要與您分享 <a href="http://flutter.dev/go/deprecation-lifetime">第一批即將結束生命週期的棄用</a>，現在 Flutter 1.22 已推出。</p>
<p>由於這是我們第一次實施這項策略，因此有很多棄用，其中有些甚至早於 Flutter 1.0！其中一些棄用也早於我們的重大變更策略。我們將會為所有這些棄用努力建立遷移工具和指南。預計在我們下一個穩定版本推出之前，這些棄用將從 Flutter 架構中移除，並會在移除時透過我們通常的管道發布公告。</p>
<p>在我們開始實施這些變更的同時，我們希望聽到您的意見！我們始終歡迎您將測試提交到我們的客戶測試儲存庫，我們會在進行中斷之前與您合作遷移您的程式碼。若要進一步了解測試儲存庫以及如何提交測試，請查看 <a href="https://github.com/flutter/tests/blob/master/README.md">Flutter 測試 README</a>。在進行這些變更時，我們將透過 <a href="https://github.com/flutter/flutter/wiki/Chat">Flutter 貢獻者 Discord</a>、<a href="https://groups.google.com/g/flutter-announce">flutter-announce</a> 和 <a href="https://groups.google.com/g/flutter-dev">flutter-dev</a> 頻道通知您並徵求您的回饋。因此，如果您尚未加入其中一個社群，請務必加入！我們期待收到您的訊息，並與您合作。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e4d76ee738ad" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/deprecation-lifetime-in-flutter-e4d76ee738ad">Flutter 中的棄用生命週期</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/8629fd50.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/8629fd50.html" class="post-title-link" itemprop="url">【文章翻譯】New ad formats for Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-11 19:57:23" itemprop="dateCreated datePublished" datetime="2020-11-11T19:57:23+08:00">2020-11-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="為-Flutter-行動廣告-Plugin-開放嵌入式橫幅和原生廣告的-Beta-程式"><a href="#為-Flutter-行動廣告-Plugin-開放嵌入式橫幅和原生廣告的-Beta-程式" class="headerlink" title="為 Flutter 行動廣告 Plugin 開放嵌入式橫幅和原生廣告的 Beta 程式"></a>為 Flutter 行動廣告 Plugin 開放嵌入式橫幅和原生廣告的 Beta 程式</h2><p>有許多方法可以讓行動應用程式開發人員獲得工作的報酬。透過廣告變現應用程式是許多行動開發人員（包括使用 Flutter 的開發人員）的熱門選擇之一。</p>
<p><a href="https://github.com/flutter/flutter/issues/12114">原生廣告格式支援</a>，特別是 Flutter 的前五名熱門功能請求之一。Flutter 團隊先前提供的 Google 廣告 Plugin（也稱為 <code>firebase_admob</code> Plugin）支援覆蓋橫幅、插頁式和獎勵影片，但無法渲染嵌入式橫幅或原生廣告等格式。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0kWrLLh_g2Ywwgcs_iAL-w.png" />
</figure>

<h3 id="嵌入式橫幅和原生廣告"><a href="#嵌入式橫幅和原生廣告" class="headerlink" title="嵌入式橫幅和原生廣告"></a>嵌入式橫幅和原生廣告</h3><p>顧名思義，嵌入式橫幅廣告讓您將廣告單元整合為 Flutter 視圖的一部分，而不是將橫幅覆蓋在 UI 上。同樣地，原生廣告允許您設計一種感覺像是您應用程式內容自然一部分的廣告體驗。一些開發人員告訴我們，缺少嵌入式橫幅和原生廣告會阻礙他們建立美麗自然的廣告體驗的能力，而另一些開發人員則表示，沒有這些功能可能會阻止他們將 Flutter 採用到他們的應用程式中。</p>
<p>為了響應您的請求，我們一直在開發對這些格式的支援。一年前，我們開始與 Google Ads 密切合作，為 Flutter 實作健全且值得信賴的嵌入式廣告解決方案。我們還完全重構了 Plugin 程式碼，以提高效能和穩定性。今天，在完成實作和一系列 Alpha 測試後，我們很高兴地宣布，此更新的 Plugin 的 beta 版本將提供僅限邀請的存取權。</p>
<p>藉由這個 beta 測試，我們在現有 Plugin 上進行了建置，並為 AdMob 和 Ad Manager 新增了對新格式的支援。與所有 beta 版本一樣，仍然存在一些需要解決的問題，而且功能支援可能會在未經通知的情況下發生變化。如果被選為參與 beta 測試，我們強烈建議您在將應用程式發佈給使用者之前，在您的應用程式中徹底測試整合。</p>
<h3 id="立即申請"><a href="#立即申請" class="headerlink" title="立即申請"></a>立即申請</h3><p>若要申請參與我們的 beta 測試，請填寫 <a href="https://forms.gle/5d1MfrbaCLX9PS2Z9">我們的申請表</a>。我們特別尋找已有應用程式上架且願意與我們團隊合作，在他們的生產應用程式中使用我們的 beta 版本的客戶。如果您被選為參與 beta 測試，您將收到一封包含更多說明的電子郵件。</p>
<p>根據此 beta 測試的結果，我們預計在 2021 年初向更廣泛的受眾開放使用。</p>
<p>我們希望嵌入式橫幅和原生廣告能幫助您為您的 Flutter 應用程式解鎖更多收入增長。</p>
<p>祝您程式設計和廣告愉快！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e48a7e9a0e64" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/new-ads-beta-inline-banner-and-native-support-for-the-flutter-mobile-ads-plugin-e48a7e9a0e64">Flutter 的新廣告格式</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/2f2adf1b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/2f2adf1b.html" class="post-title-link" itemprop="url">【文章翻譯】Accessible expression with Material Icons and Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-04 16:03:20" itemprop="dateCreated datePublished" datetime="2020-11-04T16:03:20+08:00">2020-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="使用-Material-Icons-和-Flutter-打造可存取的表達力"><a href="#使用-Material-Icons-和-Flutter-打造可存取的表達力" class="headerlink" title="使用 Material Icons 和 Flutter 打造可存取的表達力"></a>使用 Material Icons 和 Flutter 打造可存取的表達力</h2><p>Material Design 和 Flutter 都能幫助開發人員打造出靈活、可存取且富於表現力的體驗，同時提供出色的效能和效率。現在，我們很高興為您提供更多方法來使用改進的 Material Icons 支援在 Flutter 中建立獨特的 UI。</p>
<p><a href="https://material.io/resources/icons">Material Icons</a> 是為常見動作和項目精心設計的圖示，包括從用於導航的簡單箭頭和指示器，到代表可存取性、錯誤回報，甚至洗手等概念的圖示。</p>
<p>Flutter 現在支援所有四種圖示樣式——<em>填滿、描邊、銳利和圓形</em>——幫助您讓您的應用程式或網站對使用者來說熟悉且易於存取，同時讓您以獨特的方式傳達您的品牌。而且，透過對樹狀搖動的支援，Flutter 會優化您的應用程式建構，只包含您正在使用的圖示，從而使載入時間和記憶體使用更加有效率。</p>
<p>以下是一些展示您在 Material 目錄中找到的選項範圍的圖示。您可以在 <a href="https://material.io/resources/icons/">Material.io</a> 上瀏覽完整的圖示集並下載位圖或向量版本以供在您喜愛的設計工具中使用，或在 <a href="https://api.flutter.dev/flutter/material/Icons-class.html">Icons</a> API 頁面上查看 Flutter 版本。</p>
<figure>
<img alt="Sample of 4 icons: shopping_cart, chat, masks, wash shown in the 4 supported styles: filled, outlined, rounded, sharp." src="https://cdn-images-1.medium.com/max/716/1*kcT41A5GvXp8XrjHjiuc4A.png" />
<figcaption>Sample of 4 icons: shopping_cart, chat, masks, wash. Displayed in the 4 supported styles: filled, outlined, rounded, sharp.</figcaption>
</figure>

<p><strong>入門</strong></p>
<p>若要開始使用 <a href="https://master-api.flutter.dev/flutter/widgets/Icon-class.html">Icon 類別</a>，請確保在您專案的 <code>pubspec.yaml</code> 檔案中設定 <code>uses-material-design: true</code>。這會告訴 Flutter 將圖示資產包含在您的應用程式中。</p>
<p>Flutter 中的圖示透過圖示字體以向量形式提供，因此您可以無限調整大小和顏色，而無需擔心影像品質下降。在 <a href="https://github.com/material-components/material-components-flutter/tree/develop/medium/material_icons">GitHub</a> 上查看用於生成上述圖示集的程式碼。</p>
<p><strong>不要跳過語義標籤！</strong></p>
<p>為了讓使用螢幕閱讀器等輔助科技的使用者能夠有效地導航您的應用程式或網站，提供有意義且上下文適當的語義標籤非常重要。</p>
<p>預設情況下，螢幕閱讀器會朗讀螢幕上顯示的任何文字。為了將圖示等視覺元素準確地轉換為基於文字的 UI，您需要仔細標記這些元素。</p>
<p>例如，當圖示與動作元素（如按鈕）結合使用時，您應該始終將語義標籤設定為描述使用者點擊該圖示時會發生什麼的字串。</p>
<p><a href="https://material.io/design/usability/accessibility.html#writing">Material.io 提供指南</a> 來指示透過動作來表示 UI 元素。常見的錯誤是將語義標籤預設為圖示的名稱，而不是選擇該圖示時執行的動作。</p>
<figure>
<img alt="an example of what to do: a Pencil icon with the label “edit” and what not to do: a Pencil icon with the label “Pencil”" src="https://cdn-images-1.medium.com/max/1024/1*sZKrpmVM5f5bRSgy453T1Q.png" />
</figure>

<p>若要進一步了解建立可存取的數位體驗的重要性，請參閱 flutter.dev 上的 <a href="https://flutter.dev/docs/development/accessibility-and-localization/accessibility">可存取性</a>。</p>
<p><strong>只發佈您使用的內容！</strong></p>
<p>當您為發佈建構應用程式時，Flutter 編譯器會執行「樹狀搖動」，移除未使用的程式碼和資產（包括圖示），以優化應用程式的佔用空間，並幫助最大限度地減少下載和載入時間。可以使用您想要的任何圖示！在編譯期間，會生成一個自訂圖示字體，其中只包含專案中使用的圖示子集。這可以大幅減少二進制檔案的大小——所有人都能受益！</p>
<p>除了樹狀搖動之外，這裡還有一篇關於 <a href="https://medium.com/@suryadevsingh24032000/size-matters-reducing-flutter-app-size-best-practices-ca992207782">縮減 Flutter 應用程式大小的最佳實務</a> 的很棒社群文章。</p>
<p><strong>向我們展示您的傑作！</strong></p>
<p>全世界的開發人員都在使用 Material Icons 來確保在大型和小尺寸條件下都能保持可讀性和清晰度；這些圖示已針對在所有 Flutter 支援的平台和顯示解析度上美麗顯示而進行優化。</p>
<p>在 @<a href="https://twitter.com/materialdesign">MaterialDesign</a> 和 @<a href="https://twitter.com/FlutterDev">@FlutterDev</a> 上關注我們，並展示您如何使用 Material Design 和 Flutter 打造出美麗、可存取的數位體驗！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e3f3f622200b" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/accessible-expression-with-material-icons-and-flutter-e3f3f622200b">使用 Material Icons 和 Flutter 打造可存取的表達力</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/4254a2e9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/4254a2e9.html" class="post-title-link" itemprop="url">Android app 上架流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-25 19:51:40" itemprop="dateCreated datePublished" datetime="2020-10-25T19:51:40+08:00">2020-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-26 00:09:13" itemprop="dateModified" datetime="2020-10-26T00:09:13+08:00">2020-10-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本篇文章主要介紹在2020年 Goolge 改版後的 Play Store Console 如何上架 Android App</p>
<p>首先到 <a href="https://play.google.com/console/u/0/developers/" target="_blank" rel="noopener">Play Store Console</a> 右邊點擊新增應用程式</p>
<p><img src="../images/android-app-deploy/img1.png" alt=""></p>
<p>填寫以下應用程式詳細資訊</p>
<ul>
<li>應用程式名稱：會顯示在商店的App名稱</li>
<li>預設語言：預設App使用的語言，作為商店一開始提供的預設語言</li>
<li>應用程式類型：分類只有遊戲與應用程式，目的是要把遊戲區分出來，日後可更改</li>
<li>是否收費：設定App是否下載時需要費用，勾選收費後，需要至 <code>付費應用程式</code> 修改設定</li>
</ul>
<p>最後同意 <code>開發人員計畫政策</code> 及 <code>美國出口法律</code> 後，即可完成初始設定</p>
<p><img src="../images/android-app-deploy/img2.png" alt=""></p>
<p><img src="../images/android-app-deploy/img3.png" alt=""></p>
<p>接著進入到 <code>資訊主頁</code></p>
<p><img src="../images/android-app-deploy/img4.png" alt=""></p>
<p>第一次設定時會出現 <code>初始設定</code> 提示，可依序點擊設定，該步驟都是必須完成的步驟，否則無法完成審查上架</p>
<p><img src="../images/android-app-deploy/img5.png" alt=""></p>
<h1 id="應用程式存取權"><a href="#應用程式存取權" class="headerlink" title="應用程式存取權"></a>應用程式存取權</h1><p>設定 App 是否開放給全部使用者</p>
<p><img src="../images/android-app-deploy/img6.png" alt=""></p>
<p>或是部分功能有使用限制，需設定：</p>
<ul>
<li>名稱</li>
<li>使用者名稱/電話號碼</li>
<li>密碼</li>
<li>任何操作說明</li>
</ul>
<p>透過此可限制使用者下載應用程式</p>
<p><img src="../images/android-app-deploy/img7.png" alt=""></p>
<p><img src="../images/android-app-deploy/img8.png" alt=""></p>
<h1 id="廣告"><a href="#廣告" class="headerlink" title="廣告"></a>廣告</h1><p>設定App中是否有廣告，若有勾選廣告則會在Play商店上顯示 <code>含廣告內容</code> 的標籤</p>
<p><img src="../images/android-app-deploy/img10.png" alt=""></p>
<h1 id="內容分級"><a href="#內容分級" class="headerlink" title="內容分級"></a>內容分級</h1><p>根據國際年齡分級聯盟（英語：International Age Rating Coalition，縮寫IARC）設計的簡化各國分級的內容分級問卷，降低產品評比的過程，<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E5%B9%B4%E9%BD%A1%E5%88%86%E7%B4%9A%E8%81%AF%E7%9B%9F" target="_blank" rel="noopener">參考資料</a></p>
<p>填寫內容分級問卷，讓使用者了解App的分類，及是否會有不宜兒童的內容</p>
<p><img src="../images/android-app-deploy/img11.png" alt=""></p>
<p>首先填寫電子郵件，問卷完成會寄送一份結果至該信箱</p>
<p><img src="../images/android-app-deploy/img13.png" alt=""></p>
<p>選擇 App 的類別，以 <a href="https://play.google.com/store/apps/details?id=com.wtuc.ap" target="_blank" rel="noopener">文藻校務通</a> 為例，選擇 <code>參考資訊、新聞或教育內容</code></p>
<p><img src="../images/android-app-deploy/img12.png" alt=""></p>
<p>根據選擇的類型，需填寫相關內容是否有未成年暴力色情訊息</p>
<p><img src="../images/android-app-deploy/img14.png" alt=""></p>
<p>完成後會顯示基本的報表，點擊右下角提交完成問卷</p>
<p><img src="../images/android-app-deploy/img15.png" alt=""></p>
<p>完成後，若日後想在修改問卷內容，需至右上角 點擊 <code>Start new questionaire</code> 重新提交問卷</p>
<p><img src="../images/android-app-deploy/img16.png" alt=""></p>
<h1 id="目標對象"><a href="#目標對象" class="headerlink" title="目標對象"></a>目標對象</h1><p>填寫詳細的App發布目標對象</p>
<p>首先點選 <code>目標年齡層</code>，主要是確認目標對象是不是兒童，若對象未滿13歲則需要新增隱私權政策</p>
<p><img src="../images/android-app-deploy/img18.png" alt=""></p>
<p>勾選 <code>是否會引起兒童興趣</code>，若上者點擊13歲以下，可勾選 <code>是</code> 宣稱適合兒童</p>
<p><img src="../images/android-app-deploy/img19.png" alt=""></p>
<p>最後點擊 <code>儲存</code> 完成目標對象和內容</p>
<p><img src="../images/android-app-deploy/img20.png" alt=""></p>
<p>接著就完成一半了～～</p>
<p><img src="../images/android-app-deploy/img21.png" alt=""></p>
<h1 id="應用程式類別及詳細資料"><a href="#應用程式類別及詳細資料" class="headerlink" title="應用程式類別及詳細資料"></a>應用程式類別及詳細資料</h1><p>應用程式分類，區分應用程式或遊戲的類別，在Play 商店中，也會有類別排名</p>
<p><img src="../images/android-app-deploy/img22.png" alt=""></p>
<p>接著設定商店的聯絡詳細資訊，分別為</p>
<ul>
<li>電子郵件地址 (必填)</li>
<li>電話號碼</li>
<li>網站</li>
</ul>
<p><strong>以上訊息皆會在Play商店上顯示</strong></p>
<p><img src="../images/android-app-deploy/img23.png" alt=""></p>
<p>並勾選是否要在Play商店外行銷，讓外部網站可搜尋到你的App</p>
<p><img src="../images/android-app-deploy/img24.png" alt=""></p>
<p>完成後就只剩下最後一個步驟</p>
<p><img src="../images/android-app-deploy/img25.png" alt=""></p>
<h1 id="商店資訊"><a href="#商店資訊" class="headerlink" title="商店資訊"></a>商店資訊</h1><p>首先會根據一開始設定的<code>主要語言</code>，設定 App 在 Play 商店的資訊，可根據不同語言，設定不同的商店資訊，可點擊 <code>管理其他語言版本的翻譯內容</code> 管理其他語言的內容</p>
<h2 id="應用程式詳細資料"><a href="#應用程式詳細資料" class="headerlink" title="應用程式詳細資料"></a>應用程式詳細資料</h2><p>首先可設定</p>
<ul>
<li>應用程式名稱：App名稱，作為可供搜尋的關鍵字，上限50字</li>
<li>簡短說明：可在App頁面首要看到簡短說明，上限80字</li>
<li>完整說明：在點擊<code>關於這個應用程式</code>後顯示的完整說明</li>
</ul>
<p><img src="../images/android-app-deploy/img26.png" alt=""></p>
<p>可參照 Play 商店對應位置</p>
<p><img src="../images/android-app-deploy/img26-1.jpg" alt=""></p>
<p><img src="../images/android-app-deploy/img26-2.jpg" alt=""></p>
<p>接著設定 <code>應用程式圖示</code> 會顯示在 Play 商店的圖示，<strong>限定尺寸為 <code>512*512</code> 的解析度</strong>，上傳後都會以橢圓裁剪顯示</p>
<p><img src="../images/android-app-deploy/img27.png" alt=""></p>
<p>主要圖片顯示於商店資訊的最頂端，可用於宣傳應用程式，<strong>大小限制 <code>1024*500</code> 解析度的圖片</strong></p>
<p><img src="../images/android-app-deploy/img29.png" alt=""></p>
<p>螢幕截圖主要分為</p>
<ul>
<li>手機</li>
<li>七吋平板電腦</li>
<li>十吋平板電腦</li>
</ul>
<p>基本上，對應類型的裝置截圖都適用，也可自行製作符合規定的尺寸的圖片，<strong>皆為使用 JPEG 或 24 位元 PNG 圖片，長寬比建議16:9</strong></p>
<p><img src="../images/android-app-deploy/img30.png" alt=""></p>
<p><img src="../images/android-app-deploy/img31.png" alt=""></p>
<p>加入影片也會顯示於商店上</p>
<p><img src="../images/android-app-deploy/img32.png" alt=""></p>
<p>商店資訊設定完成後，若未來要修改都可直接修改，但修改後都需要等商店部署時間，通常都會為半天左右時間</p>
<h1 id="上傳App至商店"><a href="#上傳App至商店" class="headerlink" title="上傳App至商店"></a>上傳App至商店</h1><p>到 <code>發佈</code> 的目錄下，選擇App目前要發布的方式，有分成</p>
<ul>
<li>正式版：會發布給商店中所有設置的地區</li>
<li>公開測試：任何使用者可至 Play 商店點擊測試計畫，即可使用此版本</li>
<li>封閉測試：由開發人員建立電子郵件清單，或是可透過連結加入測試計畫 <a href="https://play.google.com/apps/testing/{app" target="_blank" rel="noopener">https://play.google.com/apps/testing/{app</a> id}</li>
<li>內部測試：由開發人員建立電子郵件清單，或是可透過內部邀請測試連結：<a href="https://play.google.com/apps/internaltest/{test" target="_blank" rel="noopener">https://play.google.com/apps/internaltest/{test</a> group id} 加入</li>
<li>搶先註冊：若還沒發佈正式版時，可利用此功能，在Play商店中顯示搶先體驗的字樣，並提供測試人員特殊獎勵</li>
</ul>
<p>不管利用哪種測試方式，接下來上傳App的方式都會相同，例如選擇 <code>正式版</code> 發布，並點擊右上方的 <code>建立新版本</code></p>
<p><img src="../images/android-app-deploy/img33.png" alt=""></p>
<p>接著第一次上架時需點擊 同意使用 <code>Google Play 應用程式簽署</code>，Google 會管理你簽署所使用的金鑰，並且該金鑰只能提供給該 App 使用</p>
<p>若今天金鑰遺失，可請帳戶擁有者聯絡<a href="https://support.google.com/googleplay/android-developer/contact/otherbugs" target="_blank" rel="noopener">支援小組</a>重新上傳金鑰</p>
<p>將利用 <code>Android Studio</code> 等等的 Android 編譯工具，將原生Android 的 <code>Apk</code> 或是 <code>App Bundle</code> 上傳至此頁面</p>
<p><strong>每次新上傳的 <code>版本號碼(version code)</code> 皆需大於先前上傳的</strong></p>
<p>關於金鑰使用詳細 <a href="https://support.google.com/googleplay/android-developer/answer/7384423" target="_blank" rel="noopener">可參考</a></p>
<p><img src="../images/android-app-deploy/img35.png" alt=""></p>
<h2 id="版本詳細資訊"><a href="#版本詳細資訊" class="headerlink" title="版本詳細資訊"></a>版本詳細資訊</h2><p>版本名稱會根據上傳的 <code>Apk</code> 或 <code>App Bundle</code> 命名</p>
<p>版本資訊會根據商店可提供的語言，以 <code>XML</code> 格式撰寫，將這次更新內容寫至 <code>語言碼(language code)</code> 中</p>
<p><img src="../images/android-app-deploy/img36.png" alt=""></p>
<p>完成後點擊儲存，並點擊檢查版本</p>
<p><img src="../images/android-app-deploy/img37.png" alt=""></p>
<p>接著會發現沒有設定提供地區</p>
<p><img src="../images/android-app-deploy/img38.png" alt=""></p>
<p>返回至上一頁的最上方，選擇 <code>國家與地區</code> 編輯針對正式版的發布國家/地區</p>
<p><img src="../images/android-app-deploy/img39.png" alt=""></p>
<p>若沒勾選，Play商店就不會發佈至此國家/地區</p>
<p><img src="../images/android-app-deploy/img40.png" alt=""></p>
<p>接著回到剛剛編輯的版本資訊，點擊 <code>開始發布(正式版)</code></p>
<p><img src="../images/android-app-deploy/img41.png" alt=""></p>
<p>最後會跳回正式版的頁面，並顯示審查中</p>
<p><img src="../images/android-app-deploy/img42.png" alt=""></p>
<p>自 2019 年開始，Play 商店在第一次審查時，最久大約會至七天，爾後提交大約都是一下子就完成審查，並都是半天會完全部署至商店(所有使用者都可以看到更新)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/dc2c1f00.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/dc2c1f00.html" class="post-title-link" itemprop="url">iOS app 上架流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-24 20:27:58" itemprop="dateCreated datePublished" datetime="2020-10-24T20:27:58+08:00">2020-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-25 20:07:40" itemprop="dateModified" datetime="2020-10-25T20:07:40+08:00">2020-10-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本篇文章主要介紹在2020年 Apple 改版後的 App Store Connect 如何上架 iOS App</p>
<h1 id="新增-App"><a href="#新增-App" class="headerlink" title="新增 App"></a>新增 App</h1><p>到 <a href="https://appstoreconnect.apple.com/" target="_blank" rel="noopener">App Store Connect</a> 點擊 <code>我的App</code></p>
<p><img src="../images/ios-app-deploy/img1.png" alt=""></p>
<p>點擊 App 旁邊邊的 + 選擇 <code>新的 App</code></p>
<p><img src="../images/ios-app-deploy/img2.png" alt=""></p>
<h1 id="註冊Identifier"><a href="#註冊Identifier" class="headerlink" title="註冊Identifier"></a>註冊Identifier</h1><p>到 <a href="https://developer.apple.com/account/resources/identifiers/list" target="_blank" rel="noopener">憑證、識別碼及描述檔</a> 註冊App的 <code>Identifier</code></p>
<p><img src="../images/ios-app-deploy/img4-0.png" alt=""></p>
<p>選擇 <code>App IDs</code></p>
<p><img src="../images/ios-app-deploy/img4-1.png" alt=""></p>
<p>選擇 <code>App</code></p>
<p><img src="../images/ios-app-deploy/img4-2.png" alt=""></p>
<p><strong>Discription</strong> 填寫可以識別的名稱</p>
<p><strong>App ID Prefix</strong> 選擇 <code>Explicit</code> 並填上與 Xcode 中的 <code>Bundle Indentifier</code> 相同的 ID</p>
<p><strong>App ID Prefix 的 Bundle ID 上架後就不可修改</strong></p>
<p>最後點擊 <code>Continue</code> 然後 <code>Register</code> 完成註冊</p>
<p><img src="../images/ios-app-deploy/img4-3.png" alt=""></p>
<p>或是</p>
<p>懶人方法</p>
<p>使用 <code>Xcode</code> 在 <code>Target</code> 中的 <code>Runner</code> 選擇 <code>Signing &amp; Capabilities</code></p>
<p>選擇想要上架的Apple開發者帳號</p>
<p><img src="../images/ios-app-deploy/img3.png" alt=""></p>
<p>並點擊 <code>+ Capability</code> 隨意新增一個 Capability</p>
<p>此動作 <code>Xcode</code> 會自動註冊 <code>Indentifier</code> 至 App Store Connect</p>
<p>完成後再將其取消 </p>
<p>沒取消的話審查時會納入審查範圍 要特別注意</p>
<p><img src="../images/ios-app-deploy/img4-4.png" alt=""></p>
<p>接著填寫App基本資訊</p>
<ul>
<li>平台：選擇你的App會在哪些平台提供，若沒勾選可事後新增</li>
<li>名稱：在Apple Store的名稱，無法跟已上架App相同，命名上需要先搶先贏，除非對方把App刪除或修改名稱，也是使用者搜尋時能找到你的App的首要途徑</li>
<li>主要語言：首先可在商店提供的語言，若有發佈不同國家語系，可事後新增</li>
<li>套件識別碼：選擇剛才新增的 <code>Indentifier</code>，選擇後就不能修改，對應到原生的 <code>Bundle Indentifier</code></li>
<li>SKU：App ID 為獨一無二，可任意命名，填寫後不能修改，但不會公開顯示</li>
</ul>
<p><img src="../images/ios-app-deploy/img4-5.png" alt=""></p>
<h1 id="App-資訊"><a href="#App-資訊" class="headerlink" title="App 資訊"></a>App 資訊</h1><p>新增 App 後，可先來 一般資訊 -&gt; App 資訊，填寫 App 基本資訊，這邊會分兩個區塊，一個是可本地化資訊及一般資訊</p>
<h3 id="可本地化資訊"><a href="#可本地化資訊" class="headerlink" title="可本地化資訊"></a>可本地化資訊</h3><ul>
<li>名稱：必填，為一開始輸入的 App 名稱</li>
<li>副標題：必填，商店中會位於 App 名稱下方，建議使用簡短語句說明 App</li>
<li>隱私權政策：必填，聲明你的 App 隱私權政策的網址，不限制格式</li>
</ul>
<p><img src="../images/ios-app-deploy/img16.png" alt=""></p>
<h3 id="一般資訊"><a href="#一般資訊" class="headerlink" title="一般資訊"></a>一般資訊</h3><ul>
<li>Apple ID：由 Apple 產生，作為網頁上的編號，可至 <a href="https://apps.apple.com/tw/app/id`${你的" target="_blank" rel="noopener">https://apps.apple.com/tw/app/id`${你的</a> Apple ID}`，找到你的App</li>
<li>內容版權：聲明你的 App 是否有第三方內容，像是以校務通來說，資料來源於學校，就可以視為第三方內容 </li>
<li>年齡分級：必填，根據填寫 <a href="#/年齡分級問卷">年齡分級問卷</a> 的結果</li>
<li>許可協議：必填，預設使用 <a href="https://www.apple.com/legal/internet-services/itunes/dev/stdeula/" target="_blank" rel="noopener">《Apple 標準終端使用者許可協議》(EULA)</a>，可點擊自訂許可協議</li>
<li>類別：必填，在商店的分類，可選擇兩個，也作為與同類型App排名的分類</li>
</ul>
<p><img src="../images/ios-app-deploy/img17.png" alt=""></p>
<h1 id="定價與供應狀況"><a href="#定價與供應狀況" class="headerlink" title="定價與供應狀況"></a>定價與供應狀況</h1><ul>
<li>價格排程：選擇你的App定價方式，最低免費到最高 32900元，使用者付費購買後90天內都可以反悔</li>
<li>預定：第一次上架前會顯示，自訂日期在App成功發布後，會通知預定的使用者</li>
<li>供應狀況：需先填寫<code>供應國家與地區</code>，若選擇停止供應，會從商店下架，直到重新供應為止</li>
<li>Mac 上的 iOS App：如果你的iOS App有使用到 <a href="https://developer.apple.com/mac-catalyst/" target="_blank" rel="noopener">Mac Catalyst
</a>(Flutter 目前不支援)，會將你的iOS App發佈至 Mac App Store，若有發佈macOS App，則優先發布 macOS App</li>
<li>App發布方式：根據你的開發者帳號，若個人開發者帳號只能選擇公開在Apple Store，若是企業開發者帳號，則可以發布到私人的商店發布</li>
</ul>
<p><img src="../images/ios-app-deploy/img18.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img18-1.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img26.png" alt=""></p>
<h1 id="App版本資訊"><a href="#App版本資訊" class="headerlink" title="App版本資訊"></a>App版本資訊</h1><p>進入 App <code>版本資訊</code> 後</p>
<p>首先設定 <code>App預覽與截圖</code> 可參考以下規格 <strong><code>每個至少三張</code></strong></p>
<p>12.9 吋 iPad Pro 第三代 及 第二代 尺寸是可以相容的 故截圖第三代 可直接上傳到第二代</p>
<p>建議使用模擬器截圖 上傳完可用滑鼠拖曳改變顯示順序</p>
<table>
<thead>
<tr>
<th style="text-align:center">螢幕尺寸說明</th>
<th style="text-align:center">平台</th>
<th style="text-align:center">截圖尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 6.5 吋</td>
<td style="text-align:center">iPhone 11 Pro Max、iPhone 11、iPhone X S Max、iPhone XR</td>
<td style="text-align:center">1242 x 2688 像素（直向） 2688 x 1242 像素（橫向）</td>
</tr>
<tr>
<td style="text-align:center">iPhone 5.5 吋</td>
<td style="text-align:center">iPhone 8 Plus、iPhone 7 Plus、iPhone 6s Plus</td>
<td style="text-align:center">1242 x 2208 像素（直向） 2208 x 1242 像素（橫向）</td>
</tr>
<tr>
<td style="text-align:center">12.9 吋 iPad Pro（第三代）</td>
<td style="text-align:center">iPad Pro 2018、iPad Pro 2020</td>
<td style="text-align:center">2048 x 2732 像素（直向） 2732 x 2048 像素（橫向）</td>
</tr>
<tr>
<td style="text-align:center">12.9 吋 iPad Pro（第二代）</td>
<td style="text-align:center">iPad Pro 2017</td>
<td style="text-align:center">2048 x 2732 像素（直向） 2732 x 2048 像素（橫向）</td>
</tr>
</tbody>
</table>
<p>更多詳細資訊 <a href="https://help.apple.com/app-store-connect/#/devd274dd925" target="_blank" rel="noopener">可參考</a></p>
<p><img src="../images/ios-app-deploy/img5.png" alt=""></p>
<p>接著填寫</p>
<ul>
<li>行銷宣傳文字：作為 App 行銷宣傳標語，建議簡短的文字，也要符合App的性質</li>
<li>關鍵字：在商店搜尋時，透過關鍵字加強找到App，並使用逗點隔開</li>
<li>描述：詳細介紹App的功能與特色</li>
<li>支援URL：對應商店開發者網頁</li>
<li>行銷URL：待補充</li>
<li>版本：可參考 <a href="https://semver.org/lang/zh-TW/" target="_blank" rel="noopener">語意化版本</a>，不限定兩碼或三碼，不能與先前定義的相同</li>
<li>版權：宣告App版權的註解</li>
<li>年齡分級：根據填寫 <a href="#/年齡分級問卷">年齡分級問卷</a> 的結果（需點擊編輯填寫）</li>
</ul>
<p><img src="../images/ios-app-deploy/img6.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img7.png" alt=""></p>
<p>對應在商店的位置可參考</p>
<p><img src="../images/ios-app-deploy/img6-1.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img6-2.png" alt=""></p>
<h2 id="年齡分級問卷"><a href="#年齡分級問卷" class="headerlink" title="年齡分級問卷"></a>年齡分級問卷</h2><p>針對App的內容填寫是否有兒童不宜的</p>
<p><img src="../images/ios-app-deploy/img9.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img10.png" alt=""></p>
<h2 id="App審查資訊"><a href="#App審查資訊" class="headerlink" title="App審查資訊"></a>App審查資訊</h2><p>蘋果在審查時都是採用 <code>人工審查</code>，審查過程都須填寫完整的資料</p>
<ul>
<li>登入資訊：若你的App有設計登入功能，需提供測試帳號給審查人員</li>
<li>聯絡人資訊：當審查有問題時的聯絡人資訊，電話號碼需要加入國際冠碼</li>
<li>備註：資訊則提供其他資訊供審查人員了解你的App，像是之前就被問過這幾個問題，爾後我都在新的App加入這些回答<ul>
<li>Who is the target audience?</li>
<li>How do users obtain an account?</li>
<li>Is this app meant for internal distribution in your own company, in the company of one target client, or in multiple target clients’ companies?</li>
<li>In which countries will this app primarily be distributed?</li>
<li>If this app is meant for internal distribution, will the app be accessible by both internal and external partners? Or will it be exclusive to in-house employees?<ul>
<li>附件：可附上App操作影片，若你的App無法提供帳號測試，或是有些功能需要提供範例影片操作(ex.何時會使用到讀取wifi連線資訊的功能)，都需要附上影片</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="../images/ios-app-deploy/img8.png" alt=""></p>
<h3 id="建制版本"><a href="#建制版本" class="headerlink" title="建制版本"></a>建制版本</h3><p>接著選擇要送至審查的App版本，需先透過Xcode <code>Archive</code> 後上傳至App Store Connect，點擊藍色按鈕</p>
<p><img src="../images/ios-app-deploy/img11.png" alt=""></p>
<p>選擇對應想提交的版本，通常上傳完會需要一段時間處理，當完成處理都會email通知</p>
<p><img src="../images/ios-app-deploy/img11-1.png" alt=""></p>
<p>屆時才會出現在這邊</p>
<p><img src="../images/ios-app-deploy/img12.png" alt=""></p>
<p>接著選擇這次提交的出口合規資訊，點擊是否有使用加密功能，若點擊是的話，需要另外填寫出口法律資訊</p>
<p><img src="../images/ios-app-deploy/img13.png" alt=""></p>
<h3 id="廣告識別碼"><a href="#廣告識別碼" class="headerlink" title="廣告識別碼"></a>廣告識別碼</h3><p>最後是填寫是否有使用到 <code>廣告識別碼</code>，像是 Firebase Analytics 或是 Ad Mod 等第三方的廣告或分析工具，就需要聲明有使用到，若審查後發現錯誤，則需要重新上傳新的App版本</p>
<p><img src="../images/ios-app-deploy/img14.png" alt=""></p>
<p><strong>最後回到最上方點擊完成，並點擊審查，結著就會進入正在等待審查</strong></p>
<p><img src="../images/ios-app-deploy/img20.png" alt=""></p>
<p>通常審查時間已台灣都是晚上開始到半夜，對應到美國的白天時間，第一次審查都會比較久，大約2~3天，要耐心等待</p>
<p>但有時候會審查失敗，也會寄送 email 通知，可至連結查詢問題，並回覆審查人員</p>
<p>iOS Resolve Center : <a href="">https://appstoreconnect.apple.com/apps/<code>{apple id}</code>/appstore/platform/ios/resolutioncenter?m=</a></p>
<p>macOS Resolve Center : <a href="">https://appstoreconnect.apple.com/apps/<code>{apple id}</code>/appstore/platform/osx/resolutioncenter?m=</a></p>
<p><img src="../images/ios-app-deploy/img21.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img21-1.png" alt=""></p>
<p>若審查成功，則會通知 <code>Ready for Sale</code>，完成這次版本審查</p>
<p><img src="../images/ios-app-deploy/img22.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/ce312afa.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/ce312afa.html" class="post-title-link" itemprop="url">【文章翻譯】Dart sound null safety: technical preview 2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-22 22:25:59" itemprop="dateCreated datePublished" datetime="2020-10-22T22:25:59+08:00">2020-10-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 20:22:51" itemprop="dateModified" datetime="2024-09-30T20:22:51+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Flutter-架構的空安全支援"><a href="#宣布-Flutter-架構的空安全支援" class="headerlink" title="宣布 Flutter 架構的空安全支援"></a>宣布 Flutter 架構的空安全支援</h2><p>Dart 在 Flutter 中扮演著特殊的角色，為開發人員功能（如熱重載）提供動力，並透過 Dart 的靈活編譯器技術，為行動、桌面和網頁實現跨平台應用程式。我們致力於使 Dart 語言成為 Flutter 應用程式開發人員最具生產力的語言；例如，我們加入了 <a href="https://medium.com/dartlang/announcing-dart-2-3-optimized-for-building-user-interfaces-e84919ca1dff">UI-as-code 語言結構</a>，以優化 Dart 語法，用於編寫 Flutter Widget 樹。</p>
<p>在 6 月份，我們提供了 <a href="https://medium.com/dartlang/announcing-sound-null-safety-defd2216a6f3">Dart 空安全的首個技術預覽</a>。今天是另一個重要的里程碑，我們已經 <a href="https://medium.com/dartlang/announcing-dart-2-10-350823952bd5">期待已久</a>：我們宣布 <strong>健全的空安全</strong> 的第二個技術預覽，包括對 Flutter 架構的支援。</p>
<p>空安全是一個主要的生產力功能，可以幫助您避免空引用錯誤，這種類型的錯誤通常很難發現。作為額外的優點，此功能還可以實現一系列效能改進。我們非常期待您的回饋。</p>
<h3 id="為什麼要使用空安全？"><a href="#為什麼要使用空安全？" class="headerlink" title="為什麼要使用空安全？"></a>為什麼要使用空安全？</h3><p>Dart 是一種類型安全的語言。這表示當您獲得某種類型的變數時，編譯器可以保證它屬於該類型。但是，類型安全本身不能保證變數不是空引用。</p>
<p>空引用錯誤非常普遍。在 GitHub 上搜尋會發現由於 Dart 程式碼中出現意外的空引用而導致的數千個問題，以及數千個嘗試解決這些問題的提交。試著看看您是否能在下面的 Flutter 應用程式中發現可空性問題，想像 Config 和 WeatherService 是應用程式使用的後端服務：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1965e36d06ffb1ff9dd35aec84050724/href">https://medium.com/media/1965e36d06ffb1ff9dd35aec84050724/href</a></iframe>

<p>如果 <code>getAppName()</code> 返回空引用，這個應用程式肯定會失敗；在這種情況下，我們將傳遞空引用給 <code>AppBar</code> 標題中使用的 <code>Text</code> Widget。</p>
<p>但是，還有更多微妙的情況需要考慮：<code>getTemperatures()</code> 也可能返回空引用。在這種情況下，<code>for</code> 迴圈會失敗。或者 <code>getTemperatures()</code> 可以像預期一樣返回一個列表，但該列表可能包含空值，在這種情況下，我們將呼叫 <code>round()</code> 到空引用上，應用程式將會失敗。</p>
<p>空安全功能透過 <a href="https://nullsafety.dartpad.dev/28f1db5ef4401d9e063375e5c58f0f86">驗證您的程式碼</a> 來解決這些問題，就像您在輸入時一樣：</p>
<figure>
<img alt="Screenshot of the preceding code with null errors." src="https://cdn-images-1.medium.com/max/1024/0*FE-q5RdXwPgtRVE5" />
<figcaption>利用空安全，Dart 會在您的程式碼中找到潛在的空引用錯誤。</figcaption>
</figure>

<p>利用空安全，您可以更有信心地推論您的程式碼。部署的應用程式中不再有惱人的運行時空引用解除引用錯誤。相反，您在編寫程式碼時會出現靜態錯誤。</p>
<h3 id="空安全原則"><a href="#空安全原則" class="headerlink" title="空安全原則"></a>空安全原則</h3><p>Dart 空安全支援基於以下三個核心設計原則：</p>
<ol>
<li><strong>預設不可空引用</strong>。除非您明確告訴 Dart 變數可以為空引用，否則它將被視為不可空引用。我們選擇這一點作為預設值，因為我們發現不可空引用是 API 中最常見的選擇。</li>
<li><strong>可遞增採用</strong>。有很多 Dart 程式碼。您可以選擇在您想要的時候遞增地逐漸遷移到空安全，然後逐部分地進行遷移。可以在同一個專案中使用空安全的程式碼和非空安全的程式碼。我們還將提供工具來幫助您進行遷移。</li>
<li><strong>完全健全</strong>。Dart 的空安全是 <em>健全</em> 的。這表示我們可以信任類型系統：如果它確定某個東西不是空引用，那麼它 <em>永遠</em> 不會是空引用。這可以實現編譯器最佳化. 當您將整個專案和相依項目遷移到空安全後，您將完全享受到健全性帶來的優勢 - 不僅是更少的錯誤，而且還包括更小的二進位檔案和更快的執行速度。</li>
</ol>
<p>讓我們更詳細地回顧一下這些設計原則。</p>
<h3 id="1-預設不可空引用"><a href="#1-預設不可空引用" class="headerlink" title="1. 預設不可空引用"></a>1. 預設不可空引用</h3><p>核心語法非常簡單。以下是一些以不同方式宣告的不可空引用變數。請記住，不可空引用是預設值，所以這些宣告看起來與今天一樣，但它們的含義發生了變化。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/079238103c1142e62388962925f3ce71/href">https://medium.com/media/079238103c1142e62388962925f3ce71/href</a></iframe>

<p>Dart 會確保您永遠不會將空引用指派給上述任何變數。如果您嘗試執行 <code>widget = null</code>，幾千行程式碼之後，您將得到一個靜態分析錯誤和紅色的波浪線，您的程式將拒絕編譯。</p>
<h4 id="可空引用變數"><a href="#可空引用變數" class="headerlink" title="可空引用變數"></a>可空引用變數</h4><p>如果您想要您的變數可以為空引用，您可以使用 <code>?</code>，比如這樣：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bdba421eef4db0e24cfd7962ca7376be/href">https://medium.com/media/bdba421eef4db0e24cfd7962ca7376be/href</a></iframe>

<p>您可以在函數參數和返回值中使用 <code>?</code> 語法，也是如此：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1efb02aa225d7d667a6a256a0d4da14e/href">https://medium.com/media/1efb02aa225d7d667a6a256a0d4da14e/href</a></iframe>

<p>但是，再次強調，夢想是您很少需要使用 <code>?</code>。您的絕大多數類型將是不可空引用。</p>
<h4 id="使用空安全提高生產力"><a href="#使用空安全提高生產力" class="headerlink" title="使用空安全提高生產力"></a>使用空安全提高生產力</h4><p>空安全不僅僅是關於安全。我們還希望您在使用此功能時能夠提高生產力，這表示此功能必須易於使用。例如，請看以下程式碼，它使用 <code>if</code> 來檢查空引用值：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a93e5bf7e89acc67e564ec05c1cd5bb5/href">https://medium.com/media/a93e5bf7e89acc67e564ec05c1cd5bb5/href</a></iframe>

<p>請注意，Dart 工具如何檢測到當我們通過該 <code>if</code> 語句時，<code>loudness</code> 變數不可能為空引用。因此，Dart 讓我們可以呼叫 <code>clamp()</code> 方法，而無需跳躍障礙。這種便利性是由一種稱為流程分析的功能實現的：Dart 分析器會像執行程式一樣遍歷您的程式碼，自動找出有關程式碼的更多資訊。</p>
<p>以下是一個示例，它顯示了一個情況，即 Dart 可以確定變數為不可空引用，因為我們始終將不可空引用值指派給它：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a7af8dc629471794b1f43b4c5b9fe541/href">https://medium.com/media/a7af8dc629471794b1f43b4c5b9fe541/href</a></iframe>

<p>如果您移除上述任何指派（例如，透過刪除 <code>statusText = &#39;Update failed&#39;;</code> 這行程式碼），Dart 無法保證 <code>statusText</code> 為不可空引用：您將得到一個靜態錯誤，您的程式碼將無法編譯。您可以 <a href="https://nullsafety.dartpad.dev/ecc0f87fa5af5cc7ff30d8bd3e3b12e2">在 DartPad 中嘗試一下</a>。</p>
<h3 id="2-可遞增採用"><a href="#2-可遞增採用" class="headerlink" title="2. 可遞增採用"></a>2. 可遞增採用</h3><p>由於空安全對我們的類型系統來說是一個如此基礎性的改變，如果我們堅持強制採用，這將是極其破壞性的。我們希望讓您自行決定何時是適當的時間，因此空安全是一個選擇性功能：您將能夠使用最新的 Dart 和 Flutter 版本，而無需在您準備好之前強制您啟用空安全。您甚至可以從尚未啟用空安全的應用程式或套件中相依於已經啟用空安全的套件。</p>
<p>一旦您選擇採用，我們強烈建議您按照順序遷移程式碼，相依關係圖的葉節點優先遷移。例如，如果 C 相依於 B，而 B 相依於 A，則先將 A 遷移到空安全，然後是 B，最後是 C。此順序適用於 A、B 和 C 是函式庫、套件還是應用程式。</p>
<p>為什麼順序很重要？儘管您可以在相依項目遷移之前進行一些程式碼遷移，但如果相依項目在遷移期間更改了它們的 API，您可能會冒著需要進行第二次遷移的風險。當我們到達 beta 版本時，我們將提供工具來幫助您找出哪些相依項目已經遷移。如果您是套件作者，為了避免 API 斷裂的風險，請在發佈空安全的版本之前，等待所有相依項目都完成遷移。</p>
<p>當您的相依項目準備就緒時，您可以使用我們的遷移工具。該工具透過分析您所有現有的程式碼來工作。遷移工具是互動式的，因此您可以審查工具推斷出的可空性屬性。如果您不同意工具的任何結論，您可以添加可空性提示來更改推斷。添加幾個遷移提示會對遷移品質產生巨大的影响。</p>
<figure>
<img alt="Screenshot of the migration tool" src="https://cdn-images-1.medium.com/max/1024/0*vRDfouqMsEojq6t9" />
<figcaption>遷移工具有助於您以互動方式將程式碼遷移到空安全。</figcaption>
</figure>

<h3 id="3-完全健全"><a href="#3-完全健全" class="headerlink" title="3. 完全健全"></a>3. 完全健全</h3><p>一旦您完全完成遷移，Dart 的空安全就是 <strong>健全</strong> 的。這表示 Dart 100% 確定在上面的示例中，返回值、列表和元素不可能為空引用。當 Dart 分析您的程式碼並確定變數為不可空引用時，該變數 <strong>始終</strong> 為不可空引用：如果您在偵錯工具中檢查正在執行的程式碼，您將看到不可空引用性在運行時被保留。相反，其他一些實作是非健全的，在許多情況下仍然需要執行運行時空引用檢查。Dart 與 Swift 共享 <strong>健全的空安全</strong>，但其他程式語言卻很少。</p>
<p>Dart 空安全的健全性還有另一個令人欣慰的含義：這表示您的程式可以更小更快。由於 Dart 非常確定不可空引用變數永遠不會為空引用，因此 Dart 可以進行最佳化。例如，Dart 的提前編譯 (AOT) 編譯器可以生成更小更快 Native 程式碼，因為它不需要在知道變數不是空引用時添加空引用檢查。</p>
<p>請注意，要獲得健全的空安全，您需要將整個專案和所有相依項目遷移到空安全。如果您的應用程式或相依項目的一部分尚未遷移，您將獲得部分空安全，它保留了大部分檢查，但沒有完全最佳化，也無法保證應用程式完全安全。</p>
<h3 id="空安全路線圖"><a href="#空安全路線圖" class="headerlink" title="空安全路線圖"></a>空安全路線圖</h3><p>空安全何時才能準備好投入生產使用？以下是目前的時間表：</p>
<ol>
<li><strong>Flutter 進行 <em>技術預覽 2</em> 嘗試：</strong>這就是今天。由於我們已成功將核心 Flutter 架構遷移到空安全，因此您可以嘗試使用空安全來學習新的語言功能併嘗試 <a href="https://github.com/flutter/samples/tree/master/experimental/null_safety">一個小型 Flutter 樣本</a>。如果您是套件作者，您也可以嘗試遷移，如果您有一個小型相依項目集已經被我們遷移了。您需要傳遞一個 <a href="https://dart.dev/tools/experiment-flags">實驗標誌</a>，不應該在生產環境中使用它，也不應該發佈任何遷移的套件。</li>
<li><strong>使用 <em>beta</em> 版本進行早期套件遷移：</strong>今年晚些時候，我們將完成效能調整，並擁有足夠的測試覆蓋率，讓我們有信心相信此功能按預期工作，並且向後相容性穩定。在那時，我們將發佈該功能的 beta 版本，您將不再需要傳遞實驗標誌。我們希望看到套件擁有者開始將他們的套件遷移到空安全，這將為我們提供最後一輪驗證，證明該功能已準備好發佈穩定版本。</li>
<li><strong>使用 <em>stable</em> 版本投入生產：</strong>接下來，我們將解決 beta 版本中收到的回饋，修復任何剩餘的問題，然後發佈到 stable channel。很難為此設定一個具體的時間表，但我們認為是明年年初。一旦該功能穩定，我們希望看到空安全被廣泛採用，會有空安全的應用程式發佈到商店，以及許多空安全的套件在 stable channel 上發佈到 pub.dev。</li>
</ol>
<h3 id="立即嘗試"><a href="#立即嘗試" class="headerlink" title="立即嘗試"></a>立即嘗試</h3><p>您今天就可以開始嘗試使用空安全！若要快速上手，請查看 <a href="https://nullsafety.dartpad.dev/">附帶空安全的 DartPad 特殊版本</a>。</p>
<p>如果您想在 VS Code、Android Studio 或終端機中嘗試使用空安全，請查看 <a href="https://github.com/flutter/samples/tree/master/experimental/null_safety">Flutter 空安全樣本應用程式</a>。這個應用程式包含執行說明和一個小型氣象應用程式的兩個版本：一個不使用空安全，其中包含一些零散的空引用錯誤，另一個使用空安全來確保這些問題得到處理。如果您更願意嘗試使用一個新的 Flutter 應用程式，您可以運行 <code>flutter create</code>，然後按照 <a href="https://github.com/flutter/flutter/wiki/Experimenting-with-null-safety-in-Flutter">實驗說明</a> 來啟用空安全。請注意，您將需要一個 dev channel 的 Flutter SDK（版本 1.24.0–3.0.pre 或更高版本），因為目前的穩定版本和 beta 版本的 Flutter 不支援空安全。</p>
<p>若要進一步了解功能設計，請閱讀我們最新的 <a href="https://dart.dev/null-safety/understanding-null-safety">了解空安全</a> 文件。如果您更喜歡觀看簡短的影片，請查看幾個月前 <a href="https://events.withgoogle.com/flutter-day/#content">Flutter Day 活動</a> 中的 <a href="https://www.youtube.com/watch?v=ZxSyZHq8gUg&amp;feature=youtu.be&amp;list=PLjxrf2q8roU1rBlI9vz01K2324nzIhYgp&amp;t=322">空安全影片</a>。</p>
<p>我們很高興將健全的空安全帶到 Dart。健全的空安全是 Dart 的一個特色功能，可以幫助您編寫更不易出錯的程式碼，並獲得更好的效能。我們希望您會 <a href="https://github.com/flutter/flutter/wiki/Experimenting-with-null-safety-in-Flutter">嘗試</a> 在技術預覽中使用此功能，並透過我們的議題追蹤器 <a href="https://github.com/dart-lang/sdk/issues/new?title=Null%20safety%20feedback:%20%5Bissue%20summary%5D&amp;labels=NNBD&amp;body=Describe%20the%20issue%20or%20potential%20improvement%20in%20detail%20here">提供回饋</a>。祝您編碼愉快！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=cb5c98aba187" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/null-safety-flutter-tech-preview-cb5c98aba187">Dart 健全的空安全：技術預覽 2</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/d6a738f8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/d6a738f8.html" class="post-title-link" itemprop="url">【文章翻譯】Flutter on the web, slivers, and platform-specific issues: user survey results from Q3 2020</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-20 19:29:40" itemprop="dateCreated datePublished" datetime="2020-10-20T19:29:40+08:00">2020-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 20:22:51" itemprop="dateModified" datetime="2024-09-30T20:22:51+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Flutter-網頁、Sliver-和平台特定問題：來自-2020-年第三季度的使用者調查結果"><a href="#Flutter-網頁、Sliver-和平台特定問題：來自-2020-年第三季度的使用者調查結果" class="headerlink" title="Flutter 網頁、Sliver 和平台特定問題：來自 2020 年第三季度的使用者調查結果"></a>Flutter 網頁、Sliver 和平台特定問題：來自 2020 年第三季度的使用者調查結果</h2><p><em>撰寫者：Flutter UXR 團隊（<a href="https://medium.com/@jayoung.lee">JaYoung Lee</a>，<a href="https://medium.com/@youyanghou">Youyang Hou</a>，<a href="https://medium.com/@jackhimself">Jack Kim</a>，<a href="https://medium.com/@taodong">Tao Dong</a>）</em></p>
<p>2020 年 8 月，Flutter 團隊發布了其第 10 個季度使用者調查。在 10 天的時間裡，全球有 7,668 名使用者回覆了調查。每位使用者平均花費 7.4 分鐘完成調查，相當於 39.4 天的開發者時間。我們非常感謝大家花時間提供意見回饋，我們也希望與大家分享這些結果。</p>
<p>如同往常，我們詢問了您對 Flutter 各個部分的滿意度。本季度，我們也專注於收集有關其他主題的意見回饋，例如 Flutter 網頁、Sliver（用於實現豐富捲動效果的 Widget）和除錯平台特定問題。我們將在本文中更詳細地探討每個主題。如果您有興趣，請繼續閱讀！</p>
<p><strong>摘要</strong></p>
<ul>
<li>94% 的受訪者對 Flutter 的整體滿意度很高（PSAT），58% 的受訪者非常滿意（VSAT）。雖然 PSAT 保持穩定，但 VSAT 不斷增加。</li>
<li>在企業工作的使用者比例從 26% 增加到 31%。高級使用者的比例也在增加。</li>
<li>在過去 3 個月使用 Flutter 網頁的使用者中，59% 的使用者對其效能感到滿意。71% 的使用者對 Flutter 建立在網頁上感覺自然的 UI 的能力感到滿意。</li>
<li>想要使用 Sliver 實作豐富捲動效果的使用者中，有 79% 的使用者嘗試過使用它們。最大的問題（36%）是難以找到符合他們需求的 Widget。</li>
<li>71% 的使用者有除錯平台特定問題的經驗。常見的問題包括工具（32%）、視覺差異（28%）和相依性管理問題（28%）。</li>
</ul>
<h3 id="滿意度和使用者群的變化"><a href="#滿意度和使用者群的變化" class="headerlink" title="滿意度和使用者群的變化"></a>滿意度和使用者群的變化</h3><p>本季度，對 Flutter <em>非常滿意</em> 的使用者比例創下新高，達到 58%。總體而言，Flutter 使用者對產品仍然感到滿意（94%），即使社群以指數級增長。以下圖表顯示了 Flutter 滿意度水平隨時間的推移。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*k_YiDB0OZTd8WQI2" />
<figcaption><em>58% 的使用者在回答「總體而言，您對 Flutter 的滿意度如何？」的問題時選擇了「非常滿意」。</em></figcaption>
</figure>

<p>我們的使用者群有一些顯著的變化。首先，在企業工作的使用者比例顯著增加，從第一季和第二季的 26% 增加到 31%，而在此期間，在創業公司工作的使用者比例穩定在 35% 左右。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*mTLE89U4VUtGDnEI" />
<figcaption><em>雖然大多數 Flutter 使用者都在創業公司工作，但企業開發者比例從 26% 顯著增加到 31%。</em></figcaption>
</figure>

<p>另一個顯著的變化是對 Flutter 經驗水平的感知。如以下圖表所示，新手使用者的比例隨時間推移而下降，而高級使用者的比例隨時間推移而增加。這意味著我們社群中有更多有經驗的使用者可以幫助分享他們的知識給新手使用者。如果您有興趣獲得或分享知識，您可以與其他 Flutter 開發者在線交流。請訪問 flutter.dev 上的 <a href="https://flutter.dev/community">社群標籤</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*_CopRAy_n9COQGqR" />
<figcaption><em>高級使用者的比例持續增加。</em></figcaption>
</figure>

<h3 id="Flutter-網頁"><a href="#Flutter-網頁" class="headerlink" title="Flutter 網頁"></a>Flutter 網頁</h3><p>除了在 stable channel 支援行動裝置外，Flutter 也在 beta 版中支援網頁開發。在此調查中，我們詢問了早期採用者在效能、網頁體驗、工作流程和文件方面遇到的特定問題，以便我們可以優先處理重要問題。</p>
<p>受訪者積極使用 Flutter 建立網頁應用程式。約 33% 的受訪者表示他們已評估 Flutter 網頁以供潛在生產使用（15%）、建構了 demo（11%）或發布了生產應用程式（7%），如以下圖表第三行所示。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*R7aSejQwaxUY2W9L" />
<figcaption><em>33% 的使用者（4,449 人中的 1,468 人）表示他們已評估 Flutter 網頁以供生產（15%）、建構了 demo（11%）或發布了生產應用程式（7%）。</em></figcaption>
</figure>

<p>更具體地說，在過去 3 個月擁有行動裝置和網頁開發經驗的使用者中，有 29.5% 的使用者更認真地使用 Flutter 網頁（供潛在生產使用）。這個百分比因開發者先前對平台的經驗而異。看起來，具有網頁開發背景的受訪者正在嘗試 Flutter 作為一種替代網頁框架（22% 的受訪者嘗試使用 Flutter 網頁以供潛在生產使用），而具有行動裝置開發背景的受訪者正在積極嘗試使用 Flutter 網頁作為通往網頁開發的途徑（16% 的受訪者嘗試使用 Flutter 網頁）。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*C0d4X2FddTe0fC6A" />
<figcaption><em>在過去 3 個月嘗試使用 Flutter 網頁以供生產的使用者比例因他們先前對行動裝置和網頁平台的經驗而異。</em></figcaption>
</figure>

<p>Flutter 網頁團隊也收集了有關建立網頁體驗的各個問題的意見回饋。首先，我們了解到受訪者認為瀏覽器導航和路由歷史（55%）、複製&#x2F;貼上選取文字（34%）、捲軸物理學（33%）和選取文字（32%）在建立網頁體驗中至關重要。受訪者也要求提供有關路由和調整行動版佈局以適應網頁的更好文件。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*8WXtO7Mx_n5Gs0m_" />
<figcaption><em>使用者將「瀏覽器導航和路由歷史」選為使用 Flutter 建立網頁體驗中最關鍵的功能。</em></figcaption>
</figure>

<p>Flutter 團隊正在根據我們收到的意見回饋積極進行改進。為了解決圍繞導航和路由的頂級使用者問題，團隊最近發布了 <a href="https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade">Navigator 2</a>。我們還加入了對 <a href="https://github.com/flutter/flutter/issues/47234">複製&#x2F;貼上可選文字</a> 的支援，並計劃改進 <a href="https://github.com/flutter/flutter/projects/173#card-43620465">可選文字</a> 功能（特別是針對富文字）。我們將根據社群回報的問題，繼續努力改進捲軸物理學和效能。</p>
<p>最後，團隊收到了有關工作流程、效能和第三方 API 的意見回饋。在基本工作流程中，受訪者認為除錯最困難。頁面載入速度和捲軸是受訪者遇到的最常見的效能問題。受訪者希望 Flutter 網頁更好地支援本地儲存（例如 SQLite）、Firebase 儲存和 Google 地圖。當團隊在 Flutter 網頁方面取得進展時，這些領域將會成形。</p>
<h3 id="Sliver"><a href="#Sliver" class="headerlink" title="Sliver"></a>Sliver</h3><p>Sliver Widget（以「Sliver」開頭的 Widget，例如 SliverAppBar 和 SliverList）用於建立豐富的捲軸效果。雖然可以使用 ListView、GridView、PageView 或 AnimatedList 等 Widget 實現許多捲軸效果，但 Sliver Widget 有助於自訂捲軸檢視，並實現更美觀的 UI。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/408/0*a-qk7SfiAnHAq2vU" />
<figcaption><em>您可以使用 Sliver Widget 實現像這樣的豐富捲軸效果。</em></figcaption>
</figure>

<p>Flutter 團隊聽到了有關使用者對 Sliver 體驗的不同故事。有些人表示他們沒有在應用程式中使用 Sliver，而有些人表示他們需要更多 Sliver 來實現各種效果。因此，團隊決定在本季度的調查中加入一些問題，以更好地了解 Flutter 使用者如何使用 Sliver。</p>
<p>我們首先了解到，更多使用者使用簡單的捲軸效果（49%）設計他們的 UI，而不是使用豐富的捲軸效果（39%）。（調查中呈現了簡單捲軸效果和豐富捲軸效果的範例。）對於那些需要豐富捲軸效果的人來說，78% 的人表示他們需要 Sliver 來實現他們想要的效果。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*YNnoQE06DVStrvWV" />
<figcaption><em>更多使用者使用簡單的捲軸效果（49%）設計他們的 UI，而不是使用豐富的捲軸效果（39%）。</em></figcaption>
</figure>

<p>在那些需要 Sliver 的使用者中，20% 的使用者表示他們沒有嘗試過使用 Sliver。對我們來說更有趣的是，35% 的使用者表示他們嘗試過使用 Sliver 但遇到了問題。當我們詢問他們遇到的最大問題時，如以下圖表所示，發現問題最大（36%），其次是學習問題（30%），然後是可用性問題（19%）。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-P_8Vyu4EMCZ4ji0" />
<figcaption><em>發現問題是 Sliver 使用者遇到的最大問題，其次是學習問題和可用性問題。</em></figcaption>
</figure>

<p>因為我們不希望您因這些問題而降低 UI 品質，所以我們計劃更新 <a href="https://flutter.dev/">flutter.dev</a>，以便更容易找到 Sliver Widget 和有關 Sliver 的相關資訊，並且更容易學習。如果您正在尋找 Flutter 框架中沒有的新 Sliver，請考慮使用社群套件，例如 <a href="https://pub.dev/packages/sliver_tools">sliver_tools</a> 或 <a href="https://pub.dev/packages/sticky_headers">sticky_headers</a>。Flutter 社群也歡迎您為此領域做出貢獻。</p>
<p>同時，如果您是 Sliver 的新手並且想了解更多，請參閱以下資源：</p>
<ul>
<li><a href="https://medium.com/flutter/slivers-demystified-6ff68ab0296f">Slivers, demystified</a>（Medium 文章）</li>
<li><a href="https://www.youtube.com/watch?v=Mz3kHQxBjGg">Slivers explained — making dynamic layouts</a>（YouTube 上的 The Boring Flutter Development Show，第 12 集）</li>
</ul>
<h3 id="除錯平台特定問題"><a href="#除錯平台特定問題" class="headerlink" title="除錯平台特定問題"></a>除錯平台特定問題</h3><p>在 <a href="https://medium.com/flutter/what-are-the-important-difficult-tasks-for-flutter-devs-q1-2020-survey-results-a5ef2305429b">先前的調查</a> 中，我們發現 <em>除錯平台特定問題</em> 和 <em>跨平台測試應用程式</em> 是 Flutter 開發者最困難的任務。雖然我們看到了一些與平台特定問題相關的錯誤，但我們並不知道這些問題的相對優先順序，以及它們是否被捆綁在主題中或分散開來。為了找到除錯和測試難以執行的原因，我們加入了一些問題以詢問使用者遇到了什麼特定問題。</p>
<p>首先，我們詢問使用者除錯了哪些平台特定問題。我們發現最 <em>常見</em> 的平台特定問題是工具問題（32%）、不同平台的視覺差異（28%）、相依性管理問題（28%）、不同平台的行為差異（27%）、不同平台的 Plugin 行為差異（26%）和缺少原生功能（25%）。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*YB3J0hC7A6F7NdXE" />
<figcaption><em>最常見的平台特定問題是工具問題、視覺差異和相依性管理問題。</em></figcaption>
</figure>

<p>受訪者也評估了他們除錯的每個問題的重要性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/f22b27a6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/f22b27a6.html" class="post-title-link" itemprop="url">【文章翻譯】Testable Flutter and Cloud Firestore</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-15 19:34:38" itemprop="dateCreated datePublished" datetime="2020-10-15T19:34:38+08:00">2020-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pQJzBr81G169df-ffo24Cg.png" /></figure>

<h3 id="為什麼選擇-Cloud-Firestore？"><a href="#為什麼選擇-Cloud-Firestore？" class="headerlink" title="為什麼選擇 Cloud Firestore？"></a>為什麼選擇 Cloud Firestore？</h3><p><a href="https://firebase.flutter.dev/">FlutterFire</a> 技術堆疊，由 Flutter 和 Firebase（特別是 Cloud Firestore）組成，在您構建和發佈應用程式時，為您解鎖了前所未有的開發速度。在本文中，您將探索這兩種技術之間的強大整合，重點關注測試和使用乾淨的架構模式。但是，您將一步一步地構建自己的方法，而不是直接跳到最終實作，這樣每個步驟背後的理由就清晰明瞭。</p>
<h3 id="您將構建什麼？"><a href="#您將構建什麼？" class="headerlink" title="您將構建什麼？"></a>您將構建什麼？</h3><p>為了展示將 Cloud Firestore 作為您應用程式後端的乾淨方法，您將構建經典 Flutter 計數器應用程式的修改版本。唯一的區別是，每次點擊的時間戳都儲存在 Cloud Firestore 中，並且顯示的計數是從儲存的時間戳的數量中推導出來的。您將使用 Provider 和 ChangeNotifier 保持依賴項和狀態管理程式碼乾淨，並且您將更新生成的測試以保持程式碼的 <em>正確性</em>！</p>
<h3 id="開始之前"><a href="#開始之前" class="headerlink" title="開始之前"></a>開始之前</h3><p>本文假設您已 <a href="https://www.youtube.com/watch?v=Mx24wiPilHg">觀看並按照此教學中的步驟操作</a> 將您的應用程式與 Firebase 整合。簡要說明一下：</p>
<ol>
<li>建立一個新的 Flutter 專案，並命名為 firebasecounter。</li>
<li>在 <a href="https://console.firebase.google.com/">Firebase 主控台</a> 中建立一個 Firebase 應用程式。</li>
<li>將您的應用程式連結到 iOS 和&#x2F;或 Android，具體取決於您的開發環境和目標受眾。</li>
</ol>
<blockquote>注意：如果您將您的應用程式設定為在 Android 客戶端上運行，請務必 [建立一個 `debug.keystore` 檔案](https://gist.github.com/henriquemenezes/70feb8fff20a19a65346e48786bedb8f)，然後再生成您的 SHA1 憑證。</blockquote>

<p>在您在 Firebase 中生成 iOS 或 Android 應用程式之後，您就可以繼續進行。影片的其餘部分包含您在實際專案中可能需要的精彩內容，但對於本教學來說不是必需的。</p>
<h3 id="如果您遇到問題"><a href="#如果您遇到問題" class="headerlink" title="如果您遇到問題"></a>如果您遇到問題</h3><p>如果本教學中的任何步驟對您不起作用，請諮詢 <a href="https://github.com/craiglabenz/flutter-firestore-counter">這個公開的儲存庫</a>，它將更改分解為不同的提交。在整個教學中，您將在適當的位置找到指向每個提交的連結。請隨時使用它來驗證您是否已按照預期的方式進行！</p>
<h3 id="建立一個簡單的狀態管理員"><a href="#建立一個簡單的狀態管理員" class="headerlink" title="建立一個簡單的狀態管理員"></a>建立一個簡單的狀態管理員</h3><p>要開始將您的應用程式與 Cloud Firestore 整合的過程，您必須首先重構生成的程式碼，以便初始 StatefulWidget 與單獨的類別進行通訊，而不是與自身的屬性進行通訊。這讓您最終可以指示該單獨的類別使用 Cloud Firestore。</p>
<p>在您的專案的自動生成的 <code>main.dart</code> 檔案旁邊，建立一個名為 <code>counter_manager.dart</code> 的新檔案，並將以下程式碼複製到其中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">建立一個私有整數來儲存計數。將其設為私有，</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">因此 Widget 無法直接修改它，而是必須</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">使用官方方法。</span></span></span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">公開可存取的狀態參考。</span></span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> count =&gt; _count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">公開可存取的狀態修改器。</span></span></span><br><span class="line">  <span class="keyword">void</span> increment() =&gt; _count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程式碼就位後，將以下行新增到 <code>firebasecounter/lib/main.dart</code> 的頂部：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/counter_manager.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然後，將 <code>_MyHomePageState</code> 的程式碼更改為以下內容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> manager = CounterManager();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() =&gt; manager.increment());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;You have pushed the button this many times:&#x27;</span>),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">&#x27;<span class="subst">$&#123;manager.count&#125;</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.headline4,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>儲存此程式碼更改後，您的應用程式可能會顯示崩潰並顯示一個紅色的錯誤螢幕。這是因為您引入了一個新的變數 <code>manager</code>，它初始化的機會已經過了。當您更改狀態的 <em>初始化方式</em> 時，這在 Flutter 中很常見，並且可以使用熱重新啟動輕鬆解決。</p>
<p>熱重新啟動後，您應該回到開始的地方：計數為 0，並且可以根據需要點擊浮動動作按鈕。</p>
<p>現在是運行 Flutter 在任何新的專案中提供的單一測試的好時機。您可以在 <code>test/widget_test.dart</code> 中找到它的定義，並透過運行以下命令執行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>假設測試通過，您就可以繼續進行！</p>
<blockquote>注意：如果您在此部分遇到問題，請將您的更改與教學儲存庫中的 [這個提交](https://github.com/craiglabenz/flutter-firestore-counter/commit/483dd3b3833bf710b04db4a3ba347b1d1ecbe5de) 進行比較。</blockquote>

<h3 id="持續時間戳"><a href="#持續時間戳" class="headerlink" title="持續時間戳"></a>持續時間戳</h3><p>初始應用程式描述中提到了持續儲存每次點擊的時間戳。到目前為止，您尚未添加任何基礎架構來滿足第二個要求，因此請建立另一個名為 <code>app_state.dart</code> 的新檔案，並添加以下類別：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">應用程式狀態的完整容器。</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">此類別的實例應該能夠告知任何時候</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">渲染的內容。</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppState</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">完整的點擊歷史記錄。用於非常重要的審計目的。</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">點擊的計數變為此列表的 <span class="code">`length`</span> 屬性。</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">DateTime</span>&gt; clicks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">預設生成式建構函式。對常數友好，以實現最佳</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">效能。</span></span></span><br><span class="line">  <span class="keyword">const</span> AppState([<span class="built_in">List</span>&lt;<span class="built_in">DateTime</span>&gt; clicks])</span><br><span class="line">      : clicks = clicks ?? <span class="keyword">const</span> &lt;<span class="built_in">DateTime</span>&gt;[];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">方便的輔助函式。</span></span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> count =&gt; clicks.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">複製方法，它返回一個新的 AppState 實例，而不是</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">修改現有的副本。</span></span></span><br><span class="line">  AppState copyWith(<span class="built_in">DateTime</span> latestClick) =&gt; AppState([</span><br><span class="line">        latestClick,</span><br><span class="line">        ...clicks,</span><br><span class="line">      ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從現在開始，<code>AppState</code> 類別的工作是表示應該渲染的內容的狀態。該類別不包含任何可以修改自身的方法，只有一個單獨的 <code>copyWith</code> 方法，其他類別將使用它。</p>
<p>牢記測試，您可以開始更改 <code>CounterManager</code> 概念。從長遠來看，使用單一類別將行不通，因為應用程式最終會與 Cloud Firestore 進行互動。但是，您不想在每次運行測試時都建立真實的記錄。為此，您需要一個抽象介面來定義應用程式應該如何表現。</p>
<p>再次打開 <code>counter_manager.dart</code>，並在檔案的頂部添加以下程式碼：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/app_state.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">定義操作</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">應用程式狀態所需的函式的介面。</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">定義為抽象類別，以便測試可以在不</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">與 Firebase 通訊的版本上運行。</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">任何 <span class="code">`CounterManager`</span> 都必須具有狀態的實例</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">物件。</span></span></span><br><span class="line">  AppState state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">處理必須儲存新的點擊的事件。不需要</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">任何參數，因為它只會導致時間戳</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">持續存在。</span></span></span><br><span class="line">  <span class="keyword">void</span> increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步是更新 <code>CounterManager</code> 以顯式地從 <code>ICounterManager</code> 繼承。將其定義更新為以下內容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterManager</span> <span class="keyword">implements</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">  AppState state = AppState();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> increment() =&gt; state = state.copyWith(<span class="built_in">DateTime</span>.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這個階段，我們的輔助程式碼看起來已經很好了，但是 <code>main.dart</code> 落後了。<code>main.dart</code> 中沒有 <code>ICounterManager</code> 的參考，而事實上，它是它應該知道的 <em>唯一</em> 的 <code>Manager</code> 類別。在 <code>main.dart</code> 中，更新並應用以下更改：</p>
<ol>
<li>將遺漏的匯入新增到 <code>main.dart</code> 的頂部：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/app_state.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>將 <code>_MyHomePageState</code> 更新為以下內容：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ICounterManager manager;</span><br><span class="line">  _MyHomePageState(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.manager&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() =&gt; setState(() =&gt; manager.increment());</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;You have pushed the button this many times:&#x27;</span>),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="comment">// 參考 `widget.manager` 而不是</span></span><br><span class="line">              <span class="comment">// `manager` 直接</span></span><br><span class="line">              <span class="string">&#x27;<span class="subst">$&#123;manager.state.count&#125;</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.headline4,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        <span class="comment">// 參考 `widget.manager` 而不是 `manager` 直接</span></span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此更改應該會移除 IDE 中 <code>_MyHomePageState</code> 的任何紅色波浪線，但是現在 <code>MyHomePage</code> 會抱怨，因為它的 <code>createState()</code> 方法沒有向 <code>_MyHomePageState</code> 提供所有必需的參數。您可以讓 <code>MyHomePage</code> 要求此變數，並將物件傳遞到它的基於狀態的類別，但是這可能會導致很長的 Widget 鏈，這些 Widget 會要求並傳遞它們實際上不在乎的物件，僅僅因為某些後代 Widget 要求它，而某些祖先 Widget 提供它。顯然，這需要一個更好的策略。</p>
<p>輸入： <a href="https://pub.dev/packages/provider">Provider</a></p>
<h3 id="使用-Provider-存取應用程式狀態"><a href="#使用-Provider-存取應用程式狀態" class="headerlink" title="使用 Provider 存取應用程式狀態"></a>使用 Provider 存取應用程式狀態</h3><p>Provider 是一个函式庫，它简化了 Flutter 的 <code>InheritedWidget</code> 模式的使用。Provider 允許頂級 Widget 在您的 Widget 樹中被所有後代 Widget 直接存取。這可能感覺像一個全域變數，但替代方案是將您的資料模型透過每個中間 Widget 傳遞下去，其中許多 Widget 本身並不感興趣。這種「變數 <a href="https://en.wikipedia.org/wiki/Bucket_brigade">桶式傳遞</a>」反模式會模糊您的應用程式中的關注點分離，並且會使重構佈局變得不必要地繁瑣。<code>InheritedWidget</code> 和 Provider 透過讓 Widget 樹中的任何位置的 Widget 都可以直接獲取所需的資料模型來避免這些問題。</p>
<p>要將 Provider 添加到您的應用程式，請打開 <code>pubspec.yaml</code>，並在 <code>dependencies</code> 區段中添加它：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="comment"># Add this</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">^4.3.2+2</span></span><br></pre></td></tr></table></figure>

<p>在將該行添加到您的 <code>pubspec.yaml</code> 檔案後，運行以下命令將 Provider 下載到您的機器上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter pub get</span><br></pre></td></tr></table></figure>

<p>在 <code>main.dart</code> 旁邊，建立一個名為 <code>dependencies.dart</code> 的新檔案，並將以下程式碼複製到其中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/counter_manager.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:provider/provider.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependenciesProvider</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  DependenciesProvider(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.child&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        Provider&lt;ICounterManager&gt;(create: (context) =&gt; CounterManager()),</span><br><span class="line">      ],</span><br><span class="line">      child: child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>關於 <code>DependenciesProvider</code> 的一些注意事項：</p>
<ol>
<li>它使用 <code>MultiProvider</code>，儘管它的列表中只有一個條目。從技術上講，這可以摺疊為一個單獨的 <code>Provider</code> Widget，但是實際的應用程式可能會包含許多這樣的服務，因此最好從一開始就使用 <code>MultiProvider</code>。</li>
<li>它需要一個子 Widget，它遵循 Flutter 中 Widget 組合的慣例，允許我們將此輔助程式碼插入 Widget 樹的頂部，從而使 <code>ICounterManager</code> 實例可用於整個應用程式。</li>
</ol>
<p>接下來，讓新的 <code>DependenciesProvider</code> 可用於整個應用程式。一種簡單的方法是使用它來包裝整個 <code>MaterialApp</code> Widget。打開 <code>main.dart</code>，並將 <code>main</code> 方法更新為如下所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    DependenciesProvider(child: MyApp()),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您還需要在 <code>main.dart</code> 中匯入 <code>dependencies.dart</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/dependencies.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Consumer-Widget"><a href="#使用-Consumer-Widget" class="headerlink" title="使用 Consumer Widget"></a>使用 Consumer Widget</h3><p>您已經看到了 <code>MultiProvider</code> Widget 的作用（實際上它只是一種宣告一系列單獨的 <code>Provider</code> Widget 的更便捷方式）。下一步是透過使用 <a href="https://pub.dev/documentation/provider/latest/provider/Consumer-class.html">Consumer</a> Widget 來存取 <code>ICounterManager</code> 物件。</p>
<h3 id="依賴注入"><a href="#依賴注入" class="headerlink" title="依賴注入"></a>依賴注入</h3><p>如果您使用過 Cloud Firestore 撰寫過 Flutter 應用程式，那麼您可能會發現 Firestore 會讓單元測試更難撰寫。畢竟，當 Firestore 整合直接連接到您的 Widget 樹中時，您如何避免在資料庫中生成真實的記錄？</p>
<p>如果您有過這種體驗，那麼您就會發現將依賴項直接烘焙到 UI 程式碼中的局限性，在 Flutter 的情況下，UI 程式碼是 Widget。這就是依賴注入的強大之處：如果您的 Widget 接受輔助類別，這些輔助類別促進它們與依賴項（如 Firebase、設備的檔案系統，甚至網路請求）的互動，那麼您可以在測試期間提供模擬或偽造物件，而不是真實的類別。這讓您可以測試 Widget 是否按預期工作，而無需等待緩慢的網路請求、填滿檔案系統或產生 Firebase 計費費用。</p>
<p>要實現這一點，您需要重構應用程式，以便有一個清晰的點，讓測試可以注入模擬真實 Cloud Firestore 行為的偽造物件。幸運的是，<code>Consumer</code> Widget 非常適合此工作。</p>
<p>打開 <code>main.dart</code>，並將您的 <code>MyApp</code> Widget 替換為以下程式碼：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在頂部添加此匯入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/firebase_waiter.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 `MyApp` 替換為此</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">        visualDensity: VisualDensity.adaptivePlatformDensity,</span><br><span class="line">      ),</span><br><span class="line">      home: FirebaseWaiter(</span><br><span class="line">        builder: (context) =&gt; Consumer&lt;ICounterManager&gt;(</span><br><span class="line">          builder: (context, manager, _child) =&gt; MyHomePage(</span><br><span class="line">            manager: manager,</span><br><span class="line">            title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 這是放置您的啟動頁面的好地方！</span></span><br><span class="line">        waitingChild: Scaffold(</span><br><span class="line">          body: <span class="keyword">const</span> Center(child: CircularProgressIndicator()),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，在 <code>main.dart</code> 的頂部匯入 <code>Provider</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:provider/provider.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>將 <code>MyHomePage</code> 包裹在 <code>Consumer</code> Widget 中，允許您到達 Widget 樹中任意高的地方，以存取所需的資源，並將它們注入到需要它們的 Widget 中。在本教學中，這可能感覺沒有必要的工作，因為您只向上到達 <code>MyApp()</code> 一層，但是這在實際的生產應用程式中可能會透過數十個 Widget 延伸。</p>
<p>接下來，在同一個檔案中，對 <code>MyHomePage</code> 進行以下編輯：</p>
<blockquote>注意：如果在儲存此更改後您看到紅色螢幕，請不要擔心。需要更多編輯才能完成重構！</blockquote>

<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ICounterManager manager;</span><br><span class="line">  MyHomePage(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.manager, Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這個簡單的建構函式更改允許程式碼接受在先前程式碼片段中傳入的變數。</p>
<p>最後，透過對 <code>_MyHomePageState</code> 進行以下編輯來完成重構：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不再期望接收 `ICounterManager` 物件</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;You have pushed the button this many times:&#x27;</span>),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="comment">// 參考 `widget.manager` 而不是</span></span><br><span class="line">              <span class="comment">// `manager` 直接</span></span><br><span class="line">              <span class="string">&#x27;<span class="subst">$&#123;widget.manager.state.count&#125;</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.headline4,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        <span class="comment">// 參考 `widget.manager` 而不是 `manager` 直接</span></span><br><span class="line">        onPressed: () =&gt; setState(() =&gt; widget.manager.increment()),</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>注意：您可能需要執行熱重新啟動來修復您的應用程式。</blockquote>

<p>如您所知，所有 State 物件都包含對它們在 Widget 屬性中包含的 StatefulWidget 包裹器的參考。因此，<code>_MyHomePageState</code> 物件可以透過將其程式碼從 <code>manager</code> 更改為 <code>widget.manager</code> 來存取這個新的 <code>manager</code> 屬性。</p>
<p>就這樣！您已經將依賴項注入到需要它們的 Widget 中，而不是硬編碼生產實作。</p>
<h3 id="測試應用程式"><a href="#測試應用程式" class="headerlink" title="測試應用程式"></a>測試應用程式</h3><p>如果您現在運行 <code>flutter test</code>，您將會看到測試套件不再通過。當您檢查 <code>widget_test.dart</code> 時，原因可能很清楚：測試函式實例化了 <code>MyApp()</code>，但沒有像您在真實程式碼中所做的那樣用 <code>DependenciesProvider</code> 包裹它，因此 <code>MyApp</code> 中添加的 <code>Consumer</code> Widget 無法在其祖先 Widget 中找到滿足的 <code>Provider</code>。</p>
<p>這就是依賴注入開始發揮作用的地方。您不必在測試中模仿生產程式碼（透過將 <code>MyApp</code> 包裹在 <code>DependenciesProvider</code> 中），而是更改測試以初始化 <code>MyHomePage</code>。將 <code>widget_test.dart</code> 更新為如下所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/counter_manager.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_test/flutter_test.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/main.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  testWidgets(<span class="string">&#x27;Counter increments smoke test&#x27;</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Build our app and trigger a frame.</span></span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(</span><br><span class="line">      MaterialApp(</span><br><span class="line">        home: MyHomePage(</span><br><span class="line">          manager: CounterManager(),</span><br><span class="line">          title: <span class="string">&#x27;Test Widget&#x27;</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that our counter starts at 0.</span></span><br><span class="line">    expect(find.text(<span class="string">&#x27;0&#x27;</span>), findsOneWidget);</span><br><span class="line">    expect(find.text(<span class="string">&#x27;1&#x27;</span>), findsNothing);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tap the &#x27;+&#x27; icon and trigger a frame.</span></span><br><span class="line">    <span class="keyword">await</span> tester.tap(find.byIcon(Icons.add));</span><br><span class="line">    <span class="keyword">await</span> tester.pump();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that our counter has incremented.</span></span><br><span class="line">    expect(find.text(<span class="string">&#x27;0&#x27;</span>), findsNothing);</span><br><span class="line">    expect(find.text(<span class="string">&#x27;1&#x27;</span>), findsOneWidget);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>透過直接使用 <code>MyHomePage</code> 實例（以及一個包裝的 <code>MaterialApp</code> 來提供有效的 <code>BuildContext</code> 物件），您已經為自己建立了與 Cloud Firestore 的單元測試整合！</p>
<blockquote>注意：如果您在此部分遇到問題，請將您的更改與教學儲存庫中的 [這個提交](https://github.com/craiglabenz/flutter-firestore-counter/commit/bb68c1d3bb3746eca5f2dea16bd799c98ff232f1) 進行比較。</blockquote>

<h3 id="實作-Cloud-Firestore"><a href="#實作-Cloud-Firestore" class="headerlink" title="實作 Cloud Firestore"></a>實作 Cloud Firestore</h3><p>到目前為止，您已經移動了很多程式碼，並引入了幾個輔助類別，但是您還沒有更改應用程式的任何工作方式。好消息是，一切都已就位，可以開始撰寫一些了解 Cloud Firestore 的程式碼。首先，打開 <code>pubspec.yaml</code>，並添加以下兩行：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># Add this</span></span><br><span class="line">  <span class="attr">cloud_firestore:</span> <span class="string">^0.14.1</span></span><br><span class="line">  <span class="comment"># Add this</span></span><br><span class="line">  <span class="attr">firebase_core:</span> <span class="string">^0.5.0</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">^4.3.2+2</span></span><br></pre></td></tr></table></figure>

<p>與往常一樣，當您對 <code>pubspec.yaml</code> 進行更改時（除非您的 IDE 替您完成此操作），請運行以下命令來下載和連結新的函式庫：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter pub get</span><br></pre></td></tr></table></figure>

<blockquote>注意：如果您尚未建立資料庫：請訪問 Firebase 主控台的專案，點擊 **Cloud Firestore** 標籤，然後點擊 **建立資料庫** 按鈕。</blockquote>

<h3 id="等待-Firebase"><a href="#等待-Firebase" class="headerlink" title="等待 Firebase"></a>等待 Firebase</h3><p>成功使用 Cloud Firestore 的第一步是初始化 Firebase，最關鍵的是 <em>在任務成功之前不要嘗試使用任何 Firebase 資源</em>。幸運的是，您可以使用一個 StatefulWidget 來包含該邏輯，而不是將該任務散佈在整個程式碼中。</p>
<p>在 <code>firebasecounter/lib/firebase_waiter.dart</code> 中建立一個新檔案，並添加以下程式碼：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebase_core/firebase_core.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirebaseWaiter</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget <span class="built_in">Function</span>(BuildContext) builder;</span><br><span class="line">  <span class="keyword">final</span> Widget waitingChild;</span><br><span class="line">  <span class="keyword">const</span> FirebaseWaiter(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="keyword">this</span>.waitingChild,</span><br><span class="line">    Key key,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _FirebaseWaiterState createState() =&gt; _FirebaseWaiterState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FirebaseWaiterState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FirebaseWaiter</span>&gt; </span>&#123;</span><br><span class="line">  Future&lt;FirebaseApp&gt; firebaseReady;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    firebaseReady = Firebase.initializeApp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; FutureBuilder&lt;FirebaseApp&gt;(</span><br><span class="line">        future: firebaseReady,</span><br><span class="line">        builder: (context, snapshot) =&gt; <span class="comment">//&lt;</span></span><br><span class="line">            snapshot.connectionState == ConnectionState.done</span><br><span class="line">                ? widget.builder(context)</span><br><span class="line">                : widget.waitingChild,</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此類別使用 Flutter 中的模式，利用特定 Widget 來完全處理應用程式中的特定依賴項或問題。要使用此 <code>FirebaseWaiter</code> Widget，請返回 <code>main.dart</code>，並對 <code>MyApp</code> 應用以下更改：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在頂部添加此匯入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/firebase_waiter.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 `MyApp` 替換為此</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">        visualDensity: VisualDensity.adaptivePlatformDensity,</span><br><span class="line">      ),</span><br><span class="line">      home: FirebaseWaiter(</span><br><span class="line">        builder: (context) =&gt; Consumer&lt;ICounterManager&gt;(</span><br><span class="line">          builder: (context, manager, _child) =&gt; MyHomePage(</span><br><span class="line">            manager: manager,</span><br><span class="line">            title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 這是放置您的啟動頁面的好地方！</span></span><br><span class="line">        waitingChild: Scaffold(</span><br><span class="line">          body: <span class="keyword">const</span> Center(child: CircularProgressIndicator()),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在，應用程式可以等待 Firebase 初始化，但可以在測試期間透過簡單地不使用 <code>FirebaseWaiter</code> 來跳過此過程。</p>
<blockquote>注意：上述更改可能會導致 Flutter 抱怨缺少 Firebase Plugin。如果出現這種情況，請完全關閉應用程式並重新開始除錯，這將允許 Flutter 安裝所有特定於平台的依賴項。</blockquote>

<h3 id="從-Cloud-Firestore-獲取資料"><a href="#從-Cloud-Firestore-獲取資料" class="headerlink" title="從 Cloud Firestore 獲取資料"></a>從 Cloud Firestore 獲取資料</h3><p>首先，透過將以下行添加到 <code>counter_manager.dart</code> 的頂部來匯入 Cloud Firestore：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:cloud_firestore/cloud_firestore.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>接下來，也在 <code>counter_manager.dart</code> 中，添加以下類別：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirestoreCounterManager</span> <span class="keyword">implements</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">  AppState state;</span><br><span class="line">  <span class="keyword">final</span> FirebaseFirestore _firestore;</span><br><span class="line"></span><br><span class="line">FirestoreCounterManager()</span><br><span class="line">      : _firestore = FirebaseFirestore.instance,</span><br><span class="line">        state = <span class="keyword">const</span> AppState() &#123;</span><br><span class="line">    _watchCollection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _watchCollection() &#123;</span><br><span class="line">    <span class="comment">// Part 1</span></span><br><span class="line">    _firestore</span><br><span class="line">        .collection(<span class="string">&#x27;clicks&#x27;</span>)</span><br><span class="line">        .snapshots()</span><br><span class="line">        <span class="comment">// Part 2</span></span><br><span class="line">        .listen((QuerySnapshot snapshot) &#123;</span><br><span class="line">      <span class="comment">// Part 3</span></span><br><span class="line">      <span class="keyword">if</span> (snapshot.docs.isEmpty) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// Part 4</span></span><br><span class="line">      <span class="keyword">final</span> _clicks = snapshot.docs</span><br><span class="line">          .map&lt;<span class="built_in">DateTime</span>&gt;((doc) &#123;</span><br><span class="line">            <span class="keyword">final</span> timestamp = doc.data()[<span class="string">&#x27;timestamp&#x27;</span>];</span><br><span class="line">            <span class="keyword">return</span> (timestamp != <span class="keyword">null</span>)</span><br><span class="line">                ? (timestamp <span class="keyword">as</span> Timestamp).toDate()</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">// Part 5</span></span><br><span class="line">          .where((val) =&gt; val != <span class="keyword">null</span>)</span><br><span class="line">          <span class="comment">// Part 6</span></span><br><span class="line">          .toList();</span><br><span class="line">      <span class="comment">// Part 7</span></span><br><span class="line">      state = AppState(_clicks);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    _firestore.collection(<span class="string">&#x27;clicks&#x27;</span>).add(&#123;</span><br><span class="line">      <span class="string">&#x27;timestamp&#x27;</span>: FieldValue.serverTimestamp(),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>注意：此類別幾乎是正確的，但它會建立一個稍後會探討的錯誤。如果您現在將此程式碼添加到您的應用程式中並運行它，您將會看到行為與您想要的不同。請繼續閱讀，以了解詳細的解釋！</blockquote>

<p>這裡有很多事情正在發生，因此讓我們一步一步地進行。</p>
<p>首先，<code>FirestoreCounterManager</code> 實作了 <code>ICounterManager</code> 介面，因此它是生產 Widget 中可用的候選者。（最終，它將由 <code>DependenciesProvider</code> 提供！）<code>FirestoreCounterManager</code> 也維護了 <code>FirebaseFirestore</code> 的實例，它與生產資料庫的實時連接。<code>FirestoreCounterManager</code> 在初始化期間也調用 <code>_watchCollection()</code> 來建立與您關心的特定資料的連接，這就是事情變得有趣的地方。</p>
<p><code>_watchCollection()</code> 方法做了很多事情，值得單獨研究。</p>
<p>在第一部分中，<code>_watchCollection()</code> 調用 <code>_firestore.collection(&#39;clicks&#39;).snapshots()</code>. 這會返回一個流，每當集合中的資料發生更改時，就會更新。</p>
<p>在第二部分中，<code>_watchCollection()</code> 立即使用 <code>.listen()</code> 為該流註冊一個監聽器。傳遞給 <code>listen()</code> 的回調在資料發生任何更改時接收一個新的 <code>QuerySnapshot</code> 物件。此更新物件稱為快照，因為它反映了資料庫在某一時刻的正確狀態，但是，在任何時候都可能會被新的快照替換。</p>
<p>在第三部分中，回調會在集合為空時短路。</p>
<p>在第四部分中，回調會遍歷快照的文件，並返回一個包含混合的 null 和 DateTime 值的列表。</p>
<p>在第五部分中，回調會捨棄任何 null 值。這些是因將要修復的錯誤而產生的，但是這種防禦性程式設計在處理來自 Cloud Firestore 的資料時總是一個好主意。</p>
<p>在第六部分中，回調會解決 <code>map()</code> 返回的是迭代器而不是列表的事實。對迭代器調用 <code>.toList()</code> 會強制它處理整個集合，這正是您想要的。</p>
<p>最後，在第七部分中，回調會更新狀態物件。</p>
<p>要使用這個新的類別，請打開 <code>dependencies.dart</code>，並將其內容替換為以下內容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/counter_manager.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:provider/provider.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependenciesProvider</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  DependenciesProvider(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.child&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        <span class="comment">// `Provider` 已被 `ChangeNotifierProvider` 替換</span></span><br><span class="line">        ChangeNotifierProvider&lt;ICounterManager&gt;(</span><br><span class="line">          create: (context) =&gt; FirestoreCounterManager(),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">      child: child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="診斷錯誤"><a href="#診斷錯誤" class="headerlink" title="診斷錯誤"></a>診斷錯誤</h3><p>如果您按原樣運行此程式碼，您 <em>幾乎</em> 會看到所需的行為。一切都看起來正確，除了螢幕始終落後於實際點擊次數一次。這是怎麼回事？</p>
<p>問題出現在初始計數器實作和當前基於流的實作之間的不相容性。浮動動作按鈕的 <code>onPressed</code> 處理器看起來像這樣：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">  onPressed: () =&gt; setState(() =&gt; widget.manager.increment()),</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>該處理器調用 <code>increment()</code> 並立即調用 <code>setState()</code>，這會告訴 Flutter 重新渲染。</p>
<p>當同步更新儲存在設備記憶體中的狀態時，這非常有效。但是，新的基於流的實作會啟動一系列異步步驟。這意味著，按原樣，程式碼會立即調用 <code>setState()</code>，然後僅在一個未知的未來時間點，管理員物件才會更新其狀態屬性。簡而言之，<code>onPressed</code> 處理器中的 <code>setState()</code> 調用過早了！更糟糕的是，因為所有這些活動都發生在回調內，深深地位於 <code>FirestoreCounterManager</code> 中，沒有任何 Widget 知道它，因此沒有任何 <code>Future</code> 可以讓 Widget 等待來解決問題。</p>
<p>這就像管理員物件需要能夠告訴 Widget 何時重新繪製一樣。 🤔</p>
<p>輸入： <a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/simple#changenotifier">ChangeNotifier</a></p>
<blockquote>注意：如果您在此部分遇到問題，請將您的更改與公開儲存庫中的 [這個提交](https://github.com/craiglabenz/flutter-firestore-counter/commit/3bf17b9bfac6c907b8650e1c668fa19b1160a51d) 進行比較。這些更改包括添加 Firebase 後產生的 Xcode 和 build.gradle 的更改，但是您可能可以專注於 Dart 檔案中的更改。
</blockquote>

<h3 id="使用-ChangeNotifier-重新渲染-Widget-樹"><a href="#使用-ChangeNotifier-重新渲染-Widget-樹" class="headerlink" title="使用 ChangeNotifier 重新渲染 Widget 樹"></a>使用 ChangeNotifier 重新渲染 Widget 樹</h3><p><code>ChangeNotifier</code> 是一個類別，它完全像它的名字所暗示的那樣做：當發生需要重新渲染的更改時，它會通知 Widget。</p>
<p>此過程的第一步是更新 <code>ICounterManager</code> 介面以擴展 <code>ChangeNotifier</code>。要執行此操作，請打開 <code>firebasecounter/lib/counter_manager.dart</code>，並對 <code>ICounterManager</code> 宣告進行以下更改：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將 `extends ChangeNotifier` 添加到您的宣告中</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ICounterManager</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 類別中的所有內容都相同。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您尚未匯入 <code>flutter/material.dart</code>，請打開 <code>firebasecounter/lib/counter_manager.dart</code>，並將其添加到底部：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>您現在已準備好更新 <code>CounterManager</code> 和 <code>FirestoreCounterManager</code> 的定義。對於 <code>CounterManager</code>，請將其程式碼替換為以下實作：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterManager</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> <span class="keyword">implements</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">  AppState state = AppState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">使用最近一次點擊的時間戳複製狀態物件，</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">並告訴流更新。</span></span></span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    state = state.copyWith(<span class="built_in">DateTime</span>.now());</span><br><span class="line">    <span class="comment">// 添加這行是 `ChangeNotifier` 告訴 Widget</span></span><br><span class="line">    <span class="comment">// 重新渲染自身的方式。</span></span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>對於 <code>FirestoreCounterManager</code>，應用以下更改：</p>
<ol>
<li>修改它的簽章以匹配以下內容：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirestoreCounterManager</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>將相同的 <code>notifyListeners();</code> 行添加到 <code>_watchCollection()</code> 的末尾，如下所示：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _watchCollection() &#123;</span><br><span class="line">  _firestore</span><br><span class="line">      .collection(<span class="string">&#x27;clicks&#x27;</span>)</span><br><span class="line">      .snapshots()</span><br><span class="line">      .listen((QuerySnapshot snapshot) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 為了清晰起見，省略了 `_clicks` 的生成，但不要</span></span><br><span class="line">    <span class="comment">// 更改該程式碼。</span></span><br><span class="line"></span><br><span class="line">    state = AppState(_clicks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一必要的更改是添加這行！</span></span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您現在已經建立了讓 <code>ICounterManager</code> 類別告訴 Widget 何時重新渲染的必要更改的一半。管理員類別正在告訴 Widget 重新渲染，但是如果您現在運行您的應用程式，您將會看到 Widget 沒有在監聽。</p>
<p>要修復此問題，請打開 <code>dependencies.dart</code>，並將 <code>DependenciesProvider</code> 的實作替換為以下內容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependenciesProvider</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  DependenciesProvider(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.child&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        <span class="comment">// `Provider` 已被 `ChangeNotifierProvider` 替換</span></span><br><span class="line">        ChangeNotifierProvider&lt;ICounterManager&gt;(</span><br><span class="line">          create: (context) =&gt; FirestoreCounterManager(),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">      child: child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作為最後的更改，請從 <code>_MyHomePageState</code> 中移除 <code>setState()</code>，以跳過不必要的重新渲染。將其 <code>FloatingActionButton</code> 更新為如下所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">  <span class="comment">// 移除 `setState()`！</span></span><br><span class="line">  onPressed: widget.manager.increment,</span><br><span class="line">  tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">  child: Icon(Icons.add),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>就這樣！<code>ChangeNotifierProvider</code> 確保 Widget 是「監聽器」，因此當 <code>ICounterManager</code> 類別調用 <code>notifyListeners()</code> 時，Widget 會收到重新渲染的訊息。</p>
<p>在這個階段，您應該能夠熱重新啟動您的應用程式，並看到所有內容都正常工作！</p>
<p>注意：如果您在此部分遇到問題，請將您的更改與公開儲存庫中的 <a href="https://github.com/craiglabenz/flutter-firestore-counter/commit/dfb584f62d094d8fdb6067ea11ff3551b9186aed">這個提交</a> 進行比較。</p>
<h3 id="修復測試"><a href="#修復測試" class="headerlink" title="修復測試"></a>修復測試</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/9f00e92f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/9f00e92f.html" class="post-title-link" itemprop="url">【文章翻譯】Performance testing on the web</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-02 15:01:02" itemprop="dateCreated datePublished" datetime="2020-10-02T15:01:02+08:00">2020-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="網頁上的效能測試"><a href="#網頁上的效能測試" class="headerlink" title="網頁上的效能測試"></a>網頁上的效能測試</h2><p><em>本文於 2020 年 11 月 25 日更新，以使用 `web_benchmarks` 套件。</em></p>

<h3 id="概觀"><a href="#概觀" class="headerlink" title="概觀"></a>概觀</h3><p>在開發過程中，我們經常希望在瀏覽器中測試應用程式的效能。效能測試很有用，因為它可以揭露可能導致應用程式變慢的潛在錯誤。</p>
<p>本文介紹了一種在 Chrome 中測試應用程式效能的方法。此方法類似於我們測試 <a href="https://gallery.flutter.dev/#/">新的 Flutter Gallery</a> 效能的方式。</p>
<h3 id="範例應用程式"><a href="#範例應用程式" class="headerlink" title="範例應用程式"></a>範例應用程式</h3><p>我們使用一個簡單的應用程式，其中包含一個 appbar、一個浮動動作按鈕和一個無限項目列表。列表還顯示按鈕被按下次數。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*adwmyiS509VwCCYl" />
</figure>

<p>應用程式有一個包含一些資訊的第二頁。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-d-mmdUUEW08ytWJ" />
</figure>

<p>您可以在這裡複製應用程式：</p>
<ul>
<li><a href="https://github.com/material-components/material-components-flutter-experimental/tree/develop/web_benchmarks_example">https://github.com/material-components/material-components-flutter-experimental/tree/develop/web_benchmarks_example</a></li>
</ul>
<h3 id="測試什麼？"><a href="#測試什麼？" class="headerlink" title="測試什麼？"></a>測試什麼？</h3><p>我們希望在以下使用情境下測試應用程式在 Chrome 中的效能：</p>
<ol>
<li>使用者在無限列表中捲軸。</li>
<li>使用者在兩個頁面之間切換。</li>
<li>使用者點擊浮動動作按鈕。</li>
</ol>
<h3 id="設定框架"><a href="#設定框架" class="headerlink" title="設定框架"></a>設定框架</h3><p>在 <code>pubspec.yaml</code> 中加入以下內容：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ef0ca17199a2807e917e92cb92ffc891/href">https://medium.com/media/ef0ca17199a2807e917e92cb92ffc891/href</a></iframe>

<p>此相依性會導入 <a href="https://pub.dev/packages/web_benchmarks">web_benchmarks</a>，一個實現 Chrome 中效能測試的最小套件。</p>
<p>此套件改編自 <a href="https://github.com/flutter/flutter/tree/master/dev/benchmarks/macrobenchmarks">macrobenchmarks</a> 和 <a href="https://github.com/flutter/flutter/tree/master/dev/devicelab">devicelab</a>，這兩個套件由 Flutter 用於在 Flutter Gallery 上進行網頁效能測試。目前，這兩個套件專門用於 <code>flutter/flutter</code> 中的網頁效能測試，因此導入更通用的套件 <a href="https://pub.dev/packages/web_benchmarks">web_benchmarks</a> 更容易。</p>
<p>執行 <code>flutter pub get</code> 以導入此套件。</p>
<h3 id="撰寫第一個測試"><a href="#撰寫第一個測試" class="headerlink" title="撰寫第一個測試"></a>撰寫第一個測試</h3><p>在 <code>lib</code> 目錄下加入 <code>benchmarks</code> 目錄，並在其中加入一個名為 <code>runner.dart</code> 的新 dart 檔案：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/712/0*tsvQSKBjpWJWkiKM" />
</figure>

<p>檔案的內容如下：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3a002aacd849a5e328e379e37450537c/href">https://medium.com/media/3a002aacd849a5e328e379e37450537c/href</a></iframe>

<h4 id="此測試在做什麼？"><a href="#此測試在做什麼？" class="headerlink" title="此測試在做什麼？"></a>此測試在做什麼？</h4><ul>
<li>當此應用程式執行時，會建立一個 <code>ScrollRecorder</code> 物件，它會透過自動執行手勢來驅動應用程式。在本例中，在應用程式啟動後不久，它會開始向下捲軸無限列表。</li>
<li><code>ScrollRecorder</code> 類別擴展了 <code>AppRecorder</code> 類別，<code>AppRecorder</code> 類別擴展了 <code>WidgetRecorder</code> 類別，<code>WidgetRecorder</code> 類別還會在驅動應用程式時記錄效能資料。</li>
<li><code>runBenchmarks</code> 是在 <code>package:web_benchmarks/client.dart</code> 中定義的函式，它允許使用者選擇要執行的基準測試，並在瀏覽器中顯示結果。</li>
<li><code>automate</code> 方法使用 <code>flutter_test</code> 套件，該套件提供了在應用程式中執行手勢或尋找特定 Widget 的方法。</li>
</ul>
<h3 id="執行第一個測試"><a href="#執行第一個測試" class="headerlink" title="執行第一個測試"></a>執行第一個測試</h3><p>在專案的根目錄中，執行 <code>flutter run -d chrome -t lib/benchmarks/runner.dart</code>。這會指示 Flutter 使用 <code>runner.dart</code> 作為入口點，而不是 <code>main.dart</code>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*imb9-c_LS4XF0xDX" />
</figure>

<p>到目前為止，我們只有一個基準測試，因此點擊「捲軸」以啟動它。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*3aZa4m2GbsqHECNw" />
</figure>

<p>測試開始，列表會自動向下捲軸。</p>
<p>測試在幾秒鐘內結束，顯示以下螢幕：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LitJY47Vl0J17C5V" />
</figure>

<p>此圖表顯示應用程式繪製每個（記錄的）畫面所需的時間。橫軸表示時間流逝；縱軸表示每個畫面所需的時間。</p>
<p>圖表的前 2&#x2F;3 部分具有灰色背景；這些畫面被認為是「預熱畫面」，並且從統計資料中省略。預熱畫面通常會讓 JIT 編譯器有時間編譯程式碼並建立各種快取，以便測量畫面能產生反映應用程式「最終」效能的數字，而不是它最初幾秒鐘的效能。預熱階段不應始終被忽略 - 它可以提供應用程式最初幾秒鐘效能的寶貴資訊，這仍然會影響對應用程式品質的感知。</p>
<p>紅色畫面是「異常值」 - 它們是繪製時間比其他畫面顯著長得多的畫面。有些異常值幾乎不可察覺。例如，動畫開始或結束時的卡頓，直到一定程度才會被看見。但是，動畫 <em>中間</em> 的卡頓畫面非常明顯。</p>
<p>異常值很好地表明了應用程式卡頓的程度。透過改進您的應用程式，您可以降低異常值的數值或減少異常值的數量，這表示您的應用程式已變得更流暢。</p>
<h3 id="從-Chrome-的-DevTools-收集資料"><a href="#從-Chrome-的-DevTools-收集資料" class="headerlink" title="從 Chrome 的 DevTools 收集資料"></a>從 Chrome 的 DevTools 收集資料</h3><p>此基準測試完全在 Chrome 中執行。將以下檔案新增為 <code>test/run_benchmarks.dart</code>：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5ce2ae71e67c98c50eef78779e9f1d35/href">https://medium.com/media/5ce2ae71e67c98c50eef78779e9f1d35/href</a></iframe>

<p>然後，執行 <code>dart test/run_benchmarks.dart</code>。</p>
<p>大約一分鐘後，您應該看到以下結果：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2e95cfd7eb847b13e4d86219ca683123/href">https://medium.com/media/2e95cfd7eb847b13e4d86219ca683123/href</a></iframe>

<p>準確的基準測試數值可能會因機器而異。</p>
<h4 id="此測試在做什麼？-1"><a href="#此測試在做什麼？-1" class="headerlink" title="此測試在做什麼？"></a>此測試在做什麼？</h4><ul>
<li>執行 <code>test/run_benchmarks.dart</code> 會為網頁構建應用程式。然後，它會啟動一個 Chrome 實例並在其中執行應用程式。</li>
<li><code>test/run_benchmarks.dart</code> 會連接到 Chrome 的 DevTools 連接埠，並監聽和收集相關的效能資料。</li>
</ul>
<h4 id="結果的含義是什麼？"><a href="#結果的含義是什麼？" class="headerlink" title="結果的含義是什麼？"></a>結果的含義是什麼？</h4><ul>
<li>渲染畫面時，會走訪 <a href="https://api.flutter.dev/flutter/rendering/Layer-class.html">層級樹</a> 兩次。</li>
<li>「預先處理」是第一次走訪。它不會渲染任何內容，但會計算稍後用於渲染的值。例如：轉換矩陣、轉換的逆矩陣和剪裁。</li>
<li>「應用程式畫面」是實際渲染 UI 的第二次走訪。</li>
<li>「繪製畫面」是框架渲染畫面所需的時間。它包含「預先處理」和「應用程式畫面」，但它還包含花費在構建和佈局 Widget 上的時間。</li>
<li>「總 UI 畫面」包含「繪製畫面」中的所有內容，但它還包含瀏覽器執行的某些隱藏工作，例如層級樹更新、樣式重新計算和瀏覽器端佈局（不要與 Flutter 自己進行的佈局混淆）。</li>
<li>收集資料集（持續時間列表）時，演算法會移除異常值。</li>
<li>首先，計算資料的平均值和標準差，並且任何比（平均值 + 1 個標準差）高的資料點都被視為異常值。</li>
<li>非異常值（乾淨資料）的平均值和標準差用於計算資料集的平均值和雜訊，然後報告這些值。</li>
<li>所有異常值的平均值以及「異常值平均值」和「非異常值平均值」的比率也會被報告。</li>
<li>對於每個資料集，「異常值比率」和「雜訊」都是應用程式效能中存在多少雜訊的良好指標。如果結果過於雜亂，則可能表示效能不一致（例如，GC 暫停時的卡頓畫面）。透過降低雜訊，您可以使應用程式執行更順暢。</li>
</ul>
<h3 id="加入更多測試"><a href="#加入更多測試" class="headerlink" title="加入更多測試"></a>加入更多測試</h3><p>編輯 <code>lib/benchmarks/runner.dart</code> 以加入兩個更多測試。</p>
<p>首先，修改 <code>main</code> 函式：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/86e9a82223d28c5bb1beaf236dfb297a/href">https://medium.com/media/86e9a82223d28c5bb1beaf236dfb297a/href</a></iframe>

<p>最後，加入兩個更多擴展 <code>AppRecorder</code> 的類別：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4b6ad9219c3e3c13aba5cd2796cd6052/href">https://medium.com/media/4b6ad9219c3e3c13aba5cd2796cd6052/href</a></iframe>

<h4 id="這些測試在做什麼？"><a href="#這些測試在做什麼？" class="headerlink" title="這些測試在做什麼？"></a>這些測試在做什麼？</h4><ul>
<li>我們加入了兩個剩餘的基準測試：一個用於在頁面之間切換，另一個用於點擊浮動動作按鈕。</li>
<li><code>animationStops</code> 反覆檢查動畫是否正在進行，並在所有動畫停止時停止。這會確保，例如，成功轉換到「關於」頁面。</li>
<li>在「頁面」和「點擊」基準測試中，<code>_completed</code> 布林值追蹤自動手勢是否已完成。</li>
<li>在「頁面」和「點擊」基準測試中，覆寫 <code>shouldContinue</code> 方法會導致 <code>AppRecorder</code> <strong>在</strong> 所有手勢完成 <strong>後</strong> 停止記錄畫面。</li>
</ul>
<h4 id="如何執行這些測試？"><a href="#如何執行這些測試？" class="headerlink" title="如何執行這些測試？"></a>如何執行這些測試？</h4><p>若要在 Chrome 中執行這些測試（並查看動畫），請執行：</p>
<ul>
<li><code>flutter run -d chrome -t lib/benchmarks/runner.dart --profile</code></li>
</ul>
<p>若要執行這些測試並收集 DevTools 資料，請執行：</p>
<ul>
<li><code>dart test/run_benchmarks.dart</code></li>
</ul>
<h3 id="接下來要做什麼？"><a href="#接下來要做什麼？" class="headerlink" title="接下來要做什麼？"></a>接下來要做什麼？</h3><p>在您有方法收集效能資料後，您可以隨意使用它：</p>
<ul>
<li>您可以為 CI 設定一個作業，只要有人提交 PR 就執行這些基準測試，以避免引入效能負擔大的變更。</li>
<li>您也可以設定一個儀表板來追蹤效能基準測試的趨勢。這就是我們對 Flutter Gallery 所做的事情（請參閱 <a href="https://flutter-dashboard.appspot.com/#/build">Flutter Dashboard</a>）。</li>
</ul>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=25323252de69" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/performance-testing-on-the-web-25323252de69">網頁上的效能測試</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/687439a5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/687439a5.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Flutter 1.22</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-01 14:57:05" itemprop="dateCreated datePublished" datetime="2020-10-01T14:57:05+08:00">2020-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Flutter-1-22"><a href="#宣布-Flutter-1-22" class="headerlink" title="宣布 Flutter 1.22"></a>宣布 Flutter 1.22</h2><p>我們很高兴地宣布 Flutter 的最新版本，它对 iOS 14 和 Android 11 提供了广泛的支持。Flutter 1.22 在以前版本的基础上构建，让开发者能够从单一代码库构建快速、美观的跨平台用户体验。我们的季度稳定版本包含最新的功能、性能改进和错误修复，适合广泛的生产使用。</p>
<p>由于这是新移动操作系统版本的发布季节，因此此版本专注于确保 Android 11 和 iOS 14 与 Flutter 完美配合。对这两个操作系统的更新包括大量幕后工作，以符合最新的 SDK，并确保一切通过我们的全面测试套件。对于 iOS 14，此版本包含对新 Xcode 12、新图标的支持，以及对新 iOS 14 App Clips 功能的预览支持。对于 Android 11，更新支持新的显示切口类型，以及在弹出软键盘时的更流畅动画。</p>
<p>此版本在我们的 1.20 版本发布两个月后发布，因此比大多数版本都要短。即使在这段时间内，我们也关闭了 3,024 个问题，并合并了来自 197 位贡献者的 1,944 个 PR。在这 197 位贡献者中，有 114 位（58％）来自更广泛的社区，他们贡献了 271 个 PR。最大的单一贡献者是 <a href="https://github.com/a14n">a14n</a>，他再次成为我们的顶级贡献者榜单，贡献了 20 个 PR，其中大多数是作为 Flutter 中支持空安全的工作的一部分完成的（更多相关内容即将推出）。</p>
<p>除了对新移动操作系统版本的支持外，我们还有很多新闻要分享，包括对 Android 最受欢迎功能之一的预览：状态恢复、一个新的 Material 按钮“宇宙”、与热重载配合使用的新国际化和本地化支持、一个新的 Navigator、Platform Views 的稳定版本（Google Maps 和 WebView Plugin 的基础）以及可以在代码中添加的开关，以改善具有高频率显示屏的设备上的滚动效果。我们还提供了一个新的工具来剖析应用大小，并确保您构建的 Plugin 仅支持您想要支持的平台。</p>
<h3 id="针对-iOS-14"><a href="#针对-iOS-14" class="headerlink" title="针对 iOS 14"></a>针对 iOS 14</h3><p>每当宣布新版本的移动操作系统时，我们都会对其进行彻底测试，寻找影响 Flutter 及其工具的不兼容性或更改。</p>
<p>在 iOS 14 的情况下，我们对 Flutter 做了一些更改，以确保它按开发者想要的方式工作：</p>
<ul>
<li>Xcode 12 要求 iOS 9.0 或更高版本，因此我们的默认模板将默认值从 8.0 提高到 9.0。</li>
<li>iOS 14 特定的崩溃和字体渲染问题已在 Flutter 1.22 中修复。</li>
<li>截至 Flutter 1.20.4，已修复部署到实体设备的问题。</li>
<li>一项新政策，当应用访问其剪贴板时会显示使用通知，导致 Flutter 应用出现虚假通知，这个问题已在 Flutter 1.20.4 中修复。</li>
<li>限制禁止在 iOS 14 设备上运行调试应用，除非作为调试过程的一部分。</li>
<li>针对本地调试的 Flutter 应用的网络安全新政策会导致 iOS 14 显示一次性确认对话框（仅在开发期间，而不是针对已发布的 Flutter 应用）。</li>
</ul>
<p>底线：如果您要针对 iOS 14 使用 Flutter 应用，我们强烈建议您使用 Flutter 1.22 重新构建它并将其部署到 App Store，以确保您的 iOS 14 用户获得最佳体验。</p>
<p>有关使用 Flutter 针对 iOS 14 的更多详细信息，包括一些 Add-to-App、深层链接和通知注意事项，请参阅 <a href="https://flutter.dev/docs/development/ios-14">flutter.dev 上的 iOS 14 文档</a>。</p>
<p>希望所有这些对工具和 SDK 支持的工作可以让您专注于您关心的编码——利用新的 iOS 14 功能。</p>
<p>其中一项功能是对 iOS 的新 SF Symbols 字体的更新支持，这启发了我们花了一些时间对 <a href="https://pub.dev/packages/cupertino_icons">cupertino_icon 包</a> 进行刷新。一旦您将 cupertino_icons 依赖项更新到新的 1.0 主要版本，现有的 CupertinoIcons 使用情况将自动映射到新样式。如果您将 cupertino_icons 1.0 与 Flutter 1.22 结合使用，您还可以通过 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoIcons-class.html">CupertinoIcons</a> API 访问约 900 个新图标。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/864/0*ZGKu3IhnPNp6fS_e" />
</figure>

<p>您可以在 <a href="https://flutter.github.io/cupertino_icons/">cupertino_icons</a> 预览页面上查看完整的图标列表，以及 <a href="https://flutter.dev/docs/release/breaking-changes/cupertino-icons-1.0.0">flutter.dev 上的迁移详细信息页面</a>。</p>
<p>您可以尝试在 iOS 14 上使用 Flutter 的另一项功能是 <a href="https://developer.apple.com/app-clips/">App Clips</a>，这是一项新的 iOS 14 功能，支持快速、无需安装的应用执行，可以执行 10MB 以下的应用的轻量级版本。在 Flutter 1.22 版本中，我们对使用 Flutter 构建的 App Clip 目标进行了预览。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*8MER4IM-IEt2ye2a" />
<figcaption>由 Flutter 提供支持的 App Clip 体验</figcaption>
</figure>

<p>有关使用 Flutter 构建 App Clips 的更多详细信息，请查看 <a href="https://flutter.dev/docs/development/platform-integration/ios-app-clip">flutter.dev 上的文档</a>。您还可以参考这个 <a href="https://github.com/flutter/samples/tree/master/ios_app_clip">简单的示例项目</a>。</p>
<h3 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a>Android 11</h3><p>此版本的 Flutter 也与本月推出的 Android 11 版本同步。Flutter 框架和引擎已更新，以支持最新版本的 Android 中引入的两个新功能。</p>
<p>首先，Flutter 现在支持公开 Android 切口、切出部分和瀑布显示边缘的安全内边距。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*lPO4ueKwxvV0QP_I" />
</figure>

<p>通过使用 <a href="https://api.flutter.dev/flutter/widgets/MediaQuery-class.html">MediaQuery</a> 和 <a href="https://api.flutter.dev/flutter/widgets/SafeArea-class.html">SafeArea</a> API，您可以确保将活跃的 UI 和交互式元素放置在设备显示屏的无障碍区域。此外，您还应避免在容易发生意外触碰的瀑布边缘区域放置手势检测器。</p>
<p>其次，动画与 Android 11 同步，因为它显示了软件键盘。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*DFRjYzbqIc5kOoDm" />
<figcaption>查看 FAB 的位置动画</figcaption>
</figure>

<p>问题 <a href="https://github.com/flutter/flutter/issues/19279">＃19279</a> 是一个长期存在的问题，即系统键盘显示&#x2F;隐藏动画与 Flutter 的内边距不同步。这个问题已在 Android 11 中修复。</p>
<p>关于 Android 嵌入 API 的一个说明。在去年的 Flutter 1.12 版本中，我们为 Android 推出了新的 Flutter 引擎和 Flutter Plugin API 集。我们创建了这些 v2 API 以更好地支持我们在 Android 上的 Add-to-App 用户。一年后，超过 80％ 的 Android Plugin 使用了新的 Android API。从 1.22 版本开始，我们将弃用旧的 v1 API。</p>
<p>如果您仍在使用 Android v1 API，以下内容与您相关：</p>
<ul>
<li>新创建的 Plugin 将不再针对 v1 API。</li>
<li>Flutter 工具的<code> -no-enable-android-embedding-v2</code> 配置标志已删除，现在是默认行为。</li>
<li>仍在使用 v1 API 的旧应用将在构建过程中显示一个弃用警告，该警告指向 <a href="https://flutter.dev/docs/development/packages-and-plugins/plugin-api-migration">支持新的 Android Plugin API 的文档</a>。</li>
</ul>
<p>同时，如果您仍然具有基于 v1 Android API 的 Flutter 应用，它将继续工作。但是，您可能会开始遇到仅针对 v2 API 且无法被 v1 Android API 使用的新 Plugin。有关更多详细信息，请参阅 <a href="https://flutter.dev/docs/release/breaking-changes/android-v1-embedding-create-deprecation">重大更改文档</a>。</p>
<h3 id="扩展按钮“宇宙”"><a href="#扩展按钮“宇宙”" class="headerlink" title="扩展按钮“宇宙”"></a>扩展按钮“宇宙”</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/910/1*crNLxg7CCtlQkB4mLI_ErA.png" />
<figcaption>一个新的 Material Design 按钮“宇宙”</figcaption>
</figure>

<p>现有的 Flutter 按钮看起来不错，但可能 <a href="http://flutter.dev/go/material-button-system-updates">难以使用</a>，特别是在您需要自定义主题时。此外，Material 规范已扩展到包含具有新样式的新按钮。</p>
<p>为了让 Flutter 与 Material 指南保持同步，我们很高兴地宣布 Flutter 1.22 中推出了全新的按钮“宇宙”。</p>
<p>与其尝试就地演变现有的按钮类及其主题，<a href="https://github.com/flutter/flutter/pull/59702">此 PR</a> 引入了新的替换按钮 Widget 和主题。除了让我们摆脱演化现有类所必需的后向兼容迷宫外，新名称还使 Flutter 与 <a href="https://material.io/components/buttons/">Material Design 规范</a> 同步，该规范使用新名称来表示按钮组件。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*di6uPEKEsRHoFtRryHeWPg.png" />
</figure>

<p>新主题遵循 Flutter 最近为新的 Material Widget 采用的“规范化”模式。如果您想尝试一个演示，<a href="https://dartpad.dev/e560e1c2e4455ad53aac245079ccdcf2">这里有一个很棒的 DartPad 演示</a>。这不是重大更改，因为 FlatButton、OutlineButton、RaisedButton、ButtonBar、ButtonBarTheme 和 ButtonTheme 的语义不会改变。您可以根据自己的喜好混合和匹配旧按钮和新按钮。</p>
<h3 id="新的国际化和本地化支持"><a href="#新的国际化和本地化支持" class="headerlink" title="新的国际化和本地化支持"></a>新的国际化和本地化支持</h3><p>从 Flutter 的诞生之日起，Flutter 就提供了应用程序国际化 (i18n) 和本地化 (l10n) 所需的核心功能。但是，在此版本中，我们将对最佳实践的看法融入到我们的工具中，甚至启用热重载支持，以便在您添加新的 l10n 信息时更新您的应用。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*UBVlGmhw5NUWbg5I" />
</figure>

<p>如果您希望了解有关 Flutter 对 l10n 支持的更多详细信息，包括本地化消息、带有参数的消息、日期、数字和货币，请 <a href="http://flutter.dev/go/i18n-user-guide">阅读 Flutter 国际化用户指南</a>。</p>
<p>此外，如果您对 i18n 和 l10n 感兴趣，那么您可能也对不适合纯 ASCII 字符串的字符（例如 Unicode 和表情符号）感兴趣。最近，Dart 团队发布了 <a href="https://pub.dev/packages/characters">characters 包</a>，它帮助开发者处理 Unicode（扩展）字形群集。此包帮助解决了诸如如何将类似于“A 🇬🇧 text in English”的字符串正确缩短到前 15 个字符的问题。使用 String 类，该缩写将是“A 🇬🇧 text in”，这只有 12 个用户感知字符。另一方面，使用 characters 包会产生正确的缩写“A 🇬🇧 text in Eng”。</p>
<p>通过 <a href="https://github.com/flutter/flutter/pull/59267">此 PR</a>，Flutter 使用 characters 包来正确处理这些复杂的字符。例如，当使用带有 maxLength 限制的 TextField 时，像👨‍👩‍👦这样的字符现在被正确地视为单个字符。此外，通过 <a href="https://github.com/flutter/flutter/pull/59620">此 PR</a>，characters 包在 Flutter 所在的项目中自动可用，无需手动添加它。希望这将使处理来自所有语言环境的所有类型的字符串变得更加容易。有关 characters 包的更多详细信息，请查看这篇文章：<a href="https://medium.com/dartlang/dart-string-manipulation-done-right-5abd0668ba3e">如何正确进行 Dart 字符串操作</a>。</p>
<h3 id="Google-Maps-和-WebView-Plugin-现已做好生产准备"><a href="#Google-Maps-和-WebView-Plugin-现已做好生产准备" class="headerlink" title="Google Maps 和 WebView Plugin 现已做好生产准备"></a>Google Maps 和 WebView Plugin 现已做好生产准备</h3><p>在 Flutter 团队中，我们通常谨慎地将某些东西标记为“生产就绪”，直到我们自己对其进行彻底测试。在 <a href="https://pub.dev/packages/google_maps_flutter">google_maps_flutter</a> 和 <a href="https://pub.dev/packages/webview_flutter">webview_flutter</a> Plugin 的情况下，限制因素一直是底层的 <a href="http://flutter.dev/docs/development/platform-integration/platform-views">Platform Views</a> 实现，它允许来自 Android 和 iOS 的原生 UI 组件托管在 Flutter 应用中。在此版本的 Flutter 中，我们很高兴地宣布，我们已充分增强了框架管道，足以宣布这两个 Plugin 为生产就绪。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/500/0*luz0EiazQQqsAEC4" />
<figcaption>webview_flutter Plugin 托管 flutter.dev</figcaption>
</figure>

<p>在 Flutter 1.22 中，我们添加了一个替代的 Platform Views 实现，它修复了 <a href="https://github.com/flutter/flutter/issues/61133">Android 视图的所有已知键盘和辅助功能问题</a>。此外，它与 Android API 级别 19 及更高版本配合使用（以前需要级别 20）。我们还在 iOS 上进行了线程改进，这些改进使平台视图更有效、更健壮（并且不再需要将 io.flutter.embedded_views_preview 标志添加到您的 iOS Info.plist 中）。</p>
<p>webview_flutter Plugin 支持新的 Android Platform Views 模式，但目前需要 <a href="https://github.com/flutter/plugins/blob/master/packages/webview_flutter/README.md#android">手动启用</a>。一旦它在更广泛的社区中得到更多使用，我们将在未来的版本中默认启用它。</p>
<p>Google Maps 和 WebView Plugin 已经从 Platform Views 中的改进中受益。如果您想使用 Platform Views 在 iOS 或 Android 上托管您自己的原生 UI 组件，您可以在 <a href="https://flutter.dev/docs/development/platform-integration/platform-views">使用 Platform Views 在 Flutter 应用中托管原生 Android 和 iOS 视图</a> 上了解如何操作。</p>
<h3 id="Navigator-2-0"><a href="#Navigator-2-0" class="headerlink" title="Navigator 2.0"></a>Navigator 2.0</h3><p>如果您以前在 Flutter 应用中使用过 <a href="https://flutter.dev/docs/development/ui/navigation">导航</a>，您可能已经注意到核心数据结构（用户正在浏览的页面堆栈）对您隐藏了。相反，要管理它，您会调用 Navigator.pop() 或 Navigator.push()。例如，假设您想在主页上显示一个 Widget 列表，并允许用户点击其中一个 Widget 以进入专门针对该颜色的详细信息页。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*OVbaUaMkAXrpLQCy" />
</figure>

<p>这两个屏幕可以这样实现：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/72f4a4ffdac907c3e8eda2da84dda0f6/href">https://medium.com/media/72f4a4ffdac907c3e8eda2da84dda0f6/href</a></iframe>

<p>使用最简单的 Navigator 1.0 样式可以让您以看起来非常简单的方式在这两个屏幕之间导航：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/05fab7a288dd55acf6ed63f02d36f916/href">https://medium.com/media/05fab7a288dd55acf6ed63f02d36f916/href</a></iframe>

<p>调用 Navigator.push() 是将另一个页面推到第一个页面之上的所需操作，从而创建一个包含两个页面的堆栈。但是，与在 ColorListScreen 的 build 方法中创建的 Container 列表不同，该堆栈对您隐藏了。由于它被隐藏了，因此很难管理其他场景，例如处理由原生嵌入提供的初始路由的深层链接，例如来自网页的 URL 或来自 Android 的 intent。管理相同页面不同排列之间的嵌套路由也极其困难。</p>
<p>Navigator 2.0 通过使页面堆栈可见来解决这些问题以及更多问题。以下是在 ColorListScreen 和 ColorScreen 之间导航的更新示例：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9db4a0d060729ba3e043ce6388465861/href">https://medium.com/media/9db4a0d060729ba3e043ce6388465861/href</a></iframe>

<p>应用明确地创建一个 Navigator，并为它提供一个页面列表，该列表表示完整的堆栈。我们创建了一个空 <code>_selectedColor</code> 来指示尚未选择任何颜色，因此我们不会最初显示 ColorScreen。当用户选择颜色时，我们会像往常一样调用 <code>setState()</code> 以指示 Flutter 您希望再次调用 <code>build()</code> 方法，该方法现在将在顶部创建一个包含 ColorScreen 的堆栈。</p>
<p>例如，您可以在 OnPopPage 回调中更新您的状态，如果用户弹出了，那么他们就“取消选择”了当前颜色，我们不再希望显示该页面。</p>
<p>如果 Navigator 2.0 看起来与 Flutter 的其他部分一样，那就是我们的意图——它是声明性的，与命令式的 Navigator 1.0 不同。我们的想法是统一导航和 Flutter 其他部分之间的模型，同时修复大量问题并添加功能。事实上，这个小例子只是 Navigator 2.0 中一部分内容的表面描述。有关详细信息，我强烈推荐这篇文章：<a href="https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade">Flutter 中的声明式导航和路由</a>。</p>
<p>此外，您现有的 Navigator 1.0 使用方式将继续与今天一样工作，并且不会很快被移除。如果您喜欢该模型，您当然可以继续使用它。但是，如果您尝试使用 Navigator 2.0，我们认为您会喜欢它。</p>
<h3 id="预览：Android-的状态恢复"><a href="#预览：Android-的状态恢复" class="headerlink" title="预览：Android 的状态恢复"></a>预览：Android 的状态恢复</h3><p>此版本中可供您体验的新功能是对 <a href="https://developer.android.com/topic/libraries/architecture/saving-states">Android 上的状态恢复</a> 的支持。这是我们 <a href="https://github.com/flutter/flutter/issues/6827">最受欢迎的功能之一</a>，获得了 217 个点赞！</p>
<p>对于那些不熟悉状态恢复需求的人来说，移动操作系统可能会终止后台应用以回收资源以供前台应用使用。发生这种情况时，操作系统会通知要终止的应用尽快保存任何 UI 状态，以便在用户返回到该应用时恢复它。如果实现正确，这将为用户提供无缝的体验，同时更好地利用设备资源。到目前为止，Flutter 不支持状态恢复，在没有框架支持的情况下正确地做到这一点非常困难。这就是我们很高兴能够为 Android 提供此功能的基础实现的原因。</p>
<p>以下是如何 <a href="https://api.flutter.dev/flutter/widgets/RestorationMixin-mixin.html#widgets.RestorationMixin.1">恢复默认 Flutter Counter 应用的状态的简单示例</a>：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5b53da24e0462f59d442d2af47bb265a/href">https://medium.com/media/5b53da24e0462f59d442d2af47bb265a/href">https://medium.com/media/5b53da24e0462f59d442d2af47bb265a/href</a></iframe>

<p>简而言之，每个 Widget 都获得一个存储桶，该存储桶使用唯一的 ID 与 <a href="https://api.flutter.dev/flutter/widgets/RestorationMixin-mixin.html">RestorationMixin</a> 关联。通过使用 <a href="https://master-api.flutter.dev/flutter/widgets/RestorableProperty-class.html">RestorableProperty</a> 类型（此处使用的是 RestorableInt）来存储 UI 特定的数据，并通过将该数据与状态恢复功能关联，数据将在 Android 终止应用之前自动存储，并在应用恢复时恢复。就这样。存储在 Restoration* 类型中的任何数据，例如 RestorableInt、RestorableString 和 RestorableTextEditingController（我们有很多这样的类型），都将被恢复。如果我们没有涵盖您希望恢复的所有类型，您可以通过扩展 <a href="https://api.flutter.dev/flutter/widgets/RestorableProperty-class.html">RestorableProperty&lt;T&gt;</a> 创建您自己的类型。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/720/0*1298qhTKz_FjPuRN" />
</figure>

<p>为了对状态恢复进行自动化测试，我们已向 <a href="https://api.flutter.dev/flutter/flutter_test/WidgetTester/restartAndRestore.html">WidgetTester 添加了一个新的 restartAndRestore API</a>。为了手动测试，最简单的方法是在 Android 设备上启动启用了状态恢复的 Flutter 应用，在 Android 的开发者设置中启用“不保留活动”，运行 Flutter 应用，将其置于后台，然后返回到它。此时，Android 将终止并恢复您的应用，因此您可以查看一切是否按预期工作。</p>
<p>虽然我们很高兴将此状态恢复的预览版本交给您，但仍有更多工作要做。例如，状态恢复不仅适用于 Android，iOS 应用也可以从中受益。此外，我们正在忙于更新我们自己的 Widget，以在恢复期间保持其状态。我们已经在 Scrollable 类（例如 ListView 和 SingleChildScrollView）（记住用户的滚动位置）和 TextField（恢复用户输入的文本）中提供了支持，并计划将其扩展到其他 Widget。</p>
<p>但是，我们尚未添加的关键恢复支持，也是使它成为预览版本的原因是导航（1.0 或 2.0）。这意味着用户在应用中的位置将不会被恢复。该功能将很快在测试版中推出，并在 Flutter 的下一个稳定版本中推出。</p>
<h3 id="预览：为无与伦比的输入和显示频率提供流畅的滚动效果"><a href="#预览：为无与伦比的输入和显示频率提供流畅的滚动效果" class="headerlink" title="预览：为无与伦比的输入和显示频率提供流畅的滚动效果"></a>预览：为无与伦比的输入和显示频率提供流畅的滚动效果</h3><p>Flutter 团队与我们内部的 Google 合作伙伴合作，在输入频率和显示频率不相同的情况下大大改善了滚动的性能。例如，Pixel 4 的输入频率为 120hz，而显示频率为 90hz。这种不匹配会导致滚动时出现性能损失。使用新的 resamplingEnabled 标志，您可以利用我们在 Flutter 中完成的性能工作来解决此问题：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ac9c676eb1233dd1597b234b73ffc8a3/href">https://medium.com/media/ac9c676eb1233dd1597b234b73ffc8a3/href">https://medium.com/media/ac9c676eb1233dd1597b234b73ffc8a3/href</a></iframe>

<p>根据所涉及的频率差异，通过启用此标志，您可能会看到滚动时的卡顿减少高达 97%。当我们确定这是最佳体验时，我们计划在未来的版本中默认启用此标志。</p>
<h3 id="一个新的统一-Dart-开发者工具"><a href="#一个新的统一-Dart-开发者工具" class="headerlink" title="一个新的统一 Dart 开发者工具"></a>一个新的统一 Dart 开发者工具</h3><p>与往常一样，更新 Flutter 不仅仅意味着引擎和框架，还包括工具。Flutter 1.22 包括新的 Dart 版本（2.10），并且有一个新的 dart CLI 工具，您可能会发现它也很有用。</p>
<p>Dart 历史上拥有许多较小的开发者工具（例如用于格式化的 dartfmt 和用于代码分析的 dartanalyzer）。在 Dart 2.10 中新增了一个统一的 dart 开发者工具，它与 flutter 工具非常相似。</p>
<figure>
<img alt="Screenshot of the output of `dart help`." src="https://cdn-images-1.medium.com/max/700/1*9pvyafhpaMEMhJfLVsz1JQ.png" />
</figure>

<p>从今天的 Flutter 1.22 SDK 开始，您会发现 <code>&lt;flutter-sdk&gt;/bin</code> 文件夹（您可能将其放在 PATH 中）包含 flutter 和 dart 命令。有关更多详细信息，请参阅 <a href="https://medium.com/@mit.mit/announcing-dart-2-10-350823952bd5">Dart 2.10 部落格文章</a>。</p>
<h3 id="应用大小分析工具"><a href="#应用大小分析工具" class="headerlink" title="应用大小分析工具"></a>应用大小分析工具</h3><p>作为 Flutter 1.22 的一部分发布的工具包含一个新的输出大小分析实用程序。此工具帮助诊断 Flutter 您的应用的大小分解随着时间的推移是否发生了变化。</p>
<p>您可以使用此工具通过传递一个<code>--analyze-size</code> 标志到以下任何命令来收集分析所需的数据：</p>
<ul>
<li>flutter build apk</li>
<li>flutter build appbundle</li>
<li>flutter build ios</li>
<li>flutter build linux</li>
<li>flutter build macos</li>
<li>flutter build windows</li>
</ul>
<p>在构建 Flutter 输出工件时使用此标志将打印工件大小和组成的摘要。这包括原生代码、资产，甚至编译的 Dart 代码的包级别分解。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/943/0*vfMD0AQZUOUwzfZ4" />
<figcaption>Flutter Gallery 发布的 APK 的示例分解</figcaption>
</figure>

<p>此摘要对于快速识别应用程序包大小使用情况中的热点很有用。此外，收集的数据还可用作 Dart DevTools 中的 JSON 文件，它允许您进一步探索应用的内容，查明大小问题，并通过遵循 <a href="https://flutter.dev/docs/development/tools/devtools/app-size">flutter.dev 上的说明</a> 查看两个不同 JSON 文件之间的更改。加载 JSON 文件后，您将拥有一个界面，该界面将为您提供应用大小的树状图视图。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gA2waLDAyITCzD7K" />
<figcaption>Dart DevTools 中的示例 APK 分解</figcaption>
</figure>

<p>有关使用应用大小工具可以执行的操作的更多详细信息，请阅读 <a href="https://flutter.dev/docs/development/tools/devtools/app-size">flutter.dev 上的使用应用大小工具文档</a>。</p>
<h3 id="预览：DevTools-中更新的网络页面"><a href="#预览：DevTools-中更新的网络页面" class="headerlink" title="预览：DevTools 中更新的网络页面"></a>预览：DevTools 中更新的网络页面</h3><p>此版本中的另一个 DevTools 预览功能是能够在 <strong>网络</strong> 选项卡中查看 HTTP 和 HTTPS 响应正文。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/781/0*-FukCwELl9DLlefP" />
</figure>

<p>若要启用此功能，请确保您通过 <code>flutter channel dev</code> 和 <code>flutter channel upgrade</code> 位于 Flutter dev 频道。</p>
<p>此外，对于有大量网络流量的应用，我们提供搜索和筛选功能。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/994/0*k-fEpOpbV_MiX9Fn" />
</figure>

<p>有关 <strong>网络</strong> 选项卡文档，请参阅 <a href="https://flutter.dev/docs/development/tools/devtools/network">flutter.dev 上的使用网络视图</a>。</p>
<h3 id="IntelliJ-中托管的-DevTools-Inspector-选项卡"><a href="#IntelliJ-中托管的-DevTools-Inspector-选项卡" class="headerlink" title="IntelliJ 中托管的 DevTools Inspector 选项卡"></a>IntelliJ 中托管的 DevTools Inspector 选项卡</h3><p>一段时间以来，我们一直在维护我们 Flutter 某些工具的两个副本，例如 IntelliJ 中的 <strong>Inspector</strong> 窗格和 Dart DevTools 中的 <strong>Inspector</strong> 选项卡。这不仅会降低我们的速度，因为我们必须维护两个代码库，而且某些功能（例如布局资源管理器）尚未加入 IntelliJ Plugin。因此，为了解决这两个问题，我们启用了直接在 IntelliJ 中托管来自 Dart DevTools 的 <strong>Inspector</strong> 选项卡的功能。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*RQZ-EVyFP1-BqBIX" />
</figure>

<p>请注意布局资源管理器的添加，您可以在代码旁边使用它。若要打开此选项，请转到 <strong>首选项</strong> &gt; <strong>语言和框架</strong> &gt; <strong>Flutter</strong> &gt; <strong>启用嵌入式 DevTools Inspector</strong>。</p>
<h3 id="Visual-Studio-Code-中改进的输出链接"><a href="#Visual-Studio-Code-中改进的输出链接" class="headerlink" title="Visual Studio Code 中改进的输出链接"></a>Visual Studio Code 中改进的输出链接</h3><p>所有 Flutter 开发者都会遇到的一个常规操作是从终端或堆栈跟踪中的错误输出开始。在 Visual Studio Code 的 Flutter 扩展的最新版本中，这些链接现在将被正确地解析，以启用从输出中的链接直接进行跳转。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*prigrwpp7gE6ChCE" />
</figure>

<p>这看起来似乎是一个小事情，但对这一功能的初步反馈已经非常积极。</p>
<p>与往常一样，这里列出的工具更改太多，但我建议您查看以下公告以获取详细信息：</p>
<ul>
<li><a href="https://groups.google.com/g/flutter-announce/c/UxMv8MzE_uo/m/ED539pi2AAAJ">Dart DevTools - 0.9.0</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/y27h86ATFJM">Dart DevTools - 0.9.1</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/24LppkXdMtM">Dart DevTools - 0.9.3</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/nvgDi3RLAUE/m/Fx4Ze0vrBAAJ">Flutter IntelliJ Plugin M48.1 版本</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/-ZMKRIBRtGU">Flutter IntelliJ Plugin M49 版本</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/u0zU6zv3o44/m/2y0JsX1_AwAJ">Flutter IntelliJ Plugin M50 版本</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/8e8e-ZrgySY">VS Code 扩展 v3.14.0</a></li>
<li><a href="https://dartcode.org/releases/v3-15/">VS Code 扩展 v3.15.0</a></li>
</ul>
<h3 id="客户案例：EasyA"><a href="#客户案例：EasyA" class="headerlink" title="客户案例：EasyA"></a>客户案例：EasyA</h3><p>EasyA 是一款订阅应用，旨在让学龄学生通过即时消息与优秀的导师联系，并使用 Flutter 编写。最近它被 Apple 评为 <a href="https://apps.apple.com/gb/story/id1527472788">Apple 的“今日应用”</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*yLWTxV_YTJ2HKhuz" />
</figure>

<blockquote>“当学校今年早些时候开始上网时，我们知道我们需要快速推出我们的辅导应用来帮助学生。使用 Flutter 进行开发的超快速度意味着我们能够为 iOS 和 Android 实现获奖设计，并发布到网页——恰逢封锁期间！通常情况下，这是不可能实现的。但由于 Flutter 允许我们同时定位所有三个平台，因此我们能够高效地共享代码，并充分利用我们的小型开发者团队。”</blockquote>

<blockquote>— 菲利普·郭，[EasyA](https://easya.io/) 的联合创始人</blockquote>

<h3 id="重大更改"><a href="#重大更改" class="headerlink" title="重大更改"></a>重大更改</h3><p>与往常一样，我们一直努力将重大更改的数量降至最低。以下是 Flutter 1.22 版本的列表。</p>
<ul>
<li><a href="https://github.com/flutter/flutter/pull/56413">56413</a> <a href="https://docs.google.com/document/d/1BZhxy176uUnqOCnXdnHM1XetS9mw9WIyUAOE-dgVdUM/edit?usp=sharing">防止 viewport.showOnScreen 在指定的 Rect 已经可见时滚动 viewport</a>。</li>
<li><a href="https://github.com/flutter/flutter/pull/62395">62395</a> [gen_l10n] 默认情况下进行合成包生成。</li>
<li><a href="https://github.com/flutter/flutter/pull/62588">62588</a> 更少地构建路由。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flutter 1.22 稳定版本可能是在上一个版本之后快速发布的，但它包含了如此多的优秀内容，以至于这篇文章无法全部提及。我们希望此版本能帮助您为 iOS 和 Android 构建出色的应用，我们迫不及待地想看看您将会实现什么！感谢您的支持——我们为你们构建 Flutter。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=44f146009e5f" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/announcing-flutter-1-22-44f146009e5f">宣布 Flutter 1.22</a> 最初发布在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人们在那里通过突出显示和回应这个故事，继续进行讨论。</p> </p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rainvisitor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">166</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">188</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rainvisitor</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
