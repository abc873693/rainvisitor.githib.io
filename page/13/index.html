<!DOCTYPE html>
<html lang="zh-tw,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rainvisitor.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/page/13/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.rainvisitor.me/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-tw'
  };
</script>

  <title>RainVisitor Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RainVisitor Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">RainVisitor</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/d6a738f8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/d6a738f8.html" class="post-title-link" itemprop="url">【文章翻譯】Flutter on the web, slivers, and platform-specific issues: user survey results from Q3 2020</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-20 19:29:40" itemprop="dateCreated datePublished" datetime="2020-10-20T19:29:40+08:00">2020-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 20:22:51" itemprop="dateModified" datetime="2024-09-30T20:22:51+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Flutter-網頁、Sliver-和平台特定問題：來自-2020-年第三季度的使用者調查結果"><a href="#Flutter-網頁、Sliver-和平台特定問題：來自-2020-年第三季度的使用者調查結果" class="headerlink" title="Flutter 網頁、Sliver 和平台特定問題：來自 2020 年第三季度的使用者調查結果"></a>Flutter 網頁、Sliver 和平台特定問題：來自 2020 年第三季度的使用者調查結果</h2><p><em>撰寫者：Flutter UXR 團隊（<a href="https://medium.com/@jayoung.lee">JaYoung Lee</a>，<a href="https://medium.com/@youyanghou">Youyang Hou</a>，<a href="https://medium.com/@jackhimself">Jack Kim</a>，<a href="https://medium.com/@taodong">Tao Dong</a>）</em></p>
<p>2020 年 8 月，Flutter 團隊發布了其第 10 個季度使用者調查。在 10 天的時間裡，全球有 7,668 名使用者回覆了調查。每位使用者平均花費 7.4 分鐘完成調查，相當於 39.4 天的開發者時間。我們非常感謝大家花時間提供意見回饋，我們也希望與大家分享這些結果。</p>
<p>如同往常，我們詢問了您對 Flutter 各個部分的滿意度。本季度，我們也專注於收集有關其他主題的意見回饋，例如 Flutter 網頁、Sliver（用於實現豐富捲動效果的 Widget）和除錯平台特定問題。我們將在本文中更詳細地探討每個主題。如果您有興趣，請繼續閱讀！</p>
<p><strong>摘要</strong></p>
<ul>
<li>94% 的受訪者對 Flutter 的整體滿意度很高（PSAT），58% 的受訪者非常滿意（VSAT）。雖然 PSAT 保持穩定，但 VSAT 不斷增加。</li>
<li>在企業工作的使用者比例從 26% 增加到 31%。高級使用者的比例也在增加。</li>
<li>在過去 3 個月使用 Flutter 網頁的使用者中，59% 的使用者對其效能感到滿意。71% 的使用者對 Flutter 建立在網頁上感覺自然的 UI 的能力感到滿意。</li>
<li>想要使用 Sliver 實作豐富捲動效果的使用者中，有 79% 的使用者嘗試過使用它們。最大的問題（36%）是難以找到符合他們需求的 Widget。</li>
<li>71% 的使用者有除錯平台特定問題的經驗。常見的問題包括工具（32%）、視覺差異（28%）和相依性管理問題（28%）。</li>
</ul>
<h3 id="滿意度和使用者群的變化"><a href="#滿意度和使用者群的變化" class="headerlink" title="滿意度和使用者群的變化"></a>滿意度和使用者群的變化</h3><p>本季度，對 Flutter <em>非常滿意</em> 的使用者比例創下新高，達到 58%。總體而言，Flutter 使用者對產品仍然感到滿意（94%），即使社群以指數級增長。以下圖表顯示了 Flutter 滿意度水平隨時間的推移。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*k_YiDB0OZTd8WQI2" />
<figcaption><em>58% 的使用者在回答「總體而言，您對 Flutter 的滿意度如何？」的問題時選擇了「非常滿意」。</em></figcaption>
</figure>

<p>我們的使用者群有一些顯著的變化。首先，在企業工作的使用者比例顯著增加，從第一季和第二季的 26% 增加到 31%，而在此期間，在創業公司工作的使用者比例穩定在 35% 左右。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*mTLE89U4VUtGDnEI" />
<figcaption><em>雖然大多數 Flutter 使用者都在創業公司工作，但企業開發者比例從 26% 顯著增加到 31%。</em></figcaption>
</figure>

<p>另一個顯著的變化是對 Flutter 經驗水平的感知。如以下圖表所示，新手使用者的比例隨時間推移而下降，而高級使用者的比例隨時間推移而增加。這意味著我們社群中有更多有經驗的使用者可以幫助分享他們的知識給新手使用者。如果您有興趣獲得或分享知識，您可以與其他 Flutter 開發者在線交流。請訪問 flutter.dev 上的 <a href="https://flutter.dev/community">社群標籤</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*_CopRAy_n9COQGqR" />
<figcaption><em>高級使用者的比例持續增加。</em></figcaption>
</figure>

<h3 id="Flutter-網頁"><a href="#Flutter-網頁" class="headerlink" title="Flutter 網頁"></a>Flutter 網頁</h3><p>除了在 stable channel 支援行動裝置外，Flutter 也在 beta 版中支援網頁開發。在此調查中，我們詢問了早期採用者在效能、網頁體驗、工作流程和文件方面遇到的特定問題，以便我們可以優先處理重要問題。</p>
<p>受訪者積極使用 Flutter 建立網頁應用程式。約 33% 的受訪者表示他們已評估 Flutter 網頁以供潛在生產使用（15%）、建構了 demo（11%）或發布了生產應用程式（7%），如以下圖表第三行所示。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*R7aSejQwaxUY2W9L" />
<figcaption><em>33% 的使用者（4,449 人中的 1,468 人）表示他們已評估 Flutter 網頁以供生產（15%）、建構了 demo（11%）或發布了生產應用程式（7%）。</em></figcaption>
</figure>

<p>更具體地說，在過去 3 個月擁有行動裝置和網頁開發經驗的使用者中，有 29.5% 的使用者更認真地使用 Flutter 網頁（供潛在生產使用）。這個百分比因開發者先前對平台的經驗而異。看起來，具有網頁開發背景的受訪者正在嘗試 Flutter 作為一種替代網頁框架（22% 的受訪者嘗試使用 Flutter 網頁以供潛在生產使用），而具有行動裝置開發背景的受訪者正在積極嘗試使用 Flutter 網頁作為通往網頁開發的途徑（16% 的受訪者嘗試使用 Flutter 網頁）。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*C0d4X2FddTe0fC6A" />
<figcaption><em>在過去 3 個月嘗試使用 Flutter 網頁以供生產的使用者比例因他們先前對行動裝置和網頁平台的經驗而異。</em></figcaption>
</figure>

<p>Flutter 網頁團隊也收集了有關建立網頁體驗的各個問題的意見回饋。首先，我們了解到受訪者認為瀏覽器導航和路由歷史（55%）、複製&#x2F;貼上選取文字（34%）、捲軸物理學（33%）和選取文字（32%）在建立網頁體驗中至關重要。受訪者也要求提供有關路由和調整行動版佈局以適應網頁的更好文件。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*8WXtO7Mx_n5Gs0m_" />
<figcaption><em>使用者將「瀏覽器導航和路由歷史」選為使用 Flutter 建立網頁體驗中最關鍵的功能。</em></figcaption>
</figure>

<p>Flutter 團隊正在根據我們收到的意見回饋積極進行改進。為了解決圍繞導航和路由的頂級使用者問題，團隊最近發布了 <a href="https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade">Navigator 2</a>。我們還加入了對 <a href="https://github.com/flutter/flutter/issues/47234">複製&#x2F;貼上可選文字</a> 的支援，並計劃改進 <a href="https://github.com/flutter/flutter/projects/173#card-43620465">可選文字</a> 功能（特別是針對富文字）。我們將根據社群回報的問題，繼續努力改進捲軸物理學和效能。</p>
<p>最後，團隊收到了有關工作流程、效能和第三方 API 的意見回饋。在基本工作流程中，受訪者認為除錯最困難。頁面載入速度和捲軸是受訪者遇到的最常見的效能問題。受訪者希望 Flutter 網頁更好地支援本地儲存（例如 SQLite）、Firebase 儲存和 Google 地圖。當團隊在 Flutter 網頁方面取得進展時，這些領域將會成形。</p>
<h3 id="Sliver"><a href="#Sliver" class="headerlink" title="Sliver"></a>Sliver</h3><p>Sliver Widget（以「Sliver」開頭的 Widget，例如 SliverAppBar 和 SliverList）用於建立豐富的捲軸效果。雖然可以使用 ListView、GridView、PageView 或 AnimatedList 等 Widget 實現許多捲軸效果，但 Sliver Widget 有助於自訂捲軸檢視，並實現更美觀的 UI。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/408/0*a-qk7SfiAnHAq2vU" />
<figcaption><em>您可以使用 Sliver Widget 實現像這樣的豐富捲軸效果。</em></figcaption>
</figure>

<p>Flutter 團隊聽到了有關使用者對 Sliver 體驗的不同故事。有些人表示他們沒有在應用程式中使用 Sliver，而有些人表示他們需要更多 Sliver 來實現各種效果。因此，團隊決定在本季度的調查中加入一些問題，以更好地了解 Flutter 使用者如何使用 Sliver。</p>
<p>我們首先了解到，更多使用者使用簡單的捲軸效果（49%）設計他們的 UI，而不是使用豐富的捲軸效果（39%）。（調查中呈現了簡單捲軸效果和豐富捲軸效果的範例。）對於那些需要豐富捲軸效果的人來說，78% 的人表示他們需要 Sliver 來實現他們想要的效果。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*YNnoQE06DVStrvWV" />
<figcaption><em>更多使用者使用簡單的捲軸效果（49%）設計他們的 UI，而不是使用豐富的捲軸效果（39%）。</em></figcaption>
</figure>

<p>在那些需要 Sliver 的使用者中，20% 的使用者表示他們沒有嘗試過使用 Sliver。對我們來說更有趣的是，35% 的使用者表示他們嘗試過使用 Sliver 但遇到了問題。當我們詢問他們遇到的最大問題時，如以下圖表所示，發現問題最大（36%），其次是學習問題（30%），然後是可用性問題（19%）。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-P_8Vyu4EMCZ4ji0" />
<figcaption><em>發現問題是 Sliver 使用者遇到的最大問題，其次是學習問題和可用性問題。</em></figcaption>
</figure>

<p>因為我們不希望您因這些問題而降低 UI 品質，所以我們計劃更新 <a href="https://flutter.dev/">flutter.dev</a>，以便更容易找到 Sliver Widget 和有關 Sliver 的相關資訊，並且更容易學習。如果您正在尋找 Flutter 框架中沒有的新 Sliver，請考慮使用社群套件，例如 <a href="https://pub.dev/packages/sliver_tools">sliver_tools</a> 或 <a href="https://pub.dev/packages/sticky_headers">sticky_headers</a>。Flutter 社群也歡迎您為此領域做出貢獻。</p>
<p>同時，如果您是 Sliver 的新手並且想了解更多，請參閱以下資源：</p>
<ul>
<li><a href="https://medium.com/flutter/slivers-demystified-6ff68ab0296f">Slivers, demystified</a>（Medium 文章）</li>
<li><a href="https://www.youtube.com/watch?v=Mz3kHQxBjGg">Slivers explained — making dynamic layouts</a>（YouTube 上的 The Boring Flutter Development Show，第 12 集）</li>
</ul>
<h3 id="除錯平台特定問題"><a href="#除錯平台特定問題" class="headerlink" title="除錯平台特定問題"></a>除錯平台特定問題</h3><p>在 <a href="https://medium.com/flutter/what-are-the-important-difficult-tasks-for-flutter-devs-q1-2020-survey-results-a5ef2305429b">先前的調查</a> 中，我們發現 <em>除錯平台特定問題</em> 和 <em>跨平台測試應用程式</em> 是 Flutter 開發者最困難的任務。雖然我們看到了一些與平台特定問題相關的錯誤，但我們並不知道這些問題的相對優先順序，以及它們是否被捆綁在主題中或分散開來。為了找到除錯和測試難以執行的原因，我們加入了一些問題以詢問使用者遇到了什麼特定問題。</p>
<p>首先，我們詢問使用者除錯了哪些平台特定問題。我們發現最 <em>常見</em> 的平台特定問題是工具問題（32%）、不同平台的視覺差異（28%）、相依性管理問題（28%）、不同平台的行為差異（27%）、不同平台的 Plugin 行為差異（26%）和缺少原生功能（25%）。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*YB3J0hC7A6F7NdXE" />
<figcaption><em>最常見的平台特定問題是工具問題、視覺差異和相依性管理問題。</em></figcaption>
</figure>

<p>受訪者也評估了他們除錯的每個問題的重要性</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/f22b27a6.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/f22b27a6.html" class="post-title-link" itemprop="url">【文章翻譯】Testable Flutter and Cloud Firestore</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-15 19:34:38" itemprop="dateCreated datePublished" datetime="2020-10-15T19:34:38+08:00">2020-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pQJzBr81G169df-ffo24Cg.png" /></figure>

<h3 id="為什麼選擇-Cloud-Firestore？"><a href="#為什麼選擇-Cloud-Firestore？" class="headerlink" title="為什麼選擇 Cloud Firestore？"></a>為什麼選擇 Cloud Firestore？</h3><p><a href="https://firebase.flutter.dev/">FlutterFire</a> 技術堆疊，由 Flutter 和 Firebase（特別是 Cloud Firestore）組成，在您構建和發佈應用程式時，為您解鎖了前所未有的開發速度。在本文中，您將探索這兩種技術之間的強大整合，重點關注測試和使用乾淨的架構模式。但是，您將一步一步地構建自己的方法，而不是直接跳到最終實作，這樣每個步驟背後的理由就清晰明瞭。</p>
<h3 id="您將構建什麼？"><a href="#您將構建什麼？" class="headerlink" title="您將構建什麼？"></a>您將構建什麼？</h3><p>為了展示將 Cloud Firestore 作為您應用程式後端的乾淨方法，您將構建經典 Flutter 計數器應用程式的修改版本。唯一的區別是，每次點擊的時間戳都儲存在 Cloud Firestore 中，並且顯示的計數是從儲存的時間戳的數量中推導出來的。您將使用 Provider 和 ChangeNotifier 保持依賴項和狀態管理程式碼乾淨，並且您將更新生成的測試以保持程式碼的 <em>正確性</em>！</p>
<h3 id="開始之前"><a href="#開始之前" class="headerlink" title="開始之前"></a>開始之前</h3><p>本文假設您已 <a href="https://www.youtube.com/watch?v=Mx24wiPilHg">觀看並按照此教學中的步驟操作</a> 將您的應用程式與 Firebase 整合。簡要說明一下：</p>
<ol>
<li>建立一個新的 Flutter 專案，並命名為 firebasecounter。</li>
<li>在 <a href="https://console.firebase.google.com/">Firebase 主控台</a> 中建立一個 Firebase 應用程式。</li>
<li>將您的應用程式連結到 iOS 和&#x2F;或 Android，具體取決於您的開發環境和目標受眾。</li>
</ol>
<blockquote>注意：如果您將您的應用程式設定為在 Android 客戶端上運行，請務必 [建立一個 `debug.keystore` 檔案](https://gist.github.com/henriquemenezes/70feb8fff20a19a65346e48786bedb8f)，然後再生成您的 SHA1 憑證。</blockquote>

<p>在您在 Firebase 中生成 iOS 或 Android 應用程式之後，您就可以繼續進行。影片的其餘部分包含您在實際專案中可能需要的精彩內容，但對於本教學來說不是必需的。</p>
<h3 id="如果您遇到問題"><a href="#如果您遇到問題" class="headerlink" title="如果您遇到問題"></a>如果您遇到問題</h3><p>如果本教學中的任何步驟對您不起作用，請諮詢 <a href="https://github.com/craiglabenz/flutter-firestore-counter">這個公開的儲存庫</a>，它將更改分解為不同的提交。在整個教學中，您將在適當的位置找到指向每個提交的連結。請隨時使用它來驗證您是否已按照預期的方式進行！</p>
<h3 id="建立一個簡單的狀態管理員"><a href="#建立一個簡單的狀態管理員" class="headerlink" title="建立一個簡單的狀態管理員"></a>建立一個簡單的狀態管理員</h3><p>要開始將您的應用程式與 Cloud Firestore 整合的過程，您必須首先重構生成的程式碼，以便初始 StatefulWidget 與單獨的類別進行通訊，而不是與自身的屬性進行通訊。這讓您最終可以指示該單獨的類別使用 Cloud Firestore。</p>
<p>在您的專案的自動生成的 <code>main.dart</code> 檔案旁邊，建立一個名為 <code>counter_manager.dart</code> 的新檔案，並將以下程式碼複製到其中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">建立一個私有整數來儲存計數。將其設為私有，</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">因此 Widget 無法直接修改它，而是必須</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">使用官方方法。</span></span></span><br><span class="line">  <span class="built_in">int</span> _count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">公開可存取的狀態參考。</span></span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> count =&gt; _count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">公開可存取的狀態修改器。</span></span></span><br><span class="line">  <span class="keyword">void</span> increment() =&gt; _count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程式碼就位後，將以下行新增到 <code>firebasecounter/lib/main.dart</code> 的頂部：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/counter_manager.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>然後，將 <code>_MyHomePageState</code> 的程式碼更改為以下內容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> manager = CounterManager();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() &#123;</span><br><span class="line">    setState(() =&gt; manager.increment());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;You have pushed the button this many times:&#x27;</span>),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="string">&#x27;<span class="subst">$&#123;manager.count&#125;</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.headline4,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>儲存此程式碼更改後，您的應用程式可能會顯示崩潰並顯示一個紅色的錯誤螢幕。這是因為您引入了一個新的變數 <code>manager</code>，它初始化的機會已經過了。當您更改狀態的 <em>初始化方式</em> 時，這在 Flutter 中很常見，並且可以使用熱重新啟動輕鬆解決。</p>
<p>熱重新啟動後，您應該回到開始的地方：計數為 0，並且可以根據需要點擊浮動動作按鈕。</p>
<p>現在是運行 Flutter 在任何新的專案中提供的單一測試的好時機。您可以在 <code>test/widget_test.dart</code> 中找到它的定義，並透過運行以下命令執行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>假設測試通過，您就可以繼續進行！</p>
<blockquote>注意：如果您在此部分遇到問題，請將您的更改與教學儲存庫中的 [這個提交](https://github.com/craiglabenz/flutter-firestore-counter/commit/483dd3b3833bf710b04db4a3ba347b1d1ecbe5de) 進行比較。</blockquote>

<h3 id="持續時間戳"><a href="#持續時間戳" class="headerlink" title="持續時間戳"></a>持續時間戳</h3><p>初始應用程式描述中提到了持續儲存每次點擊的時間戳。到目前為止，您尚未添加任何基礎架構來滿足第二個要求，因此請建立另一個名為 <code>app_state.dart</code> 的新檔案，並添加以下類別：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">應用程式狀態的完整容器。</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">此類別的實例應該能夠告知任何時候</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">渲染的內容。</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppState</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">完整的點擊歷史記錄。用於非常重要的審計目的。</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">點擊的計數變為此列表的 <span class="code">`length`</span> 屬性。</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">DateTime</span>&gt; clicks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">預設生成式建構函式。對常數友好，以實現最佳</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">效能。</span></span></span><br><span class="line">  <span class="keyword">const</span> AppState([<span class="built_in">List</span>&lt;<span class="built_in">DateTime</span>&gt; clicks])</span><br><span class="line">      : clicks = clicks ?? <span class="keyword">const</span> &lt;<span class="built_in">DateTime</span>&gt;[];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">方便的輔助函式。</span></span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> count =&gt; clicks.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">複製方法，它返回一個新的 AppState 實例，而不是</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">修改現有的副本。</span></span></span><br><span class="line">  AppState copyWith(<span class="built_in">DateTime</span> latestClick) =&gt; AppState([</span><br><span class="line">        latestClick,</span><br><span class="line">        ...clicks,</span><br><span class="line">      ]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從現在開始，<code>AppState</code> 類別的工作是表示應該渲染的內容的狀態。該類別不包含任何可以修改自身的方法，只有一個單獨的 <code>copyWith</code> 方法，其他類別將使用它。</p>
<p>牢記測試，您可以開始更改 <code>CounterManager</code> 概念。從長遠來看，使用單一類別將行不通，因為應用程式最終會與 Cloud Firestore 進行互動。但是，您不想在每次運行測試時都建立真實的記錄。為此，您需要一個抽象介面來定義應用程式應該如何表現。</p>
<p>再次打開 <code>counter_manager.dart</code>，並在檔案的頂部添加以下程式碼：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/app_state.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">定義操作</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">應用程式狀態所需的函式的介面。</span></span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">定義為抽象類別，以便測試可以在不</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">與 Firebase 通訊的版本上運行。</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">任何 <span class="code">`CounterManager`</span> 都必須具有狀態的實例</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">物件。</span></span></span><br><span class="line">  AppState state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">處理必須儲存新的點擊的事件。不需要</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">任何參數，因為它只會導致時間戳</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">持續存在。</span></span></span><br><span class="line">  <span class="keyword">void</span> increment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步是更新 <code>CounterManager</code> 以顯式地從 <code>ICounterManager</code> 繼承。將其定義更新為以下內容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterManager</span> <span class="keyword">implements</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">  AppState state = AppState();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> increment() =&gt; state = state.copyWith(<span class="built_in">DateTime</span>.now());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這個階段，我們的輔助程式碼看起來已經很好了，但是 <code>main.dart</code> 落後了。<code>main.dart</code> 中沒有 <code>ICounterManager</code> 的參考，而事實上，它是它應該知道的 <em>唯一</em> 的 <code>Manager</code> 類別。在 <code>main.dart</code> 中，更新並應用以下更改：</p>
<ol>
<li>將遺漏的匯入新增到 <code>main.dart</code> 的頂部：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/app_state.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>將 <code>_MyHomePageState</code> 更新為以下內容：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ICounterManager manager;</span><br><span class="line">  _MyHomePageState(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.manager&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _incrementCounter() =&gt; setState(() =&gt; manager.increment());</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;You have pushed the button this many times:&#x27;</span>),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="comment">// 參考 `widget.manager` 而不是</span></span><br><span class="line">              <span class="comment">// `manager` 直接</span></span><br><span class="line">              <span class="string">&#x27;<span class="subst">$&#123;manager.state.count&#125;</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.headline4,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        <span class="comment">// 參考 `widget.manager` 而不是 `manager` 直接</span></span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此更改應該會移除 IDE 中 <code>_MyHomePageState</code> 的任何紅色波浪線，但是現在 <code>MyHomePage</code> 會抱怨，因為它的 <code>createState()</code> 方法沒有向 <code>_MyHomePageState</code> 提供所有必需的參數。您可以讓 <code>MyHomePage</code> 要求此變數，並將物件傳遞到它的基於狀態的類別，但是這可能會導致很長的 Widget 鏈，這些 Widget 會要求並傳遞它們實際上不在乎的物件，僅僅因為某些後代 Widget 要求它，而某些祖先 Widget 提供它。顯然，這需要一個更好的策略。</p>
<p>輸入： <a href="https://pub.dev/packages/provider">Provider</a></p>
<h3 id="使用-Provider-存取應用程式狀態"><a href="#使用-Provider-存取應用程式狀態" class="headerlink" title="使用 Provider 存取應用程式狀態"></a>使用 Provider 存取應用程式狀態</h3><p>Provider 是一个函式庫，它简化了 Flutter 的 <code>InheritedWidget</code> 模式的使用。Provider 允許頂級 Widget 在您的 Widget 樹中被所有後代 Widget 直接存取。這可能感覺像一個全域變數，但替代方案是將您的資料模型透過每個中間 Widget 傳遞下去，其中許多 Widget 本身並不感興趣。這種「變數 <a href="https://en.wikipedia.org/wiki/Bucket_brigade">桶式傳遞</a>」反模式會模糊您的應用程式中的關注點分離，並且會使重構佈局變得不必要地繁瑣。<code>InheritedWidget</code> 和 Provider 透過讓 Widget 樹中的任何位置的 Widget 都可以直接獲取所需的資料模型來避免這些問題。</p>
<p>要將 Provider 添加到您的應用程式，請打開 <code>pubspec.yaml</code>，並在 <code>dependencies</code> 區段中添加它：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="comment"># Add this</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">^4.3.2+2</span></span><br></pre></td></tr></table></figure>

<p>在將該行添加到您的 <code>pubspec.yaml</code> 檔案後，運行以下命令將 Provider 下載到您的機器上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter pub get</span><br></pre></td></tr></table></figure>

<p>在 <code>main.dart</code> 旁邊，建立一個名為 <code>dependencies.dart</code> 的新檔案，並將以下程式碼複製到其中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/counter_manager.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:provider/provider.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependenciesProvider</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  DependenciesProvider(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.child&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        Provider&lt;ICounterManager&gt;(create: (context) =&gt; CounterManager()),</span><br><span class="line">      ],</span><br><span class="line">      child: child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>關於 <code>DependenciesProvider</code> 的一些注意事項：</p>
<ol>
<li>它使用 <code>MultiProvider</code>，儘管它的列表中只有一個條目。從技術上講，這可以摺疊為一個單獨的 <code>Provider</code> Widget，但是實際的應用程式可能會包含許多這樣的服務，因此最好從一開始就使用 <code>MultiProvider</code>。</li>
<li>它需要一個子 Widget，它遵循 Flutter 中 Widget 組合的慣例，允許我們將此輔助程式碼插入 Widget 樹的頂部，從而使 <code>ICounterManager</code> 實例可用於整個應用程式。</li>
</ol>
<p>接下來，讓新的 <code>DependenciesProvider</code> 可用於整個應用程式。一種簡單的方法是使用它來包裝整個 <code>MaterialApp</code> Widget。打開 <code>main.dart</code>，並將 <code>main</code> 方法更新為如下所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    DependenciesProvider(child: MyApp()),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您還需要在 <code>main.dart</code> 中匯入 <code>dependencies.dart</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/dependencies.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="使用-Consumer-Widget"><a href="#使用-Consumer-Widget" class="headerlink" title="使用 Consumer Widget"></a>使用 Consumer Widget</h3><p>您已經看到了 <code>MultiProvider</code> Widget 的作用（實際上它只是一種宣告一系列單獨的 <code>Provider</code> Widget 的更便捷方式）。下一步是透過使用 <a href="https://pub.dev/documentation/provider/latest/provider/Consumer-class.html">Consumer</a> Widget 來存取 <code>ICounterManager</code> 物件。</p>
<h3 id="依賴注入"><a href="#依賴注入" class="headerlink" title="依賴注入"></a>依賴注入</h3><p>如果您使用過 Cloud Firestore 撰寫過 Flutter 應用程式，那麼您可能會發現 Firestore 會讓單元測試更難撰寫。畢竟，當 Firestore 整合直接連接到您的 Widget 樹中時，您如何避免在資料庫中生成真實的記錄？</p>
<p>如果您有過這種體驗，那麼您就會發現將依賴項直接烘焙到 UI 程式碼中的局限性，在 Flutter 的情況下，UI 程式碼是 Widget。這就是依賴注入的強大之處：如果您的 Widget 接受輔助類別，這些輔助類別促進它們與依賴項（如 Firebase、設備的檔案系統，甚至網路請求）的互動，那麼您可以在測試期間提供模擬或偽造物件，而不是真實的類別。這讓您可以測試 Widget 是否按預期工作，而無需等待緩慢的網路請求、填滿檔案系統或產生 Firebase 計費費用。</p>
<p>要實現這一點，您需要重構應用程式，以便有一個清晰的點，讓測試可以注入模擬真實 Cloud Firestore 行為的偽造物件。幸運的是，<code>Consumer</code> Widget 非常適合此工作。</p>
<p>打開 <code>main.dart</code>，並將您的 <code>MyApp</code> Widget 替換為以下程式碼：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在頂部添加此匯入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/firebase_waiter.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 `MyApp` 替換為此</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">        visualDensity: VisualDensity.adaptivePlatformDensity,</span><br><span class="line">      ),</span><br><span class="line">      home: FirebaseWaiter(</span><br><span class="line">        builder: (context) =&gt; Consumer&lt;ICounterManager&gt;(</span><br><span class="line">          builder: (context, manager, _child) =&gt; MyHomePage(</span><br><span class="line">            manager: manager,</span><br><span class="line">            title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 這是放置您的啟動頁面的好地方！</span></span><br><span class="line">        waitingChild: Scaffold(</span><br><span class="line">          body: <span class="keyword">const</span> Center(child: CircularProgressIndicator()),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，在 <code>main.dart</code> 的頂部匯入 <code>Provider</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:provider/provider.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>將 <code>MyHomePage</code> 包裹在 <code>Consumer</code> Widget 中，允許您到達 Widget 樹中任意高的地方，以存取所需的資源，並將它們注入到需要它們的 Widget 中。在本教學中，這可能感覺沒有必要的工作，因為您只向上到達 <code>MyApp()</code> 一層，但是這在實際的生產應用程式中可能會透過數十個 Widget 延伸。</p>
<p>接下來，在同一個檔案中，對 <code>MyHomePage</code> 進行以下編輯：</p>
<blockquote>注意：如果在儲存此更改後您看到紅色螢幕，請不要擔心。需要更多編輯才能完成重構！</blockquote>

<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ICounterManager manager;</span><br><span class="line">  MyHomePage(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.manager, Key key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這個簡單的建構函式更改允許程式碼接受在先前程式碼片段中傳入的變數。</p>
<p>最後，透過對 <code>_MyHomePageState</code> 進行以下編輯來完成重構：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyHomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyHomePage</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不再期望接收 `ICounterManager` 物件</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(<span class="string">&#x27;You have pushed the button this many times:&#x27;</span>),</span><br><span class="line">            Text(</span><br><span class="line">              <span class="comment">// 參考 `widget.manager` 而不是</span></span><br><span class="line">              <span class="comment">// `manager` 直接</span></span><br><span class="line">              <span class="string">&#x27;<span class="subst">$&#123;widget.manager.state.count&#125;</span>&#x27;</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.headline4,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        <span class="comment">// 參考 `widget.manager` 而不是 `manager` 直接</span></span><br><span class="line">        onPressed: () =&gt; setState(() =&gt; widget.manager.increment()),</span><br><span class="line">        tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>注意：您可能需要執行熱重新啟動來修復您的應用程式。</blockquote>

<p>如您所知，所有 State 物件都包含對它們在 Widget 屬性中包含的 StatefulWidget 包裹器的參考。因此，<code>_MyHomePageState</code> 物件可以透過將其程式碼從 <code>manager</code> 更改為 <code>widget.manager</code> 來存取這個新的 <code>manager</code> 屬性。</p>
<p>就這樣！您已經將依賴項注入到需要它們的 Widget 中，而不是硬編碼生產實作。</p>
<h3 id="測試應用程式"><a href="#測試應用程式" class="headerlink" title="測試應用程式"></a>測試應用程式</h3><p>如果您現在運行 <code>flutter test</code>，您將會看到測試套件不再通過。當您檢查 <code>widget_test.dart</code> 時，原因可能很清楚：測試函式實例化了 <code>MyApp()</code>，但沒有像您在真實程式碼中所做的那樣用 <code>DependenciesProvider</code> 包裹它，因此 <code>MyApp</code> 中添加的 <code>Consumer</code> Widget 無法在其祖先 Widget 中找到滿足的 <code>Provider</code>。</p>
<p>這就是依賴注入開始發揮作用的地方。您不必在測試中模仿生產程式碼（透過將 <code>MyApp</code> 包裹在 <code>DependenciesProvider</code> 中），而是更改測試以初始化 <code>MyHomePage</code>。將 <code>widget_test.dart</code> 更新為如下所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/counter_manager.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_test/flutter_test.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/main.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  testWidgets(<span class="string">&#x27;Counter increments smoke test&#x27;</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="comment">// Build our app and trigger a frame.</span></span><br><span class="line">    <span class="keyword">await</span> tester.pumpWidget(</span><br><span class="line">      MaterialApp(</span><br><span class="line">        home: MyHomePage(</span><br><span class="line">          manager: CounterManager(),</span><br><span class="line">          title: <span class="string">&#x27;Test Widget&#x27;</span>,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that our counter starts at 0.</span></span><br><span class="line">    expect(find.text(<span class="string">&#x27;0&#x27;</span>), findsOneWidget);</span><br><span class="line">    expect(find.text(<span class="string">&#x27;1&#x27;</span>), findsNothing);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tap the &#x27;+&#x27; icon and trigger a frame.</span></span><br><span class="line">    <span class="keyword">await</span> tester.tap(find.byIcon(Icons.add));</span><br><span class="line">    <span class="keyword">await</span> tester.pump();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that our counter has incremented.</span></span><br><span class="line">    expect(find.text(<span class="string">&#x27;0&#x27;</span>), findsNothing);</span><br><span class="line">    expect(find.text(<span class="string">&#x27;1&#x27;</span>), findsOneWidget);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>透過直接使用 <code>MyHomePage</code> 實例（以及一個包裝的 <code>MaterialApp</code> 來提供有效的 <code>BuildContext</code> 物件），您已經為自己建立了與 Cloud Firestore 的單元測試整合！</p>
<blockquote>注意：如果您在此部分遇到問題，請將您的更改與教學儲存庫中的 [這個提交](https://github.com/craiglabenz/flutter-firestore-counter/commit/bb68c1d3bb3746eca5f2dea16bd799c98ff232f1) 進行比較。</blockquote>

<h3 id="實作-Cloud-Firestore"><a href="#實作-Cloud-Firestore" class="headerlink" title="實作 Cloud Firestore"></a>實作 Cloud Firestore</h3><p>到目前為止，您已經移動了很多程式碼，並引入了幾個輔助類別，但是您還沒有更改應用程式的任何工作方式。好消息是，一切都已就位，可以開始撰寫一些了解 Cloud Firestore 的程式碼。首先，打開 <code>pubspec.yaml</code>，並添加以下兩行：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="comment"># Add this</span></span><br><span class="line">  <span class="attr">cloud_firestore:</span> <span class="string">^0.14.1</span></span><br><span class="line">  <span class="comment"># Add this</span></span><br><span class="line">  <span class="attr">firebase_core:</span> <span class="string">^0.5.0</span></span><br><span class="line">  <span class="attr">flutter:</span></span><br><span class="line">    <span class="attr">sdk:</span> <span class="string">flutter</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">^4.3.2+2</span></span><br></pre></td></tr></table></figure>

<p>與往常一樣，當您對 <code>pubspec.yaml</code> 進行更改時（除非您的 IDE 替您完成此操作），請運行以下命令來下載和連結新的函式庫：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter pub get</span><br></pre></td></tr></table></figure>

<blockquote>注意：如果您尚未建立資料庫：請訪問 Firebase 主控台的專案，點擊 **Cloud Firestore** 標籤，然後點擊 **建立資料庫** 按鈕。</blockquote>

<h3 id="等待-Firebase"><a href="#等待-Firebase" class="headerlink" title="等待 Firebase"></a>等待 Firebase</h3><p>成功使用 Cloud Firestore 的第一步是初始化 Firebase，最關鍵的是 <em>在任務成功之前不要嘗試使用任何 Firebase 資源</em>。幸運的是，您可以使用一個 StatefulWidget 來包含該邏輯，而不是將該任務散佈在整個程式碼中。</p>
<p>在 <code>firebasecounter/lib/firebase_waiter.dart</code> 中建立一個新檔案，並添加以下程式碼：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebase_core/firebase_core.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirebaseWaiter</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget <span class="built_in">Function</span>(BuildContext) builder;</span><br><span class="line">  <span class="keyword">final</span> Widget waitingChild;</span><br><span class="line">  <span class="keyword">const</span> FirebaseWaiter(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">    <span class="keyword">this</span>.waitingChild,</span><br><span class="line">    Key key,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _FirebaseWaiterState createState() =&gt; _FirebaseWaiterState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_FirebaseWaiterState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">FirebaseWaiter</span>&gt; </span>&#123;</span><br><span class="line">  Future&lt;FirebaseApp&gt; firebaseReady;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    firebaseReady = Firebase.initializeApp();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) =&gt; FutureBuilder&lt;FirebaseApp&gt;(</span><br><span class="line">        future: firebaseReady,</span><br><span class="line">        builder: (context, snapshot) =&gt; <span class="comment">//&lt;</span></span><br><span class="line">            snapshot.connectionState == ConnectionState.done</span><br><span class="line">                ? widget.builder(context)</span><br><span class="line">                : widget.waitingChild,</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此類別使用 Flutter 中的模式，利用特定 Widget 來完全處理應用程式中的特定依賴項或問題。要使用此 <code>FirebaseWaiter</code> Widget，請返回 <code>main.dart</code>，並對 <code>MyApp</code> 應用以下更改：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在頂部添加此匯入</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/firebase_waiter.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 將 `MyApp` 替換為此</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">        visualDensity: VisualDensity.adaptivePlatformDensity,</span><br><span class="line">      ),</span><br><span class="line">      home: FirebaseWaiter(</span><br><span class="line">        builder: (context) =&gt; Consumer&lt;ICounterManager&gt;(</span><br><span class="line">          builder: (context, manager, _child) =&gt; MyHomePage(</span><br><span class="line">            manager: manager,</span><br><span class="line">            title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 這是放置您的啟動頁面的好地方！</span></span><br><span class="line">        waitingChild: Scaffold(</span><br><span class="line">          body: <span class="keyword">const</span> Center(child: CircularProgressIndicator()),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在，應用程式可以等待 Firebase 初始化，但可以在測試期間透過簡單地不使用 <code>FirebaseWaiter</code> 來跳過此過程。</p>
<blockquote>注意：上述更改可能會導致 Flutter 抱怨缺少 Firebase Plugin。如果出現這種情況，請完全關閉應用程式並重新開始除錯，這將允許 Flutter 安裝所有特定於平台的依賴項。</blockquote>

<h3 id="從-Cloud-Firestore-獲取資料"><a href="#從-Cloud-Firestore-獲取資料" class="headerlink" title="從 Cloud Firestore 獲取資料"></a>從 Cloud Firestore 獲取資料</h3><p>首先，透過將以下行添加到 <code>counter_manager.dart</code> 的頂部來匯入 Cloud Firestore：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:cloud_firestore/cloud_firestore.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>接下來，也在 <code>counter_manager.dart</code> 中，添加以下類別：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirestoreCounterManager</span> <span class="keyword">implements</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">  AppState state;</span><br><span class="line">  <span class="keyword">final</span> FirebaseFirestore _firestore;</span><br><span class="line"></span><br><span class="line">FirestoreCounterManager()</span><br><span class="line">      : _firestore = FirebaseFirestore.instance,</span><br><span class="line">        state = <span class="keyword">const</span> AppState() &#123;</span><br><span class="line">    _watchCollection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _watchCollection() &#123;</span><br><span class="line">    <span class="comment">// Part 1</span></span><br><span class="line">    _firestore</span><br><span class="line">        .collection(<span class="string">&#x27;clicks&#x27;</span>)</span><br><span class="line">        .snapshots()</span><br><span class="line">        <span class="comment">// Part 2</span></span><br><span class="line">        .listen((QuerySnapshot snapshot) &#123;</span><br><span class="line">      <span class="comment">// Part 3</span></span><br><span class="line">      <span class="keyword">if</span> (snapshot.docs.isEmpty) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// Part 4</span></span><br><span class="line">      <span class="keyword">final</span> _clicks = snapshot.docs</span><br><span class="line">          .map&lt;<span class="built_in">DateTime</span>&gt;((doc) &#123;</span><br><span class="line">            <span class="keyword">final</span> timestamp = doc.data()[<span class="string">&#x27;timestamp&#x27;</span>];</span><br><span class="line">            <span class="keyword">return</span> (timestamp != <span class="keyword">null</span>)</span><br><span class="line">                ? (timestamp <span class="keyword">as</span> Timestamp).toDate()</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="comment">// Part 5</span></span><br><span class="line">          .where((val) =&gt; val != <span class="keyword">null</span>)</span><br><span class="line">          <span class="comment">// Part 6</span></span><br><span class="line">          .toList();</span><br><span class="line">      <span class="comment">// Part 7</span></span><br><span class="line">      state = AppState(_clicks);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    _firestore.collection(<span class="string">&#x27;clicks&#x27;</span>).add(&#123;</span><br><span class="line">      <span class="string">&#x27;timestamp&#x27;</span>: FieldValue.serverTimestamp(),</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>注意：此類別幾乎是正確的，但它會建立一個稍後會探討的錯誤。如果您現在將此程式碼添加到您的應用程式中並運行它，您將會看到行為與您想要的不同。請繼續閱讀，以了解詳細的解釋！</blockquote>

<p>這裡有很多事情正在發生，因此讓我們一步一步地進行。</p>
<p>首先，<code>FirestoreCounterManager</code> 實作了 <code>ICounterManager</code> 介面，因此它是生產 Widget 中可用的候選者。（最終，它將由 <code>DependenciesProvider</code> 提供！）<code>FirestoreCounterManager</code> 也維護了 <code>FirebaseFirestore</code> 的實例，它與生產資料庫的實時連接。<code>FirestoreCounterManager</code> 在初始化期間也調用 <code>_watchCollection()</code> 來建立與您關心的特定資料的連接，這就是事情變得有趣的地方。</p>
<p><code>_watchCollection()</code> 方法做了很多事情，值得單獨研究。</p>
<p>在第一部分中，<code>_watchCollection()</code> 調用 <code>_firestore.collection(&#39;clicks&#39;).snapshots()</code>. 這會返回一個流，每當集合中的資料發生更改時，就會更新。</p>
<p>在第二部分中，<code>_watchCollection()</code> 立即使用 <code>.listen()</code> 為該流註冊一個監聽器。傳遞給 <code>listen()</code> 的回調在資料發生任何更改時接收一個新的 <code>QuerySnapshot</code> 物件。此更新物件稱為快照，因為它反映了資料庫在某一時刻的正確狀態，但是，在任何時候都可能會被新的快照替換。</p>
<p>在第三部分中，回調會在集合為空時短路。</p>
<p>在第四部分中，回調會遍歷快照的文件，並返回一個包含混合的 null 和 DateTime 值的列表。</p>
<p>在第五部分中，回調會捨棄任何 null 值。這些是因將要修復的錯誤而產生的，但是這種防禦性程式設計在處理來自 Cloud Firestore 的資料時總是一個好主意。</p>
<p>在第六部分中，回調會解決 <code>map()</code> 返回的是迭代器而不是列表的事實。對迭代器調用 <code>.toList()</code> 會強制它處理整個集合，這正是您想要的。</p>
<p>最後，在第七部分中，回調會更新狀態物件。</p>
<p>要使用這個新的類別，請打開 <code>dependencies.dart</code>，並將其內容替換為以下內容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebasecounter/counter_manager.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:provider/provider.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependenciesProvider</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  DependenciesProvider(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.child&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        <span class="comment">// `Provider` 已被 `ChangeNotifierProvider` 替換</span></span><br><span class="line">        ChangeNotifierProvider&lt;ICounterManager&gt;(</span><br><span class="line">          create: (context) =&gt; FirestoreCounterManager(),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">      child: child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="診斷錯誤"><a href="#診斷錯誤" class="headerlink" title="診斷錯誤"></a>診斷錯誤</h3><p>如果您按原樣運行此程式碼，您 <em>幾乎</em> 會看到所需的行為。一切都看起來正確，除了螢幕始終落後於實際點擊次數一次。這是怎麼回事？</p>
<p>問題出現在初始計數器實作和當前基於流的實作之間的不相容性。浮動動作按鈕的 <code>onPressed</code> 處理器看起來像這樣：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">  onPressed: () =&gt; setState(() =&gt; widget.manager.increment()),</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>該處理器調用 <code>increment()</code> 並立即調用 <code>setState()</code>，這會告訴 Flutter 重新渲染。</p>
<p>當同步更新儲存在設備記憶體中的狀態時，這非常有效。但是，新的基於流的實作會啟動一系列異步步驟。這意味著，按原樣，程式碼會立即調用 <code>setState()</code>，然後僅在一個未知的未來時間點，管理員物件才會更新其狀態屬性。簡而言之，<code>onPressed</code> 處理器中的 <code>setState()</code> 調用過早了！更糟糕的是，因為所有這些活動都發生在回調內，深深地位於 <code>FirestoreCounterManager</code> 中，沒有任何 Widget 知道它，因此沒有任何 <code>Future</code> 可以讓 Widget 等待來解決問題。</p>
<p>這就像管理員物件需要能夠告訴 Widget 何時重新繪製一樣。 🤔</p>
<p>輸入： <a href="https://flutter.dev/docs/development/data-and-backend/state-mgmt/simple#changenotifier">ChangeNotifier</a></p>
<blockquote>注意：如果您在此部分遇到問題，請將您的更改與公開儲存庫中的 [這個提交](https://github.com/craiglabenz/flutter-firestore-counter/commit/3bf17b9bfac6c907b8650e1c668fa19b1160a51d) 進行比較。這些更改包括添加 Firebase 後產生的 Xcode 和 build.gradle 的更改，但是您可能可以專注於 Dart 檔案中的更改。
</blockquote>

<h3 id="使用-ChangeNotifier-重新渲染-Widget-樹"><a href="#使用-ChangeNotifier-重新渲染-Widget-樹" class="headerlink" title="使用 ChangeNotifier 重新渲染 Widget 樹"></a>使用 ChangeNotifier 重新渲染 Widget 樹</h3><p><code>ChangeNotifier</code> 是一個類別，它完全像它的名字所暗示的那樣做：當發生需要重新渲染的更改時，它會通知 Widget。</p>
<p>此過程的第一步是更新 <code>ICounterManager</code> 介面以擴展 <code>ChangeNotifier</code>。要執行此操作，請打開 <code>firebasecounter/lib/counter_manager.dart</code>，並對 <code>ICounterManager</code> 宣告進行以下更改：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 將 `extends ChangeNotifier` 添加到您的宣告中</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ICounterManager</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 類別中的所有內容都相同。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您尚未匯入 <code>flutter/material.dart</code>，請打開 <code>firebasecounter/lib/counter_manager.dart</code>，並將其添加到底部：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>您現在已準備好更新 <code>CounterManager</code> 和 <code>FirestoreCounterManager</code> 的定義。對於 <code>CounterManager</code>，請將其程式碼替換為以下實作：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterManager</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> <span class="keyword">implements</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">  AppState state = AppState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">使用最近一次點擊的時間戳複製狀態物件，</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">並告訴流更新。</span></span></span><br><span class="line">  <span class="keyword">void</span> increment() &#123;</span><br><span class="line">    state = state.copyWith(<span class="built_in">DateTime</span>.now());</span><br><span class="line">    <span class="comment">// 添加這行是 `ChangeNotifier` 告訴 Widget</span></span><br><span class="line">    <span class="comment">// 重新渲染自身的方式。</span></span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>對於 <code>FirestoreCounterManager</code>，應用以下更改：</p>
<ol>
<li>修改它的簽章以匹配以下內容：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirestoreCounterManager</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">ICounterManager</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>將相同的 <code>notifyListeners();</code> 行添加到 <code>_watchCollection()</code> 的末尾，如下所示：</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _watchCollection() &#123;</span><br><span class="line">  _firestore</span><br><span class="line">      .collection(<span class="string">&#x27;clicks&#x27;</span>)</span><br><span class="line">      .snapshots()</span><br><span class="line">      .listen((QuerySnapshot snapshot) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 為了清晰起見，省略了 `_clicks` 的生成，但不要</span></span><br><span class="line">    <span class="comment">// 更改該程式碼。</span></span><br><span class="line"></span><br><span class="line">    state = AppState(_clicks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一必要的更改是添加這行！</span></span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您現在已經建立了讓 <code>ICounterManager</code> 類別告訴 Widget 何時重新渲染的必要更改的一半。管理員類別正在告訴 Widget 重新渲染，但是如果您現在運行您的應用程式，您將會看到 Widget 沒有在監聽。</p>
<p>要修復此問題，請打開 <code>dependencies.dart</code>，並將 <code>DependenciesProvider</code> 的實作替換為以下內容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DependenciesProvider</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Widget child;</span><br><span class="line">  DependenciesProvider(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.child&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MultiProvider(</span><br><span class="line">      providers: [</span><br><span class="line">        <span class="comment">// `Provider` 已被 `ChangeNotifierProvider` 替換</span></span><br><span class="line">        ChangeNotifierProvider&lt;ICounterManager&gt;(</span><br><span class="line">          create: (context) =&gt; FirestoreCounterManager(),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">      child: child,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作為最後的更改，請從 <code>_MyHomePageState</code> 中移除 <code>setState()</code>，以跳過不必要的重新渲染。將其 <code>FloatingActionButton</code> 更新為如下所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">floatingActionButton: FloatingActionButton(</span><br><span class="line">  <span class="comment">// 移除 `setState()`！</span></span><br><span class="line">  onPressed: widget.manager.increment,</span><br><span class="line">  tooltip: <span class="string">&#x27;Increment&#x27;</span>,</span><br><span class="line">  child: Icon(Icons.add),</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>就這樣！<code>ChangeNotifierProvider</code> 確保 Widget 是「監聽器」，因此當 <code>ICounterManager</code> 類別調用 <code>notifyListeners()</code> 時，Widget 會收到重新渲染的訊息。</p>
<p>在這個階段，您應該能夠熱重新啟動您的應用程式，並看到所有內容都正常工作！</p>
<p>注意：如果您在此部分遇到問題，請將您的更改與公開儲存庫中的 <a href="https://github.com/craiglabenz/flutter-firestore-counter/commit/dfb584f62d094d8fdb6067ea11ff3551b9186aed">這個提交</a> 進行比較。</p>
<h3 id="修復測試"><a href="#修復測試" class="headerlink" title="修復測試"></a>修復測試</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/9f00e92f.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/9f00e92f.html" class="post-title-link" itemprop="url">【文章翻譯】Performance testing on the web</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-02 15:01:02" itemprop="dateCreated datePublished" datetime="2020-10-02T15:01:02+08:00">2020-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="網頁上的效能測試"><a href="#網頁上的效能測試" class="headerlink" title="網頁上的效能測試"></a>網頁上的效能測試</h2><p><em>本文於 2020 年 11 月 25 日更新，以使用 `web_benchmarks` 套件。</em></p>

<h3 id="概觀"><a href="#概觀" class="headerlink" title="概觀"></a>概觀</h3><p>在開發過程中，我們經常希望在瀏覽器中測試應用程式的效能。效能測試很有用，因為它可以揭露可能導致應用程式變慢的潛在錯誤。</p>
<p>本文介紹了一種在 Chrome 中測試應用程式效能的方法。此方法類似於我們測試 <a href="https://gallery.flutter.dev/#/">新的 Flutter Gallery</a> 效能的方式。</p>
<h3 id="範例應用程式"><a href="#範例應用程式" class="headerlink" title="範例應用程式"></a>範例應用程式</h3><p>我們使用一個簡單的應用程式，其中包含一個 appbar、一個浮動動作按鈕和一個無限項目列表。列表還顯示按鈕被按下次數。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*adwmyiS509VwCCYl" />
</figure>

<p>應用程式有一個包含一些資訊的第二頁。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*-d-mmdUUEW08ytWJ" />
</figure>

<p>您可以在這裡複製應用程式：</p>
<ul>
<li><a href="https://github.com/material-components/material-components-flutter-experimental/tree/develop/web_benchmarks_example">https://github.com/material-components/material-components-flutter-experimental/tree/develop/web_benchmarks_example</a></li>
</ul>
<h3 id="測試什麼？"><a href="#測試什麼？" class="headerlink" title="測試什麼？"></a>測試什麼？</h3><p>我們希望在以下使用情境下測試應用程式在 Chrome 中的效能：</p>
<ol>
<li>使用者在無限列表中捲軸。</li>
<li>使用者在兩個頁面之間切換。</li>
<li>使用者點擊浮動動作按鈕。</li>
</ol>
<h3 id="設定框架"><a href="#設定框架" class="headerlink" title="設定框架"></a>設定框架</h3><p>在 <code>pubspec.yaml</code> 中加入以下內容：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ef0ca17199a2807e917e92cb92ffc891/href">https://medium.com/media/ef0ca17199a2807e917e92cb92ffc891/href</a></iframe>

<p>此相依性會導入 <a href="https://pub.dev/packages/web_benchmarks">web_benchmarks</a>，一個實現 Chrome 中效能測試的最小套件。</p>
<p>此套件改編自 <a href="https://github.com/flutter/flutter/tree/master/dev/benchmarks/macrobenchmarks">macrobenchmarks</a> 和 <a href="https://github.com/flutter/flutter/tree/master/dev/devicelab">devicelab</a>，這兩個套件由 Flutter 用於在 Flutter Gallery 上進行網頁效能測試。目前，這兩個套件專門用於 <code>flutter/flutter</code> 中的網頁效能測試，因此導入更通用的套件 <a href="https://pub.dev/packages/web_benchmarks">web_benchmarks</a> 更容易。</p>
<p>執行 <code>flutter pub get</code> 以導入此套件。</p>
<h3 id="撰寫第一個測試"><a href="#撰寫第一個測試" class="headerlink" title="撰寫第一個測試"></a>撰寫第一個測試</h3><p>在 <code>lib</code> 目錄下加入 <code>benchmarks</code> 目錄，並在其中加入一個名為 <code>runner.dart</code> 的新 dart 檔案：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/712/0*tsvQSKBjpWJWkiKM" />
</figure>

<p>檔案的內容如下：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3a002aacd849a5e328e379e37450537c/href">https://medium.com/media/3a002aacd849a5e328e379e37450537c/href</a></iframe>

<h4 id="此測試在做什麼？"><a href="#此測試在做什麼？" class="headerlink" title="此測試在做什麼？"></a>此測試在做什麼？</h4><ul>
<li>當此應用程式執行時，會建立一個 <code>ScrollRecorder</code> 物件，它會透過自動執行手勢來驅動應用程式。在本例中，在應用程式啟動後不久，它會開始向下捲軸無限列表。</li>
<li><code>ScrollRecorder</code> 類別擴展了 <code>AppRecorder</code> 類別，<code>AppRecorder</code> 類別擴展了 <code>WidgetRecorder</code> 類別，<code>WidgetRecorder</code> 類別還會在驅動應用程式時記錄效能資料。</li>
<li><code>runBenchmarks</code> 是在 <code>package:web_benchmarks/client.dart</code> 中定義的函式，它允許使用者選擇要執行的基準測試，並在瀏覽器中顯示結果。</li>
<li><code>automate</code> 方法使用 <code>flutter_test</code> 套件，該套件提供了在應用程式中執行手勢或尋找特定 Widget 的方法。</li>
</ul>
<h3 id="執行第一個測試"><a href="#執行第一個測試" class="headerlink" title="執行第一個測試"></a>執行第一個測試</h3><p>在專案的根目錄中，執行 <code>flutter run -d chrome -t lib/benchmarks/runner.dart</code>。這會指示 Flutter 使用 <code>runner.dart</code> 作為入口點，而不是 <code>main.dart</code>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*imb9-c_LS4XF0xDX" />
</figure>

<p>到目前為止，我們只有一個基準測試，因此點擊「捲軸」以啟動它。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*3aZa4m2GbsqHECNw" />
</figure>

<p>測試開始，列表會自動向下捲軸。</p>
<p>測試在幾秒鐘內結束，顯示以下螢幕：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LitJY47Vl0J17C5V" />
</figure>

<p>此圖表顯示應用程式繪製每個（記錄的）畫面所需的時間。橫軸表示時間流逝；縱軸表示每個畫面所需的時間。</p>
<p>圖表的前 2&#x2F;3 部分具有灰色背景；這些畫面被認為是「預熱畫面」，並且從統計資料中省略。預熱畫面通常會讓 JIT 編譯器有時間編譯程式碼並建立各種快取，以便測量畫面能產生反映應用程式「最終」效能的數字，而不是它最初幾秒鐘的效能。預熱階段不應始終被忽略 - 它可以提供應用程式最初幾秒鐘效能的寶貴資訊，這仍然會影響對應用程式品質的感知。</p>
<p>紅色畫面是「異常值」 - 它們是繪製時間比其他畫面顯著長得多的畫面。有些異常值幾乎不可察覺。例如，動畫開始或結束時的卡頓，直到一定程度才會被看見。但是，動畫 <em>中間</em> 的卡頓畫面非常明顯。</p>
<p>異常值很好地表明了應用程式卡頓的程度。透過改進您的應用程式，您可以降低異常值的數值或減少異常值的數量，這表示您的應用程式已變得更流暢。</p>
<h3 id="從-Chrome-的-DevTools-收集資料"><a href="#從-Chrome-的-DevTools-收集資料" class="headerlink" title="從 Chrome 的 DevTools 收集資料"></a>從 Chrome 的 DevTools 收集資料</h3><p>此基準測試完全在 Chrome 中執行。將以下檔案新增為 <code>test/run_benchmarks.dart</code>：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5ce2ae71e67c98c50eef78779e9f1d35/href">https://medium.com/media/5ce2ae71e67c98c50eef78779e9f1d35/href</a></iframe>

<p>然後，執行 <code>dart test/run_benchmarks.dart</code>。</p>
<p>大約一分鐘後，您應該看到以下結果：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2e95cfd7eb847b13e4d86219ca683123/href">https://medium.com/media/2e95cfd7eb847b13e4d86219ca683123/href</a></iframe>

<p>準確的基準測試數值可能會因機器而異。</p>
<h4 id="此測試在做什麼？-1"><a href="#此測試在做什麼？-1" class="headerlink" title="此測試在做什麼？"></a>此測試在做什麼？</h4><ul>
<li>執行 <code>test/run_benchmarks.dart</code> 會為網頁構建應用程式。然後，它會啟動一個 Chrome 實例並在其中執行應用程式。</li>
<li><code>test/run_benchmarks.dart</code> 會連接到 Chrome 的 DevTools 連接埠，並監聽和收集相關的效能資料。</li>
</ul>
<h4 id="結果的含義是什麼？"><a href="#結果的含義是什麼？" class="headerlink" title="結果的含義是什麼？"></a>結果的含義是什麼？</h4><ul>
<li>渲染畫面時，會走訪 <a href="https://api.flutter.dev/flutter/rendering/Layer-class.html">層級樹</a> 兩次。</li>
<li>「預先處理」是第一次走訪。它不會渲染任何內容，但會計算稍後用於渲染的值。例如：轉換矩陣、轉換的逆矩陣和剪裁。</li>
<li>「應用程式畫面」是實際渲染 UI 的第二次走訪。</li>
<li>「繪製畫面」是框架渲染畫面所需的時間。它包含「預先處理」和「應用程式畫面」，但它還包含花費在構建和佈局 Widget 上的時間。</li>
<li>「總 UI 畫面」包含「繪製畫面」中的所有內容，但它還包含瀏覽器執行的某些隱藏工作，例如層級樹更新、樣式重新計算和瀏覽器端佈局（不要與 Flutter 自己進行的佈局混淆）。</li>
<li>收集資料集（持續時間列表）時，演算法會移除異常值。</li>
<li>首先，計算資料的平均值和標準差，並且任何比（平均值 + 1 個標準差）高的資料點都被視為異常值。</li>
<li>非異常值（乾淨資料）的平均值和標準差用於計算資料集的平均值和雜訊，然後報告這些值。</li>
<li>所有異常值的平均值以及「異常值平均值」和「非異常值平均值」的比率也會被報告。</li>
<li>對於每個資料集，「異常值比率」和「雜訊」都是應用程式效能中存在多少雜訊的良好指標。如果結果過於雜亂，則可能表示效能不一致（例如，GC 暫停時的卡頓畫面）。透過降低雜訊，您可以使應用程式執行更順暢。</li>
</ul>
<h3 id="加入更多測試"><a href="#加入更多測試" class="headerlink" title="加入更多測試"></a>加入更多測試</h3><p>編輯 <code>lib/benchmarks/runner.dart</code> 以加入兩個更多測試。</p>
<p>首先，修改 <code>main</code> 函式：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/86e9a82223d28c5bb1beaf236dfb297a/href">https://medium.com/media/86e9a82223d28c5bb1beaf236dfb297a/href</a></iframe>

<p>最後，加入兩個更多擴展 <code>AppRecorder</code> 的類別：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/4b6ad9219c3e3c13aba5cd2796cd6052/href">https://medium.com/media/4b6ad9219c3e3c13aba5cd2796cd6052/href</a></iframe>

<h4 id="這些測試在做什麼？"><a href="#這些測試在做什麼？" class="headerlink" title="這些測試在做什麼？"></a>這些測試在做什麼？</h4><ul>
<li>我們加入了兩個剩餘的基準測試：一個用於在頁面之間切換，另一個用於點擊浮動動作按鈕。</li>
<li><code>animationStops</code> 反覆檢查動畫是否正在進行，並在所有動畫停止時停止。這會確保，例如，成功轉換到「關於」頁面。</li>
<li>在「頁面」和「點擊」基準測試中，<code>_completed</code> 布林值追蹤自動手勢是否已完成。</li>
<li>在「頁面」和「點擊」基準測試中，覆寫 <code>shouldContinue</code> 方法會導致 <code>AppRecorder</code> <strong>在</strong> 所有手勢完成 <strong>後</strong> 停止記錄畫面。</li>
</ul>
<h4 id="如何執行這些測試？"><a href="#如何執行這些測試？" class="headerlink" title="如何執行這些測試？"></a>如何執行這些測試？</h4><p>若要在 Chrome 中執行這些測試（並查看動畫），請執行：</p>
<ul>
<li><code>flutter run -d chrome -t lib/benchmarks/runner.dart --profile</code></li>
</ul>
<p>若要執行這些測試並收集 DevTools 資料，請執行：</p>
<ul>
<li><code>dart test/run_benchmarks.dart</code></li>
</ul>
<h3 id="接下來要做什麼？"><a href="#接下來要做什麼？" class="headerlink" title="接下來要做什麼？"></a>接下來要做什麼？</h3><p>在您有方法收集效能資料後，您可以隨意使用它：</p>
<ul>
<li>您可以為 CI 設定一個作業，只要有人提交 PR 就執行這些基準測試，以避免引入效能負擔大的變更。</li>
<li>您也可以設定一個儀表板來追蹤效能基準測試的趨勢。這就是我們對 Flutter Gallery 所做的事情（請參閱 <a href="https://flutter-dashboard.appspot.com/#/build">Flutter Dashboard</a>）。</li>
</ul>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=25323252de69" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/performance-testing-on-the-web-25323252de69">網頁上的效能測試</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/687439a5.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/687439a5.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Flutter 1.22</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-01 14:57:05" itemprop="dateCreated datePublished" datetime="2020-10-01T14:57:05+08:00">2020-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Flutter-1-22"><a href="#宣布-Flutter-1-22" class="headerlink" title="宣布 Flutter 1.22"></a>宣布 Flutter 1.22</h2><p>我們很高兴地宣布 Flutter 的最新版本，它对 iOS 14 和 Android 11 提供了广泛的支持。Flutter 1.22 在以前版本的基础上构建，让开发者能够从单一代码库构建快速、美观的跨平台用户体验。我们的季度稳定版本包含最新的功能、性能改进和错误修复，适合广泛的生产使用。</p>
<p>由于这是新移动操作系统版本的发布季节，因此此版本专注于确保 Android 11 和 iOS 14 与 Flutter 完美配合。对这两个操作系统的更新包括大量幕后工作，以符合最新的 SDK，并确保一切通过我们的全面测试套件。对于 iOS 14，此版本包含对新 Xcode 12、新图标的支持，以及对新 iOS 14 App Clips 功能的预览支持。对于 Android 11，更新支持新的显示切口类型，以及在弹出软键盘时的更流畅动画。</p>
<p>此版本在我们的 1.20 版本发布两个月后发布，因此比大多数版本都要短。即使在这段时间内，我们也关闭了 3,024 个问题，并合并了来自 197 位贡献者的 1,944 个 PR。在这 197 位贡献者中，有 114 位（58％）来自更广泛的社区，他们贡献了 271 个 PR。最大的单一贡献者是 <a href="https://github.com/a14n">a14n</a>，他再次成为我们的顶级贡献者榜单，贡献了 20 个 PR，其中大多数是作为 Flutter 中支持空安全的工作的一部分完成的（更多相关内容即将推出）。</p>
<p>除了对新移动操作系统版本的支持外，我们还有很多新闻要分享，包括对 Android 最受欢迎功能之一的预览：状态恢复、一个新的 Material 按钮“宇宙”、与热重载配合使用的新国际化和本地化支持、一个新的 Navigator、Platform Views 的稳定版本（Google Maps 和 WebView Plugin 的基础）以及可以在代码中添加的开关，以改善具有高频率显示屏的设备上的滚动效果。我们还提供了一个新的工具来剖析应用大小，并确保您构建的 Plugin 仅支持您想要支持的平台。</p>
<h3 id="针对-iOS-14"><a href="#针对-iOS-14" class="headerlink" title="针对 iOS 14"></a>针对 iOS 14</h3><p>每当宣布新版本的移动操作系统时，我们都会对其进行彻底测试，寻找影响 Flutter 及其工具的不兼容性或更改。</p>
<p>在 iOS 14 的情况下，我们对 Flutter 做了一些更改，以确保它按开发者想要的方式工作：</p>
<ul>
<li>Xcode 12 要求 iOS 9.0 或更高版本，因此我们的默认模板将默认值从 8.0 提高到 9.0。</li>
<li>iOS 14 特定的崩溃和字体渲染问题已在 Flutter 1.22 中修复。</li>
<li>截至 Flutter 1.20.4，已修复部署到实体设备的问题。</li>
<li>一项新政策，当应用访问其剪贴板时会显示使用通知，导致 Flutter 应用出现虚假通知，这个问题已在 Flutter 1.20.4 中修复。</li>
<li>限制禁止在 iOS 14 设备上运行调试应用，除非作为调试过程的一部分。</li>
<li>针对本地调试的 Flutter 应用的网络安全新政策会导致 iOS 14 显示一次性确认对话框（仅在开发期间，而不是针对已发布的 Flutter 应用）。</li>
</ul>
<p>底线：如果您要针对 iOS 14 使用 Flutter 应用，我们强烈建议您使用 Flutter 1.22 重新构建它并将其部署到 App Store，以确保您的 iOS 14 用户获得最佳体验。</p>
<p>有关使用 Flutter 针对 iOS 14 的更多详细信息，包括一些 Add-to-App、深层链接和通知注意事项，请参阅 <a href="https://flutter.dev/docs/development/ios-14">flutter.dev 上的 iOS 14 文档</a>。</p>
<p>希望所有这些对工具和 SDK 支持的工作可以让您专注于您关心的编码——利用新的 iOS 14 功能。</p>
<p>其中一项功能是对 iOS 的新 SF Symbols 字体的更新支持，这启发了我们花了一些时间对 <a href="https://pub.dev/packages/cupertino_icons">cupertino_icon 包</a> 进行刷新。一旦您将 cupertino_icons 依赖项更新到新的 1.0 主要版本，现有的 CupertinoIcons 使用情况将自动映射到新样式。如果您将 cupertino_icons 1.0 与 Flutter 1.22 结合使用，您还可以通过 <a href="https://api.flutter.dev/flutter/cupertino/CupertinoIcons-class.html">CupertinoIcons</a> API 访问约 900 个新图标。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/864/0*ZGKu3IhnPNp6fS_e" />
</figure>

<p>您可以在 <a href="https://flutter.github.io/cupertino_icons/">cupertino_icons</a> 预览页面上查看完整的图标列表，以及 <a href="https://flutter.dev/docs/release/breaking-changes/cupertino-icons-1.0.0">flutter.dev 上的迁移详细信息页面</a>。</p>
<p>您可以尝试在 iOS 14 上使用 Flutter 的另一项功能是 <a href="https://developer.apple.com/app-clips/">App Clips</a>，这是一项新的 iOS 14 功能，支持快速、无需安装的应用执行，可以执行 10MB 以下的应用的轻量级版本。在 Flutter 1.22 版本中，我们对使用 Flutter 构建的 App Clip 目标进行了预览。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*8MER4IM-IEt2ye2a" />
<figcaption>由 Flutter 提供支持的 App Clip 体验</figcaption>
</figure>

<p>有关使用 Flutter 构建 App Clips 的更多详细信息，请查看 <a href="https://flutter.dev/docs/development/platform-integration/ios-app-clip">flutter.dev 上的文档</a>。您还可以参考这个 <a href="https://github.com/flutter/samples/tree/master/ios_app_clip">简单的示例项目</a>。</p>
<h3 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a>Android 11</h3><p>此版本的 Flutter 也与本月推出的 Android 11 版本同步。Flutter 框架和引擎已更新，以支持最新版本的 Android 中引入的两个新功能。</p>
<p>首先，Flutter 现在支持公开 Android 切口、切出部分和瀑布显示边缘的安全内边距。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*lPO4ueKwxvV0QP_I" />
</figure>

<p>通过使用 <a href="https://api.flutter.dev/flutter/widgets/MediaQuery-class.html">MediaQuery</a> 和 <a href="https://api.flutter.dev/flutter/widgets/SafeArea-class.html">SafeArea</a> API，您可以确保将活跃的 UI 和交互式元素放置在设备显示屏的无障碍区域。此外，您还应避免在容易发生意外触碰的瀑布边缘区域放置手势检测器。</p>
<p>其次，动画与 Android 11 同步，因为它显示了软件键盘。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*DFRjYzbqIc5kOoDm" />
<figcaption>查看 FAB 的位置动画</figcaption>
</figure>

<p>问题 <a href="https://github.com/flutter/flutter/issues/19279">＃19279</a> 是一个长期存在的问题，即系统键盘显示&#x2F;隐藏动画与 Flutter 的内边距不同步。这个问题已在 Android 11 中修复。</p>
<p>关于 Android 嵌入 API 的一个说明。在去年的 Flutter 1.12 版本中，我们为 Android 推出了新的 Flutter 引擎和 Flutter Plugin API 集。我们创建了这些 v2 API 以更好地支持我们在 Android 上的 Add-to-App 用户。一年后，超过 80％ 的 Android Plugin 使用了新的 Android API。从 1.22 版本开始，我们将弃用旧的 v1 API。</p>
<p>如果您仍在使用 Android v1 API，以下内容与您相关：</p>
<ul>
<li>新创建的 Plugin 将不再针对 v1 API。</li>
<li>Flutter 工具的<code> -no-enable-android-embedding-v2</code> 配置标志已删除，现在是默认行为。</li>
<li>仍在使用 v1 API 的旧应用将在构建过程中显示一个弃用警告，该警告指向 <a href="https://flutter.dev/docs/development/packages-and-plugins/plugin-api-migration">支持新的 Android Plugin API 的文档</a>。</li>
</ul>
<p>同时，如果您仍然具有基于 v1 Android API 的 Flutter 应用，它将继续工作。但是，您可能会开始遇到仅针对 v2 API 且无法被 v1 Android API 使用的新 Plugin。有关更多详细信息，请参阅 <a href="https://flutter.dev/docs/release/breaking-changes/android-v1-embedding-create-deprecation">重大更改文档</a>。</p>
<h3 id="扩展按钮“宇宙”"><a href="#扩展按钮“宇宙”" class="headerlink" title="扩展按钮“宇宙”"></a>扩展按钮“宇宙”</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/910/1*crNLxg7CCtlQkB4mLI_ErA.png" />
<figcaption>一个新的 Material Design 按钮“宇宙”</figcaption>
</figure>

<p>现有的 Flutter 按钮看起来不错，但可能 <a href="http://flutter.dev/go/material-button-system-updates">难以使用</a>，特别是在您需要自定义主题时。此外，Material 规范已扩展到包含具有新样式的新按钮。</p>
<p>为了让 Flutter 与 Material 指南保持同步，我们很高兴地宣布 Flutter 1.22 中推出了全新的按钮“宇宙”。</p>
<p>与其尝试就地演变现有的按钮类及其主题，<a href="https://github.com/flutter/flutter/pull/59702">此 PR</a> 引入了新的替换按钮 Widget 和主题。除了让我们摆脱演化现有类所必需的后向兼容迷宫外，新名称还使 Flutter 与 <a href="https://material.io/components/buttons/">Material Design 规范</a> 同步，该规范使用新名称来表示按钮组件。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*di6uPEKEsRHoFtRryHeWPg.png" />
</figure>

<p>新主题遵循 Flutter 最近为新的 Material Widget 采用的“规范化”模式。如果您想尝试一个演示，<a href="https://dartpad.dev/e560e1c2e4455ad53aac245079ccdcf2">这里有一个很棒的 DartPad 演示</a>。这不是重大更改，因为 FlatButton、OutlineButton、RaisedButton、ButtonBar、ButtonBarTheme 和 ButtonTheme 的语义不会改变。您可以根据自己的喜好混合和匹配旧按钮和新按钮。</p>
<h3 id="新的国际化和本地化支持"><a href="#新的国际化和本地化支持" class="headerlink" title="新的国际化和本地化支持"></a>新的国际化和本地化支持</h3><p>从 Flutter 的诞生之日起，Flutter 就提供了应用程序国际化 (i18n) 和本地化 (l10n) 所需的核心功能。但是，在此版本中，我们将对最佳实践的看法融入到我们的工具中，甚至启用热重载支持，以便在您添加新的 l10n 信息时更新您的应用。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*UBVlGmhw5NUWbg5I" />
</figure>

<p>如果您希望了解有关 Flutter 对 l10n 支持的更多详细信息，包括本地化消息、带有参数的消息、日期、数字和货币，请 <a href="http://flutter.dev/go/i18n-user-guide">阅读 Flutter 国际化用户指南</a>。</p>
<p>此外，如果您对 i18n 和 l10n 感兴趣，那么您可能也对不适合纯 ASCII 字符串的字符（例如 Unicode 和表情符号）感兴趣。最近，Dart 团队发布了 <a href="https://pub.dev/packages/characters">characters 包</a>，它帮助开发者处理 Unicode（扩展）字形群集。此包帮助解决了诸如如何将类似于“A 🇬🇧 text in English”的字符串正确缩短到前 15 个字符的问题。使用 String 类，该缩写将是“A 🇬🇧 text in”，这只有 12 个用户感知字符。另一方面，使用 characters 包会产生正确的缩写“A 🇬🇧 text in Eng”。</p>
<p>通过 <a href="https://github.com/flutter/flutter/pull/59267">此 PR</a>，Flutter 使用 characters 包来正确处理这些复杂的字符。例如，当使用带有 maxLength 限制的 TextField 时，像👨‍👩‍👦这样的字符现在被正确地视为单个字符。此外，通过 <a href="https://github.com/flutter/flutter/pull/59620">此 PR</a>，characters 包在 Flutter 所在的项目中自动可用，无需手动添加它。希望这将使处理来自所有语言环境的所有类型的字符串变得更加容易。有关 characters 包的更多详细信息，请查看这篇文章：<a href="https://medium.com/dartlang/dart-string-manipulation-done-right-5abd0668ba3e">如何正确进行 Dart 字符串操作</a>。</p>
<h3 id="Google-Maps-和-WebView-Plugin-现已做好生产准备"><a href="#Google-Maps-和-WebView-Plugin-现已做好生产准备" class="headerlink" title="Google Maps 和 WebView Plugin 现已做好生产准备"></a>Google Maps 和 WebView Plugin 现已做好生产准备</h3><p>在 Flutter 团队中，我们通常谨慎地将某些东西标记为“生产就绪”，直到我们自己对其进行彻底测试。在 <a href="https://pub.dev/packages/google_maps_flutter">google_maps_flutter</a> 和 <a href="https://pub.dev/packages/webview_flutter">webview_flutter</a> Plugin 的情况下，限制因素一直是底层的 <a href="http://flutter.dev/docs/development/platform-integration/platform-views">Platform Views</a> 实现，它允许来自 Android 和 iOS 的原生 UI 组件托管在 Flutter 应用中。在此版本的 Flutter 中，我们很高兴地宣布，我们已充分增强了框架管道，足以宣布这两个 Plugin 为生产就绪。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/500/0*luz0EiazQQqsAEC4" />
<figcaption>webview_flutter Plugin 托管 flutter.dev</figcaption>
</figure>

<p>在 Flutter 1.22 中，我们添加了一个替代的 Platform Views 实现，它修复了 <a href="https://github.com/flutter/flutter/issues/61133">Android 视图的所有已知键盘和辅助功能问题</a>。此外，它与 Android API 级别 19 及更高版本配合使用（以前需要级别 20）。我们还在 iOS 上进行了线程改进，这些改进使平台视图更有效、更健壮（并且不再需要将 io.flutter.embedded_views_preview 标志添加到您的 iOS Info.plist 中）。</p>
<p>webview_flutter Plugin 支持新的 Android Platform Views 模式，但目前需要 <a href="https://github.com/flutter/plugins/blob/master/packages/webview_flutter/README.md#android">手动启用</a>。一旦它在更广泛的社区中得到更多使用，我们将在未来的版本中默认启用它。</p>
<p>Google Maps 和 WebView Plugin 已经从 Platform Views 中的改进中受益。如果您想使用 Platform Views 在 iOS 或 Android 上托管您自己的原生 UI 组件，您可以在 <a href="https://flutter.dev/docs/development/platform-integration/platform-views">使用 Platform Views 在 Flutter 应用中托管原生 Android 和 iOS 视图</a> 上了解如何操作。</p>
<h3 id="Navigator-2-0"><a href="#Navigator-2-0" class="headerlink" title="Navigator 2.0"></a>Navigator 2.0</h3><p>如果您以前在 Flutter 应用中使用过 <a href="https://flutter.dev/docs/development/ui/navigation">导航</a>，您可能已经注意到核心数据结构（用户正在浏览的页面堆栈）对您隐藏了。相反，要管理它，您会调用 Navigator.pop() 或 Navigator.push()。例如，假设您想在主页上显示一个 Widget 列表，并允许用户点击其中一个 Widget 以进入专门针对该颜色的详细信息页。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*OVbaUaMkAXrpLQCy" />
</figure>

<p>这两个屏幕可以这样实现：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/72f4a4ffdac907c3e8eda2da84dda0f6/href">https://medium.com/media/72f4a4ffdac907c3e8eda2da84dda0f6/href</a></iframe>

<p>使用最简单的 Navigator 1.0 样式可以让您以看起来非常简单的方式在这两个屏幕之间导航：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/05fab7a288dd55acf6ed63f02d36f916/href">https://medium.com/media/05fab7a288dd55acf6ed63f02d36f916/href</a></iframe>

<p>调用 Navigator.push() 是将另一个页面推到第一个页面之上的所需操作，从而创建一个包含两个页面的堆栈。但是，与在 ColorListScreen 的 build 方法中创建的 Container 列表不同，该堆栈对您隐藏了。由于它被隐藏了，因此很难管理其他场景，例如处理由原生嵌入提供的初始路由的深层链接，例如来自网页的 URL 或来自 Android 的 intent。管理相同页面不同排列之间的嵌套路由也极其困难。</p>
<p>Navigator 2.0 通过使页面堆栈可见来解决这些问题以及更多问题。以下是在 ColorListScreen 和 ColorScreen 之间导航的更新示例：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9db4a0d060729ba3e043ce6388465861/href">https://medium.com/media/9db4a0d060729ba3e043ce6388465861/href</a></iframe>

<p>应用明确地创建一个 Navigator，并为它提供一个页面列表，该列表表示完整的堆栈。我们创建了一个空 <code>_selectedColor</code> 来指示尚未选择任何颜色，因此我们不会最初显示 ColorScreen。当用户选择颜色时，我们会像往常一样调用 <code>setState()</code> 以指示 Flutter 您希望再次调用 <code>build()</code> 方法，该方法现在将在顶部创建一个包含 ColorScreen 的堆栈。</p>
<p>例如，您可以在 OnPopPage 回调中更新您的状态，如果用户弹出了，那么他们就“取消选择”了当前颜色，我们不再希望显示该页面。</p>
<p>如果 Navigator 2.0 看起来与 Flutter 的其他部分一样，那就是我们的意图——它是声明性的，与命令式的 Navigator 1.0 不同。我们的想法是统一导航和 Flutter 其他部分之间的模型，同时修复大量问题并添加功能。事实上，这个小例子只是 Navigator 2.0 中一部分内容的表面描述。有关详细信息，我强烈推荐这篇文章：<a href="https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade">Flutter 中的声明式导航和路由</a>。</p>
<p>此外，您现有的 Navigator 1.0 使用方式将继续与今天一样工作，并且不会很快被移除。如果您喜欢该模型，您当然可以继续使用它。但是，如果您尝试使用 Navigator 2.0，我们认为您会喜欢它。</p>
<h3 id="预览：Android-的状态恢复"><a href="#预览：Android-的状态恢复" class="headerlink" title="预览：Android 的状态恢复"></a>预览：Android 的状态恢复</h3><p>此版本中可供您体验的新功能是对 <a href="https://developer.android.com/topic/libraries/architecture/saving-states">Android 上的状态恢复</a> 的支持。这是我们 <a href="https://github.com/flutter/flutter/issues/6827">最受欢迎的功能之一</a>，获得了 217 个点赞！</p>
<p>对于那些不熟悉状态恢复需求的人来说，移动操作系统可能会终止后台应用以回收资源以供前台应用使用。发生这种情况时，操作系统会通知要终止的应用尽快保存任何 UI 状态，以便在用户返回到该应用时恢复它。如果实现正确，这将为用户提供无缝的体验，同时更好地利用设备资源。到目前为止，Flutter 不支持状态恢复，在没有框架支持的情况下正确地做到这一点非常困难。这就是我们很高兴能够为 Android 提供此功能的基础实现的原因。</p>
<p>以下是如何 <a href="https://api.flutter.dev/flutter/widgets/RestorationMixin-mixin.html#widgets.RestorationMixin.1">恢复默认 Flutter Counter 应用的状态的简单示例</a>：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5b53da24e0462f59d442d2af47bb265a/href">https://medium.com/media/5b53da24e0462f59d442d2af47bb265a/href">https://medium.com/media/5b53da24e0462f59d442d2af47bb265a/href</a></iframe>

<p>简而言之，每个 Widget 都获得一个存储桶，该存储桶使用唯一的 ID 与 <a href="https://api.flutter.dev/flutter/widgets/RestorationMixin-mixin.html">RestorationMixin</a> 关联。通过使用 <a href="https://master-api.flutter.dev/flutter/widgets/RestorableProperty-class.html">RestorableProperty</a> 类型（此处使用的是 RestorableInt）来存储 UI 特定的数据，并通过将该数据与状态恢复功能关联，数据将在 Android 终止应用之前自动存储，并在应用恢复时恢复。就这样。存储在 Restoration* 类型中的任何数据，例如 RestorableInt、RestorableString 和 RestorableTextEditingController（我们有很多这样的类型），都将被恢复。如果我们没有涵盖您希望恢复的所有类型，您可以通过扩展 <a href="https://api.flutter.dev/flutter/widgets/RestorableProperty-class.html">RestorableProperty&lt;T&gt;</a> 创建您自己的类型。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/720/0*1298qhTKz_FjPuRN" />
</figure>

<p>为了对状态恢复进行自动化测试，我们已向 <a href="https://api.flutter.dev/flutter/flutter_test/WidgetTester/restartAndRestore.html">WidgetTester 添加了一个新的 restartAndRestore API</a>。为了手动测试，最简单的方法是在 Android 设备上启动启用了状态恢复的 Flutter 应用，在 Android 的开发者设置中启用“不保留活动”，运行 Flutter 应用，将其置于后台，然后返回到它。此时，Android 将终止并恢复您的应用，因此您可以查看一切是否按预期工作。</p>
<p>虽然我们很高兴将此状态恢复的预览版本交给您，但仍有更多工作要做。例如，状态恢复不仅适用于 Android，iOS 应用也可以从中受益。此外，我们正在忙于更新我们自己的 Widget，以在恢复期间保持其状态。我们已经在 Scrollable 类（例如 ListView 和 SingleChildScrollView）（记住用户的滚动位置）和 TextField（恢复用户输入的文本）中提供了支持，并计划将其扩展到其他 Widget。</p>
<p>但是，我们尚未添加的关键恢复支持，也是使它成为预览版本的原因是导航（1.0 或 2.0）。这意味着用户在应用中的位置将不会被恢复。该功能将很快在测试版中推出，并在 Flutter 的下一个稳定版本中推出。</p>
<h3 id="预览：为无与伦比的输入和显示频率提供流畅的滚动效果"><a href="#预览：为无与伦比的输入和显示频率提供流畅的滚动效果" class="headerlink" title="预览：为无与伦比的输入和显示频率提供流畅的滚动效果"></a>预览：为无与伦比的输入和显示频率提供流畅的滚动效果</h3><p>Flutter 团队与我们内部的 Google 合作伙伴合作，在输入频率和显示频率不相同的情况下大大改善了滚动的性能。例如，Pixel 4 的输入频率为 120hz，而显示频率为 90hz。这种不匹配会导致滚动时出现性能损失。使用新的 resamplingEnabled 标志，您可以利用我们在 Flutter 中完成的性能工作来解决此问题：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ac9c676eb1233dd1597b234b73ffc8a3/href">https://medium.com/media/ac9c676eb1233dd1597b234b73ffc8a3/href">https://medium.com/media/ac9c676eb1233dd1597b234b73ffc8a3/href</a></iframe>

<p>根据所涉及的频率差异，通过启用此标志，您可能会看到滚动时的卡顿减少高达 97%。当我们确定这是最佳体验时，我们计划在未来的版本中默认启用此标志。</p>
<h3 id="一个新的统一-Dart-开发者工具"><a href="#一个新的统一-Dart-开发者工具" class="headerlink" title="一个新的统一 Dart 开发者工具"></a>一个新的统一 Dart 开发者工具</h3><p>与往常一样，更新 Flutter 不仅仅意味着引擎和框架，还包括工具。Flutter 1.22 包括新的 Dart 版本（2.10），并且有一个新的 dart CLI 工具，您可能会发现它也很有用。</p>
<p>Dart 历史上拥有许多较小的开发者工具（例如用于格式化的 dartfmt 和用于代码分析的 dartanalyzer）。在 Dart 2.10 中新增了一个统一的 dart 开发者工具，它与 flutter 工具非常相似。</p>
<figure>
<img alt="Screenshot of the output of `dart help`." src="https://cdn-images-1.medium.com/max/700/1*9pvyafhpaMEMhJfLVsz1JQ.png" />
</figure>

<p>从今天的 Flutter 1.22 SDK 开始，您会发现 <code>&lt;flutter-sdk&gt;/bin</code> 文件夹（您可能将其放在 PATH 中）包含 flutter 和 dart 命令。有关更多详细信息，请参阅 <a href="https://medium.com/@mit.mit/announcing-dart-2-10-350823952bd5">Dart 2.10 部落格文章</a>。</p>
<h3 id="应用大小分析工具"><a href="#应用大小分析工具" class="headerlink" title="应用大小分析工具"></a>应用大小分析工具</h3><p>作为 Flutter 1.22 的一部分发布的工具包含一个新的输出大小分析实用程序。此工具帮助诊断 Flutter 您的应用的大小分解随着时间的推移是否发生了变化。</p>
<p>您可以使用此工具通过传递一个<code>--analyze-size</code> 标志到以下任何命令来收集分析所需的数据：</p>
<ul>
<li>flutter build apk</li>
<li>flutter build appbundle</li>
<li>flutter build ios</li>
<li>flutter build linux</li>
<li>flutter build macos</li>
<li>flutter build windows</li>
</ul>
<p>在构建 Flutter 输出工件时使用此标志将打印工件大小和组成的摘要。这包括原生代码、资产，甚至编译的 Dart 代码的包级别分解。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/943/0*vfMD0AQZUOUwzfZ4" />
<figcaption>Flutter Gallery 发布的 APK 的示例分解</figcaption>
</figure>

<p>此摘要对于快速识别应用程序包大小使用情况中的热点很有用。此外，收集的数据还可用作 Dart DevTools 中的 JSON 文件，它允许您进一步探索应用的内容，查明大小问题，并通过遵循 <a href="https://flutter.dev/docs/development/tools/devtools/app-size">flutter.dev 上的说明</a> 查看两个不同 JSON 文件之间的更改。加载 JSON 文件后，您将拥有一个界面，该界面将为您提供应用大小的树状图视图。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gA2waLDAyITCzD7K" />
<figcaption>Dart DevTools 中的示例 APK 分解</figcaption>
</figure>

<p>有关使用应用大小工具可以执行的操作的更多详细信息，请阅读 <a href="https://flutter.dev/docs/development/tools/devtools/app-size">flutter.dev 上的使用应用大小工具文档</a>。</p>
<h3 id="预览：DevTools-中更新的网络页面"><a href="#预览：DevTools-中更新的网络页面" class="headerlink" title="预览：DevTools 中更新的网络页面"></a>预览：DevTools 中更新的网络页面</h3><p>此版本中的另一个 DevTools 预览功能是能够在 <strong>网络</strong> 选项卡中查看 HTTP 和 HTTPS 响应正文。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/781/0*-FukCwELl9DLlefP" />
</figure>

<p>若要启用此功能，请确保您通过 <code>flutter channel dev</code> 和 <code>flutter channel upgrade</code> 位于 Flutter dev 频道。</p>
<p>此外，对于有大量网络流量的应用，我们提供搜索和筛选功能。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/994/0*k-fEpOpbV_MiX9Fn" />
</figure>

<p>有关 <strong>网络</strong> 选项卡文档，请参阅 <a href="https://flutter.dev/docs/development/tools/devtools/network">flutter.dev 上的使用网络视图</a>。</p>
<h3 id="IntelliJ-中托管的-DevTools-Inspector-选项卡"><a href="#IntelliJ-中托管的-DevTools-Inspector-选项卡" class="headerlink" title="IntelliJ 中托管的 DevTools Inspector 选项卡"></a>IntelliJ 中托管的 DevTools Inspector 选项卡</h3><p>一段时间以来，我们一直在维护我们 Flutter 某些工具的两个副本，例如 IntelliJ 中的 <strong>Inspector</strong> 窗格和 Dart DevTools 中的 <strong>Inspector</strong> 选项卡。这不仅会降低我们的速度，因为我们必须维护两个代码库，而且某些功能（例如布局资源管理器）尚未加入 IntelliJ Plugin。因此，为了解决这两个问题，我们启用了直接在 IntelliJ 中托管来自 Dart DevTools 的 <strong>Inspector</strong> 选项卡的功能。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*RQZ-EVyFP1-BqBIX" />
</figure>

<p>请注意布局资源管理器的添加，您可以在代码旁边使用它。若要打开此选项，请转到 <strong>首选项</strong> &gt; <strong>语言和框架</strong> &gt; <strong>Flutter</strong> &gt; <strong>启用嵌入式 DevTools Inspector</strong>。</p>
<h3 id="Visual-Studio-Code-中改进的输出链接"><a href="#Visual-Studio-Code-中改进的输出链接" class="headerlink" title="Visual Studio Code 中改进的输出链接"></a>Visual Studio Code 中改进的输出链接</h3><p>所有 Flutter 开发者都会遇到的一个常规操作是从终端或堆栈跟踪中的错误输出开始。在 Visual Studio Code 的 Flutter 扩展的最新版本中，这些链接现在将被正确地解析，以启用从输出中的链接直接进行跳转。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*prigrwpp7gE6ChCE" />
</figure>

<p>这看起来似乎是一个小事情，但对这一功能的初步反馈已经非常积极。</p>
<p>与往常一样，这里列出的工具更改太多，但我建议您查看以下公告以获取详细信息：</p>
<ul>
<li><a href="https://groups.google.com/g/flutter-announce/c/UxMv8MzE_uo/m/ED539pi2AAAJ">Dart DevTools - 0.9.0</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/y27h86ATFJM">Dart DevTools - 0.9.1</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/24LppkXdMtM">Dart DevTools - 0.9.3</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/nvgDi3RLAUE/m/Fx4Ze0vrBAAJ">Flutter IntelliJ Plugin M48.1 版本</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/-ZMKRIBRtGU">Flutter IntelliJ Plugin M49 版本</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/u0zU6zv3o44/m/2y0JsX1_AwAJ">Flutter IntelliJ Plugin M50 版本</a></li>
<li><a href="https://groups.google.com/g/flutter-announce/c/8e8e-ZrgySY">VS Code 扩展 v3.14.0</a></li>
<li><a href="https://dartcode.org/releases/v3-15/">VS Code 扩展 v3.15.0</a></li>
</ul>
<h3 id="客户案例：EasyA"><a href="#客户案例：EasyA" class="headerlink" title="客户案例：EasyA"></a>客户案例：EasyA</h3><p>EasyA 是一款订阅应用，旨在让学龄学生通过即时消息与优秀的导师联系，并使用 Flutter 编写。最近它被 Apple 评为 <a href="https://apps.apple.com/gb/story/id1527472788">Apple 的“今日应用”</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*yLWTxV_YTJ2HKhuz" />
</figure>

<blockquote>“当学校今年早些时候开始上网时，我们知道我们需要快速推出我们的辅导应用来帮助学生。使用 Flutter 进行开发的超快速度意味着我们能够为 iOS 和 Android 实现获奖设计，并发布到网页——恰逢封锁期间！通常情况下，这是不可能实现的。但由于 Flutter 允许我们同时定位所有三个平台，因此我们能够高效地共享代码，并充分利用我们的小型开发者团队。”</blockquote>

<blockquote>— 菲利普·郭，[EasyA](https://easya.io/) 的联合创始人</blockquote>

<h3 id="重大更改"><a href="#重大更改" class="headerlink" title="重大更改"></a>重大更改</h3><p>与往常一样，我们一直努力将重大更改的数量降至最低。以下是 Flutter 1.22 版本的列表。</p>
<ul>
<li><a href="https://github.com/flutter/flutter/pull/56413">56413</a> <a href="https://docs.google.com/document/d/1BZhxy176uUnqOCnXdnHM1XetS9mw9WIyUAOE-dgVdUM/edit?usp=sharing">防止 viewport.showOnScreen 在指定的 Rect 已经可见时滚动 viewport</a>。</li>
<li><a href="https://github.com/flutter/flutter/pull/62395">62395</a> [gen_l10n] 默认情况下进行合成包生成。</li>
<li><a href="https://github.com/flutter/flutter/pull/62588">62588</a> 更少地构建路由。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flutter 1.22 稳定版本可能是在上一个版本之后快速发布的，但它包含了如此多的优秀内容，以至于这篇文章无法全部提及。我们希望此版本能帮助您为 iOS 和 Android 构建出色的应用，我们迫不及待地想看看您将会实现什么！感谢您的支持——我们为你们构建 Flutter。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=44f146009e5f" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/announcing-flutter-1-22-44f146009e5f">宣布 Flutter 1.22</a> 最初发布在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人们在那里通过突出显示和回应这个故事，继续进行讨论。</p> </p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/2d868a67.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/2d868a67.html" class="post-title-link" itemprop="url">【文章翻譯】Learning Flutter’s new Navigation and Routing system</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-30 01:28:59" itemprop="dateCreated datePublished" datetime="2020-09-30T01:28:59+08:00">2020-09-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="學習-Flutter-的全新導航和路由系統"><a href="#學習-Flutter-的全新導航和路由系統" class="headerlink" title="學習 Flutter 的全新導航和路由系統"></a>學習 Flutter 的全新導航和路由系統</h2><p>本文說明 Flutter 的全新 Navigator 和 Router API 如何運作。如果您關注 Flutter 的公開 <a href="https://flutter.dev/docs/resources/design-docs">設計文件</a>，您可能已經看到這些新功能被稱為 <a href="https://docs.google.com/document/d/1Q0jx0l4-xymph9O6zLaOY4d_f7YFpNWX_eGbzYxr9wY/edit#heading=h.l6kdsrb6j9id">Navigator 2.0 和 Router</a>。我們將探討這些 API 如何讓您更精細地控制應用程式中的螢幕，以及如何使用它們來解析路由。</p>
<p>這些新的 API 並不是重大變更，它們只是添加了一個新的 <a href="https://flutter.dev/docs/get-started/flutter-for/declarative">聲明式 API</a>。在 Navigator 2.0 之前，<a href="https://github.com/flutter/flutter/issues/12146">很難推送或彈出多個頁面</a>，或移除當前頁面下方的一個頁面。但是，如果您對當前 Navigator 的運作方式感到滿意，您可以繼續以相同的方式（命令式）使用它。</p>
<p>Router 提供了從底層平台處理路由和顯示適當頁面的能力。在本文中，Router 被配置為解析瀏覽器 URL 以顯示適當的頁面。</p>
<p>本文將幫助您選擇最適合您的應用程式的 Navigator 模式，並說明如何使用 Navigator 2.0 來解析瀏覽器 URL 並完全控制活動頁面堆疊。本文中的練習展示了如何構建一個應用程式，該應用程式可以處理來自平台的進站路由，並管理應用程式的頁面。以下 GIF 顯示了示例應用程式的運作方式：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PYHrYurwAGyQC8vsnAaWiA.gif" />
</figure>

<h3 id="Navigator-1-0"><a href="#Navigator-1-0" class="headerlink" title="Navigator 1.0"></a>Navigator 1.0</h3><p>如果您使用 Flutter，您可能正在使用 Navigator，並且熟悉以下概念：</p>
<ul>
<li><a href="https://master-api.flutter.dev/flutter/widgets/Navigator-class.html">Navigator</a> - 一個管理 Route 物件堆疊的 Widget。</li>
<li><a href="https://master-api.flutter.dev/flutter/widgets/Route-class.html">Route</a> - 由 Navigator 管理的一個物件，表示一個螢幕，通常由 MaterialPageRoute 等類別實作。</li>
</ul>
<p>在 Navigator 2.0 之前，Route 被推送和彈出到 Navigator 的堆疊上，使用 <em>命名路由</em> 或 <em>匿名路由</em>。接下來的幾節將簡要回顧這兩種方法。</p>
<h4 id="匿名路由"><a href="#匿名路由" class="headerlink" title="匿名路由"></a>匿名路由</h4><p>大多數行動應用程式會在彼此之上顯示螢幕，就像一個堆疊一樣。在 Flutter 中，使用 <a href="https://api.flutter.dev/flutter/widgets/Navigator-class.html">Navigator</a> 就可以輕鬆實現這一點。</p>
<p>MaterialApp 和 CupertinoApp 在幕後都已使用 Navigator。您可以使用 <a href="https://api.flutter.dev/flutter/widgets/Navigator/of.html">Navigator.of()</a> 存取 Navigator，或使用 <a href="https://api.flutter.dev/flutter/widgets/Navigator/push.html">Navigator.push()</a> 顯示一個新的螢幕，並使用 <a href="https://api.flutter.dev/flutter/services/SystemNavigator/pop.html">Navigator.pop()</a> 返回上一個螢幕：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2e1833446bde7b9ee5a95289372375af/href">https://medium.com/media/2e1833446bde7b9ee5a95289372375af/href</a></iframe>

<p>當呼叫 push() 時，DetailScreen Widget 會被放置在 HomeScreen Widget 的頂部，如下所示：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/412/1*v77nG0BRIWrOghj8fCq_EA.png" />
</figure>

<p>上一個螢幕 (HomeScreen) 仍然是 Widget 樹的一部分，因此與其關聯的任何 State 物件都會在 DetailScreen 可見時保留下來。</p>
<h4 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h4><p>Flutter 也支援命名路由，這些路由在 MaterialApp 或 CupertinoApp 的 routes 參數中定義：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7b25282a3af04785848309af09055588/href">https://medium.com/media/7b25282a3af04785848309af09055588/href</a></iframe>

<p>這些路由必須預先定義。雖然您可以 <a href="https://flutter.dev/docs/cookbook/navigation/navigate-with-arguments">將參數傳遞給命名路由</a>，但您無法從路由本身解析參數。例如，如果應用程式在網頁上運行，您無法從像 &#x2F;details&#x2F;:id 這樣的路由中解析 ID。</p>
<h4 id="使用-onGenerateRoute-的進階命名路由"><a href="#使用-onGenerateRoute-的進階命名路由" class="headerlink" title="使用 onGenerateRoute 的進階命名路由"></a>使用 onGenerateRoute 的進階命名路由</h4><p>處理命名路由的更靈活方法是使用 onGenerateRoute。此 API 使您能夠處理所有路徑：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8a46c7c8e0be87b330f8f09c5f19713d/href">https://medium.com/media/8a46c7c8e0be87b330f8f09c5f19713d/href</a></iframe>

<p>以下是完整的示例：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0b90278fd76fb7a8cbbd7c98011509dd/href">https://medium.com/media/0b90278fd76fb7a8cbbd7c98011509dd/href</a></iframe>

<p>這裡，settings 是 <a href="https://api.flutter.dev/flutter/widgets/RouteSettings-class.html">RouteSettings</a> 的一個實例。name 和 arguments 字段是呼叫 <a href="https://api.flutter.dev/flutter/widgets/Navigator/pushNamed.html">Navigator.pushNamed</a> 時提供的數值，或者設定為 <a href="https://api.flutter.dev/flutter/material/MaterialApp/initialRoute.html">initialRoute</a> 的數值。</p>
<h3 id="Navigator-2-0"><a href="#Navigator-2-0" class="headerlink" title="Navigator 2.0"></a>Navigator 2.0</h3><p>Navigator 2.0 API 為框架添加了新的類別，以便使應用程式的螢幕成為應用程式狀態的函數，並提供從底層平台（例如 Web URL）解析路由的能力。以下是新功能的概述：</p>
<ul>
<li><a href="https://master-api.flutter.dev/flutter/widgets/Page-class.html">Page</a> - 一個不可變的物件，用於設定導航器的歷史堆疊。</li>
<li><a href="https://master-api.flutter.dev/flutter/widgets/Router-class.html">Router</a> - 配置 Navigator 要顯示的頁面列表。通常，這個頁面列表會根據底層平台或應用程式狀態的變化而變化。</li>
<li><a href="https://master-api.flutter.dev/flutter/widgets/Router/routeInformationParser.html">RouteInformationParser</a>，它會從 <a href="https://master-api.flutter.dev/flutter/widgets/RouteInformationProvider-class.html">RouteInformationProvider</a> 中獲取 <a href="https://master-api.flutter.dev/flutter/widgets/RouteInformation-class.html">RouteInformation</a>，並將其解析為一個使用者定義的資料類型。</li>
<li><a href="https://master-api.flutter.dev/flutter/widgets/RouterDelegate-class.html">RouterDelegate</a> - 定義 Router 如何了解應用程式狀態變化以及如何對它們做出響應的應用程式特定行為。它的工作是監聽 RouteInformationParser 和應用程式狀態，並使用當前的 Page 列表構建 Navigator。</li>
<li><a href="https://master-api.flutter.dev/flutter/widgets/BackButtonDispatcher-class.html">BackButtonDispatcher</a> - 向 Router 報告後退按鈕按下。</li>
</ul>
<p>下圖顯示了 RouterDelegate 如何與 Router、RouteInformationParser 和應用程式的狀態交互：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*hNt4Bc8FZBp_Gqh7iED3FA.png" />
</figure>

<p>以下是這些部分如何交互的示例：</p>
<ol>
<li>當平台發出一個新的路由（例如，「books&#x2F;2」）時，RouteInformationParser 會將其轉換為一個抽象資料類型 T，您可以在您的應用程式中定義這個資料類型（例如，一個名為 BooksRoutePath 的類別）。</li>
<li>RouterDelegate 的 setNewRoutePath 方法會使用這個資料類型被呼叫，並且必須更新應用程式狀態以反映變化（例如，透過設定 selectedBookId）並呼叫 notifyListeners。</li>
<li>當呼叫 notifyListeners 時，它會告訴 Router 重新建立 RouterDelegate（使用其 build() 方法）。</li>
<li>RouterDelegate.build() 返回一個新的 Navigator，其頁面現在反映了應用程式狀態的變化（例如，selectedBookId）。</li>
</ol>
<h3 id="Navigator-2-0-練習"><a href="#Navigator-2-0-練習" class="headerlink" title="Navigator 2.0 練習"></a>Navigator 2.0 練習</h3><p>本節將引導您完成使用 Navigator 2.0 API 的練習。我們將最終獲得一個應用程式，該應用程式可以與 URL 列保持同步，並處理來自應用程式和瀏覽器的後退按鈕按下，如以下 GIF 所示：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PYHrYurwAGyQC8vsnAaWiA.gif" />
</figure>

<p>若要繼續操作，請 <a href="https://flutter.dev/docs/development/tools/sdk/upgrading#switching-flutter-channels">切換到 master channel</a>，<a href="https://flutter.dev/docs/get-started/web#create-a-new-project-with-web-support">使用 Web 支援建立一個新的 Flutter 專案</a>，並將 <code>lib/main.dart</code> 的內容替換為以下內容：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cfd1389f1cea52fd826cb2f0d3c41710/href">https://medium.com/media/cfd1389f1cea52fd826cb2f0d3c41710/href</a></iframe>

<h3 id="頁面"><a href="#頁面" class="headerlink" title="頁面"></a>頁面</h3><p>Navigator 在其建構函數中有一個新的 pages 參數。如果 Page 物件列表發生變化，Navigator 會更新路由堆疊以匹配。若要了解這如何運作，我們將構建一個顯示書籍列表的應用程式。</p>
<p>在 _BooksAppState 中，保留兩個狀態資訊：書籍列表和選中的書籍：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/845c5fd2aae489e174819bafe385665e/href">https://medium.com/media/845c5fd2aae489e174819bafe385665e/href</a></iframe>

<p>然後在 _BooksAppState 中，返回一個帶有 Page 物件列表的 Navigator：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/293236ea6a501d939a6c2a0c88cd559f/href">https://medium.com/media/293236ea6a501d939a6c2a0c88cd559f/href</a></iframe>

<p>由於這個應用程式有兩個螢幕，一個是書籍列表，另一個是顯示詳細資訊的螢幕，因此如果選中了書籍，請添加第二個（詳細資訊）頁面（使用 <a href="https://dart.dev/guides/language/language-tour#collection-operators">集合中的 if</a>）：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/30d1e88faa7b68b3559e229ea7e167cf/href">https://medium.com/media/30d1e88faa7b68b3559e229ea7e167cf/href</a></iframe>

<p>請注意，頁面的鍵由書籍物件的數值定義。這告訴 Navigator，當書籍物件不同時，這個 MaterialPage 物件與另一個物件不同。如果沒有唯一的鍵，框架無法確定何時顯示不同 Page 之間的轉場動畫。</p>
<p><strong>注意</strong>：如果您願意，您也可以擴展 Page 以自訂行為。例如，此頁面添加了一個自訂轉場動畫：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/574ae43f34ab37f0f3f276530e5d588c/href">https://medium.com/media/574ae43f34ab37f0f3f276530e5d588c/href</a></iframe>

<p>最後，在沒有提供 <a href="https://api.flutter.dev/flutter/widgets/Navigator/onPopPage.html">onPopPage</a> 回撥的情況下提供 <a href="https://api.flutter.dev/flutter/widgets/Navigator/pages.html">pages</a> 參數是一個錯誤。此函數在呼叫 Navigator.pop() 時被呼叫。它應該用於更新狀態（決定頁面列表的狀態），並且必須呼叫路由上的 didPop 來確定彈出是否成功：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d6d6bd8b3e7fd7d25f53c064c6ef33ab/href">https://medium.com/media/d6d6bd8b3e7fd7d25f53c064c6ef33ab/href</a></iframe>

<p>在更新應用程式狀態之前檢查 didPop 是否失敗非常重要。</p>
<p>使用 setState 會通知框架呼叫 build() 方法，該方法在 _selectedBook 為 null 時返回一個帶有單個頁面的列表。</p>
<p>以下是完整的示例：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bcd25ca6bdad3e3c696cb3b4af81f475/href">https://medium.com/media/bcd25ca6bdad3e3c696cb3b4af81f475/href</a></iframe>

<p>就目前而言，這個應用程式只允許我們以聲明式的方式定義頁面堆疊。我們無法處理平台的後退按鈕，並且瀏覽器的 URL 在我們導航時不會改變。</p>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>到目前為止，應用程式可以顯示不同的頁面，但它無法處理來自底層平台的路由，例如，如果使用者在瀏覽器中更新 URL。</p>
<p>本節將說明如何實作 RouteInformationParser、RouterDelegate 並更新應用程式狀態。設定好後，應用程式將與瀏覽器的 URL 保持同步。</p>
<h4 id="資料類型"><a href="#資料類型" class="headerlink" title="資料類型"></a>資料類型</h4><p>RouteInformationParser 會將路由資訊解析為一個使用者定義的資料類型，因此我們將首先定義它：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d53bacff37bb54de3e82c883673eacae/href">https://medium.com/media/d53bacff37bb54de3e82c883673eacae/href</a></iframe>

<p>在這個應用程式中，應用程式中的所有路由都可以使用單個類別來表示。相反，您可能選擇使用實作超類別的不同類別，或以其他方式管理路由資訊。</p>
<h4 id="RouterDelegate"><a href="#RouterDelegate" class="headerlink" title="RouterDelegate"></a>RouterDelegate</h4><p>接下來，添加一個擴展 RouterDelegate 的類別：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/96b856ebffe0283cc5595a29a0a9620e/href">https://medium.com/media/96b856ebffe0283cc5595a29a0a9620e/href</a></iframe>

<p>在 RouterDelegate 上定義的泛型類型是 BookRoutePath，它包含決定要顯示哪些頁面所需的所有狀態。</p>
<p>我們需要將一些邏輯從 _BooksAppState 移動到 BookRouterDelegate，並建立一個 GlobalKey。在這個示例中，應用程式狀態直接儲存在 RouterDelegate 上，但也可以分開到另一個類別中。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ea8c72e1a8b1742705d6aca9152c7e19/href">https://medium.com/media/ea8c72e1a8b1742705d6aca9152c7e19/href</a></iframe>

<p>為了在 URL 中顯示正確的路徑，我們需要根據應用程式的當前狀態返回一個 BookRoutePath：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6f459a26de1d686bf3d8fca7aafbd431/href">https://medium.com/media/6f459a26de1d686bf3d8fca7aafbd431/href</a></iframe>

<p>接下來，RouterDelegate 中的 build 方法需要返回一個 Navigator：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a46807df165f002a1c86f873dd5fbb9e/href">https://medium.com/media/a46807df165f002a1c86f873dd5fbb9e/href</a></iframe>

<p>onPopPage 回撥現在使用 notifyListeners 而不是 setState，因為這個類別現在是 ChangeNotifier，而不是 Widget。當 RouterDelegate 通知其監聽器時，Router Widget 也會被通知 RouterDelegate 的 currentConfiguration 已更改，並且需要再次呼叫其 build 方法以構建一個新的 Navigator。</p>
<p>_handleBookTapped 方法也需要使用 notifyListeners 而不是 setState：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ce4cf764a0951209deacf3d8af3f9997/href">https://medium.com/media/ce4cf764a0951209deacf3d8af3f9997/href</a></iframe>

<p>當一個新的路由被推送到應用程式時，Router 會呼叫 setNewRoutePath，這讓我們的應用程式有機會根據路由的變化來更新應用程式狀態：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/df6a5bbbc57d2bfae0cdd2fa5e127a2e/href">https://medium.com/media/df6a5bbbc57d2bfae0cdd2fa5e127a2e/href</a></iframe>

<h4 id="RouteInformationParser"><a href="#RouteInformationParser" class="headerlink" title="RouteInformationParser"></a>RouteInformationParser</h4><p>RouteInformationParser 提供了一個鉤子來解析進站路由 (RouteInformation) 並將其轉換為使用者定義的類型 (BookRoutePath)。使用 Uri 類別來處理解析：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/82d55d2673dc5cfe048869da4c5ff433/href">https://medium.com/media/82d55d2673dc5cfe048869da4c5ff433/href</a></iframe>

<p>此實作特定於此應用程式，而不是通用的路由解析解決方案。稍後將詳細說明。</p>
<p>若要使用這些新的類別，我們使用新的 MaterialApp.router 建構函數，並傳遞我們自定義的實作：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f8524f0e27ed08d99cf48761019e0729/href">https://medium.com/media/f8524f0e27ed08d99cf48761019e0729/href</a></iframe>

<p>以下是完整的示例：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/08b2e895238b4f74ea44d8ad176c8dc2/href">https://medium.com/media/08b2e895238b4f74ea44d8ad176c8dc2/href</a></iframe>

<p>在 Chrome 中運行此示例現在會顯示路由的導航方式，並在手動編輯 URL 時導航到正確的頁面。</p>
<h4 id="TransitionDelegate"><a href="#TransitionDelegate" class="headerlink" title="TransitionDelegate"></a>TransitionDelegate</h4><p>您可以提供 TransitionDelegate 的自定義實作，它會自訂當頁面列表發生變化時路由在螢幕上出現（或從螢幕中移除）的方式。如果您需要自訂此功能，請繼續閱讀，但如果您對預設行為感到滿意，您可以跳過本節。</p>
<p>為 Navigator 提供一個自訂 TransitionDelegate，它定義了所需的行為：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/37c2ae786609d0af69a2458bcbb4d91b/href">https://medium.com/media/37c2ae786609d0af69a2458bcbb4d91b/href</a></iframe>

<p>例如，以下實作會禁用所有轉場動畫：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5e3d7b4a485b8905bc531be5688bb91e/href">https://medium.com/media/5e3d7b4a485b8905bc531be5688bb91e/href</a></iframe>

<p>此自定義實作會覆蓋 resolve()，它負責將各種路由標記為推送、彈出、添加、完成或移除：</p>
<ul>
<li>markForPush - 使用動畫轉場顯示路由</li>
<li>markForAdd - 使用 <em>無</em> 動畫轉場顯示路由</li>
<li>markForPop - 使用動畫轉場移除路由，並使用結果完成它。在這個上下文中，「完成」意味著結果物件會被傳遞給 AppRouterDelegate 上的 onPopPage 回撥。</li>
<li>markForComplete - 使用無轉場移除路由，並使用結果完成它</li>
<li>markForRemove - 使用無動畫轉場移除路由，並且不完成。</li>
</ul>
<p>此類別只會影響 <em>聲明式</em> API，這就是為什麼 <strong>後退</strong> 按鈕仍然顯示轉場動畫的原因。</p>
<p><strong>此示例如何運作：</strong> 此示例會查看新的路由和即將離開螢幕的路由。它會遍歷 newPageRouteHistory 中的所有物件，並使用 markForAdd 將它們標記為無轉場動畫地添加。接下來，它會遍歷 locationToExitingPageRoute 映射的數值。如果它找到一個被標記為 isWaitingForExitingDecision 的路由，那麼它會呼叫 markForRemove 來指示該路由應該使用無轉場和無完成的方式移除。</p>
<p><a href="http://gist.github.com/5ce79aee5b5f83cfababa97c9cf0a204">以下是完整的示例（Gist）</a>。</p>
<h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>這個更大的演示展示了如何在另一個 Router 中添加 Router。許多應用程式需要為 BottomAppBar 中的目標設定路由，以及為其上方的視圖堆疊設定路由，這 <a href="https://medium.com/flutter/getting-to-the-bottom-of-navigation-in-flutter-b3e440b9386">需要兩個 Navigator</a>。若要做到這一點，應用程式會使用一個應用程式狀態物件來儲存應用程式特定的導航狀態（選中的菜單索引和選中的書籍物件）。此示例還展示了如何配置哪個 Router 處理後退按鈕。</p>
<p><a href="http://gist.github.com/bbca91e23bbb4d39247fa922533be7c9">嵌套路由示例（Gist）</a></p>
<h3 id="接下來要做什麼"><a href="#接下來要做什麼" class="headerlink" title="接下來要做什麼"></a>接下來要做什麼</h3><p>本文探討了如何為特定應用程式使用這些 API，但也可以用於構建一個更高階的 API 套件。我們希望您能加入我們，探索建立在這些功能之上的更高階 API 能夠為使用者做些什麼。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7c9068155ade" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade">學習 Flutter 的全新導航和路由系統</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/ca05ef63.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/ca05ef63.html" class="post-title-link" itemprop="url">【文章翻譯】Integration Testing with flutter_driver</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-29 15:24:10" itemprop="dateCreated datePublished" datetime="2020-09-29T15:24:10+08:00">2020-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="使用-flutter-driver-進行整合測試"><a href="#使用-flutter-driver-進行整合測試" class="headerlink" title="使用 flutter_driver 進行整合測試"></a>使用 flutter_driver 進行整合測試</h2><p>單元測試確保應用程式的個別部分按預期運作，但整個應用程式呢？這就是整合測試發揮作用的地方。</p>

<h3 id="Flutter-driver"><a href="#Flutter-driver" class="headerlink" title="Flutter driver"></a>Flutter driver</h3><p>如果您從未在 Flutter（或任何地方）進行過整合測試，別擔心！在 Flutter 中為您的應用程式添加整合測試是一項簡單的任務。有一組非常有用的文章將引導您。</p>

<ol>
<li><a href="https://flutter.dev/docs/cookbook/testing/integration/introduction">整合測試簡介</a>：這個東西是什麼，我該如何設定？</li>
<li><a href="https://flutter.dev/docs/cookbook/testing/integration/scrolling">處理捲動</a>：我該如何處理捲動到某個東西的常見模式？</li>
</ol>

<p>到達這一點可以確保您的應用程式可以正常運行、可以到達特定螢幕、特定操作會產生一些結果，等等。您創建的測試取決於您的需求。您可以使用一個測試打開應用程式的所有螢幕，或者使用測試完成特定使用者旅程。</p>

<p>但我們可以使用 flutter_driver 進一步進行效能測試。</p>

<h3 id="效能分析"><a href="#效能分析" class="headerlink" title="效能分析"></a>效能分析</h3><p>只需將您的測試用 flutterDriver.traceAction 包裹起來，就會在您的測試運行時記錄您的應用程式的效能。此輸出資料（以 JSON 格式）可以在持續整合 (CI) 測試中使用，以確保例如某些指標保持在特定臨界值之上或之下。該資料還可以用於除錯效能問題。有關如何進行效能分析的詳細資訊，請參閱整合測試文章，<a href="https://flutter.dev/docs/cookbook/testing/integration/profiling">效能分析</a>。</p>

<p>作為參考，Flutter Gallery 有個 <a href="https://github.com/flutter/gallery/tree/master/test_driver">整合測試</a>，會瀏覽所有演示並為其中的一部分捕獲效能指標。</p>

<h3 id="螢幕截圖測試"><a href="#螢幕截圖測試" class="headerlink" title="螢幕截圖測試"></a>螢幕截圖測試</h3><p><em>螢幕截圖測試</em>是一種渲染 UI、捕獲輸出螢幕截圖，然後將結果與預期圖片進行比較。為您的應用程式添加螢幕截圖測試的一個簡單方法是使用 flutterDriver.screenshot。若要了解更多資訊並查看實際的程式碼範例，請參閱 Medium 文章，<a href="https://medium.com/flutter-community/testing-flutter-ui-with-flutter-driver-c1583681e337#8561">使用 Flutter Driver 測試 Flutter UI</a>，作者是社群成員 Darshan Kawar。</p>

<p>此方法可以輕鬆整合到您的持續整合測試設定中，以防止 UI 回歸。Flutter Gallery 有幾個 <a href="https://github.com/flutter/gallery/tree/master/golden_test">螢幕截圖測試</a> 和一個 <a href="https://github.com/flutter/gallery/blob/master/.github/workflows/golden.yml">GitHub 工作流程設定</a>，用於自動測試進來的 PR。</p>

<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3821c3795913217d187d26b04dbdc1a4/href">https://medium.com/media/3821c3795913217d187d26b04dbdc1a4/href</a></iframe>

<h3 id="a11y-測試"><a href="#a11y-測試" class="headerlink" title="a11y 測試"></a>a11y 測試</h3><p><em>a11y</em> 或無障礙測試是一種可用性測試，用於確保應用程式可以被有障礙的人使用，例如視力障礙、聽力障礙、肢體障礙，等等。使用 flutterDriver.getSemanticsId 驗證語義標籤，例如，驗證所有圖片是否都有語義標籤。</p>

<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9712bbcd895e55e14cb2ede49659854b/href">https://medium.com/media/9712bbcd895e55e14cb2ede49659854b/href</a></iframe>

<p>在 Darshan Kawar 的另一篇很棒的文章中，了解更多關於無障礙測試的資訊，<a href="https://medium.com/flutter-community/developing-and-testing-accessible-app-in-flutter-1dc1d33c7eea">在 Flutter 中開發和測試無障礙應用程式</a>。</p>

<h3 id="i18n-測試"><a href="#i18n-測試" class="headerlink" title="i18n 測試"></a>i18n 測試</h3><p><em>i18n</em> 或國際化測試是測試應用程式是否可以在不同的語言和地區使用而無需任何變更的過程。</p>

<p>根據您的本地化程式碼的設定方式，您可以使用本地化的委派來更改語言環境。</p>

<pre>ExampleAppLocalizationsDelegate.load(Locale('fr'));</pre>

<p>或者，在使用 MaterialApp 時，只需允許覆蓋應用程式的語言環境，以便在不同的語言環境中運行。</p>

<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/faf86fe011e8553d226ef1e531f6bb2c/href">https://medium.com/media/faf86fe011e8553d226ef1e531f6bb2c/href</a></iframe>

<p>在啟動應用程式的驅動程式檔案中，設定語言環境。</p>

<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e56e6c3f196adf5990428f6f77a79e9e/href">https://medium.com/media/e56e6c3f196adf5990428f6f77a79e9e/href</a></iframe>

<h3 id="額外提示"><a href="#額外提示" class="headerlink" title="額外提示"></a>額外提示</h3><p>想知道頁面上是否存在某個元素嗎？</p>

<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7bc1030109a119c1862a5dc5513e34ea/href">https://medium.com/media/7bc1030109a119c1862a5dc5513e34ea/href</a></iframe>

<p>您可以選擇任何適合您的應用程式的超時時間。</p>

<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>到目前為止，您應該對 flutter_driver 的功能有了很好的了解。您可以結合方法以滿足您的需求；例如，使用不同的語言環境執行螢幕截圖測試。如果我們遺漏了什麼，請在評論中告訴我們！若要了解更多資訊，請參閱 <a href="https://api.flutter.dev/flutter/flutter_driver/flutter_driver-library.html">flutter_driver</a> API 文件。</p>

<p><em>關於作者：Pierre-Louis 是滑鐵盧大學的應屆大學畢業生。他住在慕尼黑，是維護 Flutter Material 函式庫的團隊中的一員。他對 UI、UX 和應用程式開發非常感興趣。您可以在</em> <a href="https://www.linkedin.com/in/guidezpl"><em>LinkedIn</em></a><em> 和</em> <a href="https://github.com/guidezpl"><em>GitHub</em></a><em> 上與他聯繫。</em></p>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=36f66ede5cf2" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/integration-testing-with-flutter-driver-36f66ede5cf2">使用 flutter_driver 進行整合測試</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/2a1bf84b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/2a1bf84b.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Flutter Windows Alpha</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-23 14:57:38" itemprop="dateCreated datePublished" datetime="2020-09-23T14:57:38+08:00">2020-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Flutter-Windows-Alpha-版本"><a href="#宣布-Flutter-Windows-Alpha-版本" class="headerlink" title="宣布 Flutter Windows Alpha 版本"></a>宣布 Flutter Windows Alpha 版本</h2><p>我們的使命是為開發人員提供一個開源、高生產力的框架，用於在任何平台上構建美觀的原生應用程式。到目前為止，我們已經為 Android 和 iOS 發佈了生產級別的支援，擁有 8 個穩定版本，僅 Google Play 商店就發佈了超過 100,000 個應用程式。我們繼續擴大我們的關注範圍，包括其他平台，包括網頁、macOS 和 Linux。今天，我們很高興宣布 Flutter 的另一個目標是為 Windows 發佈 Flutter 支援的 alpha 版本。</p>
<p>Windows 仍然是桌面和筆記型電腦設備的熱門選擇，微軟報告稱 <a href="https://blogs.windows.com/windowsexperience/2020/03/16/windows-10-powering-the-world-with-1-billion-monthly-active-devices/">超過 10 億台設備運行 Windows 10</a>。我們自己的統計數據顯示，超過一半的 Flutter 開發人員使用 Windows，因此它自然成為 Flutter 的目標。原生桌面支援為 Flutter 開啟了各種令人興奮的可能性，包括改進的開發人員工具、降低新使用者的摩擦，當然還有可以從單個程式碼庫到達使用者可能擁有的任何設備的應用程式。</p>
<h3 id="將-Windows-加入-Flutter"><a href="#將-Windows-加入-Flutter" class="headerlink" title="將 Windows 加入 Flutter"></a>將 Windows 加入 Flutter</h3><p>如我們的 <a href="https://flutter.dev/docs/resources/architectural-overview">架構概述</a> 中所述，Flutter 是一個跨平台 UI 工具包，旨在允許在 iOS 和 Android 等操作系統之間重複使用程式碼，同時也允許應用程式直接與底層平台服務進行互動。目標是讓開發人員能夠交付高效能的應用程式，這些應用程式在不同的平台上感覺自然，在存在差異的地方擁抱差異，同時盡可能共享程式碼。Flutter 的核心是引擎，它支援支援所有 Flutter 應用程式所必需的基本元素。引擎負責在需要繪製新畫面時對合成場景進行光柵化。它提供了 Flutter 核心 API 的低階實作，包括圖形、文字佈局、檔案和網路 I&#x2F;O、輔助功能支援、外掛架構，以及 Dart 執行時和編譯工具鏈。</p>
<p>我們添加到 Flutter 的每個新平台都會使用新的服務擴展核心框架，以便它在該平台上發光。我們從 Android 和 iOS 開始，採用 Material Design 以及基於觸控的、以行動為中心的使用者介面，該介面旨在讓兩個行動平台上的像素完美。為網頁、Windows、macOS 和 Linux 添加對桌面外觀尺寸的支援帶來了全新的服務集，包括對鍵盤、滑鼠、滑鼠滾輪和控制器（輸入端）的強大支援，以及在網頁和桌面應用程式附帶的較大螢幕尺寸上適應或甚至最有效工作的 Widget。</p>
<p>此外，每個新平台不僅會影響 Flutter 框架和引擎，還會影響許多其他方面：</p>
<ul>
<li><strong>工具鏈更新：</strong>將新目標添加到 CLI 和 IDE 工具（在本例中為 Windows）</li>
<li><strong>外殼程式：</strong>支援透過 WM_* 訊息處理來自 Windows 的輸入，以及透過 <a href="https://opensource.google/projects/angle">ANGLE</a> 輸出，ANGLE 使用 <a href="https://skia.org/">Skia</a> 以原生速度渲染到底層 DirectX 表面</li>
<li><strong>執行器：</strong>每個專案都有一個外殼程式應用程式，適用於受支援的目標。對於 Windows，它是一個載入您的 Flutter 程式碼並在執行時執行的 Win32&#x2F;C++ 程式。如果您需要，這是將原生程式碼添加到您的應用程式的好地方。</li>
<li><strong>外掛：</strong>外掛是 Dart 程式碼和原生程式碼的混合，適用於外掛支援的每個平台。需要為編譯到 Windows 上的 Flutter 應用程式中的每個外掛添加該原生程式碼。</li>
</ul>
<p>此 alpha 版本提供了堅實的基礎，我們將在接下來的幾個月內將其穩定下來。透過對 Windows 7 及更高版本的支援，我們希望這能讓具有冒險精神的開發人員擁有一些可以開始使用的東西。</p>
<h3 id="探索一些範例應用程式"><a href="#探索一些範例應用程式" class="headerlink" title="探索一些範例應用程式"></a>探索一些範例應用程式</h3><p>若要查看 Flutter 對 Windows 的支援，您可能需要嘗試一些我們建立的範例應用程式，這些應用程式在我們的最新支援下可以在 Windows 上良好運行。第一個是 Flokk 應用程式，它是與 <a href="http://gskinner.com/">gskinner.com</a> 的設計師和開發人員共同建立的。目標是透過建立一個創新的、美觀的 Flutter 桌面應用程式來證明 Flutter 已經準備好迎接桌面。Flokk 是一個與您的真實 Google 聯繫人資料配合使用的應用程式，同時還顯示了您的聯繫人在 GitHub 和 Twitter 上的活動。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*39MKtw4ICepbL_8d" />
</figure>

<p>如果您想在 Windows 電腦上使用 Flokk 應用程式，您可以 <a href="https://github.com/gskinnerTeam/Flokk/releases">在 GitHub 上下載最新版本</a>。如果您想了解 gskinner 如何構建這個應用程式，請參閱他們的出色部落格文章：<a href="https://blog.gskinner.com/archives/2020/09/flokk---how-we-built-a-desktop-app-using-flutter.html">Flokk - 我們如何使用 Flutter 建立桌面應用程式</a>。</p>
<p>此外，Flutter Gallery 應用程式（我們用於所有 Flutter 事物的展示應用程式）最近已完全重寫，以添加對桌面外觀尺寸的支援。這讓我們可以檢查它在 <a href="https://gallery.flutter.dev/">網頁</a> 以及 Windows、macOS 和 Linux 上是否運行良好。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*N_tKeqs435R4yICO" />
</figure>

<p>Gallery 中的許多研究展示了我們在使用 Flutter 設計自己的 Windows 應用程式時推薦的不同應用程式樣式的想法。當您找到喜歡的內容時，<a href="https://github.com/flutter/gallery">程式碼可在 GitHub 上獲得</a>。</p>
<h3 id="開始使用-Flutter-for-Windows"><a href="#開始使用-Flutter-for-Windows" class="headerlink" title="開始使用 Flutter for Windows"></a>開始使用 Flutter for Windows</h3><p>按照 <a href="https://flutter.dev/docs/get-started/install/windows">Windows 安裝說明</a> 安裝 Flutter SDK 以開始。若要以 Windows 桌面為目標，您首先需要 <a href="https://flutter.dev/desktop#additional-windows-requirements">安裝桌面文件中描述的工具</a>。預設情況下，Flutter 假設您正在構建生產軟體，並且沒有配置為開發 Windows 應用程式。但是，這可以輕鬆地從命令行中修復：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ flutter channel dev</span><br><span class="line">$ flutter upgrade</span><br><span class="line">$ flutter config --enable-windows-desktop</span><br></pre></td></tr></table></figure>

<p>第一個命令將 Flutter 設定為使用實驗性品質的「dev」頻道（而不是預設的「stable」頻道）。這讓您可以使用仍處於 alpha 階段的平台支援，例如 Windows。第二個命令會在該頻道上提取最新的位元。第三個命令會在您的電腦上啟用 Windows 應用程式開發。</p>
<p>設定好之後，每次您使用 Android Studio 或 Visual Studio Code 的擴展支援，或者從命令行建立新的 Flutter 應用程式時，它都會建立一個 windows 子資料夾。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*O-akivVSsv0tL0wI" />
</figure>

<p>如果您感到好奇，在 Windows 上運行預設應用程式看起來像這樣：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/838/1*fsnlPFkpQWZjYIv-NCE6Vg.png" />
</figure>

<p>最後，建立應用程式後，構建它會建立一個發佈模式的原生 EXE 檔案以及必要的支援 DLL。在那之後，如果您想嘗試在任何 Windows 10 電腦上運行您的新 Windows 應用程式，甚至那些沒有安裝 Flutter 的電腦，您可以 <a href="https://flutter.dev/desktop#distribution">按照將必要檔案壓縮成壓縮檔的步驟</a> 進行操作。</p>
<h3 id="Windows-的外掛"><a href="#Windows-的外掛" class="headerlink" title="Windows 的外掛"></a>Windows 的外掛</h3><p>儘管我們才剛剛達到 alpha 版本，但 Flutter 社群已經開始為 Windows 開發外掛。這裡有一些：</p>
<ul>
<li><a href="https://pub.dev/packages/url_launcher">url_launcher</a>：從您的應用程式啟動瀏覽器中的 URL</li>
<li><a href="https://pub.dev/packages/path_provider">path_provider</a>：查找使用者電腦上特殊位置（如文件或臨時文件）的路徑</li>
<li><a href="https://pub.dev/packages/shared_preferences">shared_preferences</a>：在您的應用程式會話之間將使用者偏好設定序列化到磁碟上</li>
<li><a href="https://pub.dev/packages/biometric_storage">biometric_storage</a>：透過生物識別資訊加密的儲存</li>
<li><a href="https://pub.dev/packages/flutter_audio_desktop">flutter_audio_desktop</a>：從您的桌面應用程式播放音訊</li>
</ul>
<p>使用這些外掛的好處是，它們中的大多數也支援其他 Flutter 平台，這使您可以將應用程式定位到 Android、iOS、網頁等以及 Windows。此外，儘管 <a href="http://pub.dev/">pub.dev</a>（Dart 和 Flutter 的套件管理器）上約三分之一的可用套件是包含平台特定程式碼的外掛，但大多數卻不是。例如，<a href="https://pub.dev/flutter/favorites">許多品質最高、使用最廣泛的套件</a> 是 Flutter Favorite 程式的一部分，它們中的大多數都在 Windows 上運行。如果您想查看在 Windows 上運行的套件的完整列表，您可以 <a href="https://pub.dev/flutter/packages?platform=windows">在 pub.dev 上運行此查詢</a>。</p>
<h3 id="與-Windows-互操作"><a href="#與-Windows-互操作" class="headerlink" title="與 Windows 互操作"></a>與 Windows 互操作</h3><p>如果您想為 Windows 建立自己的外掛，您可以。在您位於 dev 頻道並為您的電腦啟用 Windows 後，您可以使用以下命令開始：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter create --template plugin --platforms windows hello_plugin</span><br></pre></td></tr></table></figure>

<p>在那之後，您就可以將 Flutter 程式碼添加到外掛專案中的 lib 子資料夾，以及將 Windows 程式碼添加到 Windows 子資料夾中。您將透過 <a href="https://flutter.dev/docs/development/platform-integration/platform-channels">平台通道</a> 在兩個堆疊之間進行通訊，平台通道本質上是 Dart 和 C++ 程式碼之間的訊息傳遞。若要查看此方面的精心製作的範例，請 <a href="https://github.com/flutter/plugins/tree/master/packages/url_launcher/url_launcher_windows">查看 url_launcher 實作</a>。</p>
<p>但是，平台通道並不是您與 Windows 互操作的唯一選擇。如果您願意，可以使用 <a href="https://flutter.dev/docs/development/platform-integration/c-interop">Dart FFI（外部函數介面）</a> 來載入函式庫並呼叫 C 樣式的 API，例如 Win32 API。與使用平台通道的 url_launcher 不同，path_provider 外掛是使用 FFI 實作的，如您在 <a href="https://github.com/flutter/plugins/tree/master/packages/path_provider/path_provider_windows">GitHub 儲存庫</a> 中看到的那樣。FFI 不需要在 Dart 和 C++ 之間來回切換，它讓您能夠撰寫程式碼來直接匯入您想要的 API。例如，以下是呼叫 MessageBox API 的程式碼：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b635c5481c5c0f1ab18e10657790d617/href">https://medium.com/media/b635c5481c5c0f1ab18e10657790d617/href</a></iframe>

<p>此程式碼不會像平台通道那樣在兩個執行緒之間轉換時產生額外的開銷。FFI 包括對許多不同類型的 API 的支援，包括 Win32、WinRT 和 COM。但在您開始運作並封裝整個基於 C 的 Windows API 之前，請查看 <a href="https://pub.dev/packages/win32">win32 外掛</a>，它已經在進行這項工作。事實上，<a href="https://pub.dev/packages/path_provider">path_provider</a> 外掛本身是使用 win32 外掛實作的。有關 win32 外掛的開發方式及其運作方式的詳細資訊，請查看部落格文章：<a href="https://medium.com/@timsneath/windows-fun-with-dart-ffi-687c4619e78d">使用 Dart FFI 的 Windows 樂趣</a>。</p>
<h3 id="Flutter-for-Windows-資源"><a href="#Flutter-for-Windows-資源" class="headerlink" title="Flutter for Windows 資源"></a>Flutter for Windows 資源</h3><p>無論您在 Flutter for Windows 之旅中處於哪個階段，您都應該確保 <a href="http://flutter.dev/desktop">閱讀 flutter.dev 上的桌面文件</a>，其中包括最新的詳細資訊。此外，您還需要嘗試使用 Flutter <a href="https://codelabs.developers.google.com/codelabs/flutter-github-graphql-client">用於撰寫以 Windows、macOS 和 Windows 桌面為目標的應用程式的 Codelab</a>，其中包含用於實際情況的程式碼，例如使用 OAuth進行身份驗證、存取 GitHub API 以及使用 GraphQL。或者，若要查看另一個在 Windows 上運行的 Flutter 桌面程式碼的好範例，請 <a href="https://github.com/flutter/samples/tree/master/experimental/desktop_photo_search">查看 Photo Search 範例</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/816/0*3OlPPAMAvO84mJ6M" />
</figure>

<p>它使用標準的 Windows 檔案開啟對話方塊、樹狀檢視 Widget、分割器 Widget，並將結果與實際的 REST API 整合。</p>
<p>對於其他有用的以桌面為導向的 Widget，我們建議使用 <a href="https://github.com/google/flutter-desktop-embedding/tree/master/plugins/menubar">menubar 外掛</a>、<a href="https://api.flutter.dev/flutter/material/NavigationRail-class.html">NavigationRail Widget</a> 和 <a href="https://api.flutter.dev/flutter/material/DataTable-class.html">DataTable Widget</a>。您可能也對 <a href="https://api.flutter.dev/flutter/widgets/InteractiveViewer-class.html">InteractiveViewer Widget</a> 感興趣，它對滑鼠手勢（用於平移和縮放子 Widget）提供了完整的桌面支援。</p>
<p>另一組有用的 Widget 可以探索的是來自 <a href="https://pub.dev/publishers/syncfusion.com/packages">SyncFusion</a> 的 Widget，SyncFusion 在 Windows 開發社群中已經很有名。他們提供了大量企業級品質的 Widget，用於建立圖表、量規、資料網格等等。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*dY1TC_i0KyjKNrvh" />
</figure>

<p>這些 Widget 具有社群和企業許可證，因此您可以為您的專案找到合適的選項。</p>
<h3 id="Flutter-for-Windows-的實際應用"><a href="#Flutter-for-Windows-的實際應用" class="headerlink" title="Flutter for Windows 的實際應用"></a>Flutter for Windows 的實際應用</h3><p>除了 Windows 的套件和外掛（以及總體上的 Flutter 桌面）之外，Flutter 開發人員也一直在構建很棒的應用程式來以 Windows 為目標，例如來自 <a href="https://www.invoiceninja.com/">Invoice Ninja</a> 的這個實驗性版本：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ZuwlwG4e6fwCeQ_1" />
</figure>

<p>Invoice Ninja 是一家發票公司，它依賴 Flutter 來帶來收入。他們目前在生產環境中以 Android 和 iOS 為目標，並且為您提供了一個可以嘗試的 <a href="https://demo.invoiceninja.com/">基於網頁的演示</a>，但他們也展望著提供桌面版本。</p>
<blockquote>“在 Invoice Ninja，我們過去一直努力僅支援網頁和行動，一度維護了三個獨立的程式碼庫。使用 Flutter，更近一步使用 Flutter 桌面，我們已經能夠使用單個程式碼庫為所有主要平台構建應用程式。我們不僅基本獲得了應用程式的免費桌面版本，而且它的效能也最佳！”</blockquote>

<blockquote>— Hillel Coren，Invoice Ninja 的共同創辦人</blockquote>

<p>如果您對實作在行動和桌面外觀尺寸上運行的實際、產生收入的 Flutter 應用程式感興趣，<a href="https://github.com/invoiceninja/flutter-client">程式碼可在 GitHub 上獲得</a>。</p>
<p><a href="https://drone-detection-system.com/">Aartos</a> 是另一家正在構建很棒的產品的公司，包括一個使用 <a href="https://drone-detection-system.com/aartos-dds/product-overview/">Flutter 撰寫的多平台客戶端</a> 的即時無人機偵測系統。以下是一個早期版本的 Windows 客戶端，它與行動客戶端並排運行：</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FmGvPCT7Vc2Y%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DmGvPCT7Vc2Y&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FmGvPCT7Vc2Y%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/38e6826574e5d1090eb7a453f02c2480/href">https://medium.com/media/38e6826574e5d1090eb7a453f02c2480/href</a></iframe>

<p>這兩個版本都以 iOS 和 Windows 為目標，共享完全相同的程式碼庫。</p>
<p>如果您是經驗豐富的 Flutter 開發人員，並且發現自己經常在不同版本的 Flutter 之間切換；例如，一個版本用於發佈您的生產行動應用程式，另一個版本用於嘗試 Windows alpha 版本，那麼您可能會喜歡 Flutter 版本管理器，Flutter 版本管理器現在附帶了 <a href="https://github.com/leoafarias/fvm/releases">可以下載的 Windows GUI</a>。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F_WA71wSt2ww%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D_WA71wSt2ww&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F_WA71wSt2ww%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/b310e5f337134761f21ce3e179076a42/href">https://medium.com/media/b310e5f337134761f21ce3e179076a42/href</a></iframe>

<p>這個工具是開源的，因此您可以 <a href="https://github.com/leoafarias/fvm">親眼看看</a> Leo 如何讓它看起來如此棒。</p>
<h3 id="未來展望"><a href="#未來展望" class="headerlink" title="未來展望"></a>未來展望</h3><p>現在我們已經發佈了 alpha 版本，我們的注意力將轉移到完成功能集並穩定產品以供發佈。作為一個開源專案，您可以在我們的 <a href="https://github.com/flutter/flutter/projects/55">GitHub 網站上追踪我們的貝他版進度</a>，其中包括需要完成的剩餘工作，包括輔助功能、全球化和本地化、增強的鍵盤和文字處理、對命令行參數的支援等等。</p>
<p>除了支援經典的 Win32 API 之外，我們還在嘗試 <a href="https://docs.microsoft.com/en-us/windows/uwp/get-started/universal-application-platform-guide">基於 UWP 的 Flutter 外殼版本</a>，這讓 Flutter 可以到達更多種類的基於 Windows 的設備，包括 Xbox。作為該實驗的一部分，本週我們向 Windows 商店發佈了一個基於 UWP 的 <a href="https://www.microsoft.com/en-us/p/flutter-gallery/9pdwctdfc7qq">Flutter Gallery 版本</a>。</p>
<p>以下螢幕截圖顯示了基於 UWP 的 Flutter Gallery 在 Xbox 上運行：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*cNcLDSm8fwlwux15" />
</figure>

<p>以下是在運行 <a href="https://docs.microsoft.com/en-us/dual-screen/windows/get-dev-tools">Windows 10X 模擬器</a> 的雙螢幕 Windows 設備上運行的相同應用程式：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*ZIxhg4Lx_KI5v4bc1zi5zg.png" />
</figure>

<p><a href="https://github.com/flutter/flutter/issues/14967#issuecomment-697108439">您可以在 GitHub 上閱讀更多有關 Flutter for UWP 進度</a>。</p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>透過此版本，我們將 Flutter 的強大功能帶到了 Windows，它具有用於開發人員生產力的宣告式、可組合、反應式框架，以及 Material 規格的適應性實作，因此您可以讓應用程式以您想要的方式呈現和感覺，以及完整的 Flutter 開發和除錯工具集。完成後，您的應用程式將編譯為原生 64 位程式碼，您可以像任何其他原生應用程式一樣將其封裝並帶到其他 Windows 電腦。最後，您可以使用相同的程式碼庫來建立一個以 Android、iOS、網頁、macOS 和 Linux 為目標的應用程式。</p>
<p>如果您想開始使用 Flutter 建立 Windows 應用程式，我們非常歡迎您的 <a href="https://github.com/flutter/flutter/issues">回饋</a>！如果您想使用您的 Windows 專業知識來 <a href="https://flutter.dev/docs/development/packages-and-plugins/developing-packages#plugin">構建熱門外掛的 Windows 實作</a>，或者為 Flutter 建立一些以 Windows 為中心的工具（也許是一個從 flutter build windows 命令的輸出建立 MSIX 的 CLI…），也非常歡迎！</p>
<p>有了 Flutter 對 Windows 的新支援，您打算構建什麼？</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=33982cd0f433" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/announcing-flutter-windows-alpha-33982cd0f433">宣布 Flutter Windows Alpha</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/ab96634a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/ab96634a.html" class="post-title-link" itemprop="url">【文章翻譯】Handling Web Gestures in Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-21 13:31:41" itemprop="dateCreated datePublished" datetime="2020-09-21T13:31:41+08:00">2020-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="在-Flutter-中處理網頁手勢"><a href="#在-Flutter-中處理網頁手勢" class="headerlink" title="在 Flutter 中處理網頁手勢"></a>在 Flutter 中處理網頁手勢</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*BzcKF4qdbLIFFB6XL8x-9A.png" />
</figure>

<p>Flutter 發佈了網頁支援，讓您可以建立動態網站。有了 Flutter 網頁、MacOS、Linux 和 Windows 作業系統（甚至在連接到滑鼠、鍵盤或其他週邊設備的行動裝置上），您現在可以存取平台特定行為，包括焦點支援、鍵盤輸入、自訂滑鼠游標和懸停輸入。但是，您如何在 Flutter 中使用這些平台行為呢？</p>
<p>本文說明如何使用 <code>FocusableActionDetector</code> Widget，它處理鍵盤輸入、焦點輸入、懸停輸入和自訂滑鼠游標。</p>
<h3 id="如何使用-FocusableActionDetector-Widget"><a href="#如何使用-FocusableActionDetector-Widget" class="headerlink" title="如何使用 FocusableActionDetector Widget"></a>如何使用 <code>FocusableActionDetector</code> Widget</h3><p><code>FocusableActionDetector</code> Widget 允許您處理幾個網頁特定動作，包括：</p>
<ol>
<li>鍵盤輸入</li>
<li>焦點輸入</li>
<li>懸停輸入</li>
<li>自訂滑鼠游標</li>
</ol>
<p>在 <a href="https://dartpad.dev/d16345202d0e26d40fe14904657dc24a">DartPad #1</a> 範例中查看 <code>FocusableActionDetector</code> 的實際應用。</p>
<blockquote>**注意：**本文使用了兩個 DartPad 範例，儘管每個範例都有多個連結。[DartPad #1](https://dartpad.dev/d16345202d0e26d40fe14904657dc24a) 展示了 `FocusableActionDetector` 範例，而 [DartPad #2](https://dartpad.dev/5544c57e20454fe212e3ec5cf10b1f0a) 展示了 `FocusableActionDetector` 的懸停和焦點支援。</blockquote>

<h3 id="鍵盤輸入"><a href="#鍵盤輸入" class="headerlink" title="鍵盤輸入"></a>鍵盤輸入</h3><p>Flutter 允許您定義自訂動作來處理鍵盤輸入。假設您想要有一個隱藏的選單，或者您的應用程式必須處理大量的自訂鍵盤輸入。使用 <code>FocusableActionDetector</code> Widget 很容易做到這一點。</p>
<p>首先，加入以下匯入：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/services.dart&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>接下來，從調用 <code>FocusableActionDetector</code> 的類別中，初始化兩個私有變數。這些變數將鍵盤輸入映射到所需的動作：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;LogicalKeySet, Intent&gt; _shortcutMap;</span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, Action&lt;Intent&gt;&gt; _actionMap;</span><br></pre></td></tr></table></figure>

<p>定義一個 <code>FocusableActionDetector</code> Widget。請注意，自訂鍵盤輸入僅在子 Widget 獲得焦點時才會啟用：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FocusableActionDetector(</span><br><span class="line">  actions: _actionMap,</span><br><span class="line">  shortcuts: _shortcutMap,</span><br><span class="line">  child: </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>此類別將列舉和鍵盤輸入類型映射到 <code>Intent</code> 類別。以下設定是必要的，因為 <code>actions</code> 和 <code>shortcuts</code> 參數需要一個繼承自 <code>Intent</code> 的類別：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ShowSecretMessageIntent</span> <span class="keyword">extends</span> <span class="title">Intent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _ShowSecretMessageIntent(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.type&#125;);</span><br><span class="line">  <span class="keyword">const</span> _ShowSecretMessageIntent.P() : type = _SecretMessageType.P;</span><br><span class="line">  <span class="keyword">const</span> _ShowSecretMessageIntent.L() : type = _SecretMessageType.L;</span><br><span class="line">  <span class="keyword">const</span> _ShowSecretMessageIntent.A() : type = _SecretMessageType.A;</span><br><span class="line">  <span class="keyword">const</span> _ShowSecretMessageIntent.T() : type = _SecretMessageType.T;</span><br><span class="line">  <span class="keyword">const</span> _ShowSecretMessageIntent.F() : type = _SecretMessageType.F;</span><br><span class="line">  <span class="keyword">const</span> _ShowSecretMessageIntent.O() : type = _SecretMessageType.O;</span><br><span class="line">  <span class="keyword">const</span> _ShowSecretMessageIntent.R() : type = _SecretMessageType.R;</span><br><span class="line">  <span class="keyword">const</span> _ShowSecretMessageIntent.M() : type = _SecretMessageType.M;</span><br><span class="line">  <span class="keyword">final</span> _SecretMessageType type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> _SecretMessageType &#123;</span><br><span class="line">  P,</span><br><span class="line">  L,</span><br><span class="line">  A,</span><br><span class="line">  T,</span><br><span class="line">  F,</span><br><span class="line">  O,</span><br><span class="line">  R,</span><br><span class="line">  M,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>initState</code> 方法中，初始化之前定義的映射：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> initState() &#123;</span><br><span class="line">  _shortcutMap = &lt;LogicalKeySet, Intent&gt;&#123;</span><br><span class="line">    LogicalKeySet(LogicalKeyboardKey.keyP):</span><br><span class="line">      <span class="keyword">const</span> _ShowSecretMessageIntent.P(),</span><br><span class="line">    LogicalKeySet(LogicalKeyboardKey.keyL):</span><br><span class="line">      <span class="keyword">const</span> _ShowSecretMessageIntent.L(),</span><br><span class="line">    LogicalKeySet(LogicalKeyboardKey.keyA):</span><br><span class="line">      <span class="keyword">const</span> _ShowSecretMessageIntent.A(),</span><br><span class="line">    LogicalKeySet(LogicalKeyboardKey.keyT):</span><br><span class="line">      <span class="keyword">const</span> _ShowSecretMessageIntent.T(),</span><br><span class="line">    LogicalKeySet(LogicalKeyboardKey.keyF):</span><br><span class="line">      <span class="keyword">const</span> _ShowSecretMessageIntent.F(),</span><br><span class="line">    LogicalKeySet(LogicalKeyboardKey.keyO):</span><br><span class="line">      <span class="keyword">const</span> _ShowSecretMessageIntent.O(),</span><br><span class="line">    LogicalKeySet(LogicalKeyboardKey.keyR):</span><br><span class="line">      <span class="keyword">const</span> _ShowSecretMessageIntent.R(),</span><br><span class="line">    LogicalKeySet(LogicalKeyboardKey.keyM):</span><br><span class="line">      <span class="keyword">const</span> _ShowSecretMessageIntent.M(),</span><br><span class="line">    &#125;;</span><br><span class="line">  _actionMap = &lt;<span class="built_in">Type</span>, Action&lt;Intent&gt;&gt;&#123;</span><br><span class="line">    _ShowSecretMessageIntent: CallbackAction&lt;_ShowSecretMessageIntent&gt;(</span><br><span class="line">      onInvoke: _actionHandler,</span><br><span class="line">    ),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>動作處理程序將鍵盤輸入連結到應用程式中的特定函數。每次按下字元時，都會在應用程式的主要部分加入一個展開的容器。但在您的應用程式中，您可以將其用於更具創意目的：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _actionHandler(_ShowSecretMessageIntent intent) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (intent.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> _SecretMessageType.P:</span><br><span class="line">      setState(() &#123;</span><br><span class="line">        children.add(</span><br><span class="line">          Expanded(</span><br><span class="line">            child: Container(</span><br><span class="line">              color: Colors.orange,</span><br><span class="line">              child: Text(<span class="string">&#x27;Press L&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        );</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="焦點輸入"><a href="#焦點輸入" class="headerlink" title="焦點輸入"></a>焦點輸入</h3><p><code>FocusableActionDetector</code> Widget 允許您在指定 Widget 獲得焦點時執行動作呼叫。</p>
<p>焦點樹允許您使用 Tab 鍵在應用程式中瀏覽。這讓有視力障礙的人能夠瀏覽您的網站。</p>
<p><code>FocusableActionDetector</code> 子 Widget 被選為初始焦點，當其作用域中的其他節點目前沒有焦點時。如果您希望您的自訂鍵盤輸入在子 Widget 是否有焦點都不受影響的情況下運作，則將 <code>autofocus</code> 參數變數設定為 <code>true</code> 很重要。這是因為，預設情況下，此 <code>FocusableActionDetector</code> Widget 將不會獲得焦點，因此您將無法使用自訂鍵盤輸入：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FocusableActionDetector(</span><br><span class="line">  autofocus: <span class="keyword">true</span>,</span><br><span class="line">  child : …</span><br><span class="line">),</span><br></pre></td></tr></table></figure>

<p>假設您希望子 Widget 在獲得焦點時具有不同的顏色，以識別此 Widget 目前是否有焦點。如果您需要在 Widget 獲得焦點時設定自訂動作，請使用 <code>onShowFocusHighlight</code> 屬性。</p>
<p><a href="https://dartpad.dev/5544c57e20454fe212e3ec5cf10b1f0a">DartPad #2</a> 範例展示了如何使用 <code>onShowFocusHighlight</code> 屬性。</p>
<p>焦點是一個進階主題。透過閱讀 <a href="https://api.flutter.dev/flutter/widgets/Focus-class.html">Focus</a> 類別的 API 文件，您可以進一步了解焦點。</p>
<h3 id="懸停輸入"><a href="#懸停輸入" class="headerlink" title="懸停輸入"></a>懸停輸入</h3><p><code>FocusableActionDetector</code> Widget 允許您處理懸停輸入。這樣一來，每當游標懸停在特定 Widget 上時，就會發生自訂動作。與 <code>onShowFocusHighlight</code> 屬性類似，<code>onShowHoverHighlight</code> 屬性讓您能夠在滑鼠游標懸停在特定 Widget 上時建立自訂動作。</p>
<p>查看 <a href="https://dartpad.dev/5544c57e20454fe212e3ec5cf10b1f0a">DartPad #2</a> 範例，它展示了如何實作自訂懸停和焦點動作。</p>
<p>在 <a href="https://dartpad.dev/5544c57e20454fe212e3ec5cf10b1f0a">DartPad #2</a> 範例中，每當滑鼠懸停在 Widget 上時，它就會更改 Widget 的顏色。如果您使用 Tab 鍵在應用程式中瀏覽，您會注意到，與目前被懸停的 Widget 相比，獲得焦點的 Widget 會對 Widget 應用不同的陰影。</p>
<p>這意味著您可以在 Widget 獲得焦點或滑鼠游標懸停在該 Widget 上時，執行不同的自訂動作。如果您將滑鼠懸停在同一個 Widget 上並使它獲得焦點，您就可以看出來。該 Widget 會同時對該 Widget 應用兩個陰影。若要了解更多資訊，請查看 <a href="https://api.flutter.dev/flutter/widgets/FocusableActionDetector-class.html">FocusableActionDetector</a> 類別的 API 文件。</p>
<h3 id="自訂滑鼠游標"><a href="#自訂滑鼠游標" class="headerlink" title="自訂滑鼠游標"></a>自訂滑鼠游標</h3><p><code>FocusableActionDetector</code> Widget 讓您能夠實作自訂滑鼠游標。例如，如果您希望使用者知道特定 Widget 是可拖曳的，更改滑鼠游標是一個很好的指示，表示您可以執行此操作。<code>FocusableActionDetector</code> Widget 具有 <code>mouseCursor</code> 參數。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mouseCursor: SystemMouseCursors.grabbing</span><br></pre></td></tr></table></figure>

<p><a href="https://dartpad.dev/d16345202d0e26d40fe14904657dc24a">DartPad #1</a> 範例展示了 Flutter 中不同類型的滑鼠游標。點擊應用程式列中的任何圖示以嘗試使用。有九種不同的系統預設滑鼠游標：</p>
<ol>
<li><code>SystemMouseCursors.basic</code></li>
<li><code>SystemMouseCursors.text</code></li>
<li><code>SystemMouseCursors.click</code></li>
<li><code>SystemMouseCursors.forbidden</code></li>
<li><code>SystemMouseCursors.grab</code></li>
<li><code>SystemMouseCursors.grabbing</code></li>
<li><code>SystemMouseCursors.horizontalDoubleArrow</code>（未在穩定版本中）</li>
<li><code>SystemMouseCursors.verticalDoubleArrow</code>（未在穩定版本中）</li>
<li><code>SystemMouseCursors.none</code></li>
</ol>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>在 Flutter 中，您可以存取網頁特定 API。<code>FocusableActionDetector</code> Widget 讓您能夠在 Flutter 中處理網頁特定功能。若要進一步了解 Flutter 網頁，請查看 Medium 文章 <a href="https://medium.com/flutter/handling-404-page-not-found-error-in-flutter-731f5a9fba29">Handling 404: Page not found error in Flutter</a>。</p>
<p><em>關於作者：Jose 最近從大學畢業，現在在 <a href="https://material.io/">Material</a> 工作，這是一個幫助團隊構建高品質數位體驗的設計系統。Jose 的團隊維護 Flutter 的 <a href="https://api.flutter.dev/flutter/material/material-library.html">material 函式庫</a>。若要了解更多資訊，請訪問 Jose 在 <a href="https://github.com/JoseAlba">GitHub</a>、<a href="https://www.linkedin.com/in/josealba1996/">LinkedIn</a>、<a href="https://www.youtube.com/channel/UCOdKA_On0oPe1tz02z1QfxA?view_as=subscriber">YouTube</a> 和 <a href="https://www.instagram.com/jose.alba/">Instagram</a> 上的頁面。</em></p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e16946a04745" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/handling-web-gestures-in-flutter-e16946a04745">在 Flutter 中處理網頁手勢</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/a3b110e7.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/a3b110e7.html" class="post-title-link" itemprop="url">【文章翻譯】Supporting iOS 14 and Xcode 12 with Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-16 17:39:09" itemprop="dateCreated datePublished" datetime="2020-09-16T17:39:09+08:00">2020-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="使用-Flutter-支援-iOS-14-和-Xcode-12"><a href="#使用-Flutter-支援-iOS-14-和-Xcode-12" class="headerlink" title="使用 Flutter 支援 iOS 14 和 Xcode 12"></a>使用 Flutter 支援 iOS 14 和 Xcode 12</h2><p>與往常一樣，我們的目標是讓開發人員在 Flutter 上取得成功，無論您要鎖定的平台為何。自 6 月宣布 iOS 14 以來，我們一直在努力為 Flutter 加入支援此版本的新功能，包括更新 <a href="https://github.com/flutter/flutter/issues/60133">Xcode 12 支援</a>，以及加入支援 <a href="https://github.com/flutter/flutter/issues/61047">iOS 14</a> 的新功能和改進。</p>
<p>如果您的 iOS 14 應用程式使用 <a href="https://api.flutter.dev/flutter/material/TextField-class.html">TextField</a>、<a href="https://api.flutter.dev/flutter/cupertino/CupertinoTextField-class.html">CupertinoTextField</a> 或 <a href="https://api.flutter.dev/flutter/material/TextFormField-class.html">TextFormField</a>，您需要確保它使用 Flutter 1.20 或更高版本構建，以確保您的使用者不會受到不必要的剪貼簿通知訊息的困擾，這符合 Apple 更新的剪貼簿政策。</p>
<p><strong>否則，現有的生產應用程式將在您的終端使用者 iOS 14 設備上順利運行。</strong> 但是，如果您今天要將開發手機升級到 iOS 14 並希望繼續與 Flutter 一起使用它，您有兩個選擇。</p>
<p>您的第一個選擇是使用穩定頻道上的 <a href="https://github.com/flutter/flutter/wiki/Hotfixes-to-the-Stable-Channel">Flutter 最新修補程式版本</a> (1.20.4)，它支援將應用程式部署到實體 iOS 14 設備進行開發。不幸的是，還需要另一個更具侵入性（因此風險更大）的變更才能在 iOS 14 上進行除錯和熱重載。我們將此修復推遲到我們下一個穩定版本，我們計劃在下週釋出。</p>
<p>您的第二個選擇是使用我們今天釋出的即將到來的 Flutter 1.22 的 beta 版。此版本包含對 iOS 14 的更全面支援，包括更新的視覺效果、應用程式片段和 Xcode 12 支援。當它發佈到穩定頻道時，我們將分享更多關於其功能集的信息，但在此之前，我們建議您在需要立即支援 iOS 14 的情況下使用此 beta 版本。</p>
<p>若要取得 Flutter 1.22 beta 版，請使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ flutter channel beta</span><br><span class="line">$ flutter upgrade</span><br></pre></td></tr></table></figure>

<p>無論哪種情況，您都需要查看 <a href="https://flutter.dev/docs/development/ios-14">針對 iOS 14 開發頁面</a>，以獲取有關使用 Flutter 鎖定 iOS 14 的有用資訊。如果您在 iOS 14 中遇到任何問題，請 <a href="https://github.com/flutter/flutter/issues">在 Flutter 儲存庫中提交議題</a>。如果您有任何問題，請在 <a href="https://groups.google.com/g/flutter-dev">flutter-dev 群組</a> 中發布。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=15fe0062e98b" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/supporting-ios-14-and-xcode-12-with-flutter-15fe0062e98b">使用 Flutter 支援 iOS 14 和 Xcode 12</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/9735e3e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/9735e3e.html" class="post-title-link" itemprop="url">【文章翻譯】Handling 404: Page not found error in Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-10 22:13:20" itemprop="dateCreated datePublished" datetime="2020-06-10T22:13:20+08:00">2020-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 20:24:11" itemprop="dateModified" datetime="2024-09-30T20:24:11+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/850/1*eU-430nepv8cz3OYLIycng.png" /></figure>

<p>Flutter 釋出了網頁支援，允許您建立動態網站。Flutter 支援處理任何可能來自網頁使用的錯誤，例如 404 錯誤。但是，如何為您的 Flutter 應用程式製作自訂 404 頁面呢？</p>

<p>本文將說明如何建立在使用者導航到不存在的頁面時顯示的自訂頁面。</p>

<h3>如何在 Flutter 中將客戶端重新導向到自訂 404 頁面</h3>

<p>在瀏覽網際網路時，每個人都遇到過「404：頁面未找到錯誤」。Flutter 透過自動將您重新導向到初始路徑來處理此問題。這通常是您應用程式的首頁。但是，如果您想要像 [AirBnb](https://36bvmt283fg61unuud3h7qua-wpengine.netdna-ssl.com/wp-content/uploads/2013/03/airbnb-404.gif)、[GitHub](https://mamchenkov.net/wordpress/wp-content/uploads/2013/11/github-404.png) 甚至 [Flutter 網站](https://flutter.dev/foo) 那樣擁有華麗的 404 頁面該怎麼辦？您可以使用 Flutter 很輕鬆地做到這一點。</p>

<p>若要建立自訂 404 頁面，您的應用程式需要使用 MaterialApp、CupertinoApp 或 WidgetsApp Widget。大多數應用程式使用這三個 Widget 之一；它是在建立 Flutter 應用程式時呼叫的第一個 Widget。</p>

<p>MaterialApp 會將頂層 Navigator 組態設定為按以下順序搜尋路徑：</p>

<ol>
<li>對於 `/` 路徑，如果非空，則使用 [home](https://api.flutter.dev/flutter/material/MaterialApp/home.html) 屬性。</li>
<li>否則，如果它包含該路徑的條目，則使用 [routes](https://api.flutter.dev/flutter/material/MaterialApp/routes.html) 表格。</li>
<li>否則，如果提供，則呼叫 [onGenerateRoute](https://api.flutter.dev/flutter/material/MaterialApp/onGenerateRoute.html)。它應該為任何有效的路徑返回一個非空值，這些路徑未由 [home](https://api.flutter.dev/flutter/material/MaterialApp/home.html) 和 [routes](https://api.flutter.dev/flutter/material/MaterialApp/routes.html) 處理。</li>
<li>最後，如果所有其他方法都失敗了，則呼叫 [onUnknownRoute](https://api.flutter.dev/flutter/material/MaterialApp/onUnknownRoute.html)。</li>
</ol>

<p>如果您的路徑在這些表格中都沒有處理，則它使用 [onUnknownRoute](https://api.flutter.dev/flutter/material/MaterialApp/onUnknownRoute.html) 屬性來處理您的導航。此回呼通常用於錯誤處理。例如，此函數可能會始終產生一個「未找到」頁面，描述未找到的路徑。位置不明的路徑可能是由於應用程式中的錯誤或從 Android 意圖等外部請求推送路徑造成的。</p>

<p>以下範例程式碼演示如何為 onUnknownRoute 屬性定義一個匿名函數，該函數使用 RouteFactory，RouteFactory 是一個工廠方法，它以 RouteSettings 函數作為輸入，並返回一個 Route。以下程式碼片段顯示定義 onUnknownRoute 屬性可以多麼簡單：</p>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onUnknownRoute: (settings) &#123;</span><br><span class="line">  return MaterialPageRoute(builder: (_) =&gt; PageNotFound());</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>PageNotFound 是一個自訂 Widget，用於建立 404 頁面。此頁面可能會說明發生了什麼情況，並將使用者重新導向到首頁，但在建立 404 頁面時，您可以隨心所欲。</p>

<h3>結束語</h3>

<p>在建立 Flutter 應用程式時，重要的是要處理任何可能發生的問題。在 MaterialApp、CupertinoApp 或 WidgetApp 中使用 onUnknownRoute 屬性，可以讓您處理網站中不可避免的「頁面未找到」錯誤。</p>

<p>若要進一步了解 Flutter 中的路徑，請參閱 Medium 文章 [「使用命名路徑導航 URL 」](https://medium.com/flutter/flutter-web-navigating-urls-using-named-routes-307e1b1e2050)。</p>

<p><em>關於作者：Jose 最近從大學畢業，現在在 [Material](https://material.io) 工作，Material 是一個設計系統，幫助團隊建立高品質的數位體驗。Jose 的團隊維護 Flutter 的 [material 函式庫](https://api.flutter.dev/flutter/material/material-library.html)。若要進一步了解，請訪問 Jose 在 [GitHub](https://github.com/JoseAlba)、[LinkedIn](https://www.linkedin.com/in/josealba1996/)、[YouTube](https://www.youtube.com/channel/UCOdKA_On0oPe1tz02z1QfxA?view_as=subscriber) 和 [Instagram](https://www.instagram.com/jose.alba/) 上的頁面。</em></p>
<img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=731f5a9fba29" width="1" height="1"><hr><p><a href="https://medium.com/flutter/handling-404-page-not-found-error-in-flutter-731f5a9fba29">處理 Flutter 中的 404：頁面未找到錯誤</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> 

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rainvisitor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">160</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">181</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rainvisitor</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
