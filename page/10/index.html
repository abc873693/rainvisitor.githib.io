<!DOCTYPE html>
<html lang="zh-tw,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rainvisitor.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/page/10/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.rainvisitor.me/page/10/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-tw'
  };
</script>

  <title>RainVisitor Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RainVisitor Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">RainVisitor</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/73458861.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/73458861.html" class="post-title-link" itemprop="url">【文章翻譯】Perspectives from early adopters of Flutter as a game development tool</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-12 16:02:39" itemprop="dateCreated datePublished" datetime="2022-05-12T16:02:39+08:00">2022-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="來自-Flutter-遊戲開發工具早期採用者的觀點"><a href="#來自-Flutter-遊戲開發工具早期採用者的觀點" class="headerlink" title="來自 Flutter 遊戲開發工具早期採用者的觀點"></a>來自 Flutter 遊戲開發工具早期採用者的觀點</h2><h3 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h3><p>在今年的 Google I&#x2F;O 上，我們推出了 <a href="http://flutter.dev/games">Flutter 休閒遊戲工具包</a>，這個工具包是一套資源，用於支援 Flutter 社群中的遊戲開發者。在此之前，Flutter 並未將遊戲開發作為官方支援的用例，儘管我們對一些成功案例印象深刻，例如流行的文字解謎遊戲 <a href="https://apps.apple.com/app/4-pics-1-word/id595558452">4 圖 1 字</a> 以及 <a href="https://flame-engine.org/">Flame</a> 引擎等社群努力。<em>那麼，為什麼我們決定正式支持遊戲開發，以及我們如何決定工具包的初始版本應該包含哪些內容呢？</em> 在這篇文章中，我們將分享與 Flutter 遊戲開發工具的早期採用者進行的兩項使用者研究，並解釋他們的觀點如何塑造我們的策略和工具包的設計。</p>
<p>我們從一項訪談研究開始，在研究中，我們分別與 6 位成功開發和發佈了 Flutter 遊戲的開發者（稱為 P01 到 P06）進行了會面。我們對這項研究有兩個目標。第一是了解哪些類型的資源對於開始進行 Flutter 遊戲開發最有用。第二是更好地了解 Flutter 開發者在遊戲開發中的動機、需求和痛點，並利用這種理解來戰略性地規劃我們對該領域的長期投資。為了補充訪談的定性研究結果，我們還在廣泛的 Flutter 使用者社群中針對這個主題進行了一項調查。</p>
<p>在本文的其餘部分，我們首先總結了訪談和調查研究的主要發現，然後我們分享關於市場定位、文件和學習資源以及潛在的長期投資以支援 Flutter 遊戲開發者的建議。</p>
<h3 id="開發者訪談的發現"><a href="#開發者訪談的發現" class="headerlink" title="開發者訪談的發現"></a>開發者訪談的發現</h3><h4 id="Flutter-遊戲開發者的背景"><a href="#Flutter-遊戲開發者的背景" class="headerlink" title="Flutter 遊戲開發者的背景"></a>Flutter 遊戲開發者的背景</h4><p>總體而言，我們發現了當今存在的兩種 Flutter 遊戲開發者原型：</p>
<ul>
<li><strong>應用程式 - 遊戲混合開發者：</strong> 他們是 Flutter 應用程式開發者，但他們也利用 Flutter 開發相對簡單的遊戲，而不需要使用其他工具。（P02、P04 和 P05）</li>
<li><strong>計算機藝術家和圖形愛好者：</strong> 他們主要被 Flutter 提供的對圖形的控制程度所吸引，但他們可能不會將 Flutter 用於應用程式開發。（P01 和 P03）</li>
</ul>
<p>下表提供了有關我們在本次研究中所訪談的開發者背景的更多資訊。有幾位是由 Flame 團隊推薦給我們的。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/454630070af4bb296b7d344fad767d01/href">https://medium.com/media/454630070af4bb296b7d344fad767d01/href</a></iframe>

<h4 id="使用-Flutter-開發遊戲的感知益處"><a href="#使用-Flutter-開發遊戲的感知益處" class="headerlink" title="使用 Flutter 開發遊戲的感知益處"></a>使用 Flutter 開發遊戲的感知益處</h4><p>參與者列出了使用 Flutter 開發遊戲的許多益處。我們列出了下面由多位參與者提到的那些益處：</p>
<ul>
<li><strong>簡單性：</strong> 參與者認為，與 Unity 和 Unreal 等大型遊戲引擎相比，使用 Flutter 開發 2D 休閒遊戲更容易上手，也更不複雜。（P03、P04）</li>
<li><strong>控制：</strong> 參與者欣賞能夠在 IDE 中看到 Flutter 的原始碼，並完全直接地控制畫布。（P01、P02、P04）</li>
<li><strong>生態系統：</strong> 開發者可以利用 Flutter 生態系統中的套件，例如資料持久性和音訊播放。（P01、P02、P03、P04）具體而言，P01 認為 Flutter 的音訊功能優於其他跨平台 UI 工具包。</li>
<li><strong>跨平台：</strong> 參與者欣賞輕鬆部署到 iOS 和 Android 的便利性，並認為它提供了「真正的單一程式碼庫」。 (P01) 但是，由於遊戲引擎通常是跨平台的，所以這並不常被提及。</li>
<li><strong>輕鬆建立 UI：</strong> Flutter 遊戲可以在其 UI 中輕鬆利用任何 Flutter Widget。（P04、P05）這對於更類似於應用程式的遊戲特別有用，這些遊戲不需要使用遊戲引擎（例如，P05 和 P06 開發的文字解謎遊戲）。</li>
<li><strong>學習機會：</strong> Flutter 和 Flame 的開源性質提供了一個機會，透過開發遊戲來深入了解遊戲引擎和圖形管線。（P03）</li>
<li><strong>Flame 遊戲引擎：</strong> 使用 Flame 的參與者普遍對該專案及其功能以及 Flame 提供的支持表示肯定。P04 特別是在 Flutter 上開發了一款遊戲，因為他發現了 Flame。</li>
</ul>
<h4 id="使用-Flutter-開發遊戲的感知挑戰"><a href="#使用-Flutter-開發遊戲的感知挑戰" class="headerlink" title="使用 Flutter 開發遊戲的感知挑戰"></a>使用 Flutter 開發遊戲的感知挑戰</h4><p>作為一個新興用例，在 Flutter 上開發遊戲並非沒有挑戰。參與者強調了他們在各自專案中遇到的以下問題：</p>
<ul>
<li><p>整合和生態系統：</p>
<ul>
<li>难以與 Play 遊戲服務整合。（P01、P03）</li>
<li>缺少用於離線優先資料庫的良好選項，這些資料庫具有衝突管理功能。（P05）</li>
<li>需要指導以選擇最佳的音訊外掛，該外掛可以同時在前景和背景中播放音訊。（P05）</li>
<li>資產：尋找和建立高品質的遊戲資產非常耗時。（P02、P03、P04）</li>
</ul>
<blockquote>
<ul>
<li>這可能是最耗時的過程。如果我找不到彼此相符的資產，遊戲看起來就不會完全是我想要的樣子。而且由於我不太擅長製作藝術品，所以找到合適的資產對我來說是最具挑戰性的任務。 (P03) *</li>
</ul>
</blockquote>
</li>
<li><p>Flame 特定的挑戰：</p>
<ul>
<li>參與者指出，Flame 的文件對初學者不友好。特別是，<a href="https://github.com/flame-engine/forge2d">Forge2D</a>（Flame 的一部分）需要更好的文件。（P03、P04）</li>
<li>參與者指出，Flame 中的碰撞檢測過於基礎。在兩個物體碰撞後，它不會處理物理效果，除非您使用 Forge2D。（P03）</li>
</ul>
</li>
<li><p>Flutter SDK 和工具中缺少的功能：</p>
<ul>
<li>缺乏 3D 支援。（P02、P03）但是，這對這些參與者來說似乎並不重要。</li>
<li>沒有用於濾鏡、效果、層或合成圖的直接著色器訪問權。（P01、P02）這對熱衷於電腦圖形的參與者來說比較重要。</li>
<li>缺少用於控制更新率（例如 120hz）的使用者空間 API。（P01、P02）</li>
<li>不確定 Flutter 是否擁有提供對畫面緩衝區可見性的著色器除錯工具。Xcode 有很棒的 OpenGL 除錯工具。（P01）</li>
</ul>
</li>
<li><p>效能和套件大小：</p>
<ul>
<li>DevTools 在診斷具有遊戲迴圈的遊戲的效能問題時並不總是很有用。（P02）</li>
<li>在低階 iOS 設備上存在動畫卡頓。著色器預熱解決方案很有用，但非常耗費人力。 (P05) 也沒有關於如何做到的視訊教學。(P03)</li>
<li>缺乏對根據設備的效能特性調整應用程式渲染品質的支持。 (P05)</li>
<li>Web 套件大小對於 Facebook Instant Game 等網頁遊戲平台來說太大。 (P05)</li>
</ul>
</li>
</ul>
<h4 id="將-Flutter-與其他遊戲開發工具進行比較"><a href="#將-Flutter-與其他遊戲開發工具進行比較" class="headerlink" title="將 Flutter 與其他遊戲開發工具進行比較"></a>將 Flutter 與其他遊戲開發工具進行比較</h4><p>由於本研究的選擇標準，所有參與者對其他遊戲引擎的經驗都非常有限。但是，他們就入門、控制感和套件生態系統提供了他們的印象。</p>
<p>首先，參與者認為 Flutter&#x2F;Flame 比 Unity 和 Unreal 等大型遊戲引擎更容易上手和理解。（P01、P02、P03、P04）參與者發現，Unity 或 Unreal 中的許多功能與他們正在開發的遊戲類型無關。</p>
<p>其次，由於我們的參與者是經驗豐富的程式設計師，他們發現很難從 Unity 或 Unreal 的低程式碼開發環境中獲得他們需要的控制權。</p>
<blockquote>
<p><em>我真的很喜歡深入研究並完全控制所有細節。因此，使用 Flutter，Flame 引擎非常開放。我覺得我真的擁有完全的控制權，而在 Unity 中，一切都隱藏起來了。他們試圖為休閒使用者自動化某些操作。 (P01)</em></p>
</blockquote>
<p>最後但並非最不重要的是，Flutter 的生態系統被認為優於其他輕量級遊戲引擎，例如 <a href="https://godotengine.org/">Godot</a>（P02、P03）。例如，P03 表示，使用 <code>package:hive</code>，在原生平台上進行資料持久化非常容易。他懷疑使用 Godot 可能需要原生程式碼。</p>
<h3 id="對第一次使用-Flutter-開發遊戲的開發者有用的資源"><a href="#對第一次使用-Flutter-開發遊戲的開發者有用的資源" class="headerlink" title="對第一次使用 Flutter 開發遊戲的開發者有用的資源"></a>對第一次使用 Flutter 開發遊戲的開發者有用的資源</h3><p>所有參與者都提到，在開始使用 Flutter 開發遊戲時，他們需要更好的文件和學習資源。為了確定優先順序，我們要求參與者透過將不同類型的資源分類到三個桶中來評估它們對遊戲開發的重要性：<em>必須擁有</em>、<em>應該擁有</em> 和 <em>可以擁有</em>。以下清單顯示了所得的桶：</p>
<p>「必須擁有」的資源包括：</p>
<ul>
<li><p>一個 <strong>範例遊戲</strong>，其中預先整合了常見的遊戲特定技術（例如音訊支援）和平台遊戲服務（例如 Google Play 服務）。</p>
</li>
<li><p><strong>一個專用的網站</strong>，其中包含所有遊戲開發資源以及有關第三方服務（例如套件、資產市場）的推薦。</p>
</li>
<li><p><strong>操作指南視訊</strong>，涵蓋基本的遊戲開發概念（例如遊戲迴圈）、與後端的整合、遊戲支援和變現服務。P03 也對像 <a href="https://www.youtube.com/playlist?list=PLjxrf2q8roU3ahJVrSgAnPjzkpGmL9Czl">無聊的表演</a> 等長篇視訊感興趣，這些視訊涵蓋了整個遊戲開發過程，包括疑難排解：</p>
<blockquote>
<ul>
<li>我覺得兩種不同的 [視訊] 內容會更好。一種是類似於「本週 Widget」的非常短的內容，然後是類似於「無聊的 Flutter 表演」的內容，其中您會深入了解整個過程，並逐步完成建立該遊戲的所有步驟。 (P03)*</li>
</ul>
</blockquote>
</li>
</ul>
<p>「應該擁有」的資源包括：</p>
<ul>
<li>一個專門針對 Flutter 遊戲的 Discord 頻道，這個頻道比 Flame 團隊的 Discord 更通用。</li>
</ul>
<p>「可以擁有」的資源包括：</p>
<ul>
<li>Codelabs</li>
<li>教師指導的研討會</li>
<li>Google 服務的信用額度（例如 GCP、廣告、Firebase）</li>
<li>直接存取專用支援</li>
</ul>
<p>根據參與者的寶貴意見，我們在休閒遊戲工具包的初始版本中優先考慮了「必須擁有」的資源。</p>
<h3 id="調查的發現"><a href="#調查的發現" class="headerlink" title="調查的發現"></a>調查的發現</h3><p>如前所述，我們進行了一項補充調查，以更廣泛地了解 Flutter 社群中的遊戲開發情況。以下圖表顯示了高階結果：</p>
<h4 id="Flutter-使用者有興趣使用-Flutter-開發遊戲"><a href="#Flutter-使用者有興趣使用-Flutter-開發遊戲" class="headerlink" title="Flutter 使用者有興趣使用 Flutter 開發遊戲"></a>Flutter 使用者有興趣使用 Flutter 開發遊戲</h4><p>許多 Flutter 使用者（62.4%）不知道他們可以使用 Flutter 開發遊戲，這並不奇怪。然而，39.2% 的人有興趣了解更多。</p>
<figure>
<img alt="Results for the survey question “Did you know that you can use Flutter to build games?” 39.3% — “No, and I’m interested in learning more.” 37.6% — “Yes.” 23.2% — “No, I’m not interested in the topic.”" src="https://cdn-images-1.medium.com/max/1024/0*n0cpV0PkueLSiSYx" />
</figure>

<p>許多 Flutter 使用者對使用 Flutter 開發遊戲的廣泛興趣也反映在許多 Flutter 使用者對遊戲開發並不陌生這一事實中。在 936 位受訪者中，有 500 多人有使用 Unity 的經驗，130 多人有使用 Unreal 的經驗，120 多人有使用 <a href="https://docs.flame-engine.org/1.0.0/#">Flame</a> 的經驗，80 多人有使用 Godot 的經驗。看到這麼多開發者已經具備遊戲開發技能，這令人鼓舞。</p>
<h4 id="許多-Flutter-遊戲開發者才剛起步"><a href="#許多-Flutter-遊戲開發者才剛起步" class="headerlink" title="許多 Flutter 遊戲開發者才剛起步"></a>許多 Flutter 遊戲開發者才剛起步</h4><p>然後，我們詢問那些了解或對 Flutter 開發遊戲的能力感興趣的人，他們在遊戲開發過程中處於什麼階段。在這個群體中，43.2% 尚未開始具體的遊戲專案，這表明需要入門支持。</p>
<figure>
<img alt="Summarized responses to the question: “which of the following statements best describe your experience using Flutter to build games?”" src="https://cdn-images-1.medium.com/max/1024/0*ZrpkIfhAQ0MW1RYp" />
</figure>

<h4 id="比我們想像的更多-Flutter-遊戲已經出現"><a href="#比我們想像的更多-Flutter-遊戲已經出現" class="headerlink" title="比我們想像的更多 Flutter 遊戲已經出現"></a>比我們想像的更多 Flutter 遊戲已經出現</h4><p>我們要求受訪者向我們指出他們使用 Flutter 開發的任何遊戲。令我們驚訝的是，我們收到了 148 個回覆。其中許多遊戲是 2D 解謎遊戲或 <a href="https://www.google.com/search?q=platformers+definition&amp;oq=platform&amp;aqs=chrome.0.69i59j46i67i433j69i64l3j69i65j69i60j69i61.2458j0j7&amp;sourceid=chrome&amp;ie=UTF-8">平台遊戲</a>，而其中一小部分嘗試使用 Flutter 創造擬 3D 效果。</p>
<p>使用 Flutter 開發非常成功的行動遊戲似乎是完全可能的。例如，我們透過這項調查了解的 Flutter 遊戲 <a href="https://play.google.com/store/apps/details?id=com.he2apps.kelimelik&amp;hl=en_US&amp;gl=US">Kelimelik</a> 在撰寫本文時在 Google Play 上獲得了 4.5 星的評分，有 356,000 多條評論和 500 萬次安裝！</p>
<figure>
<img alt="The kelimelik game’s listing on the Google Play store." src="https://cdn-images-1.medium.com/max/1024/1*gq-r9Mn1BzgKL8XYLnFsEQ.png" />
</figure>

<h4 id="Flutter-使用者希望更多關於遊戲開發的文件"><a href="#Flutter-使用者希望更多關於遊戲開發的文件" class="headerlink" title="Flutter 使用者希望更多關於遊戲開發的文件"></a>Flutter 使用者希望更多關於遊戲開發的文件</h4><p>當我們詢問受訪者什麼因素阻礙了他們在遊戲專案中的進展時，我們收到了 31 個回覆。其中許多與缺乏文件有關：</p>
<ul>
<li>「沒有足夠的教學，我沒有理解透徹。」</li>
<li>「沒有足夠的資源&#x2F;教學&#x2F;文件 (flutter flame)。」</li>
<li>「文件對初學者遊戲開發者並不友好。在教學或案例研究演練中，還有很多工作要做，才能為 Flame 元件建立一個非常清晰的入門介紹，並提供常見的場景，以幫助新入門者。」</li>
</ul>
<p>這個回饋呼應了我們從訪談研究中了解到的內容。調查受訪者還提到了缺少 3D 支援、使用著色器遇到困難以及特定硬體和視覺效果（例如陰影）的效能問題。</p>
<h3 id="建議"><a href="#建議" class="headerlink" title="建議"></a>建議</h3><p>我們的研究結果顯示了在 Flutter 上開發 2D 休閒遊戲的潛力。一些 Flutter 使用者嘗試過並成功發佈了高評分的遊戲，還有更多使用者有興趣在未來的幾個月裡開始嘗試。</p>
<p>為了讓這些新的遊戲開發者取得成功，我們必須適當地定位 Flutter 在市場上其他遊戲開發工具中的位置，並利用 Flutter 開放和參與的性質來完善其對遊戲開發的支持。</p>
<p>基於此，我們想提出一些建議，這些建議不僅針對 Google 的 Flutter 團隊，也針對 Flutter 社群的套件作者、工具開發者和內容創作者。</p>
<h3 id="市場定位"><a href="#市場定位" class="headerlink" title="市場定位"></a>市場定位</h3><p>研究結果表明了我們在遊戲開發工具市場中定位 Flutter 時需要考慮的三个维度：</p>
<p><strong>遊戲類型：</strong></p>
<ul>
<li>以 2D 休閒遊戲為目標是一個良好的起點。</li>
<li>解謎遊戲和平台遊戲是在 Flutter 中開發的成功子類別。</li>
</ul>
<p><strong>開發者類型：</strong></p>
<ul>
<li>希望利用 Flutter 的休閒遊戲開發能力的 Flutter 應用程式開發者（例如 P02、P04 和 P05）。</li>
<li>被 Flutter 提供的高度控制和開放性所吸引的計算機藝術家和圖形愛好者（例如 P01 和 P03）。</li>
</ul>
<p><strong>遊戲開發團隊類型：</strong></p>
<ul>
<li>我們可以專注於獨立遊戲開發者和混合遊戲&#x2F;應用程式代理商，這些代理商的專業角色較少，可以從 Flutter 的跨平台功能中獲益更多。</li>
</ul>
<h4 id="文件和學習資源"><a href="#文件和學習資源" class="headerlink" title="文件和學習資源"></a>文件和學習資源</h4><p>根據訪談研究的使用者意見，我們認為 Flutter 社群中的創作者和教育工作者可以透過專注於建立開源範例遊戲、操作指南視訊和為遊戲開發策劃資源列表來發揮最大作用。我們在 I&#x2F;O 上發佈的 Flutter 休閒遊戲工具包是我們沿著這些方向組織資源並提高它們在 Flutter 使用者中的可見度的第一次嘗試。</p>
<h4 id="對-Flutter-API-和功能的潛在投資"><a href="#對-Flutter-API-和功能的潛在投資" class="headerlink" title="對 Flutter API 和功能的潛在投資"></a>對 Flutter API 和功能的潛在投資</h4><p>在研究過程中，參與者指出了他們希望 Flutter SDK 在未來更好地支援的一些主要產品功能：</p>
<ul>
<li>著色器的可用性和支援（<a href="https://github.com/flutter/flutter/issues/93800">GitHub 議題</a>）。或者，如果函式庫維護者（例如 Flame）直接使用著色器 API，可能就足夠了（例如，P03 希望遊戲引擎中有一個更高階的抽象）。</li>
<li>Web 應用程式套件大小。一位參與者指出了將遊戲擴展到基於網頁的遊戲平台（例如 Facebook Instant Game）的問題。由於 Web 套件大小過大，他們最終選擇了 HTML 渲染後端，而不是速度更快但更大的 Canvas Kit 後端。（P05）</li>
<li>Windows&#x2F;Steam 支援。多位參與者表達了對嘗試使用他們的遊戲的全新 Windows 支援的濃厚興趣。其中一人提到，Windows 是最需要支持的平台，特別是如果您打算在 Steam 上發佈您的遊戲。（P03）但是，鑑於沒有參與者或我們的團隊成員在 Windows 上測試過遊戲開發或整合 Steam，所以這種情況仍然不明確。</li>
</ul>
<p>除了這三個改進領域之外，我們最近開始與社群成員合作，對與遊戲相關的議題進行分類，並將它們標記為 <a href="https://github.com/flutter/flutter/labels/a%3A%20gamedev">a: gamedev</a>。</p>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>我們從這兩項研究中了解到，包括 Flutter 使用者對遊戲開發的廣泛興趣，以及現有 Flutter 遊戲開發者所欣賞的 Flutter 的簡單性和高度控制，讓團隊對追求遊戲開發作為可行的用例充滿信心。休閒遊戲工具包是我們在這個領域的第一項投資，我們期待在後續研究中了解我們的社群成員如何利用它。</p>
<h3 id="致謝"><a href="#致謝" class="headerlink" title="致謝"></a>致謝</h3><p><a href="https://medium.com/@zoeyfan_43394">Zoey Fan</a>、<a href="https://twitter.com/chrisfujino">Christopher Fujino</a> 和 <a href="https://medium.com/@jayoung.lee">JaYoung Lee</a> 參與了這項研究，<a href="https://medium.com/@shaza">Shams Zakhour</a> 編輯了這篇文章。我們要感謝參與這項研究的使用者，以及 Flame 團隊在參與者招募方面的支持。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f95fb3406d51" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/perspectives-from-early-adopters-of-flutter-as-a-game-development-tool-f95fb3406d51">來自 Flutter 遊戲開發工具早期採用者的觀點</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/7e790f7c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/7e790f7c.html" class="post-title-link" itemprop="url">【文章翻譯】Introducing Flutter 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-11 19:49:05" itemprop="dateCreated datePublished" datetime="2022-05-11T19:49:05+08:00">2022-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="邁向多平台-UI-開發的旅程：手機、桌面和網頁"><a href="#邁向多平台-UI-開發的旅程：手機、桌面和網頁" class="headerlink" title="邁向多平台 UI 開發的旅程：手機、桌面和網頁"></a>邁向多平台 UI 開發的旅程：手機、桌面和網頁</h2><p><em>我們很興奮地宣布，作為 Google I&#x2F;O 主題演講的一部分，Flutter 3 正式推出。Flutter 3 完成了我們從以行動為中心的框架到多平台框架的路線圖，其中包含 macOS 和 Linux 桌面應用程式支援的可用性，以及 Firebase 整合的改進、新的生產力與效能功能，以及對 Apple Silicon 的支援。</em></p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ZQ9Xa7CINFVMA95w" />
</figure>

<h3 id="Flutter-3-的旅程"><a href="#Flutter-3-的旅程" class="headerlink" title="Flutter 3 的旅程"></a>Flutter 3 的旅程</h3><p>我們最初開發 Flutter 的目標是徹底改變應用程式開發：將網頁的迭代開發模式與硬體加速的圖形渲染和像素級別控制（以前是遊戲的專利）結合起來。在 Flutter 1.0 beta 發佈後的過去四年裡，我們在這些基礎之上不斷發展，新增了新的框架功能和 Widget、與底層平台更深層次的整合、豐富的套件函式庫，以及許多效能和工具方面的改進。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*pL2z2iYzWPrMu5hw" />
</figure>

<p>隨著產品的成熟，越來越多的人開始使用 Flutter 構建應用程式。如今，使用 Flutter 構建的應用程式超過 500,000 個。來自 data.ai 等研究機構的分析，以及公開的見證表明，Flutter 被許多領域的 <a href="https://flutter.dev/showcase">廣泛客戶群</a> 使用：從像 <a href="https://play.google.com/store/apps/details?id=com.tencent.mm&amp;hl=en_US&amp;gl=US">微信</a> 這樣的社交應用程式，到像 <a href="https://apps.apple.com/us/app/betterment-investing-saving/id393156562">Betterment</a> 和 <a href="https://play.google.com/store/apps/details?id=com.nu.production&amp;hl=en_US&amp;gl=US">Nubank</a> 這樣的金融和銀行應用程式；從像 <a href="https://play.google.com/store/apps/details?id=com.zzkko&amp;hl=en_US&amp;gl=US">SHEIN</a> 和 <a href="https://apps.apple.com/us/app/trip-com-hotels-flights-trains/id681752345">trip.com</a> 這樣的電商應用程式，到像 <a href="https://fastic.com/">Fastic</a> 和 <a href="https://auspreneur.com.au/tabcorp-adopts-googles-flutter-platform/">Tabcorp</a> 這樣的休閒應用程式；從像 <a href="https://www.press.bmwgroup.com/global/article/detail/T0328610EN/the-my-bmw-app:-new-features-and-tech-insights-for-march-2021?language=en">My BMW</a> 這樣的伴侶應用程式，到像 <a href="https://apps.apple.com/app/id1506827551">巴西政府</a> 這樣的公共機構。</p>
<blockquote>如今，使用 Flutter 構建的應用程式超過 500,000 個。</blockquote>

<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F8RmsstcNE1Y%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D8RmsstcNE1Y&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F8RmsstcNE1Y%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/2abf9b2ad16ba8d94fa7f54c5768ebdc/href">https://medium.com/media/2abf9b2ad16ba8d94fa7f54c5768ebdc/href</a></iframe>

<p>開發人員告訴我們，Flutter 有助於更快速地為更多平台構建更精美的應用程式。在我們最近的使用者研究中：</p>
<ul>
<li>91% 的開發人員同意 Flutter 縮短了構建和發佈應用程式所需的時間。</li>
<li>85% 的開發人員同意 Flutter 使他們的應用程式比以前更精美。</li>
<li>85% 的開發人員同意它使他們能夠為比以前更多的平台發佈應用程式。</li>
</ul>
<p>在 <a href="https://tech-blog.sonos.com/posts/renovating-setup-with-flutter/">Sonos 最近的一篇部落格文章</a> 中，他們討論了他們改進的設定體驗，並強調了其中第二點：</p>
<blockquote>「毫不誇張地說，[Flutter] 解鎖了我們團隊以前從未實現的「*高級*」程度。對我們的設計師來說，最重要的是，可以輕鬆構建新的 UI，意味著我們的團隊花在對規格說「不」上的時間更少，花在迭代上的時間更多。如果這聽起來很划算，我們建議您試試 Flutter - 我們很慶幸我們嘗試了。」</blockquote>

<h3 id="介紹-Flutter-3"><a href="#介紹-Flutter-3" class="headerlink" title="介紹 Flutter 3"></a>介紹 Flutter 3</h3><p>今天，我們推出 Flutter 3，這是我們完成 Flutter 支援平台的旅程的成果。使用 Flutter 3，您可以從單個程式碼庫中為六個平台構建精美的體驗，為開發人員提供無與倫比的生產力，並讓新創公司能夠從第一天起就將新想法推向整個可服務市場。</p>
<p>在之前的版本中，我們在 iOS 和 Android 的基礎上補充了 <a href="https://medium.com/flutter/flutter-web-support-hits-the-stable-milestone-d6b84e83b425">網頁</a> 和 <a href="https://medium.com/flutter/announcing-flutter-for-windows-6979d0d01fed">Windows 支援</a>，現在 <strong>Flutter 3 新增了對 macOS 和 Linux 應用程式的穩定支援</strong>。新增平台支援需要的更多是渲染像素：它還包括新的輸入和互動模型、編譯和構建支援、無障礙性和國際化，以及平台特定的整合。我們的目標是讓您能夠靈活地充分利用底層作業系統，同時根據需要分享盡可能多的 UI 和邏輯。</p>
<p>在 macOS 上，我們在支援 Intel 和 Apple Silicon 上投資了，並提供了 <a href="https://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary">通用二進位檔</a> 支援，允許應用程式封裝在兩種架構上都能原生執行的可執行檔。在 Linux 上，Canonical 和 Google 合作提供了高度整合的、最優的開發選項。</p>
<p><a href="https://superlist.com/">Superlist</a> 是 Flutter 如何實現精美的桌面體驗的一個很好的範例，它今天以 beta 版推出。Superlist 提供超級加強的協作功能，透過一個新的應用程式將清單、任務和自由格式內容結合在一起，重新詮釋待辦事項清單和個人規劃。Superlist 團隊選擇 Flutter 是因為它能夠提供快速且高度品牌化的桌面體驗，我們認為他們迄今為止的進展證明了為什麼這是一個非常棒的選擇。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FYRuQj7mlH2I%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DYRuQj7mlH2I&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FYRuQj7mlH2I%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/e55485a40119915c1ee67f6e9bd45938/href">https://medium.com/media/e55485a40119915c1ee67f6e9bd45938/href</a></iframe>

<p>Flutter 3 還改進了許多基礎功能，包括改進的效能、Material You 支援和生產力更新。</p>
<p>除了上面提到的工作之外，透過這個版本，Flutter 在 <em>開發</em> 上完全原生於 <a href="https://support.apple.com/en-us/HT211814">Apple Silicon</a>。雖然 Flutter 自從推出以來就一直與搭載 M1 的 Apple 設備相容，但 Flutter 現在充分利用了 <a href="https://medium.com/dartlang/announcing-dart-2-14-b48b9bb2fb67">Dart 對 Apple Silicon 的支援</a>，使搭載 M1 的設備上的編譯速度更快，並支援 <a href="https://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary">通用二進位檔</a> <strong>用於 macOS 應用程式。</strong></p>
<p>我們對 <a href="https://m3.material.io/">Material Design 3</a> 的工作在這個版本中已基本完成，讓開發人員能夠利用自適應的跨平台設計系統，該系統提供動態色彩方案和更新的視覺組件：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*LM_w2DE9aM-_9J0Z" />
</figure>

<p>我們詳細的技術部落格文章將深入探討這些功能以及 Flutter 3 中的許多其他新功能。</p>
<p>Flutter 由 Dart 提供支援，Dart 是一種高生產力、可移植的語言，適用於多平台開發。我們在此週期的 Dart 工作包括新的語言功能，這些功能可以減少樣板程式碼並幫助提高可讀性、實驗性的 RISC-V 支援、升級的 linter 和新的文件。若要進一步了解 Dart 2.17 中的所有新改進，請查看 <a href="https://medium.com/dartlang">專門的部落格文章</a>。</p>
<h3 id="Firebase-和-Flutter"><a href="#Firebase-和-Flutter" class="headerlink" title="Firebase 和 Flutter"></a>Firebase 和 Flutter</h3><p>當然，構建應用程式需要的不仅仅是 UI 框架。應用程式發行商需要一套完整的工具來幫助您構建、發佈和運行應用程式，包括身份驗證、資料儲存、雲端函數和裝置測試等服務。有多種服務支援 Flutter，包括 <a href="https://docs.sentry.io/platforms/flutter/">Sentry</a>、<a href="https://appwrite.io/docs/getting-started-for-flutter">AppWrite</a> 和 <a href="https://docs.amplify.aws/start/q/integration/flutter/">AWS Amplify</a>。</p>
<p>Google 的應用程式服務產品是 Firebase，<a href="https://www.slashdata.co/developer-program-benchmarking/">SlashData 開發者基准研究</a> 表明 62% 的 Flutter 開發人員在他們的應用程式中使用 Firebase。因此，在過去的幾個版本中，我們一直在與 Firebase 合作，將 Flutter 作為一級整合擴展和改進整合。這包括將 Flutter 的 Firebase Plugin 提升至 1.0 版本，新增更好的文件和工具，以及像 <a href="https://pub.dev/packages/flutterfire_ui">FlutterFire UI</a> 這樣的新的 Widget，為開發人員提供可重複使用的 UI 用於身份驗證和檔案螢幕。</p>
<p>今天，我們宣布將 Flutter&#x2F;Firebase 整合升級為 Firebase 提供的全功能核心部分。我們將原始碼和文件移至 Firebase 的主要存取庫和網站，您可以信賴我們會讓 Flutter 的 Firebase 支援與 Android 和 iOS 同步發展。</p>
<p>此外，我們對支援使用 Crashlytics（Firebase 受歡迎的即時崩潰報告服務）的 Flutter 應用程式進行了重大改進。透過 <a href="https://firebase.google.com/docs/crashlytics">Flutter Crashlytics Plugin</a> 的更新，您可以即時追蹤致命錯誤，為您提供與其他 iOS 和 Android 開發人員相同的功能集。這包括重要的警報和指標，例如「無崩潰使用者」，可以幫助您掌握應用程式的穩定性。Crashlytics 分析管道已升級，以改進 Flutter 崩潰的聚類，讓您可以更快地對問題進行分類、優先排序和修復。最後，我們簡化了 Plugin 安裝過程，因此您只需幾個步驟即可從 Dart 程式碼中啟動並運行 Crashlytics。</p>
<h3 id="Flutter-休閒遊戲工具包"><a href="#Flutter-休閒遊戲工具包" class="headerlink" title="Flutter 休閒遊戲工具包"></a>Flutter 休閒遊戲工具包</h3><p>對於大多數開發人員來說，Flutter 是一個應用程式框架。但是，圍繞休閒遊戲開發的社群也在不斷增長，他們利用了 Flutter 提供的硬體加速圖形支援，以及像 <a href="https://flame-engine.org/">Flame</a> 這樣的開源遊戲引擎。我們希望讓休閒遊戲開發人員更容易入門，因此，在今天的 I&#x2F;O 上，我們宣布 <a href="https://flutter.dev/games">休閒遊戲工具包</a>，它提供了一套包含範例和最佳實務的入門套件，以及廣告和雲端服務的信用額度。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*wK4YI3N-Hh2vtDQ2" />
</figure>

<p>雖然 Flutter 不是為高強度 3D 動作遊戲而設計的，但甚至一些這樣的遊戲也開始使用 Flutter 來處理非遊戲 UI，包括像 <a href="https://play.google.com/store/apps/details?id=com.tencent.ig">PUBG Mobile</a> 這樣的熱門遊戲，該遊戲擁有數億使用者。為了讓 I&#x2F;O 更上一層樓，我們想看看我們可以將技術推到什麼程度，因此我們製作了一個有趣的彈珠台遊戲，該遊戲由 Firebase 和 Flutter 的 Web 支援提供支援。I&#x2F;O 彈珠台提供了一個自訂的桌子，設計圍繞著 Google 的四個最喜歡的吉祥物：Flutter 的 Dash、Firebase 的 Sparky、Android 機器人和 Chrome 恐龍，讓您可以與其他人競爭高分。我們認為這是一個展示 Flutter 多功能性的有趣方式。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*87xQ1AYdEF2YrmQ1" />
</figure>

<h3 id="由-Google-贊助，社群提供支援"><a href="#由-Google-贊助，社群提供支援" class="headerlink" title="由 Google 贊助，社群提供支援"></a>由 Google 贊助，社群提供支援</h3><p>我們喜歡 Flutter 的一點是，它不仅仅是 Google 的產品，它是「大家的」產品。開源意味著我們都可以參與其中，並在它的成功中發揮作用，無論是貢獻新的程式碼還是文件，建立賦予核心框架新能力的套件，撰寫書籍和培訓課程來教導他人，還是幫助組織活動和使用者群組。</p>
<p>為了展示社群的最佳一面，我們最近與 DevPost 合作，贊助了一項拼圖黑客挑戰賽，讓開發人員有机会透過重新構思經典的滑動拼圖來展示他們的技能。這證明了 Web、桌面和行動如何整合在一起：現在我們都可以透過網路或商店玩這些遊戲。</p>
<p>我們製作了這個影片來展示一些我們最喜歡的投稿和獲獎作品；我們認為您會喜歡的：</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2Fl6hw4o6_Wcs%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3Dl6hw4o6_Wcs&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2Fl6hw4o6_Wcs%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/14a9a66c075fa562dfcae0239f446826/href">https://medium.com/media/14a9a66c075fa562dfcae0239f446826/href</a></iframe>

<p>感謝您對 Flutter 的支援，歡迎來到 Flutter 3！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mt5JTb-02GrFFtCnW20Tqg.png" />
</figure>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=5eb69151622f" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/introducing-flutter-3-5eb69151622f">Introducing Flutter 3</a> was originally published in <a href="https://medium.com/flutter">Flutter</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/a17d9997.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/a17d9997.html" class="post-title-link" itemprop="url">【文章翻譯】What’s new in Flutter 3</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-11 19:48:56" itemprop="dateCreated datePublished" datetime="2022-05-11T19:48:56+08:00">2022-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="深入了解最新版本，包括-macOS-和-Linux-穩定版本、效能提升等等！"><a href="#深入了解最新版本，包括-macOS-和-Linux-穩定版本、效能提升等等！" class="headerlink" title="深入了解最新版本，包括 macOS 和 Linux 穩定版本、效能提升等等！"></a>深入了解最新版本，包括 macOS 和 Linux 穩定版本、效能提升等等！</h2><p>是時候再次發佈 Flutter 穩定版本了——我們非常自豪地宣布 <strong>Flutter 3</strong>！僅僅三個月前，我們宣布了 Flutter 對 Windows 的支援。今天，我們很高興地宣布，除了 Windows 之外，Flutter 現在也穩定支援 macOS 和 Linux！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*K1Ru7PVkH74N56hgjBTjjQ.png" />
</figure>

<p>感謝 Flutter 貢獻者的辛勤工作，我們已合併了 5248 個 Pull Request！</p>
<p>我們在此版本中有一些令人興奮的消息要宣布，包括 Flutter 對 macOS 和 Linux 的支援更新、重大的效能提升、行動和 Web 更新——以及更多！此外，我們還有一些關於減少對舊版 Windows 支援的資訊，以及一小部分重大變更。好了，讓我們開始吧！</p>
<h3 id="隨時準備好在所有桌面平台上投入生產"><a href="#隨時準備好在所有桌面平台上投入生產" class="headerlink" title="隨時準備好在所有桌面平台上投入生產"></a>隨時準備好在所有桌面平台上投入生產</h3><p>Linux 和 macOS 已達到穩定狀態，並包含以下功能：</p>
<h4 id="階層式選單和對-macOS-系統選單列的支援"><a href="#階層式選單和對-macOS-系統選單列的支援" class="headerlink" title="階層式選單和對 macOS 系統選單列的支援"></a>階層式選單和對 macOS 系統選單列的支援</h4><p>您現在可以使用 PlatformMenuBar Widget 在 macOS 上建立平台渲染的選單列，它支援插入僅平台選單，以及控制 macOS 應用程式選單中顯示的內容。</p>
<figure>
<img alt="A user clicks a menu which shows submenus on Mac" src="https://cdn-images-1.medium.com/max/1024/1*kS32jfapJAvSyspT3aOH5A.gif" />
<figcaption>階層式選單示範</figcaption>
</figure>

<h4 id="在所有桌面平台上完全支援國際文字輸入"><a href="#在所有桌面平台上完全支援國際文字輸入" class="headerlink" title="在所有桌面平台上完全支援國際文字輸入"></a>在所有桌面平台上完全支援國際文字輸入</h4><p>國際文字輸入，包括對使用文字輸入法編輯器 (IME)（例如中文、日語和韓語）的語言的支援，在所有三個桌面平台上都得到完全支援，包括 Sogou 和 Google 日語輸入等第三方輸入法。</p>
<h4 id="所有桌面平台上的無障礙功能"><a href="#所有桌面平台上的無障礙功能" class="headerlink" title="所有桌面平台上的無障礙功能"></a>所有桌面平台上的無障礙功能</h4><p>Windows、macOS 和 Linux 的 Flutter 支援無障礙服務，例如螢幕閱讀器、無障礙導航和反色。</p>
<h4 id="macOS-上預設為通用二進制檔案"><a href="#macOS-上預設為通用二進制檔案" class="headerlink" title="macOS 上預設為通用二進制檔案"></a>macOS 上預設為通用二進制檔案</h4><p>從 Flutter 3 開始，Flutter macOS 桌面應用程式被建構為通用二進制檔案，原生支援現有的基於 Intel 的 Mac 和 Apple 最新推出的 Apple Silicon 設備。</p>
<h4 id="棄用-Windows-7-8-開發"><a href="#棄用-Windows-7-8-開發" class="headerlink" title="棄用 Windows 7&#x2F;8 開發"></a>棄用 Windows 7&#x2F;8 開發</h4><p>在此版本中，我們將推薦的 Windows 開發版本提升到 Windows 10。雖然我們沒有阻止在舊版本（Windows 7、Windows 8、Windows 8.1）上進行開發，但這些版本 <a href="https://docs.microsoft.com/en-us/lifecycle/faq/windows">不再受 Microsoft 支援</a>，而且我們對這些版本的測試有限。雖然我們將繼續為舊版本提供「盡力而為」的支援，但我們鼓勵您升級。</p>
<blockquote>**注意：**我們繼續提供對在 Windows 7 和 Windows 8 上 *運行* 的 Flutter 應用程式的支援；此更改僅影響推薦的開發環境。</blockquote>

<h3 id="行動更新"><a href="#行動更新" class="headerlink" title="行動更新"></a>行動更新</h3><p>我們對行動平台的更新包括以下內容：</p>
<h4 id="可折疊手機支援"><a href="#可折疊手機支援" class="headerlink" title="可折疊手機支援"></a>可折疊手機支援</h4><p>Flutter 3 版本支援可折疊行動設備。在由 Microsoft 帶頭合作的過程中，新功能和 Widget 讓您可以在可折疊設備上建立動態且令人愉悅的體驗。</p>
<p>作為此工作的一部分，<a href="https://master-api.flutter.dev/flutter/widgets/MediaQuery-class.html">MediaQuery</a> 現在包含一個 <a href="https://master-api.flutter.dev/flutter/dart-ui/DisplayFeature-class.html">DisplayFeatures</a> 清單，描述設備元素（如鉸鏈、摺疊和切口）的邊界和狀態。此外，<a href="https://master-api.flutter.dev/flutter/widgets/DisplayFeatureSubScreen-class.html">DisplayFeatureSubScreen</a> Widget 現在會將其子 Widget 定位在不與 DisplayFeatures 的邊界重疊的位置，並且已經與框架的預設對話方塊和彈出視窗整合在一起，使 Flutter <strong>開箱即用</strong> 地感知和對這些元素做出響應。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*z8pzEtJOPFv-xzw2" />
</figure>

<p>非常感謝 Microsoft 團隊，尤其是 <a href="https://github.com/andreidiaconu">@andreidiaconu</a>，他們的貢獻！</p>
<p>嘗試 <a href="https://docs.microsoft.com/en-us/dual-screen/flutter/samples">Surface Duo 模擬器範例</a>，其中包括一個帶有 Flutter 圖庫的特殊分支，以查看 Flutter 的雙顯示器在實際情況下的運行情況。</p>
<h4 id="iOS-可變更新率支援"><a href="#iOS-可變更新率支援" class="headerlink" title="iOS 可變更新率支援"></a>iOS 可變更新率支援</h4><p>Flutter 現在支援具有 ProMotion 顯示器的 iOS 設備（包括 iPhone 13 Pro 和 iPad Pro）上的可變更新率。在這些設備上，Flutter 應用程式可以以高達 120 赫茲的更新率渲染，而之前限制為 60 赫茲。這在快速動畫（例如捲軸）期間產生更流暢的體驗。查看 <a href="http://flutter.dev/go/variable-refresh-rate">flutter.dev&#x2F;go&#x2F;variable-refresh-rate</a> 以獲取更多詳細資訊。</p>
<h4 id="簡化的-iOS-發佈"><a href="#簡化的-iOS-發佈" class="headerlink" title="簡化的 iOS 發佈"></a>簡化的 iOS 發佈</h4><p>我們已在 <a href="https://github.com/flutter/flutter/pull/97672">flutter build ipa 命令</a> 中加入了新選項，以簡化 iOS 應用程式的發佈。當您準備好發佈到 TestFlight 或 App Store 時，運行 flutter build ipa 以建立 Xcode 檔案 (.xcarchive 檔案) 和應用程式捆綁 (.ipa 檔案)。您可以選擇性地加入 —-export-method ad-hoc、—-export-method development 或 —-export-method enterprise。建立應用程式捆綁後，透過 <a href="https://apps.apple.com/us/app/transporter/id1450874784">Apple Transport macOS 應用程式</a> 或在命令列上使用 xcrun altool 將其上傳到 Apple（運行 man altool 以獲取 App Store Connect API 金鑰驗證指示）。上傳後，您的應用程式即可發佈到 <a href="https://docs.flutter.dev/deployment/ios#release-your-app-to-the-app-store">TestFlight 或 App Store</a>。在設定初始 <a href="https://docs.flutter.dev/deployment/ios#review-xcode-project-settings">Xcode 專案設定</a>（如顯示名稱和應用程式圖標）後，您不再需要打開 Xcode 來發佈應用程式。</p>
<h4 id="Gradle-版本更新"><a href="#Gradle-版本更新" class="headerlink" title="Gradle 版本更新"></a>Gradle 版本更新</h4><p>如果您使用 Flutter 工具建立新的專案，您可能會注意到，產生的檔案現在使用 Gradle 和 Android Gradle Plugin 的最新版本。對於現有的專案，您需要手動將 Gradle 的版本提升到 7.4，將 Android Gradle Plugin 的版本提升到 7.1.2。</p>
<h4 id="停止支援-32-位-iOS-iOS-9-iOS-10"><a href="#停止支援-32-位-iOS-iOS-9-iOS-10" class="headerlink" title="停止支援 32 位 iOS&#x2F;iOS 9&#x2F;iOS 10"></a>停止支援 32 位 iOS&#x2F;iOS 9&#x2F;iOS 10</h4><p>正如我們在 2022 年 2 月的 2.10 穩定版本中所宣布的那樣，Flutter 對 32 位 iOS 設備和 iOS 版本 9 和 10 的支援即將結束。此更改影響 iPhone 4S、iPhone 5、iPhone 5C，以及第 2 代、第 3 代和第 4 代 iPad 設備。Flutter 3 是最後一個支援這些 iOS 版本和設備的穩定版本。</p>
<p>若要進一步了解此更改，請查看 <a href="http://flutter.dev/go/rfc-32-bit-ios-unsupported">RFC：停止支援 32 位 iOS 設備</a>。</p>
<h3 id="Web-更新"><a href="#Web-更新" class="headerlink" title="Web 更新"></a>Web 更新</h3><p>我們對 Web 應用程式的更新包括以下內容：</p>
<h4 id="圖片解碼"><a href="#圖片解碼" class="headerlink" title="圖片解碼"></a>圖片解碼</h4><p>Flutter 網頁現在會自動檢測並在支援它的瀏覽器中使用 ImageDecoder API。截至今天，大多數基於 Chromium 的瀏覽器（Chrome、Edge、Opera、Samsung Browser 等等）都加入了這個 API。</p>
<p>新的 API 使用瀏覽器的內建圖片編解碼器，在主執行緒之外異步地解碼圖片。這將圖片解碼速度提高了 2 倍，而且它永遠不會阻塞主執行緒，消除了之前由圖片引起的任何卡頓。</p>
<h4 id="Web-應用程式生命週期"><a href="#Web-應用程式生命週期" class="headerlink" title="Web 應用程式生命週期"></a>Web 應用程式生命週期</h4><p>Flutter Web 應用程式的新生命週期 API 讓您能夠從託管的 HTML 頁面控制 Flutter 應用的引導過程，並幫助 Lighthouse 分析應用的效能。這適用於許多用例，包括以下常用的場景：</p>
<ul>
<li>啟動畫面。</li>
<li>載入指示器。</li>
<li>在 Flutter 應用之前顯示的純 HTML 互動式登陸頁面。</li>
</ul>
<p>如需更多資訊，請查看 docs.flutter.dev 上的 <a href="https://docs.flutter.dev/development/platform-integration/web/initialization">自訂 Web 應用程式初始化</a>。</p>
<h3 id="工具更新"><a href="#工具更新" class="headerlink" title="工具更新"></a>工具更新</h3><p>我們對 Flutter 和 Dart 工具的更新包括：</p>
<h4 id="更新的-lint-套件"><a href="#更新的-lint-套件" class="headerlink" title="更新的 lint 套件"></a>更新的 lint 套件</h4><p>lint 套件的 2.0 版本已發佈：</p>
<ul>
<li>Flutter：<a href="https://pub.dev/packages/flutter_lints/versions/2.0.0">https://pub.dev/packages/flutter_lints&#x2F;versions&#x2F;2.0.0</a></li>
<li>Dart：<a href="https://pub.dev/packages/lints/versions/2.0.0">https://pub.dev/packages/lints/versions/2.0.0</a></li>
</ul>
<p>使用 flutter create 在 Flutter 3 中生成的應用程式會自動啟用 v2.0 的 lint 集合。鼓勵現有的應用程式、套件和 Plugin 透過運行 flutter pub upgrade –major-versions flutter_lints 遷移到 v2.0，以遵循 Flutter 世界中的最新最佳實務。</p>
<p>v2 中新增的大多數 lint 警告都帶有自動修復。因此，在將應用程式 <code>pubspec.yaml</code> 檔案中的套件升級到最新版本之後，您可以在程式碼庫上運行 <code>dart fix --apply</code> 以自動修復大多數 lint 警告（一些警告仍然需要手動操作）。尚未使用 package:flutter_lints 的應用程式、套件或 Plugin 可以透過遵循 <a href="https://docs.flutter.dev/release/breaking-changes/flutter-lints-package#migration-guide">遷移指南</a> 來遷移。</p>
<h4 id="效能提升"><a href="#效能提升" class="headerlink" title="效能提升"></a>效能提升</h4><p>感謝開源貢獻者 <a href="https://github.com/knopp">@knopp</a>，部分重新繪製已在支援它的 Android 設備上 <a href="https://github.com/flutter/engine/pull/29591">啟用</a>。在我們的本地測試中，此更改將 Pixel 4 XL 設備上 <code>backdrop_filter_perf</code> 基準測試的平均、第 90 個百分位數和第 99 個百分位數畫面柵格化時間減少了 5 倍。當存在單個矩形髒區域時，部分重新繪製現在已在 iOS 和更新的 Android 設備上啟用。</p>
<p>我們已 <a href="https://github.com/flutter/engine/pull/30957">進一步改進</a> 了簡單情況下不透明度動畫的效能。特別是，當 Opacity Widget 僅包含單個渲染原語時，Opacity 通常會調用的 <code>saveLayer</code> 方法被省略。在一項用於衡量此優化效益的基準測試中，這種情況下的柵格化時間 <a href="https://flutter-flutter-perf.skia.org/e/?begin=1643063115&end=1644004520&keys=X32827d8819e8271e025f50e77bf2bec0&amp;requestType=0&amp;xbaroffset=27447">提高了一個數量級</a>。在未來的版本中，我們計劃將此優化應用於更多場景。</p>
<p>感謝開源貢獻者 <a href="https://github.com/JsouLiang">@JsouLiang</a>，引擎的柵格化和 UI 執行緒現在在 Android 和 iOS 上比其他執行緒（例如 Dart VM 後台垃圾回收執行緒）擁有更高的優先級。在我們的基準測試中，這導致 <a href="https://flutter-flutter-perf.skia.org/e/?begin=1644581114&end=1644647407&keys=X3999dc0a0c89054eaa9f66bcff27d882&amp;num_commits=50&amp;request_type=1&amp;xbaroffset=27549">平均畫面構建時間快了約 20%</a>。</p>
<p>在 3 版本之前，柵格快取的准入政策只查看圖片中的繪製操作數量，假設任何超過幾個操作的圖片都是快取的良好候選者。不幸的是，這導致引擎浪費記憶體來快取實際上渲染速度非常快的圖片。此版本 <a href="https://github.com/flutter/engine/pull/31417">引入了一種機制</a>，它根據圖片中包含的繪製操作的成本來估計圖片的渲染複雜度。使用此作為柵格快取准入政策，<a href="https://flutter-flutter-perf.skia.org/e/?begin=1644790212&end=1646044276&keys=X4c7dd4e4903a38523816c00b31d4d787&amp;requestType=0&amp;xbaroffset=27636">減少了記憶體使用量</a>，而在我們的基準測試中沒有降低效能。</p>
<p>感謝開源貢獻者 <a href="https://github.com/ColdPaleLight">@ColdPaleLight</a>，他 <a href="https://github.com/flutter/engine/pull/31513">修復了畫面排程中的錯誤</a>，該錯誤導致 iOS 上有少量動畫畫面被丟棄。感謝每一位報告此問題並提供重現步驟和丟棄畫面的影片的人。</p>
<h4 id="Impeller"><a href="#Impeller" class="headerlink" title="Impeller"></a>Impeller</h4><p>團隊一直在努力尋找解決 iOS 和其他平台上早期卡頓的方法。在 Flutter 3 版本中，您可以在 iOS 上預覽一個名為 <a href="https://github.com/flutter/engine/tree/main/impeller">Impeller</a> 的實驗性渲染後端。Impeller 在引擎構建時預編譯了 <a href="https://github.com/flutter/flutter/issues/77412">更小、更簡單的著色器集合</a>，以便它們不會在應用程式運行時編譯；這是 Flutter 中卡頓的主要來源。Impeller 尚未準備好投入生產，而且還遠未完成。目前還未實作所有 Flutter 功能，但我們對其在 <a href="https://github.com/flutter/gallery">flutter&#x2F;gallery</a> 應用程式中的保真度和效能感到滿意，因此我們分享了我們的進展。特別是，圖庫應用程式轉場動畫中最差的畫面 <a href="https://flutter-flutter-perf.skia.org/e/?begin=1650297849&end=1651261748&amp;queries=sub_result=worst_frame_rasterizer_time_millis&test=new_gallery_impeller_ios__transition_perf&test=new_gallery_ios__transition_perf&amp;requestType=0">快了約 20 倍</a>。</p>
<p>Impeller 在 iOS 上可以使用標記。您可以將 —-enable-impeller 傳遞給 flutter run，或者將 Info.plist 檔案中的 FLTEnableImpeller 標記設定為 true，以嘗試使用 Impeller。Impeller 的開發工作仍在 Flutter 的 master channel 上繼續進行，我們希望在未來的版本中提供更多更新。</p>
<h4 id="Android-上的內嵌廣告"><a href="#Android-上的內嵌廣告" class="headerlink" title="Android 上的內嵌廣告"></a>Android 上的內嵌廣告</h4><p>當您使用 <a href="https://pub.dev/packages/google_mobile_ads">google_mobile_ads 套件</a> 時，您應該會在使用者關鍵互動（例如捲軸和頁面之間的轉場）中看到更好的效能。這在新興市場中流行的設備上尤其明顯。最棒的是，不需要進行任何程式碼更改！</p>
<p>在幕後，Flutter 現在會異步地組合 Android 視圖，通常稱為 <a href="https://docs.flutter.dev/development/platform-integration/platform-views">平台視圖</a>。這意味著 Flutter 柵格化執行緒不需要等待 Android 視圖渲染。相反，Flutter 引擎會使用它管理的 OpenGL 紋理將視圖放置在螢幕上。</p>
<h3 id="更多令人興奮的更新"><a href="#更多令人興奮的更新" class="headerlink" title="更多令人興奮的更新"></a>更多令人興奮的更新</h3><p>Flutter 生態系統的其他更新包括以下內容：</p>
<h4 id="Material-3"><a href="#Material-3" class="headerlink" title="Material 3"></a>Material 3</h4><p>Flutter 3 支援 <a href="https://m3.material.io/">Material Design 3</a>，這是 Material Design 的下一代版本。Flutter 3 為 Material 3 提供了選擇性支援；這包括 Material You 功能，如動態色彩、更新的色彩系統和字體排版、對許多組件的更新，以及 Android 12 中引入的新的視覺效果，如新的觸控漣漪設計和拉伸過捲效果。在 <em>新的</em> <a href="https://codelabs.developers.google.com/codelabs/flutter-boring-to-beautiful">將您的 Flutter 應用程式從無聊變成漂亮</a> 程式碼實驗室中嘗試 Material 3 功能。查看 <a href="https://api.flutter.dev/flutter/material/ThemeData/useMaterial3.html">API 文件</a> 以了解如何選擇性使用這些新功能以及哪些組件支援 Material 3。透過 <a href="https://github.com/flutter/flutter/issues/91605">Material 3 總體議題</a> 關注正在進行的工作。</p>
<h4 id="主題擴展"><a href="#主題擴展" class="headerlink" title="主題擴展"></a>主題擴展</h4><p>Flutter 現在可以使用名為 <em>主題擴展</em> 的概念將 <em>任何</em> 內容加入到 material 函式庫的 ThemeData 中。您可以指定 ThemeData.extensions，而不是（在 Dart 中的意義上）擴展 ThemeData 並重新實作其 copyWith、lerp 和其他方法。此外，作為套件開發人員，您可以提供 ThemeExtension。查看 <a href="https://flutter.dev/go/custom-colors-m3">flutter.dev&#x2F;go&#x2F;theme-extensions</a> 以獲取更多詳細資訊，並查看 <a href="https://github.com/guidezpl/flutter/blob/master/examples/api/lib/material/theme/theme_extension.1.dart">GitHub 上的這個範例</a>。</p>
<h4 id="廣告"><a href="#廣告" class="headerlink" title="廣告"></a>廣告</h4><p>我們知道，發佈者向使用者要求個人化廣告的同意並處理 Apple 的 App 追蹤透明度 (ATT) 要求非常重要。</p>
<p>為了支援這些要求，Google 提供了使用者訊息平台 (UMP) SDK，它取代了之前的開源 <a href="https://github.com/googleads/googleads-consent-sdk-ios">同意 SDK</a>。在即將發佈的 Flutter 版 GMA SDK 中，我們將加入對 UMP SDK 的支援，以允許發佈者獲得使用者同意。如需更多詳細資訊，請查看 pub.dev 上的 <a href="https://pub.dev/packages/google_mobile_ads">google_mobile_ads</a> 頁面。</p>
<h3 id="重大變更"><a href="#重大變更" class="headerlink" title="重大變更"></a>重大變更</h3><p>隨著 Flutter 的不斷成長和改進，我們旨在將重大變更的數量降至最低。在 Flutter 3 發佈時，我們有以下重大變更：</p>
<ul>
<li><a href="https://docs.flutter.dev/release/breaking-changes/2-10-deprecations">v2.10 之後移除的棄用 API</a></li>
<li><a href="https://docs.flutter.dev/release/breaking-changes/page-transition-replaced-by-ZoomPageTransitionBuilder">頁面轉場被 ZoomPageTransitionsBuilder 取代</a></li>
<li><a href="https://docs.flutter.dev/release/breaking-changes/chip-usedeletebuttontooltip-migration">將 useDeleteButtonTooltip 遷移到 Chips 的 deleteButtonTooltipMessage</a></li>
</ul>
<p>如果您正在使用任何這些 API，請參閱 <a href="https://docs.flutter.dev/release/breaking-changes">Flutter.dev 上的遷移指南</a>。</p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>來自 Google 的 Flutter 團隊向您表示感謝，感謝社群做出的出色工作，幫助 Flutter 保持其作為最受歡迎的跨平台 UI 工具包的地位，正如 Statista 和 SlashData 等分析師所衡量的那樣。我們期待以社群為驅動的工具一起努力，繼續為開發人員和使用者提供令人愉悅的體驗！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8c74a5bc32d0" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/whats-new-in-flutter-3-8c74a5bc32d0">Flutter 3 的新功能</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/bf1721fb.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/bf1721fb.html" class="post-title-link" itemprop="url">【文章翻譯】Dart 2.17: Productivity and integration</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-11 19:48:43" itemprop="dateCreated datePublished" datetime="2022-05-11T19:48:43+08:00">2022-05-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-26 19:28:05" itemprop="dateModified" datetime="2024-12-26T19:28:05+08:00">2024-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="Dart-2-17：提升生產力和整合能力"><a href="#Dart-2-17：提升生產力和整合能力" class="headerlink" title="Dart 2.17：提升生產力和整合能力"></a>Dart 2.17：提升生產力和整合能力</h2><p>今天在 <a href="https://io.google/2022/products/flutter/">Google I&#x2F;O</a> 上，我們宣布推出新的 Dart SDK，版本 2.17。此版本基於我們提升生產力和平台可攜性的核心主題而構建。它提供了新的語言特性：支援成員的列舉、改進了向父類別轉發參數的功能，以及更靈活的命名參數。我們改進了工具，推出了 package:lints 的一個新的主要版本——我們的工具支援根據我們的最佳實務檢查 Dart 程式碼——並廣泛更新了核心函式庫 API 文件，其中包含豐富的程式碼範例。為了改進平台整合，我們提供了在 Flutter 外掛中使用 dart:ffi（原生 C 互通性）的新範本、對 RISC-V 處理器的實驗性支援，以及對簽署 macOS 和 Windows 可執行檔的支援。</p>
<figure>
<img alt="Dart 2.17 reease banner" src="https://cdn-images-1.medium.com/max/1024/1*eJKM-4rFprGXyxNd5w2m-Q.png" />
</figure>

<h3 id="新的語言特性以提高生產力"><a href="#新的語言特性以提高生產力" class="headerlink" title="新的語言特性以提高生產力"></a>新的語言特性以提高生產力</h3><p>我們不斷改進 Dart 語言，以提高您的生產力——透過新增新特性和改進現有特性。Dart 2.17 新增了對列舉成員的主要新支援，改進了您在建構函式中使用命名參數的方式，並使將參數轉發給父類別的程式碼更加簡潔，減少了重複。</p>
<h4 id="增強的列舉支援成員"><a href="#增強的列舉支援成員" class="headerlink" title="增強的列舉支援成員"></a>增強的列舉支援成員</h4><p>列舉非常適合表示一組離散的狀態。例如，我們可以將水建模為列舉 <code>Water &#123; frozen, lukewarm, boiling &#125;</code>。但是，如果我們想要在列舉上新增一些方法——例如，將每個狀態轉換為溫度，並支援將列舉轉換為字串，該怎麼辦？我們或許可以使用擴充方法來新增 <code>waterToTemp()</code> 方法，但我們必須小心地使其與列舉保持同步。對於字串轉換，我們更希望覆寫 <code>toString()</code>，但這一直不受支援。</p>
<p>在 Dart 2.17 中，我們現在全面支援列舉成員。這意味著我們可以新增儲存狀態的欄位、設定該狀態的建構函式、具有功能的方法，甚至覆寫現有的成員。你們中的許多人一直在要求此功能；這是我們在語言追蹤器中 <a href="https://github.com/dart-lang/language/issues?q=is:issue+sort:reactions-+1-desc+">投票數第三高的議題</a>。</p>
<p>對於我們的 <code>water</code> 範例，我們可以新增一個儲存溫度的 <code>int</code> 欄位和一個接受 <code>int</code> 的預設建構函式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Water &#123;</span><br><span class="line">…</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> tempInFahrenheit;</span><br><span class="line">  <span class="keyword">const</span> Water(<span class="keyword">this</span>.tempInFahrenheit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>為了確保在建立列舉時調用建構函式，我們需要為每個列舉值調用它：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Water &#123;</span><br><span class="line">  frozen(<span class="number">32</span>),</span><br><span class="line">  lukewarm(<span class="number">100</span>),</span><br><span class="line">  boiling(<span class="number">212</span>);</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>為了支援轉換為字串，我們只需覆寫從 <code>Object</code> 繼承的 <code>toString()</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="built_in">String</span> toString() =&gt; <span class="string">&quot;The <span class="subst">$name</span> water is <span class="subst">$tempInFahrenheit</span> F.&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>這樣，您就有一個完整的列舉，可以輕鬆地實例化，並且可以在其上調用方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(Water.frozen); <span class="comment">// 輸出 “The frozen water is 32 F.”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這兩種方法的完整範例如下圖所示；我們發現新的 Dart 2.17 版本更易於閱讀和維護。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*hGKUdu4DT9v2IZGj" />
</figure>

<h4 id="父類別初始化器"><a href="#父類別初始化器" class="headerlink" title="父類別初始化器"></a>父類別初始化器</h4><p>當您有一個類別繼承階層時，一種常見的模式是將一些建構函式參數傳遞給父類別的建構函式。為此，子類別需要 1) 在其自身的建構函式中列出每個參數，以及 2) 使用這些參數調用父類別建構函式。這會導致程式碼樣板化：大量重複，使程式碼更難閱讀，維護起來也更麻煩。</p>
<p>一些 Dart 社群成員幫助實現了這一點。GitHub 使用者 @roy-sianez 大約半年前提交了一個關於此的 <a href="https://github.com/dart-lang/language/issues/1855">語言議題</a>；建議使用類似於 GitHub 使用者 <a href="http://twitter.com/apps">@apps</a>-transround <a href="https://github.com/dart-lang/language/issues/493#issuecomment-879624528">先前建議</a> 的內容：我們或許可以透過引入一個新的結構來表示參數是在父類別中指定的來解決這個問題。我們認為這是一個很棒的主意，所以這已經新增到 Dart 2.17 中。從下面的範例中可以看出，這與 Flutter widget 程式碼特別相關。事實上，當我們將新特性應用於 Flutter 架構時，我們發現程式碼總共減少了 <a href="https://github.com/flutter/flutter/pull/100905/files">近兩千行</a>！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ypTj-6zzDBoqnpRL" />
</figure>

<h4 id="任何地方的命名參數"><a href="#任何地方的命名參數" class="headerlink" title="任何地方的命名參數"></a>任何地方的命名參數</h4><p>最後，我們改進了當您調用方法時命名參數的工作方式。以前，這些參數必須出現在方法的參數列表的最後。如果您希望將位置參數放在最後以使程式碼更具可讀性，這會很煩人。例如，請參閱以下對 <code>List&lt;T&gt;.generate</code> 建構函式的調用——以前，<code>growable</code> 參數必須放在最後，這使得它很容易在包含產生器本身的大型位置參數下方被遺漏。現在您可以按照自己的喜好排序它們，讓您可以將小型命名參數放在最前面，將產生器放在最後。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gMf1J56vEgV96z1l" />
</figure>


<p>欲了解更多關於這三個特性的實際應用範例，請參閱我們更新的 <a href="https://github.com/dart-lang/samples/blob/master/enhanced_enums/lib/members.dart">列舉</a>、<a href="https://github.com/dart-lang/samples/blob/master/parameters/lib/super_initalizer.dart">父類別初始化器</a> 和 <a href="https://github.com/dart-lang/samples/blob/master/parameters/lib/named_parameters.dart">命名參數</a> 的範例。</p>
<h3 id="生產力工具"><a href="#生產力工具" class="headerlink" title="生產力工具"></a>生產力工具</h3><p>繼續生產力主題，我們在核心工具中進行了多項改進。</p>
<p>在 Dart 2.14 中，我們引入了 package:lints，它與 Dart 分析器一起工作，幫助您編寫 Dart 程式碼，以防止錯誤，並使用規範的風格，從而更有效地進行程式碼審查。從那時起，分析器中提供了許多新的 lint，我們仔細地對其進行了分類，並從中為所有 Dart 程式碼選擇了 <a href="https://github.com/dart-lang/lints/blob/main/CHANGELOG.md#200">十個新的 lint</a>，並專門為 Flutter 程式碼選擇了 <a href="https://github.com/flutter/packages/blob/master/packages/flutter_lints/CHANGELOG.md#200">兩個新的 lint</a>。這些 lint 包括確保您的導入包含在您的 pubspec 檔案中，防止在類型參數上誤用 null 檢查，以及確保子屬性具有一致的風格。您可以使用一個簡單的命令升級到新的 lint：</p>
<ul>
<li>對於 Dart 套件：<br><code>dart pub upgrade --major-versions lints</code></li>
<li>對於 Flutter 套件：<br><code>flutter pub upgrade --major-versions flutter_lints</code></li>
</ul>
<p>SecureSockets 通常用於啟用透過 TLS 和 SSL 保護的 TCP sockets。在 Dart 2.17 之前，在開發過程中除錯這些 sockets 非常棘手，因為沒有辦法檢查安全資料流量。我們現在新增了對指定 keyLog 檔案的支援。指定後，當與伺服器交換新的 TLS 金鑰時，<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format">NSS 金鑰日誌格式</a> 的一行文字會附加到檔案中。這使得網路流量分析器工具（例如 <a href="https://gitlab.com/wireshark/wireshark/-/wikis/TLS#tls-decryption">Wireshark</a>）能夠解密透過 socket 傳送的內容。有關詳細資訊，請參閱 <a href="https://api.dart.dev/stable/2.17.0/dart-io/SecureSocket/connect.html">SecureSocket.connect()</a> 的 API 文件。</p>
<p>由 dart doc 工具產生的 API 文件是大多數 Dart 開發人員學習新 API 的關鍵資產。雖然我們的 <a href="https://dart.dev/guides/libraries">核心函式庫 API</a> 長期以來都有豐富的文字描述，但許多開發人員告訴我們，他們更喜歡透過閱讀使用 API 的範例程式碼來學習 API。在 Dart 2.17 中，我們徹底修改了所有主要的程式碼函式庫，在瀏覽量最高的 200 個頁面中新增了範例程式碼，因此它們現在都有全面的範例程式碼。例如，比較 Dart 2.16 中 <a href="https://api.dart.dev/stable/2.16.2/dart-convert/dart-convert-library.html">dart:convert 的文件</a> 與 Dart 2.17 中更新的 <a href="https://api.dart.dev/stable/2.17.0/dart-convert/dart-convert-library.html">頁面</a>；希望這能使文件更易於使用。</p>
<p>生產力的提高不僅僅來自於我們為平台新增新特性，還來自於我們清理堆疊並移除不再使用的特性。這有助於保持我們平台的精簡，這對於新開發人員尤其重要。為此，我們從 dart:io 函式庫中移除了 <a href="https://dart-review.googlesource.com/c/sdk/+/236840">231 行棄用的程式碼</a>——如果您仍在使用這些棄用的 API，您可以使用 <a href="https://dart.dev/tools/dart-fix">dart fix</a> 升級到它們的替代品。我們也繼續努力移除 <a href="https://github.com/dart-lang/sdk/issues/46100">棄用的 Dart 命令列工具</a>，這次移除了 dartdoc 工具（改用 dart doc）和 pub 工具（改用 dart pub 或 flutter pub）。</p>
<h3 id="擴大我們的平台整合和支援"><a href="#擴大我們的平台整合和支援" class="headerlink" title="擴大我們的平台整合和支援"></a>擴大我們的平台整合和支援</h3><p>第二個核心主題是平台整合和支援。Dart 是一種真正的跨平台語言。雖然我們已經支援 <a href="https://dart.dev/overview#platform">各種平台</a>，但我們仍在不斷改進，以確保您可以與每個支援的平台深度整合，並支援新興平台。</p>
<p>Dart FFI——我們與 <a href="https://dart.dev/guides/libraries/c-interop">C&#x2F;原生程式碼互通的核心機制</a>——是一種將 Dart 程式碼與現有原生平台程式碼整合的常用方法。在 Flutter 上，這可能是構建使用主機平台原生 API（例如 Windows win32 API）的 <a href="https://docs.flutter.dev/development/packages-and-plugins/developing-packages">外掛</a> 的好方法。在 Dart 2.17 和 Flutter 3 中，我們在 flutter 工具中新增了範本，因此您現在可以輕鬆建立 FFI 外掛，這些外掛具有由 dart:ffi 調用到原生程式碼的 Dart API。有關詳細資訊，請參閱 flutter.dev 上更新的 <a href="https://docs.flutter.dev/development/packages-and-plugins/developing-packages#dart-only-platform-implementations">開發套件和外掛</a> 頁面。</p>
<p>為了能夠在具有特定於其 ABI（<a href="https://en.wikipedia.org/wiki/Application_binary_interface">應用程式二進位介面</a>）的類型的平台上使用 FFI，FFI 現在支援特定於 ABI 的類型。例如，您現在可以使用 <a href="https://api.dart.dev/stable/2.17.0/dart-ffi/Long-class.html">Long</a>（C 語言中的 long）來正確表示具有特定於 ABI 大小的長整數，根據 CPU 架構，它可能是 32 位或 64 位。有關支援類型的完整列表，請參閱 <a href="https://api.dart.dev/stable/2.17.0/dart-ffi/AbiSpecificInteger-class.html">AbiSpecificInteger</a> API 頁面中的「實作者」列表。</p>
<p>當使用 Dart FFI 與原生平台深度整合時，您有時需要調整由 Dart 和原生程式碼分配的記憶體或其他資源（埠、檔案等）的清理。從歷史上看，這一直非常棘手，因為 Dart 是一種垃圾回收語言，會自動處理清理工作。Dart 2.17 透過引入 Finalizer 的概念來解決這個問題，Finalizer 包括一個 Finalizable 標記介面，用於「標記」不應過早完成或丟棄的物件，以及一個 NativeFinalizer 類別，可以附加到 Dart 物件上，以便在物件即將被垃圾回收時提供一個回調執行。這些一起允許在原生程式碼和 Dart 程式碼中執行清理程式碼。有關詳細資訊，請參閱 <a href="https://api.dart.dev/stable/2.17.0/dart-ffi/NativeFinalizer-class.html">NativeFinalizer</a> 的 API 文件中的描述和範例，或 <a href="https://api.dart.dev/stable/2.17.0/dart-core/WeakReference-class.html">WeakReferences</a> 和 <a href="https://api.dart.dev/stable/2.17.0/dart-core/Finalizer-class.html">Finalizer</a> 的文件，以了解在常規 Dart 程式碼中的類似支援。</p>
<p>我們對將 Dart 編譯為原生程式碼的支援是使 Flutter 應用程式具有出色的啟動效能和快速渲染的核心推動因素。第二個用例是使用 <a href="https://dart.dev/tools/dart-compile">dart compile</a> 將 Dart 編譯為可執行檔的能力。這些可執行檔可以在任何機器上獨立執行，而無需安裝 Dart SDK。Dart 2.17 中的另一個新功能是支援 <a href="https://dart.dev/tools/dart-compile#exe">簽署可執行檔</a>，這使得在 Windows 和 macOS 上進行部署成為可能，因為在這些平台上通常需要簽署。</p>
<p>我們也繼續透過保持在新興平台的最前沿來擴大我們支援的平台集。<a href="https://riscv.org/about/">RISC-V</a> 是一種新的創新處理器指令集。RISC-V International 是一個全球非營利組織，擁有 RISC-V 規範，使指令集免費且開源。這仍然是一個新興平台，但我們對其潛力感到興奮，因此我們的 2.17.0-266.1.beta Linux 版本（或我們 <a href="https://dart.dev/get-dart/archive#beta-channel">beta 頻道</a> 的更高版本）包含對它的實驗性支援。我們很樂意聽到您的回饋，所以請 <a href="https://github.com/dart-lang/sdk/issues">提交議題</a> 或 <a href="https://groups.google.com/a/dartlang.org/g/misc">發布</a> 關於您的體驗！</p>
<h3 id="開始使用-Dart-2-17！"><a href="#開始使用-Dart-2-17！" class="headerlink" title="開始使用 Dart 2.17！"></a>開始使用 Dart 2.17！</h3><p>我們希望今天的 Dart 2.17 版本能讓您興奮，提高您的生產力，並為您的應用程式實現更多的平台整合。要開始使用，您可以直接下載 Dart <a href="https://dart.dev/get-dart">2.17</a> 版本，或者將其作為今天 <a href="https://docs.flutter.dev/get-started/install">Flutter 3</a> SDK 版本的一部分嵌入。</p>
<p>我們也邀請您查看我們為 Google I&#x2F;O 提供的 <a href="https://io.google/2022/products/flutter/">新內容</a>！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=b216bfc80c5d" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/dart-2-17-b216bfc80c5d">Dart 2.17：生產力和整合</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/8e1574a8.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/8e1574a8.html" class="post-title-link" itemprop="url">【文章翻譯】I/O Pinball Powered by Flutter and Firebase</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-10 17:03:02" itemprop="dateCreated datePublished" datetime="2022-05-10T17:03:02+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="將-Flutter-遊戲開發提升到新的境界"><a href="#將-Flutter-遊戲開發提升到新的境界" class="headerlink" title="將 Flutter 遊戲開發提升到新的境界"></a>將 Flutter 遊戲開發提升到新的境界</h2><figure>
<img alt="Flutter’s Dash, Android Jetpack, Chrome Dino, and Firebase’s Sparky gathering around a pinball machine." src="https://cdn-images-1.medium.com/max/1024/1*yuiVVfFOuPnrsHcUx7xf_Q.png" />
</figure>

<p>為了 Google I/O，我們與 Flutter 團隊合作，重新構想了一款經典彈珠台遊戲，該遊戲使用 Flutter 和 Firebase 構建。以下是如何在 Flame 遊戲引擎的幫助下將 [I/O 彈珠台](https://pinball.flutter.dev/) 在網頁上呈現。</p>

<h3 id="遊戲開發基礎"><a href="#遊戲開發基礎" class="headerlink" title="遊戲開發基礎"></a>遊戲開發基礎</h3><p>對於構建由使用者互動驅動的遊戲（例如益智遊戲和文字遊戲）來說，Flutter 架構是一個很好的選擇。當談到使用遊戲迴圈的遊戲時，[Flame](https://docs.flame-engine.org/)（一個建立在 Flutter 之上的二維遊戲引擎）可以成為一個有用的工具。I/O 彈珠台使用 Flame 的開箱即用功能，例如動畫、物理、碰撞偵測等等，同時也利用 Flutter 架構的基礎設施。如果您可以使用 Flutter 構建應用程式，那麼您已經擁有了使用 Flame 構建遊戲所需的基礎。</p>

<figure>
<img alt="Flame engine logo" src="https://cdn-images-1.medium.com/max/1024/1*Qyyvx52AjpBRuI8MeZ7cAg.png" />
</figure>

<h3 id="遊戲迴圈"><a href="#遊戲迴圈" class="headerlink" title="遊戲迴圈"></a>遊戲迴圈</h3><p>在傳統應用程式中，螢幕通常在使用者發生事件或互動之前都是視覺上的靜態。對於遊戲來說，則相反 - UI 是持續渲染的，遊戲的狀態也在不斷變化。Flame 提供了一個遊戲 Widget，它在內部管理遊戲迴圈，以便 UI 能夠以高效能的方式持續渲染。`Game` 類別包含遊戲元件和邏輯的實作，這些實作傳遞給 Widget 樹中的 `GameWidget`。在 I/O 彈珠台中，遊戲迴圈會對彈珠在遊戲場上的位置和狀態做出反應，如果彈珠與物體發生碰撞或掉出了遊戲，則會應用必要的特效。</p>

<pre>@override<br>void update(double dt) {<br>  super.update(dt);</pre><pre>  final direction = -parent.body.linearVelocity.normalized();<br>  angle = math.atan2(direction.x, -direction.y);<br>  size = (_textureSize / 45) * <br>    parent.body.fixtures.first.shape.radius;<br>}</pre>

<h3 id="使用二維元件渲染三維空間"><a href="#使用二維元件渲染三維空間" class="headerlink" title="使用二維元件渲染三維空間"></a>使用二維元件渲染三維空間</h3><p>構建 I/O 彈珠台的挑戰之一是弄清楚如何僅使用二維元素來建立三維效果。元件的順序決定了它們在螢幕上的渲染方式。例如，當彈珠向上發射到斜坡時，彈珠的順序會上升，因此它看起來像是位於斜坡的頂部。</p>

<figure>
<img alt="I/O Pinball playfield featuring Flutter’s Dash, Android Jetpack, Chrome’s Dino, and Firebase’s Sparky, and other Google-themed elements. Toward the bottom of the board there are two flippers with two bumpers above and to the bottom right is the ball ready to be launched." src="https://cdn-images-1.medium.com/max/828/1*03SErV-PT46HyU9nmuwd7g.png" />
</figure>

<p>彈珠、彈射器、兩個彈射器和 Chrome 恐龍都是具有動態主體的元素，這些元素會受到世界物理的影響。彈珠的大小也會根據它在遊戲場上的位置而變化。當彈珠移動到遊戲場的頂部時，它的尺寸會縮小，從使用者的角度來看，它看起來離使用者更遠。此外，彈珠上的重力會根據彈珠台的角度進行調整，因此彈珠在斜坡上會下降得更快。</p>

<pre>/// 根據彈珠在遊戲場上的位置縮放彈珠的主體和 Sprite。<br>class BallScalingBehavior extends Component with ParentIsA&lt;Ball&gt; {<br>  @override<br>  void update(double dt) {<br>    super.update(dt);<br>    final boardHeight = BoardDimensions.bounds.height;<br>    const maxShrinkValue = BoardDimensions.perspectiveShrinkFactor;</pre><pre>    final standardizedYPosition = parent.body.position.y +   (boardHeight / 2);<br>    final scaleFactor = maxShrinkValue +<br>        ((standardizedYPosition / boardHeight) * (1 - maxShrinkValue));</pre><pre>parent.body.fixtures.first.shape.radius = (Ball.size.x / 2) * scaleFactor;</pre><pre>final ballSprite = parent.descendants().whereType&lt;SpriteComponent&gt;();<br>    if (ballSprite.isNotEmpty) {<br>      ballSprite.single.scale.setValues(<br>        scaleFactor,<br>        scaleFactor,<br>      );<br>    }<br>  }<br>}</pre>

<h3 id="使用-Forge-2D-實現物理"><a href="#使用-Forge-2D-實現物理" class="headerlink" title="使用 Forge 2D 實現物理"></a>使用 Forge 2D 實現物理</h3><p>I/O 彈珠台很大程度上依賴於由 Flame 團隊維護的 [forge2d](https://pub.dev/packages/forge2d) 套件。此套件將開源 [Box2D 物理引擎](https://box2d.org/) 移植到 Dart 中，以便可以輕鬆地與 Flutter 整合。我們使用 forge2d 來為遊戲的物理提供動力，例如遊戲場上物體（Fixture）之間的碰撞偵測。</p>

<p>forge2D 允許我們監聽 Fixture 之間的碰撞事件。然後，我們為 Fixture 添加 `ContactCallbacks`，以便在兩個元素之間發生接觸時收到通知。例如，當彈珠（具有具有 `CircleShape` 的 Fixture）與彈珠台（具有具有 `EllipseShape` 的 Fixture）發生接觸時，得分會增加。在這些回呼函式中，我們可以精確設定接觸的開始和結束位置，因此當兩個元素與另一個元素發生接觸時，就會發生碰撞。</p>

<pre>@override<br>Body createBody() {<br>  final shape = CircleShape()..radius = size.x / 2;<br>  final bodyDef = BodyDef(<br>    position: initialPosition,<br>    type: BodyType.dynamic,<br>    userData: this,<br>  );</pre><pre>  return world.createBody(bodyDef)<br>    ..createFixtureFromShape(shape, 1);<br>}</pre>

<h3 id="Sprite-表格動畫"><a href="#Sprite-表格動畫" class="headerlink" title="Sprite 表格動畫"></a>Sprite 表格動畫</h3><p>彈珠台遊戲場上有一些元素，例如 Android、Dash、Sparky 和 Chrome 恐龍，它們是動畫的。對於這些元素，我們使用了 Sprite 表格，這些表格包含在 Flame 引擎中，並帶有 `SpriteAnimationComponent`。對於每個元素，我們都有一個檔案，其中包含圖像的不同方向、檔案中的幀數以及幀之間的時間。使用這些資料，Flame 中的 `SpriteAnimationComponent` 會將所有圖像在迴圈中編譯在一起，使元素看起來像動畫。</p>

<figure>
<img alt="Sprite sheet showing the Android in various orientations so that if played on a loop, it will appear to be spinning in a circle." src="https://cdn-images-1.medium.com/max/1024/1*l1WjOu97J6hfDTO0KgzKlA.png" />
<figcaption>Sprite sheet 範例</figcaption>
</figure>

<pre>final spriteSheet = gameRef.images.fromCache(<br>  Assets.images.android.spaceship.animatronic.keyName,<br>);</pre><pre>const amountPerRow = 18;<br>const amountPerColumn = 4;<br>final textureSize = Vector2(<br>  spriteSheet.width / amountPerRow,<br>  spriteSheet.height / amountPerColumn,<br>);<br>size = textureSize / 10;</pre><pre>animation = SpriteAnimation.fromFrameData(<br>  spriteSheet,<br>  SpriteAnimationData.sequenced(<br>    amount: amountPerRow * amountPerColumn,<br>    amountPerRow: amountPerRow,<br>    stepTime: 1 / 24,<br>    textureSize: textureSize,<br>  ),<br>);</pre>

<h3 id="更加深入地了解-I-O-彈珠台程式碼庫"><a href="#更加深入地了解-I-O-彈珠台程式碼庫" class="headerlink" title="更加深入地了解 I&#x2F;O 彈珠台程式碼庫"></a>更加深入地了解 I&#x2F;O 彈珠台程式碼庫</h3><h3 id="Firebase-實時結果排行榜"><a href="#Firebase-實時結果排行榜" class="headerlink" title="Firebase 實時結果排行榜"></a>Firebase 實時結果排行榜</h3><p>I/O 彈珠台排行榜實時顯示世界各地玩家的最高分。使用者還可以將他們的得分分享到 Twitter 和 Facebook。我們使用 Firebase [Cloud Firestore](https://firebase.google.com/docs/firestore) 來追蹤前十名得分，並將其擷取以顯示在排行榜上。當新的得分寫入排行榜時，[Cloud Function](https://firebase.google.com/docs/functions) 會將得分按降序排序，並移除任何不在前十名的得分。</p>

<figure>
<img alt="Leaderboard for I/O pinball with 10 top scores displayed." src="https://cdn-images-1.medium.com/max/468/1*vD6H6j8WKFxS5RJf8Z0EDA.png" />
</figure>

<pre>/// 擷取前 10 個 [LeaderboardEntryData]。<br>Future&lt;List&lt;LeaderboardEntryData&gt;&gt; fetchTop10Leaderboard() async {<br>  try {<br>    final querySnapshot = await _firebaseFirestore<br>      .collection(_leaderboardCollectionName)<br>      .orderBy(_scoreFieldName, descending: true)<br>      .limit(_leaderboardLimit)<br>      .get();<br>    final documents = querySnapshot.docs;<br>    return documents.toLeaderboard();<br>  } on LeaderboardDeserializationException {<br>    rethrow;<br>  } on Exception catch (error, stackTrace) {<br>    throw FetchTop10LeaderboardException(error, stackTrace);<br>  }<br>}</pre>

<h3 id="為網頁構建"><a href="#為網頁構建" class="headerlink" title="為網頁構建"></a>為網頁構建</h3><p>與傳統應用程式相比，構建響應式的遊戲可能會更容易。彈珠台遊戲場只需要縮放到設備的大小即可。對於 I/O 彈珠台，我們根據設備的大小以固定比例進行縮放。這確保了無論顯示大小如何，座標系始終保持一致，這對於確保元件在設備之間一致地顯示和互動非常重要。</p>

<p>I/O 彈珠台還可以適應行動或桌面瀏覽器。在行動瀏覽器中，使用者可以點擊發射按鈕開始遊戲，也可以點擊螢幕的左右兩側來控制對應的彈射器。在桌面瀏覽器中，使用者可以使用鍵盤來發射彈珠和控制彈射器。</p>

<h3 id="程式碼庫架構"><a href="#程式碼庫架構" class="headerlink" title="程式碼庫架構"></a>程式碼庫架構</h3><p>彈珠台程式碼庫遵循分層架構，每個功能都在其自己的資料夾中。此專案中，遊戲邏輯也與視覺元件分開。這可以確保我們能夠輕鬆地獨立更新視覺元素，而與遊戲邏輯無關，反之亦然。</p>

<p>彈珠台的主題會根據使用者在開始遊戲之前選擇的角色而有所不同。主題由 `CharacterThemeCubit` 類別控制。根據角色選擇，彈珠顏色、背景和其他元素會更新。</p>

<figure>
<img alt="Displays the different I/O Pinball themes. The top left shows Sparky, carpet with prominent flame decorations and neon orange lighting. The top right shows Dash, a carpet with prominent egg decorations and neon blue lighting. The bottom left shows Android, carpet with prominent Android Jetpack decorations and neon green lighting. The bottom right shows Chrome Dino, carpet with prominent cactus decorations, and neon white lighting." src="https://cdn-images-1.medium.com/max/1024/1*I0xzMeuSQHI_vB0x28IucQ.png" />
</figure>

<pre>/// {@template character_theme}<br>/// 用於建立角色主題的基類。<br>///<br>/// 角色特定的遊戲元件應在此處指定一個 getter，以<br>/// 載入其對應的遊戲資產。<br>/// {@endtemplate}<br>abstract class CharacterTheme extends Equatable {<br>  /// {@macro character_theme}<br>  const CharacterTheme();</pre><pre>/// 角色名稱。<br>  String get name;</pre><pre>/// 彈珠的資產。<br>  AssetGenImage get ball;</pre><pre>/// 背景的資產。<br>  AssetGenImage get background;</pre><pre>/// 圖示資產。<br>  AssetGenImage get icon;</pre><pre>/// 排行榜的圖示資產。<br>  AssetGenImage get leaderboardIcon;</pre><pre>/// 閒置角色動畫的資產。<br>  AssetGenImage get animation;</pre><pre>@override<br>  List&lt;Object&gt; get props =&gt; [<br>        name,<br>        ball,<br>        background,<br>        icon,<br>        leaderboardIcon,<br>        animation,<br>      ];<br>}</pre>

<p>I/O 彈珠台的遊戲狀態由 [flame_bloc](https://pub.dev/packages/flame_bloc) 處理，flame_bloc 是一個將 bloc 與 Flame 元件連接起來的套件。例如，我們使用 flame_bloc 來追蹤剩餘的遊戲回合數、透過遊戲獲得的任何獎金以及目前的遊戲得分。此外，Widget 樹的頂部還有一個 Widget，其中包含載入頁面的邏輯，包括如何玩遊戲的說明。我們還遵循 [行為模式](https://en.wikipedia.org/wiki/Behavioral_pattern) 來封裝和隔離遊戲功能的某些元素，這些元素基於其元件。例如，彈珠台在被彈珠擊中時會發出聲音，因此我們實作了 `BumperNoiseBehavior` 類別來處理此問題。</p>

<pre>class BumperNoiseBehavior extends ContactBehavior {<br>  @override<br>  void beginContact(Object other, Contact contact) {<br>    super.beginContact(other, contact);<br>    readProvider&lt;PinballPlayer&gt;().play(PinballAudio.bumper);<br>  }<br>}</pre>

<p>程式碼庫還包含全面的單元、Widget 和黃金測試。有時，由於單個元件可能具有多個責任，這使得它們難以隔離測試，因此測試遊戲會帶來一些挑戰。結果，我們最終定義了一些模式來更好地隔離和測試元件。我們還將改進整合到 [flame_test](https://pub.dev/packages/flame_test) 套件中。</p>

<h3 id="元件沙箱"><a href="#元件沙箱" class="headerlink" title="元件沙箱"></a>元件沙箱</h3><p>此專案很大程度上依賴於 Flame 元件，以將彈珠台體驗呈現出來。程式碼庫附帶了一個元件沙箱，它類似於 [UI 元件庫](https://gallery.flutter.dev/#/)。這是在開發遊戲時的一個有用的工具，因為它允許您隔離開發遊戲元件，並確保它們在整合到遊戲中之前，看起來和行為符合預期。</p>

<figure>
<img alt="Chrome Dino is animated, moving left to right and opening its mouth to shoot out the pinball ball." src="https://cdn-images-1.medium.com/max/358/1*zAjKICKgCTiEiiMTou9MJQ.gif" />
</figure>

<h3 id="接下來要做什麼"><a href="#接下來要做什麼" class="headerlink" title="接下來要做什麼"></a>接下來要做什麼</h3><p>看看您是否可以在 [I/O 彈珠台](https://pinball.flutter.dev/) 中獲得高分！程式碼在 [這個 GitHub 儲存庫](https://github.com/flutter/pinball) 中是開源的。請關注排行榜，並在社交媒體上分享您的得分！</p>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=d22423f3f5d" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/i-o-pinball-powered-by-flutter-and-firebase-d22423f3f5d">I&#x2F;O 彈珠台由 Flutter 和 Firebase 提供支援</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/d310af3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/d310af3.html" class="post-title-link" itemprop="url">【文章翻譯】Bulk application of fixes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-05 22:41:38" itemprop="dateCreated datePublished" datetime="2022-05-05T22:41:38+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-26 19:28:05" itemprop="dateModified" datetime="2024-12-26T19:28:05+08:00">2024-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="一步修復多個分析問題"><a href="#一步修復多個分析問題" class="headerlink" title="一步修復多個分析問題"></a>一步修復多個分析問題</h2><p>在<a href="https://medium.com/dartlang/quick-fixes-for-analysis-issues-c10df084971a">快速修復分析問題</a>中，我們探討了在編輯時自動修復個別診斷的支持。有時即使這樣也太慢了，您真的希望一次修復多個診斷。幸運的是，也有支持這樣做的，我們將在本文中介紹。</p>
<p>修復多個診斷的方法有幾種，取決於您要修復多少診斷，我們將分別研究每一種方法。</p>
<h3 id="修復同一個診斷的多個出現位置"><a href="#修復同一個診斷的多個出現位置" class="headerlink" title="修復同一個診斷的多個出現位置"></a>修復同一個診斷的多個出現位置</h3><p>您是否曾經透過將類別移動到不同的檔案來重構程式碼？如果是這樣，很可能某些 import 僅僅是因為移動的類別中的引用才需要的，這會導致您留下未使用的 import：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/460/0*URmNnWSjGRGOorjv" />
<figcaption>Visual Studio Code</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/444/0*3QaE0FunXWpPp2Az" />
<figcaption>IntelliJ IDEA</figcaption>
</figure>

<p>對於任何可以在同一個檔案中多次應用的修復，工具都提供了一個選項，可以在檔案中的任何位置應用它。</p>
<p>這些修復會顯示在與其他修復相同的位置，並且標籤通常與單個位置修復相似，但會添加一些短語，例如「在檔案中」。例如，以下是此修復在 IDE 中的顯示方式：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/658/0*p2Pf06L6A4JSX7IS" />
<figcaption>Visual Studio Code</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/658/0*S4UnOqdx-h0U55jU" />
<figcaption>IntelliJ IDEA</figcaption>
</figure>

<p>選擇「在檔案中」修復會完全按照您的預期執行 - 它會移除檔案中所有未使用的 import：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/430/0*dHw4rjdxTR0liZX8" />
<figcaption>Visual Studio Code</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/352/0*Wk6qnyUlNr3qN0GQ" />
<figcaption>IntelliJ IDEA</figcaption>
</figure>

<h3 id="修復檔案中的所有診斷"><a href="#修復檔案中的所有診斷" class="headerlink" title="修復檔案中的所有診斷"></a>修復檔案中的所有診斷</h3><p>這很棒，但它只修復一種診斷，並且需要您找到報告診斷的位置（在編輯器中或在問題視圖中）才能調用修復。看起來工具還可以做得更多。</p>
<p>在 Visual Studio Code 中，它可以。您可以將修復應用於單個檔案中的所有診斷。為了了解如何操作，我們將使用與上面相同的示例：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/460/0*mr1A2XnnRCaamU22" />
</figure>

<p>如果您按一下滑鼠右鍵打開上下文選單，您將看到以下內容：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/640/0*3klKEJk5p40lCPbO" />
</figure>

<p>如果您選擇**原始碼動作…**，它會打開第二個選單：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/536/0*iRZIzPrwKl7jEYNY" />
</figure>

<p>選擇<strong>全部修復</strong>會將修復應用於編輯器中的所有診斷，產生以下結果：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/430/0*FDf16dDPwfPg_dET" />
</figure>

<p>您也可以從命令面板調用<strong>全部修復</strong>命令，您可以透過從<strong>檢視</strong>選單中選擇**命令面板…**或使用鍵盤快捷鍵（任何平台上的 F1，Windows 和 Linux 上的 Control+Shift+P 或 macOS 上的 Command+Shift+P）來打開命令面板。您可以透過輸入命令的名稱來篩選列表。命令面板看起來像這樣：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Jrz3MRfYVtcXrb9C" />
</figure>

<h3 id="修復目錄中的所有診斷"><a href="#修復目錄中的所有診斷" class="headerlink" title="修復目錄中的所有診斷"></a>修復目錄中的所有診斷</h3><p>我們用於修復診斷的最完整的工具是命令列工具 <code>dart fix</code>。它可以修復給定目錄中的所有診斷，這意味著您可以使用它來修復套件或應用程式中的所有內容。</p>
<p>當然，有一些注意事項。它並不能修復每個診斷，因為它應用與 IDE 中可用的快速修復相同的快速修復，並且並非每個診斷都有快速修復。當有多個同樣有效的方法來修復問題時，它也不會應用快速修復診斷，因為它不知道您更喜歡應用哪個修復。這些注意事項也適用於上一節中描述的<strong>全部修復</strong>命令。</p>
<p>雖然不需要經常使用此工具（這也是您可能不知道它的原因之一），但在某些情況下它特別有用。</p>
<p>首先，考慮您想要啟用新的 lint，甚至是 lints 集的情況，例如<a href="https://github.com/dart-lang/lints/blob/main/lib/core.yaml">核心</a>、<a href="https://github.com/dart-lang/lints/blob/main/lib/recommended.yaml">建議</a>或<a href="https://github.com/flutter/packages/blob/master/packages/flutter_lints/lib/flutter.yaml">flutter</a>規則集之一。您的套件中很可能至少有一些違反 lint 規則的情況。如果存在與 lint 相關聯的修復，那麼一步應用該修復到所有位置會比單獨應用修復到每個違規位置更方便。</p>
<p>其次，考慮您從一個 Flutter 版本更新到另一個版本的情況。如果兩個版本之間有 API 變更，則很有可能存在修復以升級您的程式碼以符合最新版本。同樣，如果所有這些變更都在單個操作中應用，則會很方便。</p>
<p>這就是 <code>dart fix</code> 命令的用武之地。它可以在多個檔案中應用針對多個診斷的快速修復。</p>
<p>該命令有兩種模式。「空運行」模式會告訴您可以應用多少變更以及可以修復哪些診斷，但不會修改任何檔案。「應用」模式會應用變更。</p>
<p>您可以提供包含要修復的檔案的目錄的路徑，但如果您省略目錄，它會遞迴地修復目前目錄及其子目錄中的所有檔案。</p>
<p>假設您已啟用 <code>prefer_single_quotes</code> lint，並且您有一個包含以下內容的檔案：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:logging/logging.dart&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> logger = Logger(<span class="string">&quot;myApp&quot;</span>);</span><br><span class="line">  logger.info(<span class="string">&quot;Entering myApp&quot;</span>);</span><br><span class="line">  <span class="comment">// Do stuff.</span></span><br><span class="line">  logger.info(<span class="string">&quot;Exiting myApp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>從包含此檔案的目錄中使用 <code>--dry-run</code> 選項運行 <code>dart fix</code> 命令會產生以下輸出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ dart fix --dry-run</span><br><span class="line">Computing fixes in __bin__ (dry run)... 4.3s</span><br><span class="line"></span><br><span class="line">3 proposed fixes in 1 file.</span><br><span class="line"></span><br><span class="line">demo.dart</span><br><span class="line">  prefer_single_quotes • 3 fixes</span><br></pre></td></tr></table></figure>

<p>該工具已找到三個違反 lint 的地方，並報告它能夠修復所有三個，但它不會修改檔案。</p>
<p>再次運行 <code>dart fix</code> 工具，但這次使用 <code>--apply</code> 選項，會產生幾乎相同的輸出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ dart fix --apply</span><br><span class="line">Computing fixes in __bin__... 5.3s</span><br><span class="line">Applying fixes...         0.0s</span><br><span class="line"></span><br><span class="line">3 proposed fixes in 1 file.</span><br><span class="line"></span><br><span class="line">demo.dart</span><br><span class="line">  prefer_single_quotes • 3 fixes</span><br><span class="line"></span><br><span class="line">3 fixes made in 1 file.</span><br></pre></td></tr></table></figure>

<p>但這次檔案會更新為包含以下內容：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:logging/logging.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> logger = Logger(<span class="string">&#x27;myApp&#x27;</span>);</span><br><span class="line">  logger.info(<span class="string">&#x27;Entering myApp&#x27;</span>);</span><br><span class="line">  <span class="comment">// Do stuff.</span></span><br><span class="line">  logger.info(<span class="string">&#x27;Exiting myApp&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於空運行模式不會產生任何允許您查看所建議的實際變更的 diff 輸出，<strong>請考慮在使用 <code>--apply</code> 選項運行工具之前提交您的變更</strong>。這樣，更容易查看工具實際進行了哪些變更，並還原您不喜歡的任何變更。</p>
<p>如果您不想在運行工具之前提交，並且您正在使用 IntelliJ IDEA，則可以使用<strong>檔案-&gt;本地歷史記錄</strong>功能來比較應用修復前後的狀態。（如需更多資訊，請參閱<a href="https://www.jetbrains.com/help/idea/local-history.html#label-local-history-revisions">將標籤添加到特定狀態的本地歷史記錄</a>。）</p>
<p><code>dart fix</code> 命令無法修復所有問題，但如果可以的話，它比手動應用修復到所有位置要容易得多。</p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>能夠在單個操作中應用多個修復不僅提高了快速修復的功能，還可能更容易進行更大規模的變更，例如啟用新的 lint 規則或升級到最新版本的 Flutter。</p>
<p>與往常一樣，如果您對如何改進這些工具有任何想法，請透過<a href="https://github.com/dart-lang/sdk/issues/new">建立 dart-lang&#x2F;sdk 問題</a>告知我們。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/4acb2e9a.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/4acb2e9a.html" class="post-title-link" itemprop="url">【文章翻譯】Does Flutter boost developer productivity?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-05 19:53:01" itemprop="dateCreated datePublished" datetime="2022-05-05T19:53:01+08:00">2022-05-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Flutter-是否提升了開發人員的生產力？"><a href="#Flutter-是否提升了開發人員的生產力？" class="headerlink" title="Flutter 是否提升了開發人員的生產力？"></a>Flutter 是否提升了開發人員的生產力？</h2><p>Flutter 團隊持續進行每季一次的使用者調查，以收集您，也就是 Flutter 開發人員的意見。2022 年的第一份調查於 2 月 22 日至 3 月 3 日進行，並透過 Flutter IDE 外掛、docs.flutter.dev 網站和 Twitter 進行訪問，超過 8,000 人參與了調查。</p>
<p>Flutter 仍然受到大多數開發人員的喜愛（93% 對 Flutter 感到滿意），甚至創下了有史以來「非常滿意」的最高百分比（60%）！這一點值得注意，因為自上次季度調查（2021 年 11 月至 2022 年 2 月）以來，Flutter 開發人員的數量增加了 10% 以上。我們很高兴看到，即使社群不斷增長，Flutter 仍然能够保持高水準的滿意度。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*hjsh42RwSy9QAK1S" />
<figcaption>隨著時間推移，對 Flutter 的滿意度。</figcaption>
</figure>

<p>在此次調查中，我們重點關注以下四個主題：</p>
<ul>
<li><strong>IDE 外掛：</strong>我們可以做些什麼來改進 Flutter 的 IDE 外掛支援？</li>
<li><strong>Dart 可擴展性：</strong>當 Flutter 專案規模越來越大時，Dart 工具是否會變慢或無回應？</li>
<li><strong>遊戲開發：</strong>您是否對遊戲開發感興趣？ <em>（更多資訊請參閱即將發布的部落格文章。）</em></li>
<li><strong>Flutter 對開發人員的價值：</strong>Flutter 是否實現了對開發人員做出的承諾？</li>
</ul>
<p>我們不會視您的支持為理所當然，我們會密切关注顯示我們可以進一步改進的指標。我們意识到，改进的空间总是存在的，在本文中，我们将告诉您更多关于我们所学到的知识以及这些信息如何推动我们的路线图。</p>
<h3 id="IDE-外掛"><a href="#IDE-外掛" class="headerlink" title="IDE 外掛"></a>IDE 外掛</h3><p>根據此次調查，63.5% 的開發人員對 Flutter 的 IDE 外掛「非常滿意」。那麼其他開發人員呢？為什麼他們沒有完全滿意？</p>
<p>如以下圖所示，沒有任何單一項目能突出顯示為沒有對 IDE 外掛完全滿意的原因。對 Android Studio&#x2F;IntelliJ 和 VS Code 用戶來說，缺少功能（35%）是最主要的原因，但外掛速度慢（29%）、記憶體消耗（28%）、外掛有 bug（26%）都收到了不少票數。（當受訪者點擊 IDE 中的調查連結時，會記錄 IDE 類型）。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*EMCuq3u9Ou_ALwgz" />
<figcaption>沒有對 Flutter 的 IDE 外掛完全滿意的原因。</figcaption>
</figure>

<p>「IntelliJ」標籤也包含 Android Studio 用戶。</p>
<p>當我們詢問缺少或支援不完善的功能時，重構和快速修復被選為需要更好地支援的兩個最主要功能。這多少令人驚訝，因為我們沒有預料到重構會排名最高。此外，我們也驚訝地發現 Android Studio&#x2F;IntelliJ 用戶非常關心導航，儘管我們理解 Android Studio&#x2F;IntelliJ 用戶比 VS Code 用戶更關心 Android 整合。開發人員對 UI 建立器也有很大興趣。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*JMOa0ZRVpHAy7prt" />
<figcaption>IDE 中缺少或支援不足的功能。</figcaption>
</figure>

<p>總之，我們現在對 Flutter 開發人員的需求有了更清晰的理解。但是，我們將透過各種研究繼續了解改進關注領域所需的內容。</p>
<h3 id="Dart-工具"><a href="#Dart-工具" class="headerlink" title="Dart 工具"></a>Dart 工具</h3><p>Dart 工具（例如 Dart 分析器、編譯器、DevTools 和 IDE 外掛）使使用這種語言變得更加容易。我們從一些開發人員那裡得知，當 Flutter 專案規模很大時，Dart 工具可能會變慢甚至無回應。我們希望在下次調查中評估這個問題的普遍程度和嚴重程度。</p>
<p>從此次調查中我們發現，大約四分之一的開發人員遇到过這種情況（24.5%），其中近一半人表示，這對開發工作造成了極其負面的影響（16.7%）或中等負面的影響（29.6%）。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Jv2irMQ8bSqUxGTW" />
<figcaption>開發人員在 Flutter 專案規模越來越大時，遇到 Dart 工具變慢或無回應。</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*EHUt9u95L4cLrRBk" />
<figcaption>Dart 工具速度慢或無回應對生產力的影響。</figcaption>
</figure>

<p>我們預計這些數字會更低，我們渴望在這方面有所改進，因此我們計劃與一些對后续对话表示兴趣的開發人員聯繫，以重現問題，並最終提高工具的效能。</p>
<h3 id="Flutter-對開發人員的價值"><a href="#Flutter-對開發人員的價值" class="headerlink" title="Flutter 對開發人員的價值"></a>Flutter 對開發人員的價值</h3><p>Flutter 承諾提供一個框架，可以從單個程式碼庫構建美麗、快速、跨平台的應用程式。在本次調查中，我們探討了 Flutter 開發人員是否認為我們實現了這些價值。</p>
<p>我們向那些將現有應用程式轉換為 Flutter 的開發人員和從頭開始創建新 Flutter 應用程式的開發人員提問了不同的問題。允許選擇多個答案，59.2% 的開發人員從頭開始創建了新應用程式，26.5% 的開發人員要么將現有應用程式轉換為 Flutter，要么將 Flutter 組件添加到現有應用程式中。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*CmgeijL3JkkAQA1_" />
<figcaption>開發人員開發和發布 Flutter 應用程式的經驗。</figcaption>
</figure>

<p>對於那些使用 Flutter 創建新應用程式的開發人員，我們詢問他們在何種程度上同意關於與其他 Google 服務的整合、開發生產力和目標平台的三个陳述。我們發現，超過 90% 的開發人員同意「與我使用過的其他技術相比，Flutter 缩短了構建和發布新應用程式的時間」（92.1%），並且同意「Flutter 使我的應用程式能夠面向更多平台」。(92.2%)</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*F-sHYKccRgOOQ85L" />
<figcaption>使用 Flutter 創建新應用程式的影響。</figcaption>
</figure>

<p>類似的問題也詢問了那些將 Flutter 應用於現有應用程式的開發人員。90.7% 的開發人員同意「與之前相比，Flutter 使我的應用程式能夠更快速地開發」，85.3% 的開發人員同意「與之前相比，Flutter 使我的應用程式能夠在更多平台上提供」。我們還發現，84.8% 的開發人員同意「Flutter 使我的應用程式比以前更美觀」。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*PihM7mrr3InFiCOZ" />
<figcaption>將 Flutter 應用於現有應用程式的影響。</figcaption>
</figure>

<p>當然，我們也聽到了 Flutter 可以改进的地方，例如為所有支援的平台提供更多外掛、添加更多文件、提高感知效能、更好地與其他工具整合等等。一些評論還提到，某些問題領域在多年的調查之後依然沒有改變。雖然我們努力解决這些問題並改進產品，但我們感謝您的耐心！不過，我們很高兴了解到，我们的開發人员正以更高效的方式面向更多平台。</p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>特別感謝所有參與我們調查的人！Flutter 團隊成員每季度都会花時間分析和消化反馈，并为下一个季度及以后做出决策。我們會繼續收集您的意見，以了解我們可以做些什麼來讓您使用 Flutter 的体验更加愉快和高效。</p>
<p>Flutter 的 UX 研究團隊也在進行各種使用者體驗研究。如果您有興趣參與，請<a href="https://docs.google.com/forms/d/e/1FAIpQLSe0i4De809KXVCdljGKrjMj3lxhuzbuFKCtY5PEQPCYtGxFMg/viewform">註冊</a>以參加未來研究。</p>
<p>請繼續參與並分享您的想法。我們下次調查再见！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=475f713724b3" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/does-flutter-boost-developer-productivity-475f713724b3">Flutter 是否提升了開發人員的生產力？</a> 最初發佈在 Medium 上的 <a href="https://medium.com/flutter">Flutter</a>，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/35d75874.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/35d75874.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing the Flutter Puzzle Hack winners!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-21 17:56:05" itemprop="dateCreated datePublished" datetime="2022-04-21T17:56:05+08:00">2022-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="敲鑼打鼓…-宣布-Flutter-拼圖-Hack-大賽得獎者！"><a href="#敲鑼打鼓…-宣布-Flutter-拼圖-Hack-大賽得獎者！" class="headerlink" title="敲鑼打鼓… 宣布 Flutter 拼圖 Hack 大賽得獎者！"></a>敲鑼打鼓… 宣布 Flutter 拼圖 Hack 大賽得獎者！</h2><figure>
<img alt="The Flutter puzzle hack logo" src="https://cdn-images-1.medium.com/max/1024/1*RpaR1pTpRa0PUdNdfv4njA.png" />
</figure>

<p><a href="https://flutter.dev/events/puzzle-hack">Flutter 拼圖 Hack 大賽</a> 邀請參賽者發揮創意，重新詮釋經典的滑動拼圖。可以說，作品讓評審們驚豔不已！</p>
<p>超過 5,500 位來自 120 多個國家、各個經驗層次的開發人員參與了 Flutter 拼圖 Hack 大賽。在公布各個類別的獲獎者之前，我們想向所有參與挑戰的開發者致敬。Flutter 社群再次團結一致，打造出非凡的成果。我們聚在一起參加了關於 <a href="https://www.youtube.com/watch?v=9F6dxDDh9yk">動畫</a>、<a href="https://www.youtube.com/watch?v=kWjJ0aUq5L0">Firebase 主機</a> 和 <a href="https://www.youtube.com/watch?v=2jZn7ccre9g">滑動拼圖基礎</a> 的演講。然後，看到 Flutter 開發人員打造出令人驚嘆的滑動拼圖陣容，<a href="https://twitter.com/roaakdm/status/1493614287515967492">一路分享亮點</a>，<a href="https://flutterhack.devpost.com/project-gallery">為您最喜歡的拼圖投票</a>，真是令人興奮。感謝大家！</p>
<p>成為如此熱情且充滿創意的社群的一份子，真是太棒了。誰能想到有這麼多不同的方法來建立一個簡單的滑動拼圖遊戲？🤷‍♂️</p>
<p><strong>廢話不多說… 頒獎時間到！</strong></p>
<h3 id="各個類別的獲獎者"><a href="#各個類別的獲獎者" class="headerlink" title="各個類別的獲獎者"></a>各個類別的獲獎者</h3><h4 id="最佳執行"><a href="#最佳執行" class="headerlink" title="最佳執行"></a>最佳執行</h4><p><a href="https://fph-planets.web.app/#/">Planets</a>，作者：Jyotirmoy Paul</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*NBpZfqcmNXabcfXw" />
<figcaption>Flutter 拼圖 Hack 大賽獲獎者</figcaption>
</figure>

<p>這個專案在許多方面給評審們留下了深刻印象，包括出色的動畫運用、程式碼品質和純粹的創意。除了程式碼本身，Jyotirmoy 還分享了一些過程中很棒的學習時刻 - <a href="https://flutterhack.devpost.com/review/submissions/NG5qSUlZT0wrOTREM3ExNVZ4ZUx4ZmJacnVrRTVxU1pRKzdYOGFsVjlsME9Ia0FoLzNweHRkVmt5aldVNE1HZFkzY3dUdjN3ZHBna1h5cFBxTENYYVRGeEFOanptV1FodFN4Vm9BVWpMaVU9LS0wMkRkTzhNeTRxM2pPSEw5dlFkbFdnPT0=--f9621a4ed75f9e521ff0c61d2459f3c3f371d6f1">看看他的分享</a>，如果您有興趣。</p>
<h4 id="最具創意"><a href="#最具創意" class="headerlink" title="最具創意"></a>最具創意</h4><p><a href="https://puzzle.wolfiz.com/">The Werewolves Escape</a>，作者：Ahmad Ayaz Noor 和他的團隊</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*El3UlTpr8NMOn23v" />
<figcaption>Flutter 拼圖 Hack 大賽獲獎者</figcaption>
</figure>

<p>這個功能豐富的專案結合了 Flutter 在網頁、行動和桌面端的優點。故事線讓滑動拼圖遊戲的趣味提升到了一個全新的層級。查看他們的 <a href="https://devpost.com/software/the-werewolves-escape">作品提交頁面</a>，了解這個團隊在建立這個專案時學到了什麼。</p>
<h4 id="最佳動畫-設計"><a href="#最佳動畫-設計" class="headerlink" title="最佳動畫&#x2F;設計"></a>最佳動畫&#x2F;設計</h4><p><a href="https://ashishbeck.github.io/slide_puzzle/">Retro Slide Puzzle</a>，作者：Ashish Beck</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*-G6C7XhJ0Dt1YP_W" />
<figcaption>Flutter 拼圖 Hack 大賽獲獎者</figcaption>
</figure>

<p>這個拼圖的精緻視覺效果立刻吸引了評審們的注意。這個專案融合了流暢的 <a href="https://rive.app/">Rive</a> 動畫、聲音外掛、自動完成和其他功能，讓遊戲體驗令人難以置信地令人滿足。</p>
<h4 id="最佳跨平台"><a href="#最佳跨平台" class="headerlink" title="最佳跨平台"></a>最佳跨平台</h4><p><a href="https://slideparty.vercel.app/#/">Slide Party</a>，作者：Duong Bui Dai</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*Cv4DedVkWjqpQI6k" />
<figcaption>Flutter 拼圖 Hack 大賽獲獎者</figcaption>
</figure>

<p>您是否曾經想過與朋友比賽，看誰能最快解開一個滑動拼圖？這個拼圖讓您夢想成真！不僅如此，由於 Flutter 的靈活性，玩家甚至不需要在同一台設備或作業系統上。</p>
<h3 id="超過-40-位獲獎者！"><a href="#超過-40-位獲獎者！" class="headerlink" title="超過 40 位獲獎者！"></a>超過 40 位獲獎者！</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/434/0*f_uqnrRyCc2QtHwm" />
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/387/0*qBSPIHNDApk5U0UE" />
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/480/0*dsLnVO7wz1Y3aF6i" />
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/480/0*-_mzr5eRCScnnW6P" />
</figure>

<p>儘管這些是各個類別的獲獎者，但從這麼多創意中選出獲獎者幾乎是不可能的。Flutter 拼圖 Hack 大賽還有超過 30 位其他獲獎者，以及許多其他優秀的參賽作品。前往 <a href="https://flutter.dev/events/puzzle-hack">flutter.dev&#x2F;events&#x2F;puzzle-hack</a> 查看獲獎者，並親自嘗試他們的拼圖！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ae55f45c6363" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/announcing-the-flutter-puzzle-hack-winners-ae55f45c6363">宣布 Flutter 拼圖 Hack 大賽得獎者！</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/f5668a8d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/f5668a8d.html" class="post-title-link" itemprop="url">【文章翻譯】Dart asynchronous programming: Streams</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-14 11:32:14" itemprop="dateCreated datePublished" datetime="2022-04-14T11:32:14+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-26 19:28:05" itemprop="dateModified" datetime="2024-12-26T19:28:05+08:00">2024-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="Dart-非同步程式設計：串流"><a href="#Dart-非同步程式設計：串流" class="headerlink" title="Dart 非同步程式設計：串流"></a>Dart 非同步程式設計：串流</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/272/0*yUEX9fxMxoG63vi0.gif" />
<figcaption>一個顯示來自串流資料的簡單 Flutter 應用程式</figcaption>
</figure>

<p>本文涵蓋了反應式程式設計的基礎之一：串流，它們是 <code>Stream</code> 類型的物件。</p>
<p>如果您已閱讀我們先前關於 <a href="https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137">Futures 的文章</a>，您可能記得 <strong>每個 Future 代表一個單一值</strong>（錯誤或資料），以<strong>非同步</strong>方式傳遞。串流的工作方式類似，只是它不是單一物件，<strong>串流可以隨著時間傳遞零個或多個值和錯誤</strong>。</p>
<blockquote>
<p>本文最初發表於 <a href="https://medium.com/dartlang/dart-asynchronous-programming-streams-2569a993324d">2020 年 2 月</a>。此版本將包含的程式碼更新為可空安全性。</p>
</blockquote>
<blockquote>
<p>本文是基於《Flutter in Focus》影片系列《Dart 中的非同步程式設計》的第三篇文章。第一篇文章 <a href="https://medium.com/dartlang/dart-asynchronous-programming-isolates-and-event-loops-bffc3e296a6a">Isolates and event loops</a> 涵蓋了 Dart 支援背景工作的基礎知識。第二篇 <a href="https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137">Futures</a> 討論了 Future 類別。</p>
</blockquote>
<blockquote>
<p>如果您喜歡透過觀看或聆聽來學習，本文中的所有內容都包含在以下影片中。</p>
</blockquote>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FnQBpOIHE4eE%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DnQBpOIHE4eE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FnQBpOIHE4eE%2Fhqdefault.jpg&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/19f7572c0ed7e65b2b45fc00703972c6/href">https://medium.com/media/19f7572c0ed7e65b2b45fc00703972c6/href</a></iframe>

<blockquote>
<p><strong>注意：</strong>本文中的程式碼已更新，以反映影片於 2019 年 6 月 28 日發佈後發生的最佳實務和 Dart 語言的變化（包括可空安全性）。</p>
</blockquote>
<p>如果您考慮單一值與相同類型的 <a href="https://dart.dev/codelabs/iterables">迭代器</a> 的關係，那就是 Future 與串流的關係：Future 代表具有單一響應的單一請求，而串流代表具有多個響應的單一請求。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/429/0*e0Lz6RaBIx2uK5R4.png" />
</figure>

<p>就像 Futures 一樣，關鍵是在事先決定 1) 當資料準備就緒時要做什麼，2) 發生錯誤時要做什麼，以及 3) 串流完成時要做什麼。與 Futures 一樣，在這個過程中，Dart 事件迴圈仍然在運行。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/proxy/0*tYShCv7ndeKeJFsv" />
<figcaption>串流與 Dart 事件迴圈一起工作。</figcaption>
</figure>

<h4 id="事件迴圈阻塞"><a href="#事件迴圈阻塞" class="headerlink" title="事件迴圈阻塞"></a>事件迴圈阻塞</h4><p>例如，如果您使用 File 類別的 <code>openRead()</code> 方法從檔案讀取資料，此方法會返回一個串流。</p>
<p>資料塊從磁碟讀取並到達事件迴圈。Dart 函式庫查看它們並說：「啊，有人正在等待這個」，將資料加入到串流中，然後將其發送到您的應用程式。</p>
<p>當另一段資料到達時——它就會進入並出來。基於計時器的串流和從網路通訊端串流資料也與事件迴圈一起工作，使用時鐘和網路事件。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/429/0*4NRFcYLryiLlUIrT" />
<figcaption>事件迴圈對資料進行排序。</figcaption>
</figure>

<h4 id="監聽串流"><a href="#監聽串流" class="headerlink" title="監聽串流"></a>監聽串流</h4><p>接下來要了解的是如何使用串流提供的資料。</p>
<p>假設您有一個類別，它提供一個串流，每秒發出一個新的整數（1、2、3、4、5…）。您可以使用 <code>listen()</code> 方法訂閱串流。唯一的必需參數是一個函數。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> myStream = NumberCreator().stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> subscription = myStream.listen(</span><br><span class="line">    (data) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;Data: <span class="subst">$data</span>&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>每次串流發出新值時，都會呼叫該函數並列印該值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Data: 1</span><br><span class="line">Data: 2</span><br><span class="line">Data: 3</span><br><span class="line">Data: 4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>這就是 <code>listen()</code> 的工作原理。</p>
<blockquote>
<p><strong>重要：</strong>預設情況下，串流設定為單一訂閱。它們會保留其值，直到有人訂閱，並且它們在其整個生命週期中只允許一個監聽器。如果您嘗試兩次監聽同一個串流，則會收到異常。</p>
<p>幸運的是，Dart 也提供廣播串流。您可以使用 <code>asBroadcastStream()</code> 方法從單一訂閱串流建立廣播串流。廣播串流的工作方式與單一訂閱串流相同，但它們可以有多個監聽器。</p>
<p><strong>廣播串流的另一個區別：</strong>如果在資料準備就緒時沒有人在監聽，則該資料會被丟棄。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> myStream = NumberCreator().stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> subscription = myStream.listen(</span><br><span class="line">  (data) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;Data: <span class="subst">$data</span>&#x27;</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> subscription2 = myStream.listen(</span><br><span class="line">  (data) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;Data again: <span class="subst">$data</span>&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>讓我們回到第一個 <code>listen()</code> 呼叫，因為還有一些事情要討論。</p>
<p>如前所述，串流可以像 Futures 一樣產生錯誤。透過將 <code>onError</code> 函數加入到 <code>listen()</code> 呼叫中，您可以捕獲和處理任何錯誤。</p>
<p>還有一個 <code>cancelOnError</code> 屬性，預設情況下為 <code>true</code>，但可以設定為 <code>false</code>，以便即使在發生錯誤後也能保持訂閱繼續進行。</p>
<p>您可以新增 <code>onDone</code> 函數，以便在串流完成傳送資料時執行一些程式碼，例如檔案已完全讀取完畢時。</p>
<p>結合所有四個參數——<code>onError</code>、<code>onDone</code>、<code>cancelOnError</code> 和必需的參數 (<code>onData</code>)——您可以預先準備好應對任何情況。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> myStream = NumberCreator().stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> subscription = myStream.listen(</span><br><span class="line">  (data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Data: <span class="subst">$data</span>&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  onError: (err) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error!&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  cancelOnError: <span class="keyword">false</span>,</span><br><span class="line">  onDone: () &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Done!&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示：</strong> <code>listen()</code> 返回的物件本身有一些有用的方法。它被稱為 <code>StreamSubscription</code>，您可以使用它來暫停、繼續，甚至取消資料流。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> subscription = myStream.listen(...);</span><br><span class="line"></span><br><span class="line">subscription.pause();</span><br><span class="line">subscription.resume();</span><br><span class="line">subscription.cancel();</span><br></pre></td></tr></table></figure>

<h4 id="使用和操作串流"><a href="#使用和操作串流" class="headerlink" title="使用和操作串流"></a>使用和操作串流</h4><p>現在您已經知道如何使用 <code>listen()</code> 訂閱串流並接收資料事件，讓我們來談談讓串流真正酷炫的地方：操作它們。</p>
<p>一旦您在串流中獲得了資料，許多操作就會突然變得流暢而優雅。</p>
<p>讓我們回到之前的數字串流。</p>
<p>使用名為 <code>map()</code> 的方法，您可以從串流中獲取每個值，並動態地將其轉換為其他內容。給 <code>map()</code> 一個執行轉換的函數，它會返回一個新的串流，其類型與函數的返回值相符。</p>
<p>現在不再是整數串流，而是一個字串串流。在末尾呼叫一個 <code>listen()</code>，將 <code>print()</code> 函數傳遞給它，現在它會直接從串流中列印字串——非同步地，當它們到達時。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NumberCreator().stream</span><br><span class="line">    .map((i) =&gt; <span class="string">&#x27;String <span class="subst">$i</span>&#x27;</span>)</span><br><span class="line">    .listen(<span class="built_in">print</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String 1</span><br><span class="line">String 2</span><br><span class="line">String 3</span><br><span class="line">String 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>您可以像這樣連結許多方法。例如，如果您只想列印偶數，則可以使用 <code>where()</code> 過濾串流。給它一個測試函數，該函數為每個元素返回一個布林值，它會返回一個新的串流，該串流只包含通過測試的值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NumberCreator().stream</span><br><span class="line">    .where((i) =&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .map((i) =&gt; <span class="string">&#x27;String <span class="subst">$i</span>&#x27;</span>)</span><br><span class="line">    .listen(<span class="built_in">print</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String 2</span><br><span class="line">String 4</span><br><span class="line">String 6</span><br><span class="line">String 8</span><br></pre></td></tr></table></figure>

<p><code>distinct()</code> 方法是另一個好方法。對於使用 Redux store 的應用程式，該 store 會在 <code>onChange</code> 串流中發出新的應用程式狀態物件。</p>
<p>您可以使用 <code>map()</code> 將狀態物件串流轉換為應用程式一部分的視圖模型串流。然後，您可以使用 <code>distinct()</code> 方法獲取一個串流，該串流會過濾掉連續的相同值（以防 store 啟動一個不影響視圖模型中資料子集的更改）。</p>
<p>然後，您可以監聽並在獲得新的視圖模型時更新 UI。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myReduxStore.onChange</span><br><span class="line">    .map((s) =&gt; MyViewModel(s))</span><br><span class="line">    .distinct()</span><br><span class="line">    .listen( <span class="comment">/* update UI */</span> )</span><br></pre></td></tr></table></figure>

<p>Dart 內建了其他方法，您可以使用它們來調整和修改您的串流。此外，當您準備好使用更進階的功能時，還有 Dart 團隊維護的 <a href="https://pub.dev/packages/async">async 套件</a>，可在 <a href="https://pub.dev/">pub.dev</a> 上獲得。它包含可以合併兩個串流、快取結果以及執行其他基於串流的魔術的類別。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*x-uuwOB-kV_dlw80Gx5kkA.png" />
<figcaption>嘗試使用 async 套件來獲得更多基於串流的魔術。</figcaption>
</figure>

<p>若要獲得更多串流魔術，請查看 <a href="https://pub.dev/packages/stream_transform">stream_transform 套件</a>。</p>
<h4 id="建立串流"><a href="#建立串流" class="headerlink" title="建立串流"></a>建立串流</h4><p>最後，還有一個值得一提的更進階的主題是如何建立您自己的串流。</p>
<p>就像 Futures 一樣，大多數情況下，您將使用網路函式庫、檔案函式庫、狀態管理等為您建立的串流，但您可以使用 <code>StreamController</code> 建立自己的串流。</p>
<p>讓我們回到我們一直使用的 NumberCreator 範例。這是它的實際程式碼：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberCreator</span> </span>&#123;</span><br><span class="line">  NumberCreator() &#123;</span><br><span class="line">    Timer.periodic(<span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), (timer) &#123;</span><br><span class="line">      _controller.sink.add(_count);</span><br><span class="line">      _count += <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _controller = StreamController&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">  Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> stream =&gt; _controller.stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所見，它會持續計數，並使用計時器每秒增加一次計數。然而，有趣的是串流控制器。</p>
<p><code>StreamController</code> 從頭開始建立一個全新的串流，並讓您可以存取它的兩端。有串流端本身，資料到達的地方。（我們在本文中一直在使用這個。）</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">int</span>&gt; <span class="keyword">get</span> stream =&gt; _controller.stream;</span><br></pre></td></tr></table></figure>

<p>還有接收端，這是將新資料加入到串流的地方：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_controller.sink.add(_count);</span><br></pre></td></tr></table></figure>

<p>NumberCreator 使用了這兩個。當計時器關閉時，它會將最新的計數加入到控制器的接收端，然後它會使用公共屬性公開控制器的串流，以便其他物件可以訂閱它。</p>
<h4 id="使用串流構建-Flutter-Widget"><a href="#使用串流構建-Flutter-Widget" class="headerlink" title="使用串流構建 Flutter Widget"></a>使用串流構建 Flutter Widget</h4><p>現在我們已經介紹了建立、操作和監聽串流，讓我們來談談如何在 Flutter 中使用它們來構建 Widget。</p>
<p>如果您閱讀了先前關於 <a href="https://medium.com/dartlang/dart-asynchronous-programming-futures-96937f831137">Futures</a> 的文章，您可能記得 <code>FutureBuilder</code>。您給它一個 Future 和一個構建器方法，它會根據 Future 的狀態構建 Widget。</p>
<p>對於串流，有一個類似的 Widget 稱為 <code>StreamBuilder</code>。給它一個像 number creator 那樣的串流和一個構建器方法，它會在每次串流發出新值時重建其子 Widget。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">  stream: NumberCreator().stream.map((i) =&gt; <span class="string">&#x27;String <span class="subst">$i</span>&#x27;</span>),</span><br><span class="line">  builder: (context, snapshot) &#123;</span><br><span class="line">    <span class="comment">// 構建一些 Widget</span></span><br><span class="line">    <span class="keyword">throw</span> UnimplementedError(<span class="string">&quot;Case not handled yet&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>snapshot</code> 參數是一個 <code>AsyncSnapshot</code>，就像 <code>FutureBuilder</code> 一樣。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">  stream: NumberCreator().stream.map((i) =&gt; <span class="string">&#x27;String <span class="subst">$i</span>&#x27;</span>),</span><br><span class="line">  builder: (context, snapshot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.waiting) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">const</span> Text(<span class="string">&#x27;No data yet.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> UnimplementedError(<span class="string">&quot;Case not handled yet&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>您可以檢查其 <code>connectionState</code> 屬性以查看串流是否尚未傳送任何資料，或者它是否已完全完成。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">  stream: NumberCreator().stream.map((i) =&gt; <span class="string">&#x27;String <span class="subst">$i</span>&#x27;</span>),</span><br><span class="line">  builder: (context, snapshot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.waiting) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">const</span> Text(<span class="string">&#x27;No data yet.&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.done)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">const</span> Text(<span class="string">&#x27;Done!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> UnimplementedError(<span class="string">&quot;Case not handled yet&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>您可以使用 <code>hasError</code> 屬性來處理資料值，並查看最新值是否為錯誤。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">StreamBuilder&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">  stream: NumberCreator().stream.map((i) =&gt; <span class="string">&#x27;String <span class="subst">$i</span>&#x27;</span>),</span><br><span class="line">  builder: (context, snapshot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.waiting) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">const</span> Text(<span class="string">&#x27;No data yet.&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snapshot.connectionState == ConnectionState.done) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">const</span> Text(<span class="string">&#x27;Done!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (snapshot.hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">const</span> Text(<span class="string">&#x27;Error!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Text(snapshot.data ?? <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最重要的是要確保您的構建器知道如何處理串流的所有可能狀態。一旦您掌握了這一點，它就可以對串流的任何操作做出反應。（有關更多資訊，包括您可以使用的 DartPad 實例，請參閱 <a href="https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html"><code>StreamBuilder</code> API 頁面</a>。）</p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>本文涵蓋了串流的含義、如何從串流中獲取值、操作這些值的方法，以及 <code>StreamBuilder</code> 如何幫助您在 Flutter 應用程式中使用串流值。</p>
<p>您可以從 Dart 和 Flutter 文件中了解更多關於串流的資訊：</p>
<ul>
<li>在 <a href="https://dart.dev/">dart.dev</a> 上，請參閱<a href="https://dart.dev/tutorials/language/streams">串流教學</a>、<a href="https://dart.dev/tutorials/server/cmdline">命令列應用程式教學</a> 以及函式庫導覽的 <a href="https://dart.dev/guides/libraries/library-tour#stream">串流部分</a>。</li>
<li>在 <a href="https://flutter.dev/">flutter.dev</a> 上，請參閱 <a href="https://flutter.dev/docs/cookbook/networking/web-sockets">使用 WebSockets</a>，其中包含一個使用 <code>StreamBuilder</code> 的範例。</li>
</ul>
<p><strong>敬請期待</strong>本系列的更多文章。接下來我們將討論 <code>async</code> 和 <code>await</code>。這是 Dart 提供的兩個關鍵字，可幫助您保持非同步程式碼的簡潔性和可讀性。</p>
<p>同時，您可以在我們的 YouTube 頻道上觀看關於《Dart 中的非同步程式設計》的<strong>下一部影片系列</strong>，或者<strong>訪問我們的網站</strong>以獲取更多關於 <a href="https://dart.dev/">Dart</a> 和 <a href="https://flutter.dev/">Flutter</a> 的資訊。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FSmTCmDMi4BY%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DSmTCmDMi4BY&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FSmTCmDMi4BY%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/924c442a7c91b7366476ddd092178bfe/href">https://medium.com/media/924c442a7c91b7366476ddd092178bfe/href</a></iframe>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/740/0*IGPMOenc2CSAeOFH.png" />
</figure>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=dab952023ed7" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/dart-asynchronous-programming-streams-dab952023ed7">Dart 非同步程式設計：串流</a> 最初發佈於 Medium 上的 <a href="https://medium.com/dartlang">Dart</a>，人們在那裡透過醒目顯示和回應這個故事來繼續對話。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/7c1bbf4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/7c1bbf4.html" class="post-title-link" itemprop="url">【文章翻譯】Contributors for Google Summer of Code 2022</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-07 09:23:41" itemprop="dateCreated datePublished" datetime="2022-04-07T09:23:41+08:00">2022-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-12-26 19:28:05" itemprop="dateModified" datetime="2024-12-26T19:28:05+08:00">2024-12-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動翻譯產生】</p>
<h2 id="徵求-Google-Summer-of-Code-2022-貢獻者"><a href="#徵求-Google-Summer-of-Code-2022-貢獻者" class="headerlink" title="徵求 Google Summer of Code 2022 貢獻者"></a>徵求 Google Summer of Code 2022 貢獻者</h2><figure><img alt="" src="https://cdn-images-1.medium.com/max/406/1*YkWeEU6ii0k_DW0bmrD0Ig.png" /></figure>

<p><a href="https://summerofcode.withgoogle.com/">Google Summer of Code</a> (GSoC) 是一個全球性的計畫，旨在讓學生開發者參與開源軟體開發。Google 贊助學生在夏季與一個指導性的開源組織合作進行一個 12 週以上的程式設計專案。在過去的 17 年裡，已有超過 18,000 名學生參與了 Google Summer of Code。</p>
<p>我們很高興地宣布，Dart 將在 2022 年的 Google Summer of Code 中擔任指導組織（這是第三次！）。查看成果文章，了解更多關於 <a href="https://medium.com/dartlang/google-summer-of-code-2020-results-a38cd072c9fe">2020</a> 年和 <a href="https://medium.com/dartlang/google-summer-of-code-2021-results-e514cce50fc">2021</a> 年的優秀專案。</p>
<h4 id="您有興趣嗎？"><a href="#您有興趣嗎？" class="headerlink" title="您有興趣嗎？"></a>您有興趣嗎？</h4><p>現在就開始閱讀 <a href="https://github.com/dart-lang/sdk/wiki/Dart-GSoC-2022-Project-Ideas">專案構想列表</a>，找到符合您的技能和興趣的專案。正式申請必須在 4 月 19 日之前提交，但鼓勵潛在申請者提交早期草稿並徵求回饋。</p>
<blockquote>
<p>Dart 團隊預計會有足夠的導師，但只會接受少數申請，因此也請查看 <a href="https://summerofcode.withgoogle.com/organizations/">其他指導組織</a>。</p>
</blockquote>
<p>如果您有關於 Dart 和 GSoC 的具體問題，請在我們 <a href="https://groups.google.com/g/dart-gsoc">專用的郵件列表</a> 中提問。</p>
<p>有關 Google Summer of Code 的更多資訊，請觀看下面的影片。或者閱讀 <a href="https://google.github.io/gsocguides/student/">Google Summer of Code 貢獻者指南</a>。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FS6IP_6HG2QE%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DS6IP_6HG2QE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FS6IP_6HG2QE%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href">https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href</a></iframe>

<p>我們期待您的參與！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=17e777f043f0" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/contributors-for-google-summer-of-code-2022-17e777f043f0">Google Summer of Code 2022 貢獻者</a> 最初發佈於 Medium 的 <a href="https://medium.com/dartlang">Dart</a>，人們在那裡透過醒目顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rainvisitor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">245</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">239</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rainvisitor</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
