<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>RainVisitor Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/page/2/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="RainVisitor Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RainVisitor Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.rainvisitor.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2024-05-06T17:35:44.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/cbc08ce3.html" class="article-date">
  <time datetime="2024-05-06T09:35:44.000Z" itemprop="datePublished">2024-05-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Flutter/">Flutter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/cbc08ce3.html">【文章翻譯】Best practices for optimizing Flutter web loading speed</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="優化-Flutter-Web-載入速度的最佳實務"><a href="#優化-Flutter-Web-載入速度的最佳實務" class="headerlink" title="優化 Flutter Web 載入速度的最佳實務"></a>優化 Flutter Web 載入速度的最佳實務</h2><p>身為一名與 Google Flutter 團隊合作，並在私人時間進行個人專案的 Flutter 開發人員，我遇到並理解了關於 Flutter Web 應用程式載入速度的擔憂。優化載入速度對於提升效能和提供良好的使用者體驗至關重要，尤其是在 Flutter 開發人員擴展到 Web 開發時。本指南提供可執行的策略和最佳實務，以加速 Flutter Web 應用程式的效能。</p>
<h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>CanvasKit 是 Flutter Web 應用程式的預設 <a href="https://docs.flutter.dev/platform-integration/web/renderers">渲染器</a>，它透過利用 WebGL 在平台間提供高效能和像素完美的一致性。這種功能對於需要豐富動畫和高保真度的複雜圖形應用程式特別有用。然而，CanvasKit 的內建檔案大小（約 1.5 MB）可能是一個缺點，特別是在初始載入時間至關重要的應用程式中。</p>
<p>儘管 <code>flutter.js</code> 載入 API 可並行下載 CanvasKit 和 <code>main.dart.js</code>，但所有 Flutter Widget 都必須等到它們完全載入到瀏覽器中，這可能會在應用程式變得互動之前導致明顯的延遲。為了減輕這些問題並優化載入體驗，開發人員可以選擇 Wasm 渲染模式。</p>
<p>由於 Flutter Web 中的 <a href="https://docs.flutter.dev/platform-integration/web/wasm">WebAssembly 支援</a> 被視為實驗性並且可能會發生變化，因此這些步驟適用於願意嘗試尖端功能的開發人員。功能和指令可能會演變，因此請務必參閱最新的 Flutter 文件以瞭解目前的實務。</p>
<h4 id="相容性"><a href="#相容性" class="headerlink" title="相容性"></a>相容性</h4><p>當使用 Wasm 進行構建時，<code>dart:html</code> 套件不受支援。此限制意味著您必須仔細考慮您的應用程式相依的 API。或者，<a href="https://pub.dev/packages/web">web 套件</a> 受 <code>dart2wasm</code> 和 <code>dart2js</code> 支援。</p>
<h4 id="效能"><a href="#效能" class="headerlink" title="效能"></a>效能</h4><p>Wasm 不僅與 CanvasKit 相比減少了應用程式大小，而且與 JavaScript 相比，啟動速度也更快。</p>
<h3 id="延遲載入"><a href="#延遲載入" class="headerlink" title="延遲載入"></a>延遲載入</h3><p>Dart 的 <a href="https://dart.dev/language/libraries#lazily-loading-a-library">延遲載入函式庫</a> 允許您分割程式碼，並且只在需要時載入部分程式碼，從而減少初始載入時間。以下部分將討論如何使用延遲載入。</p>
<h4 id="宣告延遲載入"><a href="#宣告延遲載入" class="headerlink" title="宣告延遲載入"></a>宣告延遲載入</h4><p>在 Dart 檔案的頂部，宣告您要延遲載入的載入。在載入陳述式中，指定 <code>deferred</code>，後面接著識別符號。當您需要使用函式庫時，請使用延遲載入的 <code>loadLibrary()</code> 方法非同步載入它：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:myapp/hello.dart&#x27;</span> <span class="keyword">deferred</span> <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; loadHelloLibrary() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.sayHi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="呼叫載入函數"><a href="#呼叫載入函數" class="headerlink" title="呼叫載入函數"></a>呼叫載入函數</h4><p>在您的 Flutter 應用程式中，根據需要呼叫此函數，例如，作為對使用者互動的回應。以下範例在使用者按下 Widget 時載入所需的函式庫：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  runApp(MaterialApp(home: MyApp()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: ElevatedButton(</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            loadHelloLibrary();</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Text(<span class="string">&#x27;Load Feature&#x27;</span>),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="未等待的函數呼叫"><a href="#未等待的函數呼叫" class="headerlink" title="未等待的函數呼叫"></a>未等待的函數呼叫</h3><p>為了減少顯示應用程式初始 Widget 所花費的時間，請嘗試在呼叫 <code>runApp</code> 之前不要等待代價高昂的 Future。可以將一些 Future 設為未等待，以便它們在完成後更新 UI。<a href="https://api.flutter.dev/flutter/dart-async/unawaited.html">unawaited 函數</a> 允許應用程式程式設計師明確告知「未等待的 Future」提示，這些 Future 不會等待。此改進透過讓應用程式感覺更具回應性，在應用程式啟動和頁面載入期間都增強了使用者體驗。但是，必須小心管理這些函數，以避免與應用程式狀態一致性和資源管理相關的問題。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:async&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  unawaited(downloadVideos().then((videos) &#123;</span><br><span class="line">    playlist.add(videos);</span><br><span class="line">  &#125;));</span><br><span class="line"></span><br><span class="line">  runApp(<span class="keyword">const</span> MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="媒體檔案"><a href="#媒體檔案" class="headerlink" title="媒體檔案"></a>媒體檔案</h3><h4 id="以最佳解析度顯示資產"><a href="#以最佳解析度顯示資產" class="headerlink" title="以最佳解析度顯示資產"></a>以最佳解析度顯示資產</h4><p>Flutter 會自動根據設備的像素密度 <a href="https://docs.flutter.dev/ui/assets/assets-and-images#resolution-aware">以適當的解析度載入資產</a>。這可確保在不同螢幕尺寸上顯示最佳視覺效果。雖然優化資產以進行有效傳遞很重要，但請優先考慮在探索替代圖片格式之前提供所需精確解析度的資產，就像我們在下一節中將討論的那樣。</p>
<h4 id="更好的圖片壓縮"><a href="#更好的圖片壓縮" class="headerlink" title="更好的圖片壓縮"></a>更好的圖片壓縮</h4><p>PNG 和 JPG 是網站上使用最普遍的圖片格式。這些格式以其廣泛的支援和相容性而聞名。然而，新一代格式（如 <a href="https://developers.google.com/speed/webp">WebP</a> 和 <a href="https://netflixtechblog.com/avif-for-next-generation-image-coding-b1d75675fe4">AVIF</a>）在減少檔案大小方面取得了重大進展，而不會顯著降低圖片品質。例如，原始大小為 319 KB 的 PNG 圖片可以用 WebP 格式壓縮到僅 38 KB，或者更令人印象深刻的是，可以用 AVIF 格式壓縮到 10 KB。這些檔案大小的縮減是透過肉眼幾乎無法察覺的品質損失來實現的，這證明了這些格式在保持視覺保真度的同時，提升網站載入速度的潛力。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*_bz3_DRzn9aoB0qD" />
<figcaption>PNG 319 KB / WebP 38 KB / AVIF 10 KB</figcaption>
</figure>

<p>然而，重要的是要注意，並非所有瀏覽器都支援 <a href="https://caniuse.com/webp">WebP</a> 和 <a href="https://caniuse.com/avif">AVIF</a> 圖片。在將這些格式整合到您的網站之前，請驗證它們與您的觀眾最常使用的瀏覽器的相容性。這將幫助您確定這些新一代圖片格式是否符合您的網站要求和觀眾需求。</p>
<h3 id="快取"><a href="#快取" class="headerlink" title="快取"></a>快取</h3><h4 id="記憶體、磁碟、Service-Worker-快取"><a href="#記憶體、磁碟、Service-Worker-快取" class="headerlink" title="記憶體、磁碟、Service Worker 快取"></a>記憶體、磁碟、Service Worker 快取</h4><p>利用記憶體快取、磁碟快取和 Service Worker 的功能可以顯著減少初始頁面載入後的載入時間。這是因為這些快取機制需要檔案先載入一次，然後才能快取它們。記憶體快取儲存在 RAM 中，提供快速的存取速度，但易失性。另一方面，磁碟快取雖然速度較慢，但提供持久性。Service Worker 作為可程式化的網路代理，可以跨記憶體和磁碟實現複雜的快取策略。</p>
<p>瀏覽器或作業系統通常會自動管理記憶體和磁碟快取，除非有特定的要求需要以程式方式操作它們，否則不需要手動干預。雖然 Flutter 在一定程度上管理 Service Worker，但開發人員可以靈活地在 Flutter 之外實作自訂 Service Worker，以增強對快取和網路互動的控制。</p>
<h4 id="Wasm"><a href="#Wasm" class="headerlink" title="Wasm"></a>Wasm</h4><p>瀏覽器會快取 Wasm 檔案（如 CanvasKit，以及很快的 <code>dart2wasm</code> 輸出），以及它們的編譯原生程式碼。這意味著快取的 Wasm 模組載入速度與原生二進制檔案一樣快，與 JavaScript 不同，JavaScript 需要重新解析、重新編譯和重新 JIT（Just-In-Time）處理。</p>
<p>雖然 Flutter 的 Wasm 構建選項尚未完全穩定，但當 <code>dart2wasm</code> 穩定後，採用現代 JS-interop 實務會使您受益。例如，避免使用 <code>dart:html</code> 和 <code>dart:js</code> 等傳統函式庫，並優先考慮 <code>package:web</code> 和 <code>dart:js_interop</code>。此外，請考慮檢查您正在使用的其他套件是否與 Wasm 相容。</p>
<h3 id="預載入"><a href="#預載入" class="headerlink" title="預載入"></a>預載入</h3><h4 id="HTML-標籤、HTTP-響應標頭"><a href="#HTML-標籤、HTTP-響應標頭" class="headerlink" title="HTML &lt;head&gt; 標籤、HTTP 響應標頭"></a>HTML <code>&lt;head&gt;</code> 標籤、HTTP 響應標頭</h4><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/preload">預載入資產</a>（如圖片、字體和 JavaScript 檔案）可以顯著提高網頁載入速度。透過在 HTML <code>&lt;head&gt;</code> 標籤中預載入或使用 HTTP 響應標頭，您可以指示瀏覽器在需要用於渲染之前下載這些資源。這樣可以消除延遲，並確保更順暢的使用者體驗。若要預載入資產，請在 <code>&lt;head&gt;</code> 部分添加 <code>&lt;link&gt;</code> 標籤，並將 <code>rel</code> 屬性設定為 <code>preload</code>。僅預載入立即使用的資產，最優化的是應用程式的第一個螢幕，否則瀏覽器會將預載入視為浪費頻寬。</p>
<h4 id="HTML-標籤"><a href="#HTML-標籤" class="headerlink" title="HTML &lt;head&gt; 標籤"></a>HTML <code>&lt;head&gt;</code> 標籤</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;assets/logo.webp&quot;</span> <span class="attr">as</span>=<span class="string">&quot;image&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;assets/logo.webp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/webp&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Firebase-托管的-HTTP-響應標頭"><a href="#Firebase-托管的-HTTP-響應標頭" class="headerlink" title="Firebase 托管的 HTTP 響應標頭"></a>Firebase 托管的 HTTP 響應標頭</h4><p>以下程式碼塊是一個 <code>firebase.json</code> 範例，其中包含一個鍵&#x2F;值組合，展示如何為資產預載入添加 HTTP 標頭。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;headers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Link&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;assets/logo.webp&gt;; rel=preload; as=image&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h4 id="登陸頁面"><a href="#登陸頁面" class="headerlink" title="登陸頁面"></a>登陸頁面</h4><p>Flutter 使您能夠使用純粹的 HTML&#x2F;CSS 為您的應用程式構建完全互動式的登陸頁面。當使用者與您的登陸頁面互動時，<code>flutter.js</code> 會預載入您的 Flutter 應用程式 - 確保使用者導航到 Flutter 應用程式時立即啟動。這對於具有 <strong>播放</strong> 按鈕的遊戲和需要登入的應用程式特別有用。</p>
<h3 id="載入-啟動畫面"><a href="#載入-啟動畫面" class="headerlink" title="載入&#x2F;啟動畫面"></a>載入&#x2F;啟動畫面</h3><p>雖然我們一直關注應用程式載入速度的技術優化，但感知載入速度更為關鍵。您的目標應該是讓您的應用程式 <em>感覺很快</em>。</p>
<p>載入&#x2F;啟動畫面在增強這種感知方面非常有效。透過提供視覺活動，它們向使用者保證應用程式正在迅速啟動。相反，空白螢幕會引起不確定性，可能會導致沮喪和頁面重新整理。</p>
<p>為了實現最快的回應能力，請使用純粹的 CSS&#x2F;HTML 在您的 <code>index.html</code> 檔案中直接實作啟動畫面。這可以最大限度地減少任何潛在的延遲。</p>
<p>例如，請查看 <a href="https://github.com/flutter/gallery/blob/cfcb9dbda56697fe8bafe4b64c1a9261dde908ae/web/index.html#L211">Flutter Gallery 實作</a>。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>在本文件中，我們探討了加速 Flutter Web 應用程式初始載入和渲染效能的方法。您可以採用多種策略，但請記住，每個解決方案都涉及權衡取捨。選擇最適合您的特定需求和使用者需求的優化。透過結合這些方法، 您可以為您的 Flutter Web 應用程式創造更流暢、更具回應性的使用者體驗。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7cc0df14ce5c" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/best-practices-for-optimizing-flutter-web-loading-speed-7cc0df14ce5c">優化 Flutter Web 載入速度的最佳實務</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/cbc08ce3.html" data-id="cm1ntp44e0001v517bvcdf595" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flutter/" rel="tag">flutter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flutter-web/" rel="tag">flutter-web</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flutter-web-development/" rel="tag">flutter-web-development</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2024-03-28T15:01:12.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/793e693d.html" class="article-date">
  <time datetime="2024-03-28T07:01:12.000Z" itemprop="datePublished">2024-03-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dart/">Dart</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/793e693d.html">【文章翻譯】History of JS interop in Dart</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Dart-中-JS-互操作的歷史"><a href="#Dart-中-JS-互操作的歷史" class="headerlink" title="Dart 中 JS 互操作的歷史"></a>Dart 中 JS 互操作的歷史</h2><h4>Wasm 支援剛剛在現有的 Flutter beta 版本中推出，這得益於 Dart 3.3 中達成的令人興奮的 JavaScript 互操作里程碑。為了慶祝，我們回顧了 Dart 和 JS 互操作長達十年的發展歷程。</h4>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*dhBQqKXU46sGKjx36LNf0w.jpeg" />
<figcaption>AI Image generated by Gemini</figcaption>
</figure>

<p>互操作性一直是 Dart 從一開始就關注的核心議題。當 Dart 在 2011 年首次發佈時，它被設計為 <em>可嵌入</em> 和 <em>跨平台</em> 的。它運行在獨立的虛擬機上，嵌入在瀏覽器中，並編譯為 JavaScript。當 Flutter 在 2015 年出現時，我們已經準備好將它嵌入到這裡。現在，我們也很興奮地 <a href="https://docs.flutter.dev/platform-integration/web/wasm">將目標定位到 WasmGC 執行時</a>。</p>
<p>起初，我們迅速努力暴露 Dart 嵌入的每個平台的功能。這就是我們的 SDK 平台特定函式庫出現的方式：<a href="https://api.dart.dev/stable/dart-io/dart-io-library.html">dart:io</a> 暴露了 VM 上的文件系統，<a href="https://api.dart.dev/stable/dart-html/dart-html-library.html">dart:html</a> 暴露了 Web 上的瀏覽器 API，等等。這些函式庫看起來和感覺起來像普通的 Dart 函式庫，但在幕後隱藏了一些複雜的低階原生元素，使它們能夠運作。這是我們發明的第一種互操作形式。它表達力強，但僅限於 SDK 函式庫。</p>
<p>在 Web 上，開發人員需要的遠不止瀏覽器 API。因此，我們開始尋找將互操作性擴展到更多目標的方法。作為起點，我們在 2013 年引入了 <a href="https://codereview.chromium.org//15782009">dart:js</a>，以啟用存取 JavaScript 函式庫。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Short example JavaScript code to illustrate Dart/JS interop</span><br><span class="line">window.myTopLevel = &#123;</span><br><span class="line">  field1: 0,</span><br><span class="line">  method2() &#123;</span><br><span class="line">    return this.field1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// Access via `dart:js` (2013)</span><br><span class="line">import &#x27;dart:js&#x27; as js;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // This line has a typo! oops :(</span><br><span class="line">  var object = js.context[&#x27;myTopLevl&#x27;];</span><br><span class="line">  object[&#x27;field1&#x27;] = 1;</span><br><span class="line">  // This call fails with a noSuchMethod because method2</span><br><span class="line">  // returns an int, oops</span><br><span class="line">  object.callMethod(&#x27;method2&#x27;, []).substr(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們當時就知道 dart:js 不是我們想要的程式設計模型。您必須使用字串來存取 JavaScript 中的名稱 - 忘記編譯時找到問題，更別提代碼補全了！實作起來也很昂貴。它在大多数操作中高度依赖盒子和深度复制。因此，我們在 2014 年和 2015 年繼續 <a href="https://github.com/dart-archive/js-interop-deprecated">草擬</a> 想法，直到發佈了 package:js v0.6。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Access via `package:js` (2015)</span><br><span class="line">import &#x27;package:js/js.dart&#x27;;</span><br><span class="line"></span><br><span class="line">// Magic annotations allow us to declare API signatures:</span><br><span class="line">@JS()</span><br><span class="line">class MyObject &#123;</span><br><span class="line">  external int get field1;</span><br><span class="line">  external void set field1(int value);</span><br><span class="line">  external String method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@JS()</span><br><span class="line">external MyObject get myTopLevel;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  // Access to code is less error prone: analyzer can check that</span><br><span class="line">  // these symbols match a declaration, and we get code-completion too!</span><br><span class="line">  var object = myTopLevel;</span><br><span class="line">  object.field1 = 1;</span><br><span class="line">  // But types are not checked, this unsoundly invokes substring on an int</span><br><span class="line">  object.method2().substring(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了 <a href="https://pub.dev/documentation/js/latest/">package:js</a>，我們終於擁有一個開放的 API，它既高效又使用者友善。您可以在抽象類別上添加一些註解，然後 <em>voila</em>，您就可以存取 JavaScript API。它就像魔法一樣運作，直到它失效。有很多事情您無法使用 package:js 做到：直接存取瀏覽器 API、重新命名成員、轉換、附加 Dart 邏輯，以及 <a href="https://github.com/dart-lang/sdk/issues/35084">更多</a>。為了彌補，我們還發佈了 <a href="https://codereview.chromium.org/2150313003/">dart:js_util</a> - 一個類似於 dart:js 的輕量級高效低階 API，作為後備方案。package:js 中的所有限制確實困擾著我們，但我們束手無策。我們需要從 Dart 語言中獲得更多幫助才能做得更好。</p>
<p>在那段時間裡，我們已經在為語言做最大的變更，我們從未做過 - 我們正在使 Dart <a href="https://dart.dev/language/type-system#what-is-soundness">健全</a>。具有諷刺意味的是，當我們在 2018 年使用 Dart 2.0 發佈新的類型系統時，互操作性變得 <em>更差</em> 了！除了早期的限制之外，使 package:js 特殊的魔法也有陰暗面 - 它無法檢查類型的有效性。這意味著我們的互操作性是我們其他健全語言中不健全的來源。</p>
<p>然後，我們的旅程轉變為專注於改善 Dart 和 JS 互操作，作為一項協同努力。我們秉持著明確的原則（要慣用、表達力強、可組合、精確、易於使用、務實、非魔法且完整），朝著一個以類型和靜態分派為基礎的設計前進，並挑戰 Dart 語言。此後，語言同步演進。</p>
<ul>
<li>在 2019 年，Dart 2.7 添加了靜態擴展方法。您可以將自訂 Dart 邏輯附加到 JS 互操作類別，並轉換值，例如將 JS Promise 轉換為 Dart Future，而無需使用包裝器。</li>
<li>在 2021 年，我們發佈了 package:js v0.6.4 中的 @staticInterop。最終，JS 互操作變得足夠表達力強 - 您可以暴露以前專屬於 SDK 函式庫（如 dart:html）管理的瀏覽器 API。</li>
<li>在 2023 年，當我們在 Dart 3.0 中放棄不健全的空安全時，我們終於看到了取得的進展，我們的設計和 @staticInterop 的工作使我們清楚地知道，我們已經準備好解決長期以來存在的健全性差距。</li>
</ul>
<p>那一年，我們引入了編譯到 WasmGC，並利用 JS 互操作在它上面運行豐富的框架，例如 <a href="https://medium.com/flutter/whats-next-for-flutter-b94ce089f49c">Flutter Web</a>。這激發了對 <a href="https://dart.dev/interop/js-interop/js-types">JS 類型</a> 的工作，以便在程式設計模型中明確定義 Dart 和 JS 的界限，並找到在 Wasm 和 JS 編譯目標中與 JS 相處的統一方法。我們還開始了 <a href="https://dart.dev/language/extension-types">擴展類型</a> 語言實驗 - 一項在 Dart 3.3 中推出的功能，它彌合了 Dart 語言和 JS 互操作之間的差距。多年來，JS 互操作一直存在一些行為，例如類型擦除，這些行為與 Dart 中的其他任何東西都不匹配。有了擴展類型，JS 互操作終於可以變得慣用，並在 Dart 開發工具中獲得它應有的支援。</p>
<p>儘管一路上經歷了許多變化和轉折，但有一件事始終保持一致：我們 Dart 社群的積極參與。社群成員率先對 dart:js 進行測試和貢獻，然後又影響了 package:js 的設計。他們編寫了工具來解決功能差距（<a href="https://github.com/a14n/dart-js-wrapping">package:js_wrapping</a>），並嘗試透過自動生成 Dart API 來提高生產力（<a href="https://github.com/dart-archive/js_facade_gen">package:js_facade_gen</a>、<a href="https://pub.dev/packages/js_bindings">package:js_bindings</a>、<a href="https://pub.dev/packages/typings">package:typings</a>）。每一次貢獻都幫助 Dart 的互操作設計變得更好。對於在這裡的每個人，感謝您使這段旅程如此令人興奮！</p>
<p>最後，我們來到了 2024 年。我們在 Dart 3.3 中發佈了 <a href="https://dart.dev/interop/js-interop">dart:js_interop</a>，以及 <a href="https://dart.dev/interop/js-interop/package-web">package:web</a>，這是 Dart 中最新的 JS 互操作解決方案，使 <a href="https://docs.flutter.dev/platform-integration/web/wasm">將 Flutter 編譯到 Wasm</a> 成为可能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Access via `dart:js_interop` (2024)</span><br><span class="line">import &#x27;dart:js_interop&#x27;;</span><br><span class="line"></span><br><span class="line">// Declarations use extension types, which are very similar to package:js</span><br><span class="line">// declarations. The main difference: they are statically dispatched.</span><br><span class="line">extension type MyObject._(JSObject _) implements JSObject &#123;</span><br><span class="line">  external int get field1;</span><br><span class="line">  external void set field1(int value);</span><br><span class="line">  external String method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@JS()</span><br><span class="line">external MyObject get myTopLevel;</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  var object = myTopLevel;</span><br><span class="line">  object.field1 = 1;</span><br><span class="line">  // At last, access is sound - this line fails with a type error</span><br><span class="line">  // when returning from method2.</span><br><span class="line">  object.method2().substring(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>dart:js_interop 是一種靜態、健全、慣用、表達力強且一致的互操作形式，基於擴展類型，能夠暴露任何 JavaScript 或瀏覽器 API。</li>
<li>package:web 使用 dart:js_interop 來完成 dart:html 13 年前做的事情，但以一種在 JavaScript 和 WasmGC 中都支援的方式。</li>
</ul>
<p>今天，我們很高興地慶祝 Dart&#x2F;JS 互操作的新形式，以及它帶來的未來。了解我們的過去，我们確信這不是旅程的終點，而是我們歷史上一個令人興奮的時刻。</p>
<p>我們迫不及待地想看看您將用它建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=98b06991158f" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/history-of-js-interop-in-dart-98b06991158f">Dart 中 JS 互操作的歷史</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/793e693d.html" data-id="cm1nvba260009h1178bvwcfdk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dart/" rel="tag">dart</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dartlang/" rel="tag">dartlang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interoperability/" rel="tag">interoperability</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2024-03-05T09:02:06.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/c653c78e.html" class="article-date">
  <time datetime="2024-03-05T01:02:06.000Z" itemprop="datePublished">2024-03-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dart/">Dart</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/c653c78e.html">【文章翻譯】Dart in Google Summer of Code 2024</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Dart-在-2024-年-Google-暑期程式碼計畫"><a href="#Dart-在-2024-年-Google-暑期程式碼計畫" class="headerlink" title="Dart 在 2024 年 Google 暑期程式碼計畫"></a>Dart 在 2024 年 Google 暑期程式碼計畫</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/801/1*69jdaJUqgu_phIVF4w-7_A.png" />
</figure>

<p>Google 暑期程式碼計畫 (GSoC) 致力於將來自世界各地的學生開發者引入開源軟體開發。Google 在夏季贊助學生與一個開源的指導組織合作，進行一個為期 12 週（或更長）的程式設計專案。在過去的 19 年中，超過 20,000 名貢獻者參與了 Google 暑期程式碼計畫。</p>
<p>我們很興奮地宣布，Dart 專案將在 2024 年 Google 暑期程式碼計畫中（第五次！）指導貢獻者。</p>
<h4>您有興趣嗎？</h4>

<p>現在就開始，閱讀 <a href="https://github.com/dart-lang/sdk/wiki/Dart-GSoC-2024-Project-Ideas">專案想法清單</a> 尋找符合您的技能和興趣的專案。正式申請必須在 4 月 2 日之前提交。我們鼓勵潛在申請人提前提交草稿並要求回饋。</p>
<blockquote><em>Dart 團隊預計有足夠的指導者，只能接受少數申請，因此請查看 [其他指導組織](https://summerofcode.withgoogle.com/programs/2024/organizations)。</em></blockquote>

<p>如果您對 Dart 和 GSoC 有任何特定問題，請在 <a href="https://groups.google.com/g/dart-gsoc">我們專用的郵件清單</a> 上提出。</p>
<p>若要進一步了解 Google 暑期程式碼計畫，請觀看以下影片或閱讀 <a href="https://google.github.io/gsocguides/student/">Google 暑期程式碼計畫的貢獻者指南</a>。</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FS6IP_6HG2QE%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DS6IP_6HG2QE&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FS6IP_6HG2QE%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href">https://medium.com/media/2f7a6111e84d69cfd8478327d937df69/href</a></iframe>

<p>我們期待收到您的來信！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8ca45fb6dc4e" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/dart-in-google-summer-of-code-2024-8ca45fb6dc4e">Dart 在 2024 年 Google 暑期程式碼計畫</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>
<p>undefined</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/c653c78e.html" data-id="cm1nvba260006h117e74fg7ys" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dartlang/" rel="tag">dartlang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/flutter/" rel="tag">flutter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/google-summer-of-code/" rel="tag">google-summer-of-code</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/open-source/" rel="tag">open-source</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2023-11-15T21:44:57.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/6c7c35de.html" class="article-date">
  <time datetime="2023-11-15T13:44:57.000Z" itemprop="datePublished">2023-11-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dart/">Dart</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/6c7c35de.html">【文章翻譯】Announcing Dart 3.2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Dart-3-2"><a href="#宣布-Dart-3-2" class="headerlink" title="宣布 Dart 3.2"></a>宣布 Dart 3.2</h2><p>作者： <a href="https://medium.com/u/441fe70f4b5e">Kevin Moore</a> 和 <a href="https://medium.com/u/a6d788faa5e5">Michael Thomsen</a></p>
<p>今天，我們宣布推出 Dart 3.2，其中包含一個新的語言功能，用於對私有 final 欄位進行非空推斷，透過新的互操作性功能改進開發人員體驗，支援 DevTools 中的擴展，以及關於我們的 Web 路線圖的更新，包括對 Wasm（又名 WebAssembly）的支援。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*u5YRn1uMmXf94b2aPbcLRQ.png" />
</figure>

<h3 id="私有-final-欄位的非空推斷"><a href="#私有-final-欄位的非空推斷" class="headerlink" title="私有 final 欄位的非空推斷"></a>私有 final 欄位的非空推斷</h3><p>自從我們在 Dart 2.12 中引入 <a href="https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87">可靠的空安全</a> 已經過了好幾年。在空安全中，您可以宣告哪些類型是可空的（可能包含值或 null），以及哪些類型是非空的（始終包含值）。空安全與 <a href="https://dart.dev/null-safety/understanding-null-safety#flow-analysis">流分析</a> 結合在一起，可以偵測到可空變數何時可以「推斷」為更安全的非空類型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> definitelyInt(<span class="built_in">int?</span> aNullableInt) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aNullableInt == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果流分析到達此處，</span></span><br><span class="line">  <span class="comment">// aNullableInt 可以安全地推斷為非空的 int。</span></span><br><span class="line">  <span class="keyword">return</span> aNullableInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>類型推斷自 Dart 2.12 起一直是空安全的核心部分，但僅限於區域變數。欄位或頂層變數無法推斷，例如在這種情況下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int?</span> _fillLevel;</span><br><span class="line">  Container(<span class="keyword">this</span>._fillLevel);</span><br><span class="line">  check() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_fillLevel != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="built_in">int</span> i = _fillLevel; <span class="comment">// 在 Dart 3.2 之前，會導致錯誤。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這種限制是由于在流分析無法安全地確定何時或如何更改欄位的一些複雜情況造成的。例如，在類別的欄位推斷情況下，如果子類別使用 getter 覆蓋欄位，而 getter 有時會返回 null，就會出現問題。</p>
<p>在 Dart 3.2 中，我們改進了我們的流分析引擎，現在能夠推斷 <strong>私有 final 欄位</strong> 的類型。現在，上面的程式碼片段可以在沒有錯誤的情況下通過。這利用了這樣一種了解，即對於私有和 final 欄位，在初始賦值之後，該值永遠不會改變，因此只檢查一次被認為是安全的。私有的 final 欄位推斷從 Dart 3.2 開始可用，並且將應用於 Dart SDK <a href="https://dart.dev/guides/language/evolution#language-versioning">下限</a> 為 3.2 或更高的專案。</p>
<h3 id="package-lints-3-0-中的新的程式碼分析選項"><a href="#package-lints-3-0-中的新的程式碼分析選項" class="headerlink" title="package:lints 3.0 中的新的程式碼分析選項"></a>package:lints 3.0 中的新的程式碼分析選項</h3><p>說到程式碼分析，我們還在 <a href="https://pub.dev/packages/lints">package:lints</a> 中對我們的標準程式碼分析規則進行了一些改進。這個套件包含與使用 <code>dart create</code> 或 <code>flutter create</code> 建立的任何新專案一起提供的預設和推薦的靜態分析規則集（透過 <a href="https://pub.dev/packages/flutter_lints">package:flutter_lints</a> - package:lints 的擴展）。</p>
<p>這個 lint 集的最新主要版本 3.0 現在已經可以使用了。此修訂版在核心集添加了六個 lint，在推薦集添加了兩個 lint。它具有用於驗證 pubspec URL、驗證集合方法是否使用正確參數調用等的 lint。若要查看完整的更改列表，請查看 <a href="https://github.com/dart-lang/lints/blob/main/CHANGELOG.md#300">變更日誌</a>。3.0 版本將是下一個版本中新專案的預設版本。對於現有專案，您可以 <a href="https://github.com/dart-lang/lints#upgrading-to-the-latest-lints">立即升級</a>。</p>
<h3 id="Dart-互操作性更新"><a href="#Dart-互操作性更新" class="headerlink" title="Dart 互操作性更新"></a>Dart 互操作性更新</h3><p>在 <a href="https://dart.dev/overview#platform">各種平台</a> 上的多平台支援一直是 Dart 的核心原則。但是，即使 Dart 程式碼行可以在所有這些平台上無需更改地執行，大型應用程式仍然經常需要與現有程式碼互操作。這可能意味著來自舊專案的程式碼，或在其他函式庫或系統 API 中可用的 API。我們在這個領域進行了一系列投資，從用於 <a href="https://dart.dev/guides/libraries/c-interop">與原生 C API 互操作</a> 的 FFI 開始。我們目前正在努力將其擴展以支援與 <a href="https://dart.dev/guides/libraries/java-interop">Java 和 Kotlin</a> 以及 <a href="https://dart.dev/guides/libraries/objective-c-interop">Objective C 和 Swift</a> 互操作。有關 JS 互操作性的令人興奮的更新，請查看下面的 Dart Web 部分。</p>
<p>截至 Dart 3.2，我們對原生互操作性進行了許多改進：</p>
<ul>
<li>我們為 C FFI 引入了 <a href="https://api.dart.dev/stable/dart-ffi/NativeCallable/NativeCallable.isolateLocal.html">NativeCallable.isolateLocal</a> 建構函式，它從任意 Dart 函數建立 C 函數指標。這是 <a href="https://api.dart.dev/stable/dart-ffi/Pointer/fromFunction.html">Pointer.fromFunction</a> 提供的功能的擴展，它只能從頂層函數建立函數指標。</li>
<li>我們更新了 Objective-C 綁定生成器，以使用 <a href="https://api.dart.dev/stable/dart-ffi/NativeCallable/NativeCallable.listener.html">NativeCallable.listener</a>，我們在 Dart 3.1 中添加了它。生成器現在可以自動處理包含異步回調的 API，例如 <a href="https://developer.apple.com/documentation/coremotion">Core Motion</a>。以前，此類 API 需要手動編寫一些綁定程式碼。</li>
<li>我們繼續改進用於 Java 和 Kotlin 互操作性的 <a href="https://dart.dev/guides/libraries/java-interop">package:jnigen</a>。這使我們能夠將 <a href="https://pub.dev/packages/cronet_http">package:cronet_http</a> - Android Cronet HTTP 客戶端的包裝器 - 從手動編寫的綁定程式碼遷移到自動 <a href="https://github.com/dart-lang/http/blob/master/pkgs/cronet_http/jnigen.yaml">生成的</a> 包裝器。</li>
<li>我們在 <a href="https://github.com/dart-lang/sdk/issues/50565">原生資產</a> 功能方面取得了重大進展，該功能旨在解決與依賴原生程式碼的 Dart 套件分發相關的許多問題。它透過提供用於整合與構建 Flutter 和獨立 Dart 應用程式相關的各種構建系統的統一掛鉤來實現。若要查看預覽，請查看 <a href="http://dart.dev/guides/libraries/c-interop#native-assets">文件</a>。</li>
</ul>
<h3 id="Dart-套件的-DevTools-擴展"><a href="#Dart-套件的-DevTools-擴展" class="headerlink" title="Dart 套件的 DevTools 擴展"></a>Dart 套件的 DevTools 擴展</h3><p>Dart <a href="https://dart.dev/tools/dart-devtools">DevTools</a> 是一套用於除錯和效能分析的工具，支援純 Dart 和 Flutter 應用程式。在 Dart 3.2 和 Flutter 3.16 中，我們 <a href="https://medium.com/p/c8bc1aaf8e5f/">宣布</a> 推出一個新的 <a href="https://pub.dev/packages/devtools_extensions">擴展框架</a>，它使套件作者能夠為他們的套件構建自訂工具，並直接在 DevTools 中顯示。這允許包含框架的 pub.dev 套件提供專門針對其用例的自訂工具。例如，<a href="https://pub.dev/packages/serverpod">Serverpod</a> 的作者一直在努力為他們的套件構建開發人員工具，並且很高兴地宣布他們将在即将发布的 <a href="https://github.com/orgs/serverpod/projects/4">1.2 版本</a> 中发布 DevTools 扩展。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*N6ZSt1McXO_opQU7" />
<figcaption><em>計劃在即將推出的 ServerPod 1.2 版本中使用的 DevTools 擴展</em></figcaption>
</figure>

<h3 id="Dart-Web-和-Wasm-更新"><a href="#Dart-Web-和-Wasm-更新" class="headerlink" title="Dart Web 和 Wasm 更新"></a>Dart Web 和 Wasm 更新</h3><p>Wasm（也稱為 <a href="https://webassembly.org/">WebAssembly</a>）是一種用於 Web 瀏覽器的令人興奮的新指令格式，它提供了一種可移植、平台中立的二進制程式碼格式，以便在現代瀏覽器中執行。像 Dart 這樣的更高級別的受控語言使用垃圾收集，而垃圾收集正在添加到 Wasm 標準中。截至 Chrome 119，<a href="https://developer.chrome.com/blog/wasmgc/">Wasm 的垃圾收集支援</a>（稱為 Wasm-GC）已預設啟用。Wasm-GC 支援也即將在 Firefox 120 中推出，這是他們的下一個穩定版本。那麼 Dart、Flutter 和 Wasm-GC 的狀態如何呢？</p>
<p>Dart 到 Wasm 編譯器幾乎已完成功能。團隊對效能和相容性非常滿意。我們現在的重點是邊緣情況，以確保我們的輸出在各種情況下都能快速執行。</p>
<p>對於 Flutter Web，我們已完成一個新的「Skwasm」渲染引擎。為了最大限度地提高效能，Swasm 將編譯後的應用程式程式碼直接連接到使用 wasm 到 wasm 綁定的自訂 <a href="https://skia.org/docs/user/modules/canvaskit/">CanvasKit Wasm 模組</a>。它也是 Flutter Web 多線程渲染支援的第一個版本，它可以進一步提高幀時間。</p>
<p>在 Flutter Web 與 Wasm 擺脫目前的實驗狀態之前，還有一些事情需要完成：</p>
<ul>
<li><strong>雙重編譯：</strong> 生成 Wasm 和 JavaScript 輸出，并在運行時啟用功能偵測，以支持具有 Wasm-GC 支援和沒有 Wasm-GC 支援的瀏覽器。</li>
<li><strong>現代 JavaScript 互操作性：</strong> 基於 <a href="https://github.com/dart-lang/language/issues/2727">擴展類型</a> 的新的 JS 互操作性機制，以在針對 JavaScript 和 Wasm 時，在 Dart 程式碼、瀏覽器 API 和 JS 函式庫之間實現簡潔、類型安全的調用。</li>
<li><strong>具有 Wasm 支援的瀏覽器 API：</strong> 一個新的 package:web，基於現代 JS 互操作性機制，取代 dart:html（以及相關的函式庫）。這將為 JS 和 Wasm 目標上的瀏覽器 API 提供簡單的存取權。</li>
</ul>
<p>我們開始將許多內部專案遷移到 package:web 和新的 JS 互操作性機制，並預計在下一個穩定版本中會有更多更新。同時，您可以在我們的 <a href="https://flutter.dev/wasm">WebAssembly 支援</a> 頁面上獲取最新詳細資訊。</p>
<h3>結語</h3>

<p>今天就到這裡。Dart 3.2 現在可以從 <a href="https://dart.dev/get-dart">dart.dev</a> 中獲取，或者作為今天 <a href="https://medium.com/flutter/whats-new-in-flutter-3-16-dba6cb1015d1">Flutter 3.16</a> 版本的一部分。下次再見，祝您使用 Dart 開發愉快！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c8de8fe1b91f" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/dart-3-2-c8de8fe1b91f">宣布 Dart 3.2</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>
<p>undefined</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/6c7c35de.html" data-id="cm1nvba250004h1177es5ge3y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dart/" rel="tag">dart</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dartlang/" rel="tag">dartlang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2023-08-16T18:00:21.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/46a8336.html" class="article-date">
  <time datetime="2023-08-16T10:00:21.000Z" itemprop="datePublished">2023-08-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dart/">Dart</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/46a8336.html">【文章翻譯】Dart 3.1 &amp; a retrospective on functional style programming in Dart 3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Dart-3-1：回顧-Dart-3-中的功能式程式設計風格"><a href="#Dart-3-1：回顧-Dart-3-中的功能式程式設計風格" class="headerlink" title="Dart 3.1：回顧 Dart 3 中的功能式程式設計風格"></a>Dart 3.1：回顧 Dart 3 中的功能式程式設計風格</h2><p><strong>模式匹配和窮舉式切換結合在一起，可以啟用與 Dart 的物件導向核心無縫融合的功能式風格資料模型。</strong></p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*IWd8aRO__OzDkJVsjfoe2A.png" />
<figcaption>Dart 3 重構使用功能式風格特性的內部程式碼庫的 diff</figcaption>
</figure>

<p><em>今天我們發佈 Dart 3.1，這是自 5 月份重大 <a href="https://medium.com/dartlang/announcing-dart-3-53f065a10635">Dart 3.0</a> 發佈以來，我們的第一个穩定版本。Dart 3.1 包含一些次要更新，以及一些 API 調整，以進一步使用 3.0 中介紹的類別修飾符（您可以在 <a href="https://github.com/dart-lang/sdk/blob/main/CHANGELOG.md#310">變更日誌</a> 中了解更多資訊）。不過，大多數情況下，我們一直在花時間研究新的路線圖項目，我們希望看到它們在未來的版本中達到 beta 和穩定版本。敬請期待未來關於這方面的更多資訊！</em></p>
<p><em>因此，作為傳統發佈文章的替代，我們將回顧 Dart 3 中主要功能的一部分，討論它們如何徹底改變（在某些情況下）以及如何大幅改進您撰寫和組織 Dart 程式碼的方式。</em></p>
<h3 id="您如何建模資料？"><a href="#您如何建模資料？" class="headerlink" title="您如何建模資料？"></a>您如何建模資料？</h3><p>物件導向 (OO) 和函數式語言在許多方面有所不同，但可以說，<em>每種範式如何建模資料</em> 是區分它們的決定性特徵。具體來說，建模相關資料的不同變體以及對這些變體的操作的問題。</p>
<p>但<em>「我應該如何建模這些資料？」</em> 通常不是我們在開始新專案時會意識地思考的事情。我們傾向於使用我們所使用語言類型中常見的任何資料建模範式，而不是相反，根據對我們的資料最有意義的模型來選擇語言。</p>
<p>如果您使用的是 OO 語言，您將使用類別階層和對子類別的操作來建模資料。如果您使用的是某些函數式語言，與類別階層模型等效的是 <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">代數資料類型</a> 模型，其對操作子類別的操作等效於使用 <a href="https://en.wikipedia.org/wiki/Pattern_matching">模式匹配</a> 在它們之間切換。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*mA116alArq7XKrm_PSCjyw.png" />
<figcaption>物件導向類別階層模型和函數式代數資料類型模型的簡化並列比較</figcaption>
</figure>

<p>Dart 是一種物件導向語言，但隨著時間推移一直在穩步地整合函數式特性，允許以更多多範式方法進行資料建模。最近，Dart 3 添加了 <a href="https://dart.dev/language/patterns">模式匹配</a>，<a href="https://dart.dev/language/patterns#switch-statements-and-expressions">switch</a> 上的新功能，以及 <a href="https://dart.dev/language/class-modifiers#sealed">封閉類型</a>。這些特性使在 Dart 中實作出代數資料類型成為可能，讓您可以在繼續最大限度地利用 Dart 的物件導向核心的同時，撰寫功能式風格的程式碼。</p>
<p>像 Dart 這樣的多範式語言為您提供了從單行運算式到整個類別階層的設計工具和機會。您可以考慮哪個模型最適合您的專案，或者僅僅只是考慮您的個人喜好。為了幫助您做出最佳決定，本文將分別總結每個範式的結構和優勢，然後教您如何在 Dart 3 中使用新特性來重構一些經典的物件導向設計，這些設計最適合以函數式風格撰寫。</p>
<h4 id="物件導向方法"><a href="#物件導向方法" class="headerlink" title="物件導向方法"></a>物件導向方法</h4><p>當您針對不同的資料類型具有特定操作時，在 OO 語言中，標準組織方法是在基類上建立一個方法，以及一組覆寫基類以定義其唯一行為的子類別。每個子類別都將其資料和操作放在其宣告中的一個位置。</p>
<p>以這個（高級偽程式碼）建模食譜的範例來說。將食材和步驟與食譜結合在一起，擁有食譜物件是有意義的。食譜基類可能具有用於烹飪方法的一些函數，每個食譜都會覆寫這些函數，以滿足其唯一的需求：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3a6f22bcd1ef1ff84f0fe4b47689a631/href">https://medium.com/media/3a6f22bcd1ef1ff84f0fe4b47689a631/href</a></iframe>

<p>具有實例方法的類別階層使您能夠輕鬆地新增新的子類別，而無需觸摸任何現有程式碼。這適用於某些領域，例如 Flutter，您在其中有數不盡的 Widget 都擴展了 Widget 類別。每個 Widget 都可以唯一地擴展和覆寫其定義中的任何必要行為。您 <em>絕對</em> 不需要知道每個 Widget 子類型如何定義其方法來新增專門的行為到您的自己的 Widget。</p>
<h4 id="函數式方法（代數資料類型）"><a href="#函數式方法（代數資料類型）" class="headerlink" title="函數式方法（代數資料類型）"></a>函數式方法（代數資料類型）</h4><p>您可以將函數式風格架構視為 OO 架構的逆向。與將 <em>一種類型的所有程式碼放在一個位置</em>（OO 實例方法在子類別宣告中）不同，您將 <em>一個操作的所有程式碼放在一個位置</em>（函數式切換類型以定義行為）。</p>
<p>這引發了一個問題，什麼時候 <em>有必要</em> 知道階層中每個子類型如何定義操作？可能基於以下幾個原因：</p>
<ul>
<li>當在程式碼中並排新增、維護和理解同一操作行為的變體更容易時。</li>
<li>當您無法修改子類別本身，但又想定義特定於每個子類別的新行為時。</li>
<li>當操作行為對於不同類型的變體之間的關係比它們與它們所操作的類型之間的關係更緊密時。</li>
</ul>
<p>有時這很明顯，但大多數情況下隻是一種觀點轉變。再次思考食譜範例。從某種意義上說，例如烤箱手冊，將烤箱說明按每個食譜分組到一個位置更有意義：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/fce49155327bfd44fd1f78a4ca589728/href">https://medium.com/media/fce49155327bfd44fd1f78a4ca589728/href</a></iframe>

<p>在此範例中，程式結構側重於 bake 操作。無論 bake 對哪些類型進行操作，它們都隻是同一函數的不同可能的輸出；bake 與其操作的類型無關。</p>
<p>這就是 <strong>代數資料類型模型</strong>（以數學集合論中的「代數」命名）。它是函數式語言的核心組織模型，如同類別階層是 OO 語言的核心一樣。代數資料類型透過按操作將所有類型的行為分組在一起，來將行為與資料分開。</p>
<p>現在，可以使用 Dart 3 協調一致地實作出代數資料類型！</p>
<h3 id="建模物件導向代數資料類型"><a href="#建模物件導向代數資料類型" class="headerlink" title="建模物件導向代數資料類型"></a>建模物件導向代數資料類型</h3><p>函數式語言通常透過對 <a href="https://en.wikipedia.org/wiki/Tagged_union">總和類型</a> 中的案例進行模式匹配來實作出 <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">代數資料類型</a> ，以將行為分配給每個變體。Dart 3 在 switch 案例中使用 <a href="https://dart.dev/language/patterns#switch-statements-and-expressions">模式匹配</a> 來實現同樣的效果，並利用了 OO 子類型自然地建模總和類型的特性。這使我們可以使用與 Dart 無縫融合的物件來實作真正 <a href="https://dart.dev/language/patterns#algebraic-data-types">多範式代數資料類型</a>。</p>
<p>以下各節將向您展示如何在 Dart 中設計代數資料類型模型，以及使用前 Dart 3 的相同功能的範例。</p>
<ul>
<li>首先，我們將說明如何透過在 <a href="https://dart.dev/language/pattern-types#object">物件模式</a> 上進行切換來將操作的基於類型的變體分組在一起。</li>
<li>然後，我們將退一步，看看如何使用新的 <a href="https://dart.dev/language/class-modifiers#sealed">封閉</a> 類別修飾符來設計子類別本身，以確保 switch 為 <a href="https://dart.dev/language/branches#exhaustiveness-checking">物件可能採用的所有可能子類型</a> 定義行為。</li>
</ul>
<h4 id="在類型之間分組行為"><a href="#在類型之間分組行為" class="headerlink" title="在類型之間分組行為"></a>在類型之間分組行為</h4><p>Dart 語言的個別部分（例如語句、類別和文字）在類別階層中都有自己的定義，但都受到多個系統（例如解析器、格式化程序和編譯器操作）的操作影響。想像一下，如果每個應用於每個語言元素的函數都必須在這些元素的宣告中定義，語言實作將會變得多麼混亂！它看起來會像這樣：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ffb98bc8686a75e1c08e1459a68267a0/href">https://medium.com/media/ffb98bc8686a75e1c08e1459a68267a0/href</a></iframe>

<p>出於這個原因，Dart 的內部程式碼已經自然地傾向於將函數與類型定義分開的功能式方法。以 Dart 編譯器中的 <a href="https://github.com/dart-lang/sdk/blob/main/pkg/analyzer/lib/src/error/annotation_verifier.dart">annotation_verifier</a> 函式庫為例。它包含定義注釋行為的函數（例如 @override 或 @deprecated），具體取決於注釋所附加的程式碼部分（例如 @override 如何影響類別與欄位）。</p>
<p>但根據類型分配行為不像一開始做出將行為分開的決定那麼簡單。根據類型定義行為的標準方法是使用鏈式 if-else 語句，您在注釋驗證器中經常會看到。以以下未使用任何 Dart 3 特性撰寫的驗證函數為例。它驗證了 <a href="https://github.com/dart-lang/sdk/commit/4079a47cc4fb8f88e2dd9b7faff3bd587931a379">最近貢獻的</a> @visibleOutsideTemplate 注釋的行為，該注釋選擇退出另一個注釋 @visibleForTemplate 的級聯效應：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/a3c434f36ddd91f30755438674324b2b/href">https://medium.com/media/a3c434f36ddd91f30755438674324b2b/href</a></iframe>

<p>該函數使用精心設計的鏈式 if-else 語句，測試注釋的祖父母是否為某種宣告（ClassDeclaration、EnumDeclaration 或 MixinDeclaration），然後根據類型定義其行為。</p>
<p>使用 Dart 3，您可以在 switch 案例中使用物件模式將此結構顯著地重構為更宣告式的風格，使其更短、更容易閱讀。原始作者 <a href="https://github.com/dart-lang/sdk/blob/4079a47cc4fb8f88e2dd9b7faff3bd587931a379/pkg/analyzer/lib/src/error/annotation_verifier.dart#L417-L426">就是這麼做的</a>！16 行鏈式 if-else 語句被精簡為 7 行 switch 語句：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/80466ddfaaece549a847e51911950a0b/href">https://medium.com/media/80466ddfaaece549a847e51911950a0b/href</a></iframe>

<p>這裡的每個案例都是一個 <a href="https://dart.dev/language/pattern-types#object">物件模式</a>，它與 grandparent 的靜態類型進行比對。與說 if (object is Type &amp;&amp; object.property !&#x3D; null) 不同，每個案例都檢查物件的模式是否與模式 Type(propertyOfType) 相符。此外，當物件與物件模式相符時，它隱含地要求它不為 null，因此無需進行顯式空檢查！</p>
<p>物件模式還可以使用嵌套的 <a href="https://dart.dev/language/pattern-types#variable">變數模式</a>，讓您可以在與之進行比對的同一行程式碼中從物件中提取（或 <a href="https://dart.dev/language/patterns#destructuring">解構</a>）屬性值。語法 (:var metadata) 隻是表示「比對並宣告一個與此 getter 名稱相同的變數」。這就是變數 metadata 如何進入最後的 for 迴圈的範圍。非常簡潔！</p>
<p>請注意，for 迴圈現在在每個案例之間是共用的。每個類型的 declaredElement 屬性實際上是另一個類型 InterfaceElement（classElement、enumElement 或 mixinElement）的不同子類型。因此，前 Dart 3 的鏈式 if-else 語句在每個 if 子句中分別迭代 metadata，以確保最終注釋對於 metadata 可能採用的所有可能類型都是類型安全的。</p>
<p>現在，重構後的結構對每個案例使用深度嵌套的物件模式，將 metadata 提升到其超類型 InterfaceElement。這使單個共用 for 迴圈能夠在案例之間迭代 metadata，成為類型安全的。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/986/1*qYQb8DZyeJDFD-VKEb4P6Q.png" />
<figcaption>深度嵌套的物件和變數模式的語法註釋圖</figcaption>
</figure>

<p>在 Dart 3 的代數資料類型實作中，在物件模式上進行切換很重要，因為它能夠簡潔地測試子類型並解構值。一個很好的副作用是可以透過單行程式碼提供同時的保證。重申一下，此重構中的每個案例模式都同時驗證：</p>
<ul>
<li>物件是 ClassDeclaration、EnumDeclaration 或 MixinDeclaration 之一。</li>
<li>物件具有 declaredElement 屬性。</li>
<li>declaredElement 具有 metadata 屬性。</li>
<li>metadata 的類型為 InterfaceElement。</li>
<li>所有正在考慮的物件或屬性都不為 null。</li>
</ul>
<p>這是 Dart 3 如何徹底實作模式以考慮 OO 語言的許多細微差別，以及如何真正使物件導向代數資料類型成為 Dart 中的實際設計選項的完美範例。</p>
<p>在物件模式上進行類型測試非常適合將行為與類型分開。但它缺少 OO 子類型的其中一個特性，即編譯器可以讓您知道是否宣告了新的子類型，但沒有為其超類型的抽象方法定義行為。當我們不再處理類型宣告上的實例方法時，Dart 的代數資料類型模型如何實作相同的安全保證？答案是 <em>窮舉式檢查</em>。</p>
<h4 id="窮舉式檢查"><a href="#窮舉式檢查" class="headerlink" title="窮舉式檢查"></a>窮舉式檢查</h4><p>函數式語言對代數資料類型的實作使用可枚舉的總和類型，這意味著編譯器始終知道正在切換的類型的所有可能變體。然後，編譯器可以讓您知道您的 switch 是否缺少案例，因此可能某些值可能會在未被處理的情況下通過該 switch。</p>
<p>這稱為 <a href="https://dart.dev/language/branches#exhaustiveness-checking">窮舉式檢查</a>。從技術上講，它始終存在於 Dart 中，用於可枚舉的類型，例如枚舉和布林值。這些類型具有一組不可變化的可能值，如果您要對它們進行切換，編譯器會在您遺漏一個值時告知您。使用預設子句是另一種偽窮舉式檢查。由於預設會匹配所有未明確考慮的案例，它會導致編譯器在不知道是否實際考慮到所有可能的類型的情況下，認為 switch 是窮舉式的。</p>
<p>如前所述，我們想要使用子類型而不是總和類型來進行 Dart 的代數資料類型建模。但由於 Dart 中的類別可以從任何函式庫中進行擴展，因此編譯器不可能窮舉列舉類別的子類型，因為它不知道任何子類別是否在外部函式庫中宣告。</p>
<p>為了解決這個問題並完成 Dart 的代數資料類型實作，我們在 Dart 3 中加入了 <a href="https://dart.dev/language/class-modifiers#sealed">封閉類別修飾符</a>。封閉類別不能從除了自身以外的任何函式庫（<a href="https://dart.dev/language/libraries">包含其定義的檔案</a>）進行擴展或實作。這確保編譯器始終知道任何和所有可能的子類型，使其完全可枚舉。</p>
<p>以下是一個作為 3.1 版本發佈的一部分加入到 Dart SDK 中的實際重構範例：<a href="https://github.com/dart-lang/sdk/commit/c3e815bc7ad488eddf00344ab4106485a9d1ba32#diff-e98c6de423bf7e0b5b961cd10efed50330004229243aa87c18ad6314fef054b0L879-R879">封閉</a> <a href="https://github.com/dart-lang/sdk/commit/c3e815bc7ad488eddf00344ab4106485a9d1ba32#diff-e98c6de423bf7e0b5b961cd10efed50330004229243aa87c18ad6314fef054b0L879-R879">FileSystemEvent</a>，以便可以對其子類型進行窮舉式切換。做好心理準備，重構很困難…</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ebbec98bf5109bbc14be7867a3b4c117/href">https://medium.com/media/ebbec98bf5109bbc14be7867a3b4c117/href</a></iframe>

<p>開玩笑的，這一點也不難！不過，需要注意的是，封閉現有的類別階層是一種重大變更。針對舊版本 Dart 的程式碼將無法實作或擴展該類別，因此始終檢查相依性並提醒可能在其他地方子類型化您的類別的任何使用者。</p>
<p>封閉 FileSystemEvent 允許透過 FileSystemEntity.watch 生成的事件（對應於 FileSystemEvent 的子類型）進行窮舉式切換。通常，您會監聽此事件串流並使用 <a href="https://github.com/dart-lang/sdk/issues/52273">鏈式</a> <a href="https://github.com/dart-lang/sdk/issues/52273">if-else</a> 語句來根據發生的事件類型確定操作。</p>
<p>但封閉基類不僅允許您在物件模式上進行切換，例如上一節中的 _checkVisibleOutsideTemplate 範例。它還確保在這樣做的同時，您正在考慮該類型可能產生的所有可能值，而無需使用預設案例：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9618c7e18185c98dcb4e4cf9968759f9/href">https://medium.com/media/9618c7e18185c98dcb4e4cf9968759f9/href</a></iframe>

<p>如果曾經新增了新的子類型，例如 FileSystemSyncEvent，編譯器會知道它，因為它隻能新增到 <a href="https://github.com/dart-lang/sdk/blob/main/sdk/lib/io/file_system_entity.dart">與 FileSystemEvent 相同的函式庫</a> 中。由於類別階層是封閉的，因此編譯器要求對其實例進行任何切換都必須是窮舉式的，並且會生成 <a href="https://dart.dev/tools/diagnostic-messages#non_exhaustive_switch_expression">錯誤</a> 來提醒使用者（編寫 switch 的人，而不是函式庫擁有者）未處理的案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The type &#x27;FileSystemEvent&#x27; is not exhaustively matched by the switch cases since it doesn&#x27;t match &#x27;FileSystemSyncEvent&#x27;</span><br></pre></td></tr></table></figure>

<p>將封閉類別和在物件模式上進行切換結合在一起，可以使 Dart 中的完整、物件導向代數資料類型程式設計架構成為可能。</p>
<h4 id="附加功能式特性"><a href="#附加功能式特性" class="headerlink" title="附加功能式特性"></a>附加功能式特性</h4><p>上面的窮舉式切換範例包含了比促進代數資料類型更多的 Dart 3 功能特性。</p>
<p>請注意，switch 在 _fileListener 函數的 return 語句的右側 - 那是 Dart 3 中新的 <a href="https://dart.dev/language/branches#switch-expressions">switch 運算式</a>。對運算式和函數的一般強調是函數式語言的關鍵元素。Dart 3 允許生成值的 switch 運算式，並且可以在允許使用運算式的任何地方使用。</p>
<p>那麼，_fileListener 在前面的範例中最終返回什麼？那是個 <a href="https://dart.dev/language/records">記錄</a>，這是 Dart 3 的另一個新特性，也與函數式程式設計相關。記錄讓您可以從函數中返回多個異質值，擴展了函數在 Dart 中的用途，並進一步減少了對自訂類別的依賴（這將是除了在過程中不會丟失其類型之外，返回不同類型的多個值的唯一其他方法）。</p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>您可以透過以下方式在 Dart 中建模代數資料類型：</p>
<ul>
<li>撰寫一個在封閉類別的實例 <em>上</em> 進行切換，並 <em>在</em> 其子類型 <em>上</em> 切換的函數，</li>
<li>並在 switch 案例中定義每個子類型的行為差異。</li>
</ul>
<p>在物件模式上進行切換允許您以簡潔的方式將所有操作保持在一起，而窮舉式檢查確保編譯器會在您遺漏任何類型的行為定義時提醒您。而且所有這些都建立在 Dart 已經使用的物件導向類別之上。</p>
<p>最棒的是，您不必選擇物件導向或函數式風格；這兩種範式可以融合在一起，您可以使用最適合您正在定義的操作的風格。</p>
<p>您可以透過少量修改使現有的類別階層更具函數式特性，甚至可以在同一個類別階層中混合使用實例方法和代數資料類型。無論將行為與類型緊密結合起來是否有意義，還是將不同類型的行為分組到一個函數中，您都可以使用最合理的風格。</p>
<p>我們希望這個介紹能夠激發您對函數式程式設計以及嘗試使用新的 Dart 3 特性的興趣。誰知道呢，也許我們很快就會看到第一個完全使用函數式風格的 Dart 程式出自你們其中一位！</p>
<h4 id="資源"><a href="#資源" class="headerlink" title="資源"></a>資源</h4><ul>
<li>若要進一步了解 Dart 中的函數式程式設計，請查看以下資源：<ul>
<li>有關 <a href="https://dart.dev/language/patterns">模式</a> 和 <a href="https://dart.dev/language/branches#exhaustiveness-checking">窮舉式檢查</a> 的官方 Dart 文件。</li>
<li>有關使用 Dart 3 重構 Flutter 程式碼的 <a href="https://codelabs.developers.google.com/codelabs/dart-patterns-records#0">模式和記錄程式碼實驗室</a>。</li>
<li>來自 FlutterCon 的關於 Dart 中函數式程式設計的 <a href="https://www.droidcon.com/2023/08/07/the-joy-of-functional-programming-in-dart/">社群演講</a>。</li>
<li>這篇 <a href="https://journal.stuffwithstuff.com/2023/08/04/representing-heterogeneous-data/">部落格文章</a> 介紹了 Bob Nystrom（<a href="https://github.com/dart-lang/language/blob/main/accepted/3.0/patterns/feature-specification.md">在 Dart 中設計模式</a> 的作者！）的個人部落格，講述了如何建模異質資料。</li>
</ul>
</li>
</ul>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a1f4b3a7cdda" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/dart-3-1-a-retrospective-on-functional-style-programming-in-dart-3-a1f4b3a7cdda">Dart 3.1 和回顧 Dart 3 中的功能式程式設計風格</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p>undefined</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/46a8336.html" data-id="cm1nvba250005h117c93o8lrd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/announcements/" rel="tag">announcements</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dart/" rel="tag">dart</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dartlang/" rel="tag">dartlang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/functional-programming/" rel="tag">functional-programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/releases/" rel="tag">releases</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2023-05-10T13:35:19.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/af8aacca.html" class="article-date">
  <time datetime="2023-05-10T05:35:19.000Z" itemprop="datePublished">2023-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dart/">Dart</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/af8aacca.html">【文章翻譯】Announcing Dart 3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Dart-3"><a href="#宣布-Dart-3" class="headerlink" title="宣布 Dart 3"></a>宣布 Dart 3</h2><p>來自 Google I&#x2F;O 2023 的問候。今天，我們將從山景城現場宣布 Dart 3——迄今為止最大的 Dart 版本！Dart 3 包含三個主要進展。首先，我們完成了通往 100% 聲稱空安全性的旅程。其次，我們為記錄、模式和類修飾符添加了主要的新語言功能。第三，我們正在預覽未來，在未來我們將透過 Wasm 編譯為 Web 提供原生程式碼，從而擴展我們的平台支援。讓我們深入了解細節。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*2XwxNKHrKb3SGaWEyqg2nA.png" />
</figure>

<h3 id="100-聲稱空安全性"><a href="#100-聲稱空安全性" class="headerlink" title="100% 聲稱空安全性"></a>100% 聲稱空安全性</h3><p>在過去的四年中，我們將 Dart 演變為一種快速、可移植且現代的語言。現在，有了 Dart 3，它成為了 100% 聲稱空安全的語言！正如我們之前所 <a href="https://medium.com/dartlang/the-road-to-dart-3-afdd580fbefa">討論過</a>的那樣，我們認為沒有其他程式設計語言曾經為現有的語言添加過聲稱空安全性。所以，這是一段漫長的旅程。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/960/1*KPbxBAjFYPCSk2OqwjKs7A.png" />
</figure>

<p>有了 Dart 中的 100% 空安全性，我們擁有一個 <em>聲稱</em> 的類型系統。您可以相信，如果類型表示值不為 null，那麼它永遠不會為 null。這避免了某些類型的編碼錯誤，例如空指標異常。它還允許我們的編譯器和運行時以在沒有空安全性時無法實現的方式優化程式碼。這個設計選擇涉及一個權衡。儘管遷移變得有點困難，但我們相信我們為 Dart 做出了正確的選擇。</p>
<h4 id="遷移到-Dart-3"><a href="#遷移到-Dart-3" class="headerlink" title="遷移到 Dart 3"></a>遷移到 Dart 3</h4><p>在實現聲稱空安全性方面，Dart 社群的不懈支援至關重要：pub.dev 上排名前 1000 的套件中有 99% 支援空安全性！</p>
<p>基於此，我們預計絕大多數已遷移到空安全性的套件和應用程式都可以在 Dart 3 中正常運行。在極少數情況下，Dart 3 中的少量相關清除可能會影響某些程式碼。一些遺留核心函式庫 API 已被移除（<a href="https://github.com/dart-lang/sdk/issues/34233">#34233</a>，<a href="https://github.com/dart-lang/sdk/issues/49529">#49529</a>），並且一些工具已調整（<a href="https://github.com/dart-lang/sdk/issues/50707">#50707</a>）。如果您在遷移到使用 Dart 3 SDK 時遇到任何問題，請參閱 <a href="https://dart.dev/resources/dart-3-migration">Dart 3 遷移指南</a>。除此之外，我們希望您能享受新的合理化核心函式庫和工具。</p>
<h3 id="主要語言功能-記錄、模式和類修飾符"><a href="#主要語言功能-記錄、模式和類修飾符" class="headerlink" title="主要語言功能 - 記錄、模式和類修飾符"></a>主要語言功能 - 記錄、模式和類修飾符</h3><p>Dart 3 不僅僅是關於更改現有語言。它還包括添加重要的新功能和能力！這些包括記錄、模式和類修飾符。</p>
<h4 id="使用記錄構建結構化資料"><a href="#使用記錄構建結構化資料" class="headerlink" title="使用記錄構建結構化資料"></a>使用記錄構建結構化資料</h4><p>傳統上，Dart 函數只能返回單個值。因此，需要返回多個值的函數必須將這些值打包到其他資料類型中，例如映射或列表，或者定義可以保存這些值的新的類別。使用未類型化的資料結構會削弱類型安全性。必須定義新的類別僅用於攜帶資料，這在編碼過程中會增加摩擦。您已經很清楚地告訴我們：對多個返回值的語言請求是我們 <a href="https://github.com/dart-lang/language/issues?q=is:issue+sort:reactions-+1-desc+">排名第四</a> 的問題。</p>
<p>使用記錄，您可以使用乾淨利落的語法構建結構化資料。考慮這個函數。它讀取 JSON blob 的名稱和年齡，並將它們都返回到一個記錄中：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">String</span>, <span class="built_in">int</span>) userInfo(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; json) &#123;</span><br><span class="line">  <span class="keyword">return</span> (json[<span class="string">&#x27;name&#x27;</span>] <span class="keyword">as</span> <span class="built_in">String</span>, json[<span class="string">&#x27;height&#x27;</span>] <span class="keyword">as</span> <span class="built_in">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這對所有 Dart 開發人員來說應該很熟悉。記錄看起來像列表常量，例如 [<code>&#39;Michael&#39;</code>, <code>&#39;Product Manager&#39;</code> ]，但使用括号而不是方括号。在 Dart 中，記錄是一個通用功能。它們可以用於函數返回值以外的其他用途。您也可以將它們存儲在變數中，將它們放入列表中，將它們用作映射中的鍵，或建立包含其他記錄的記錄。您可以添加未命名的欄位，就像我們在之前的示例中所做的那樣，以及命名的欄位，例如 <code>(42, description: &#39;Meaning of life&#39;)</code>。</p>
<p>記錄是值類型，沒有身份。這使得我們的編譯器可以在某些情況下完全擦除記錄物件。記錄還帶有自動定義的 <code>==</code> 運算符和 <code>hashCode</code> 函數。<a href="https://dart.dev/language/records">記錄文件</a> 具有更多詳細信息。</p>
<h4 id="使用模式和模式匹配處理結構化資料"><a href="#使用模式和模式匹配處理結構化資料" class="headerlink" title="使用模式和模式匹配處理結構化資料"></a>使用模式和模式匹配處理結構化資料</h4><p>記錄簡化了您構建結構化資料的方式。這不會取代使用類別來構建更正式的類型層次結構。它只提供另一個選項。無論哪種情況，您可能都希望將這些結構化資料分解成其個別元素以進行處理。這就是模式匹配發揮作用的地方。</p>
<p>考慮一種基本的模式形式。以下記錄模式將記錄分解成兩個新的變數 <code>name</code> 和 <code>height</code>。這些變數之後可以像任何其他變數一樣使用，例如在呼叫 <code>print</code> 時：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (<span class="built_in">String</span> name, <span class="built_in">int</span> height) = userInfo(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>&#125;);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;User <span class="subst">$name</span> is <span class="subst">$height</span> cm tall.&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>列表和映射也存在類似的模式。對於所有這些模式，您可以使用下劃線模式來跳過個別元素：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (<span class="built_in">String</span> name, _) = userInfo(...);</span><br></pre></td></tr></table></figure>

<p>模式在 <code>switch</code> 語句中使用時效果顯著。Dart 從一開始就對 <code>switch</code> 提供了有限的支援。在 Dart 3 中，我們擴展了 <code>switch</code> 語句的功能和表現力。我們現在在這些情況下支援模式匹配。我們已經不需要在每個 <code>case</code> 的末尾添加 <code>break</code>。我們還支援邏輯運算符來組合 <code>case</code>。以下示例展示了一個乾淨利落的 <code>switch</code> 語句，它解析字元碼：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (charCode) &#123;</span><br><span class="line">  <span class="keyword">case</span> slash <span class="keyword">when</span> nextCharCode == slash:</span><br><span class="line">    skipComment();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> slash || star || plus || minus:</span><br><span class="line">    <span class="keyword">operator</span>(charCode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> &gt;= digit0 &amp;&amp; &lt;= digit9:</span><br><span class="line">    number();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    invalid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>當您需要為每個 <code>case</code> 使用一個或多個語句時，<code>switch</code> 語句提供了很好的幫助。在某些情況下，您只想做的是計算一個值。對於這種情況，我們提供了一個非常簡潔的 <code>switch</code> <em>表達式</em>。這類似於 <code>switch</code> <em>語句</em>，但使用不同的語法，該語法針對表達式進行了微調。以下示例函數返回一個 <code>switch</code> 表達式的值，以計算當前日期的星期幾描述：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> describeDate(<span class="built_in">DateTime</span> dt) =&gt; </span><br><span class="line">  <span class="keyword">switch</span> (dt.weekday) &#123;</span><br><span class="line">      <span class="number">1</span> =&gt; <span class="string">&#x27;Feeling the Monday blues?&#x27;</span>,</span><br><span class="line">      <span class="number">6</span> || <span class="number">7</span> =&gt; <span class="string">&#x27;Enjoy the weekend!&#x27;</span>,</span><br><span class="line">      _ =&gt; <span class="string">&#x27;Hang in there.&#x27;</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>模式的一個強大功能是能夠檢查「窮舉性」。此功能確保 <code>switch</code> 處理所有可能的情況。在前面的示例中，我們正在處理 <code>weekday</code> 的所有可能值，<code>weekday</code> 是一個 <code>int</code>。我們透過組合針對特定值 1、6 或 7 的匹配語句，然後使用預設情況 <code>_</code> 來處理剩餘情況，來窮舉所有可能的值。若要啟用對使用者定義的資料層次結構（例如類別層次結構）的這種檢查，請在類別層次結構頂部使用新的 <code>sealed</code> 修飾符，如以下示例所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cow</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> whatDoesItSay(Animal a) =&gt;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123; Cow c =&gt; <span class="string">&#x27;<span class="subst">$c</span> says moo&#x27;</span>, Sheep s =&gt; <span class="string">&#x27;<span class="subst">$s</span> says baa&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>這將返回以下錯誤，提醒我們漏掉了對最後一個可能的子類型 <code>Pig</code> 的處理：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line <span class="number">6</span> • The type <span class="string">&#x27;Animal&#x27;</span> <span class="keyword">is</span> not exhaustively matched by the <span class="keyword">switch</span> cases</span><br><span class="line">since it doesn<span class="string">&#x27;t match &#x27;</span>Pig()<span class="string">&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>最後，<code>if</code> 語句也可以使用模式。在下面的示例中，我們正在使用 <em>if-case</em> 匹配一個映射模式來分解 JSON 映射。在其中，我們根據常量值（字串，例如 <code>&#39;name&#39;</code> 和 <code>&#39;Michael&#39;</code>）和類型測試模式 <code>int h</code> 進行匹配，以讀取 JSON 值。如果模式匹配失敗，Dart 將執行 <code>else</code> 語句。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> json = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find Michael&#x27;s height.</span></span><br><span class="line"><span class="keyword">if</span> (json <span class="keyword">case</span> &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;height&#x27;</span>: <span class="built_in">int</span> h&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Michael is <span class="subst">$h</span> cm tall.&#x27;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;Error: json contains no height info for Michael!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這僅觸及了您可以使用模式完成的所有事情。我們相信它們將在所有 Dart 程式碼中變得普遍。若要進一步了解，請查看 <a href="http://dart.dev/language/patterns">模式文件</a> 和 <a href="https://codelabs.developers.google.com/codelabs/dart-patterns-records">模式程式碼實驗室</a>。</p>
<h4 id="使用類修飾符為類別提供細粒度的存取控制"><a href="#使用類修飾符為類別提供細粒度的存取控制" class="headerlink" title="使用類修飾符為類別提供細粒度的存取控制"></a>使用類修飾符為類別提供細粒度的存取控制</h4><p>第三個 Dart 3 語言功能是類修飾符。與我們期望每個 Dart 開發人員使用的記錄和模式不同，這更像是一個強大的使用者功能。它滿足了編寫大型 API 表面或構建企業級應用程式的 Dart 開發人員的需求。</p>
<p>類修飾符使 API 作者能夠僅支援特定功能集。不過，預設值保持不變。我們希望 Dart 保持簡單易懂。因此，和以前一樣，常規類別可以 <em>構造</em>、<em>擴展</em> 和 <em>實作</em>，如下面的示例所示：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> make; <span class="built_in">String</span> model;</span><br><span class="line">  <span class="keyword">void</span> moveForward(<span class="built_in">int</span> meters) &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construct.</span></span><br><span class="line"><span class="keyword">var</span> myCar = Vehicle(make: <span class="string">&#x27;Ford&#x27;</span>, model: <span class="string">&#x27;T&#x27;</span>,);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extend.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> passengers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockVehicle</span> <span class="keyword">implements</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span> <span class="keyword">void</span> moveForward ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>類修飾符支援對此添加限制。考慮一些示例用例：</p>
<ul>
<li>使用介面類別，您可以為其他人定義一個要實作的合約。介面類別不能被擴展。</li>
<li>使用基類別，您可以確保您類別的所有子類型都繼承自它，而不是實作其介面。這確保私有方法在所有實例上都可用。</li>
<li>使用 <code>final</code> 類別，您可以關閉類型層次結構，防止在您自己的函式庫之外建立任何子類別。作為一個示例優點，這允許 API 擁有者添加新的成員，而不會冒著對 API 使用者造成重大變更的風險。</li>
</ul>
<p>有關詳細信息，請參閱新的 <a href="https://dart.dev/language/class-modifiers">類修飾符文件</a>。</p>
<h3 id="未來展望"><a href="#未來展望" class="headerlink" title="未來展望"></a>未來展望</h3><p>Dart 3 不僅僅是您今天可以使用的功能方面的一個重大進步。我們還將預覽一下下一步。</p>
<h4 id="Dart-語言"><a href="#Dart-語言" class="headerlink" title="Dart 語言"></a>Dart 語言</h4><p>記錄、模式和類修飾符是十分重要的新功能，因此，它們的設計部分可能存在可以改進的地方。我們將繼續監控 <a href="https://github.com/dart-lang/language/issues">您的回饋</a>，並查看是否需要在 Dart 3 後的次要版本中進行更新。</p>
<p>我們還正在考慮一些更小、更增量式的功能，這些功能完全不可破壞，並且專注於提高開發人員的生產力，而無需遷移成本。我們正在探索的兩個示例是 <a href="https://github.com/dart-lang/language/issues/2727">內聯類別</a>，用於以零成本的「包裝器」包裝現有類型，以及 <a href="https://github.com/dart-lang/language/issues/2364">主建構函數</a>；此功能引入了定義包含少數欄位和主建構函數的類別的更簡潔的語法。</p>
<p>我們之前討論過宏（也稱為 <a href="https://github.com/dart-lang/language/blob/main/working/macros/feature-specification.md">元程式設計</a>）。我們特別關注這一點，以實現對 JSON（和類似資料）的更好的反序列化，以及啟用資料類別。考慮到元程式設計的規模和固有的風險，我們正在採取非常徹底的方法，因此我們沒有任何明確的時間表可以分享，即使是最終確定設計決定的時間表。</p>
<h4 id="原生互操作"><a href="#原生互操作" class="headerlink" title="原生互操作"></a>原生互操作</h4><p>行動裝置和桌面的應用程式通常依賴於原生平台提供的許多 API，無論是通知、支付還是獲取手機的位置。傳統上，在 Flutter 中，這些 API 是透過構建外掛來存取的，這需要同時編寫 API 的 Dart 程式碼和大量平台特定程式碼以提供實作。</p>
<p>我們已經支援與編譯成 C 函式庫的程式碼進行互操作，可以使用 <a href="https://dart.dev/guides/libraries/c-interop">dart:ffi</a>。我們目前正在努力擴展此支援，以支援 Android 上的 <a href="https://dart.dev/guides/libraries/java-interop">Java 和 Kotlin 互操作</a> 以及 iOS&#x2F;macOS 上的 <a href="https://dart.dev/guides/libraries/objective-c-interop">Objective C 和 Swift 互操作</a>。若要了解 Android 互操作的簡介，請查看新的 Google I&#x2F;O 23 <a href="https://io.google/2023/program/2f02692d-9a41-49c0-8786-1a22b7155628/">Android 互操作性影片</a>。</p>
<h4 id="編譯成-WebAssembly-使用原生程式碼定位-Web"><a href="#編譯成-WebAssembly-使用原生程式碼定位-Web" class="headerlink" title="編譯成 WebAssembly - 使用原生程式碼定位 Web"></a>編譯成 WebAssembly - 使用原生程式碼定位 Web</h4><p><a href="https://webassembly.org/">WebAssembly</a>（簡稱為 Wasm）作為一種平台中立的二進制指令格式，在 <a href="https://caniuse.com/wasm">所有現代瀏覽器</a> 中日益成熟。Flutter 架構已經使用 Wasm 一段時間了。這是我們將以 C++ 編寫的 SKIA 圖形渲染引擎透過 Wasm 編譯的模組傳遞到瀏覽器的方式。我們一直對使用 Wasm 部署 Dart 程式碼很感興趣，但我們一直受阻。Dart 與許多其他面向物件語言一樣，使用垃圾回收。在過去的一年中，我們已與 Wasm 生態系統中的多個團隊合作，為 WebAssembly 標準添加新的 WasmGC 功能。這現在在 Chromium 和 Firefox 瀏覽器中接近穩定狀態。</p>
<p>我們在將 Dart 編譯成 Wasm 模組方面的工作具有兩個針對 Web 應用程式的目標：</p>
<ul>
<li><strong>載入時間：</strong>我們希望我們能夠使用瀏覽器載入速度更快的 Wasm 傳遞部署有效載荷，從而縮短到達使用者可以與 Web 應用程式互動的點所需的時間。</li>
<li><strong>效能：</strong>由 JavaScript 驅動的 Web 應用程式需要即時編譯才能實現良好的效能。Wasm 模組是更低階的，更接近機器碼，因此我們認為它們可以透過更少的卡頓和更一致的畫面速率提供更高的效能。</li>
<li><strong>語義一致性：</strong>Dart 對於我們支援的平台之間的高度一致性感到自豪。但是，在 Web 上，有一些例外。例如，Dart Web 目前在 <a href="https://dart.dev/guides/language/numbers">數字的表示方式</a> 方面有所不同。有了 Wasm 模組，我們將能夠將 Web 視為一個「原生」平台，其語義類似於其他原生目標。</li>
</ul>
<p>我們很興奮地宣布今天首次預覽將 Dart 編譯成 Wasm！我們最初的重點是 Flutter Web 支援。這還處於早期階段，我們還有很多工作要做，但我們 <a href="https://flutter.dev/wasm">邀請您進行嘗試</a>，看看您是否像我們一樣興奮。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>感謝您耐心閱讀到結尾。我們希望這篇文章讓您對 Dart 3 感到興奮，Dart 3 目前已在獨立的 <a href="https://dart.dev/get-dart">Dart SDK</a> 和 <a href="https://medium.com/flutter/whats-new-in-flutter-3-10-b21db2c38c73">Flutter 3.10 SDK</a> 中提供。</p>
<p>我們已使用聲稱空安全性、核心函式庫和工具清理對 Dart 語言進行了重大改進。有一些主要的新語言功能，使 Dart 透過記錄和模式變得更具表現力和簡潔性。對於大型 API 表面，類修飾符啟用了詳細的控制。我們還包括對 WebAssembly 的支援預覽。</p>
<p>有了所有這些功能，我們認為 Dart 3 展示了我們的長期願景：<em>為在任何平台上構建快速應用程式構建最具生產力的程式設計語言</em>。我們希望您也這麼認為！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=53f065a10635" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/announcing-dart-3-53f065a10635">宣布 Dart 3</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/af8aacca.html" data-id="cm1nvba220001h117gk5cbngq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dart/" rel="tag">dart</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dartlang/" rel="tag">dartlang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/releases/" rel="tag">releases</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-2023-02-09T16:02:34.000Z" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/cb368ef1.html" class="article-date">
  <time datetime="2023-02-09T08:02:34.000Z" itemprop="datePublished">2023-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Dart/">Dart</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/cb368ef1.html">【文章翻譯】Introducing Realm for Dart &amp; Flutter</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="案例研究：使用-Dart-平台原生指令建立一個豐富的跨平台函式庫，支援-Dart-和-Flutter-應用程式"><a href="#案例研究：使用-Dart-平台原生指令建立一個豐富的跨平台函式庫，支援-Dart-和-Flutter-應用程式" class="headerlink" title="案例研究：使用 Dart 平台原生指令建立一個豐富的跨平台函式庫，支援 Dart 和 Flutter 應用程式"></a>案例研究：使用 Dart 平台原生指令建立一個豐富的跨平台函式庫，支援 Dart 和 Flutter 應用程式</h2><p>我們很興奮地看到 MongoDB 今天宣布 Realm for Dart 和 Flutter 的正式發佈！Realm 是一個反應式、面向物件的跨平台資料庫，在應用程式開發人員中很受歡迎。換句話說，它非常適合 Dart 和 Flutter。因此，在過去的一年中，我們與 MongoDB 合作將 Realm 帶到 Dart 和 Flutter。查看 MongoDB 發布的 <a href="https://www.mongodb.com/developer/products/realm/announcing-realm-flutter-sdk/">部落格文章</a>，了解 Realm 提供的功能、自早期預覽版以來的改進以及未來計畫。我們認為 Realm 將非常適合 Dart 和 Flutter 開發人員。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/530/1*cAi4WO4IfN5Sp6WE6Ex8Ig.png" />
<figcaption>使用 Dart 將書籍寫入 Realm 資料庫</figcaption>
</figure>

<p>在這篇伴隨文章中，我們將透過幕後一窺 Realm for Dart 和 Flutter 的建立過程，作為一個實際的範例，說明如何建立新的基於 Dart 的開發人員 SDK。</p>
<h3 id="Realm-範例"><a href="#Realm-範例" class="headerlink" title="Realm 範例"></a>Realm 範例</h3><p>在深入探討 Realm SDK 的實作之前，讓我們先從快速了解如何使用 SDK 作為在 Dart <a href="https://dart.dev/tutorials/server/cmdline">終端應用程式</a> 上工作的開發人員開始（<em>注意</em>：Flutter 應用程式的步驟略有不同；請參閱 <a href="https://www.mongodb.com/docs/realm/sdk/flutter/install/">文件</a> 以獲取詳細資訊）。</p>
<p>首先，您定義資料模型。這可以使用帶有額外 Realm 注解的普通 Dart 類別來完成。以下是一個書籍的範例資料類別：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ca8542a6b2438d675c7f3e20e8b3f36f/href">https://medium.com/media/ca8542a6b2438d675c7f3e20e8b3f36f/href</a></iframe>

<p>定義好模型，並完全生成資料模型（見下文）後，您可以開始將一些書籍寫入 Realm 資料庫：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e5eb95b84ad9ff3cb9e777f037b9135f/href">https://medium.com/media/e5eb95b84ad9ff3cb9e777f037b9135f/href</a></iframe>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b25a09e353d2cdfa327fa45d7c3f1c4e/href">https://medium.com/media/b25a09e353d2cdfa327fa45d7c3f1c4e/href</a></iframe>

<h3 id="Realm-for-Dart-和-Flutter-是如何建立的"><a href="#Realm-for-Dart-和-Flutter-是如何建立的" class="headerlink" title="Realm for Dart 和 Flutter 是如何建立的"></a>Realm for Dart 和 Flutter 是如何建立的</h3><p>既然我們已經涵蓋了基本知識，讓我們看看 MongoDB 團隊是如何使用許多 Dart 函式庫和工具建立 Realm for Dart 和 Flutter。我們將看看在初始化 Realm SDK 時會發生什麼，Realm SDK 如何建立在一個共用原生 C++ 函式庫之上，Realm 終端工具是如何建立的，以及 Realm 模型是如何生成的。</p>
<h3 id="初始化-Realm-SDK"><a href="#初始化-Realm-SDK" class="headerlink" title="初始化 Realm SDK"></a>初始化 Realm SDK</h3><p>Dart 和 Flutter 開發人員將首先將 Realm 加入到他們現有的應用程式中，然後運行安裝程式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dart pub add realm_dart</span><br><span class="line">dart run realm_dart install</span><br></pre></td></tr></table></figure>

<p>第一步只是將 Realm SDK 加入到 <code>pubspec.yaml</code> 中，以 <a href="https://dart.dev/tools/pub/dependencies">註冊它作為應用程式的相依</a>。第二步運行 Realm 終端工具，要求它安裝 SDK。如果我們查看 <a href="https://github.com/realm/realm-dart/blob/main/lib/src/cli/install/install_command.dart">安裝指令的原始碼</a>，我們可以看到安裝會確定我們正在開發的作業系統，然後下載該作業系統的 Realm SDK 二進位檔案。</p>
<p>但是為什麼安裝指令要下載二進位檔案？Realm SDK 是一個非常全面的產品，可以在各種作業系統和開發人員框架上使用。為了避免必須建立大量 Realm SDK 的實例，Realm 團隊決定將核心 Realm SDK 實作為一個共用的 <a href="https://github.com/realm/realm-core">realm-core C++ 函式庫</a>。因此，安裝指令真正做的事情是下載這個核心函式庫的編譯版本，適用於應用程式支援的所有平台。</p>
<h3 id="調用-realm-core-SDK"><a href="#調用-realm-core-SDK" class="headerlink" title="調用 realm-core SDK"></a>調用 realm-core SDK</h3><p>使用 Realm SDK 撰寫 Dart 或 Flutter 應用程式的使用者可以獲得不錯的強類型 Dart API，如本文開頭所示。這些 API 如何與 <a href="https://github.com/realm/realm-core">realm-core</a> C++ 函式庫相對應？</p>
<p>如果我們瀏覽 Realm SDK 的 <code>lib</code> 目錄，我們會找到 <a href="https://github.com/realm/realm-dart/blob/main/lib/src/native/realm_bindings.dart">realm_bindings.dart</a>，它以以下內容開頭：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9354147dc5966ded3adbb95280d03a06/href">https://medium.com/media/9354147dc5966ded3adbb95280d03a06/href</a></iframe>

<p>謎團解開了：Realm SDK 使用 Dart 對原生 API 的互操作性支援（透過 <code>dart:ffi</code> 函式庫）來調用 realm-core。為了避免必須為大量可用的 Realm API 手動撰寫 FFI 綁定，這些綁定是使用 Dart 的 <a href="https://pub.dev/packages/ffigen">ffigen</a> 工具自動生成的。這是我們在 Dart 團隊中看到快速發展的模式。</p>
<h3 id="Realm-終端工具"><a href="#Realm-終端工具" class="headerlink" title="Realm 終端工具"></a>Realm 終端工具</h3><p>讓我們轉向 Realm 終端工具本身。在上面，我們運行了安裝指令，但我們也可以在沒有指定指令的情況下運行這個工具：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ dart run realm_dart</span><br><span class="line">Realm commands for working with Realm Flutter &amp; Dart SDKs.</span><br><span class="line"></span><br><span class="line">Usage: dart run realm|realm_dart &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">Global options:</span><br><span class="line">-h, --help    Print this usage information.</span><br><span class="line"></span><br><span class="line">Available commands:</span><br><span class="line">  generate   Generate Realm objects from data model classes</span><br><span class="line">  install    Download &amp; install Realm native binaries into a Flutter or Dart project</span><br><span class="line">  metrics    Report anonymized builder metrics to Realm</span><br><span class="line"></span><br><span class="line">Run &quot;dart run realm|realm_dart help &lt;command&gt;&quot; for more information about a command.</span><br></pre></td></tr></table></figure>

<p>您可能會注意到這個輸出看起來很像核心 dart 和 flutter 工具的輸出。這不是巧合；所有三個工具都是使用相同的 Dart 基礎函式庫建立的，這些函式庫來自 <a href="https://pub.dev/packages/args">package:args</a>，專門用於終端工具：</p>
<ul>
<li><a href="https://pub.dev/documentation/args/latest/args/args-library.html">args</a> 函式庫對將原始命令列參數解析為選項和標誌有豐富的支援。</li>
<li><a href="https://pub.dev/documentation/args/latest/command_runner/command_runner-library.html">command_runner</a> 函式庫提供工具支援的指令結構（例如，安裝）。</li>
</ul>
<h3 id="生成-Realm-模型"><a href="#生成-Realm-模型" class="headerlink" title="生成 Realm 模型"></a>生成 Realm 模型</h3><p>生成指令特別有趣，因為它根據我們在「Realm 範例」章節中定義的帶有注解的 Dart 模型類別生成完整的 Realm 模型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dart run realm_dart generate</span><br></pre></td></tr></table></figure>

<p>生成指令是如何工作的？它依賴於 Realm <a href="https://github.com/realm/realm-dart/blob/main/generator/README.md">生成器</a>，該生成器建立在 Dart 的 <a href="https://pub.dev/packages/build_runner">build_runner</a> 之上，這是一個用於生成器的框架，它接收一組輸入檔案，然後建立新的輸出檔案。通常 - 如 Realm 案例 - 輸入是帶有注解的 Dart 原始碼檔案，輸出檔案是額外的生成的 Dart 原始碼。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>希望您喜歡這次對大型開發人員框架如何從一組可重複使用的 Dart 函式庫中建立起來的幕後一窺。如果您是框架開發人員，希望這能为您提供一些靈感，激發您下一个基於 Dart 的框架的構思。</p>
<p>對於 Dart 和 Flutter 應用程式開發人員來說，Realm 是 MongoDB 團隊提供的一個很棒的新產品。我們邀請您查看 <a href="https://www.mongodb.com/docs/realm/sdk/flutter/">Realm SDK 文件</a> 以及今天的 <a href="https://www.mongodb.com/developer/products/realm/announcing-realm-flutter-sdk/">Realm 部落格文章</a>。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e30cb05eb313" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/introducing-realm-for-dart-flutter-e30cb05eb313">介紹 Realm for Dart 和 Flutter</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p>undefined</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/cb368ef1.html" data-id="cm1nvba1z0000h117bx3tedaz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dart/" rel="tag">dart</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/realm/" rel="tag">realm</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-app-store-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/4254a2e9.html" class="article-date">
  <time datetime="2020-10-25T11:51:40.000Z" itemprop="datePublished">2020-10-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Flutter/">Flutter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/4254a2e9.html">Android app 上架流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章主要介紹在2020年 Goolge 改版後的 Play Store Console 如何上架 Android App</p>
<p>首先到 <a href="https://play.google.com/console/u/0/developers/" target="_blank" rel="noopener">Play Store Console</a> 右邊點擊新增應用程式</p>
<p><img src="../images/android-app-deploy/img1.png" alt=""></p>
<p>填寫以下應用程式詳細資訊</p>
<ul>
<li>應用程式名稱：會顯示在商店的App名稱</li>
<li>預設語言：預設App使用的語言，作為商店一開始提供的預設語言</li>
<li>應用程式類型：分類只有遊戲與應用程式，目的是要把遊戲區分出來，日後可更改</li>
<li>是否收費：設定App是否下載時需要費用，勾選收費後，需要至 <code>付費應用程式</code> 修改設定</li>
</ul>
<p>最後同意 <code>開發人員計畫政策</code> 及 <code>美國出口法律</code> 後，即可完成初始設定</p>
<p><img src="../images/android-app-deploy/img2.png" alt=""></p>
<p><img src="../images/android-app-deploy/img3.png" alt=""></p>
<p>接著進入到 <code>資訊主頁</code></p>
<p><img src="../images/android-app-deploy/img4.png" alt=""></p>
<p>第一次設定時會出現 <code>初始設定</code> 提示，可依序點擊設定，該步驟都是必須完成的步驟，否則無法完成審查上架</p>
<p><img src="../images/android-app-deploy/img5.png" alt=""></p>
<h1 id="應用程式存取權"><a href="#應用程式存取權" class="headerlink" title="應用程式存取權"></a>應用程式存取權</h1><p>設定 App 是否開放給全部使用者</p>
<p><img src="../images/android-app-deploy/img6.png" alt=""></p>
<p>或是部分功能有使用限制，需設定：</p>
<ul>
<li>名稱</li>
<li>使用者名稱/電話號碼</li>
<li>密碼</li>
<li>任何操作說明</li>
</ul>
<p>透過此可限制使用者下載應用程式</p>
<p><img src="../images/android-app-deploy/img7.png" alt=""></p>
<p><img src="../images/android-app-deploy/img8.png" alt=""></p>
<h1 id="廣告"><a href="#廣告" class="headerlink" title="廣告"></a>廣告</h1><p>設定App中是否有廣告，若有勾選廣告則會在Play商店上顯示 <code>含廣告內容</code> 的標籤</p>
<p><img src="../images/android-app-deploy/img10.png" alt=""></p>
<h1 id="內容分級"><a href="#內容分級" class="headerlink" title="內容分級"></a>內容分級</h1><p>根據國際年齡分級聯盟（英語：International Age Rating Coalition，縮寫IARC）設計的簡化各國分級的內容分級問卷，降低產品評比的過程，<a href="https://zh.wikipedia.org/wiki/%E5%9C%8B%E9%9A%9B%E5%B9%B4%E9%BD%A1%E5%88%86%E7%B4%9A%E8%81%AF%E7%9B%9F" target="_blank" rel="noopener">參考資料</a></p>
<p>填寫內容分級問卷，讓使用者了解App的分類，及是否會有不宜兒童的內容</p>
<p><img src="../images/android-app-deploy/img11.png" alt=""></p>
<p>首先填寫電子郵件，問卷完成會寄送一份結果至該信箱</p>
<p><img src="../images/android-app-deploy/img13.png" alt=""></p>
<p>選擇 App 的類別，以 <a href="https://play.google.com/store/apps/details?id=com.wtuc.ap" target="_blank" rel="noopener">文藻校務通</a> 為例，選擇 <code>參考資訊、新聞或教育內容</code></p>
<p><img src="../images/android-app-deploy/img12.png" alt=""></p>
<p>根據選擇的類型，需填寫相關內容是否有未成年暴力色情訊息</p>
<p><img src="../images/android-app-deploy/img14.png" alt=""></p>
<p>完成後會顯示基本的報表，點擊右下角提交完成問卷</p>
<p><img src="../images/android-app-deploy/img15.png" alt=""></p>
<p>完成後，若日後想在修改問卷內容，需至右上角 點擊 <code>Start new questionaire</code> 重新提交問卷</p>
<p><img src="../images/android-app-deploy/img16.png" alt=""></p>
<h1 id="目標對象"><a href="#目標對象" class="headerlink" title="目標對象"></a>目標對象</h1><p>填寫詳細的App發布目標對象</p>
<p>首先點選 <code>目標年齡層</code>，主要是確認目標對象是不是兒童，若對象未滿13歲則需要新增隱私權政策</p>
<p><img src="../images/android-app-deploy/img18.png" alt=""></p>
<p>勾選 <code>是否會引起兒童興趣</code>，若上者點擊13歲以下，可勾選 <code>是</code> 宣稱適合兒童</p>
<p><img src="../images/android-app-deploy/img19.png" alt=""></p>
<p>最後點擊 <code>儲存</code> 完成目標對象和內容</p>
<p><img src="../images/android-app-deploy/img20.png" alt=""></p>
<p>接著就完成一半了～～</p>
<p><img src="../images/android-app-deploy/img21.png" alt=""></p>
<h1 id="應用程式類別及詳細資料"><a href="#應用程式類別及詳細資料" class="headerlink" title="應用程式類別及詳細資料"></a>應用程式類別及詳細資料</h1><p>應用程式分類，區分應用程式或遊戲的類別，在Play 商店中，也會有類別排名</p>
<p><img src="../images/android-app-deploy/img22.png" alt=""></p>
<p>接著設定商店的聯絡詳細資訊，分別為</p>
<ul>
<li>電子郵件地址 (必填)</li>
<li>電話號碼</li>
<li>網站</li>
</ul>
<p><strong>以上訊息皆會在Play商店上顯示</strong></p>
<p><img src="../images/android-app-deploy/img23.png" alt=""></p>
<p>並勾選是否要在Play商店外行銷，讓外部網站可搜尋到你的App</p>
<p><img src="../images/android-app-deploy/img24.png" alt=""></p>
<p>完成後就只剩下最後一個步驟</p>
<p><img src="../images/android-app-deploy/img25.png" alt=""></p>
<h1 id="商店資訊"><a href="#商店資訊" class="headerlink" title="商店資訊"></a>商店資訊</h1><p>首先會根據一開始設定的<code>主要語言</code>，設定 App 在 Play 商店的資訊，可根據不同語言，設定不同的商店資訊，可點擊 <code>管理其他語言版本的翻譯內容</code> 管理其他語言的內容</p>
<h2 id="應用程式詳細資料"><a href="#應用程式詳細資料" class="headerlink" title="應用程式詳細資料"></a>應用程式詳細資料</h2><p>首先可設定</p>
<ul>
<li>應用程式名稱：App名稱，作為可供搜尋的關鍵字，上限50字</li>
<li>簡短說明：可在App頁面首要看到簡短說明，上限80字</li>
<li>完整說明：在點擊<code>關於這個應用程式</code>後顯示的完整說明</li>
</ul>
<p><img src="../images/android-app-deploy/img26.png" alt=""></p>
<p>可參照 Play 商店對應位置</p>
<p><img src="../images/android-app-deploy/img26-1.jpg" alt=""></p>
<p><img src="../images/android-app-deploy/img26-2.jpg" alt=""></p>
<p>接著設定 <code>應用程式圖示</code> 會顯示在 Play 商店的圖示，<strong>限定尺寸為 <code>512*512</code> 的解析度</strong>，上傳後都會以橢圓裁剪顯示</p>
<p><img src="../images/android-app-deploy/img27.png" alt=""></p>
<p>主要圖片顯示於商店資訊的最頂端，可用於宣傳應用程式，<strong>大小限制 <code>1024*500</code> 解析度的圖片</strong></p>
<p><img src="../images/android-app-deploy/img29.png" alt=""></p>
<p>螢幕截圖主要分為</p>
<ul>
<li>手機</li>
<li>七吋平板電腦</li>
<li>十吋平板電腦</li>
</ul>
<p>基本上，對應類型的裝置截圖都適用，也可自行製作符合規定的尺寸的圖片，<strong>皆為使用 JPEG 或 24 位元 PNG 圖片，長寬比建議16:9</strong></p>
<p><img src="../images/android-app-deploy/img30.png" alt=""></p>
<p><img src="../images/android-app-deploy/img31.png" alt=""></p>
<p>加入影片也會顯示於商店上</p>
<p><img src="../images/android-app-deploy/img32.png" alt=""></p>
<p>商店資訊設定完成後，若未來要修改都可直接修改，但修改後都需要等商店部署時間，通常都會為半天左右時間</p>
<h1 id="上傳App至商店"><a href="#上傳App至商店" class="headerlink" title="上傳App至商店"></a>上傳App至商店</h1><p>到 <code>發佈</code> 的目錄下，選擇App目前要發布的方式，有分成</p>
<ul>
<li>正式版：會發布給商店中所有設置的地區</li>
<li>公開測試：任何使用者可至 Play 商店點擊測試計畫，即可使用此版本</li>
<li>封閉測試：由開發人員建立電子郵件清單，或是可透過連結加入測試計畫 <a href="https://play.google.com/apps/testing/{app" target="_blank" rel="noopener">https://play.google.com/apps/testing/{app</a> id}</li>
<li>內部測試：由開發人員建立電子郵件清單，或是可透過內部邀請測試連結：<a href="https://play.google.com/apps/internaltest/{test" target="_blank" rel="noopener">https://play.google.com/apps/internaltest/{test</a> group id} 加入</li>
<li>搶先註冊：若還沒發佈正式版時，可利用此功能，在Play商店中顯示搶先體驗的字樣，並提供測試人員特殊獎勵</li>
</ul>
<p>不管利用哪種測試方式，接下來上傳App的方式都會相同，例如選擇 <code>正式版</code> 發布，並點擊右上方的 <code>建立新版本</code></p>
<p><img src="../images/android-app-deploy/img33.png" alt=""></p>
<p>接著第一次上架時需點擊 同意使用 <code>Google Play 應用程式簽署</code>，Google 會管理你簽署所使用的金鑰，並且該金鑰只能提供給該 App 使用</p>
<p>若今天金鑰遺失，可請帳戶擁有者聯絡<a href="https://support.google.com/googleplay/android-developer/contact/otherbugs" target="_blank" rel="noopener">支援小組</a>重新上傳金鑰</p>
<p>將利用 <code>Android Studio</code> 等等的 Android 編譯工具，將原生Android 的 <code>Apk</code> 或是 <code>App Bundle</code> 上傳至此頁面</p>
<p><strong>每次新上傳的 <code>版本號碼(version code)</code> 皆需大於先前上傳的</strong></p>
<p>關於金鑰使用詳細 <a href="https://support.google.com/googleplay/android-developer/answer/7384423" target="_blank" rel="noopener">可參考</a></p>
<p><img src="../images/android-app-deploy/img35.png" alt=""></p>
<h2 id="版本詳細資訊"><a href="#版本詳細資訊" class="headerlink" title="版本詳細資訊"></a>版本詳細資訊</h2><p>版本名稱會根據上傳的 <code>Apk</code> 或 <code>App Bundle</code> 命名</p>
<p>版本資訊會根據商店可提供的語言，以 <code>XML</code> 格式撰寫，將這次更新內容寫至 <code>語言碼(language code)</code> 中</p>
<p><img src="../images/android-app-deploy/img36.png" alt=""></p>
<p>完成後點擊儲存，並點擊檢查版本</p>
<p><img src="../images/android-app-deploy/img37.png" alt=""></p>
<p>接著會發現沒有設定提供地區</p>
<p><img src="../images/android-app-deploy/img38.png" alt=""></p>
<p>返回至上一頁的最上方，選擇 <code>國家與地區</code> 編輯針對正式版的發布國家/地區</p>
<p><img src="../images/android-app-deploy/img39.png" alt=""></p>
<p>若沒勾選，Play商店就不會發佈至此國家/地區</p>
<p><img src="../images/android-app-deploy/img40.png" alt=""></p>
<p>接著回到剛剛編輯的版本資訊，點擊 <code>開始發布(正式版)</code></p>
<p><img src="../images/android-app-deploy/img41.png" alt=""></p>
<p>最後會跳回正式版的頁面，並顯示審查中</p>
<p><img src="../images/android-app-deploy/img42.png" alt=""></p>
<p>自 2019 年開始，Play 商店在第一次審查時，最久大約會至七天，爾後提交大約都是一下子就完成審查，並都是半天會完全部署至商店(所有使用者都可以看到更新)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/4254a2e9.html" data-id="ckrhj405y0000gxb30xskeeey" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ios-app-store-tutorial" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/dc2c1f00.html" class="article-date">
  <time datetime="2020-10-24T12:27:58.000Z" itemprop="datePublished">2020-10-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Flutter/">Flutter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/dc2c1f00.html">iOS app 上架流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本篇文章主要介紹在2020年 Apple 改版後的 App Store Connect 如何上架 iOS App</p>
<h1 id="新增-App"><a href="#新增-App" class="headerlink" title="新增 App"></a>新增 App</h1><p>到 <a href="https://appstoreconnect.apple.com/" target="_blank" rel="noopener">App Store Connect</a> 點擊 <code>我的App</code></p>
<p><img src="../images/ios-app-deploy/img1.png" alt=""></p>
<p>點擊 App 旁邊邊的 + 選擇 <code>新的 App</code></p>
<p><img src="../images/ios-app-deploy/img2.png" alt=""></p>
<h1 id="註冊Identifier"><a href="#註冊Identifier" class="headerlink" title="註冊Identifier"></a>註冊Identifier</h1><p>到 <a href="https://developer.apple.com/account/resources/identifiers/list" target="_blank" rel="noopener">憑證、識別碼及描述檔</a> 註冊App的 <code>Identifier</code></p>
<p><img src="../images/ios-app-deploy/img4-0.png" alt=""></p>
<p>選擇 <code>App IDs</code></p>
<p><img src="../images/ios-app-deploy/img4-1.png" alt=""></p>
<p>選擇 <code>App</code></p>
<p><img src="../images/ios-app-deploy/img4-2.png" alt=""></p>
<p><strong>Discription</strong> 填寫可以識別的名稱</p>
<p><strong>App ID Prefix</strong> 選擇 <code>Explicit</code> 並填上與 Xcode 中的 <code>Bundle Indentifier</code> 相同的 ID</p>
<p><strong>App ID Prefix 的 Bundle ID 上架後就不可修改</strong></p>
<p>最後點擊 <code>Continue</code> 然後 <code>Register</code> 完成註冊</p>
<p><img src="../images/ios-app-deploy/img4-3.png" alt=""></p>
<p>或是</p>
<p>懶人方法</p>
<p>使用 <code>Xcode</code> 在 <code>Target</code> 中的 <code>Runner</code> 選擇 <code>Signing &amp; Capabilities</code></p>
<p>選擇想要上架的Apple開發者帳號</p>
<p><img src="../images/ios-app-deploy/img3.png" alt=""></p>
<p>並點擊 <code>+ Capability</code> 隨意新增一個 Capability</p>
<p>此動作 <code>Xcode</code> 會自動註冊 <code>Indentifier</code> 至 App Store Connect</p>
<p>完成後再將其取消 </p>
<p>沒取消的話審查時會納入審查範圍 要特別注意</p>
<p><img src="../images/ios-app-deploy/img4-4.png" alt=""></p>
<p>接著填寫App基本資訊</p>
<ul>
<li>平台：選擇你的App會在哪些平台提供，若沒勾選可事後新增</li>
<li>名稱：在Apple Store的名稱，無法跟已上架App相同，命名上需要先搶先贏，除非對方把App刪除或修改名稱，也是使用者搜尋時能找到你的App的首要途徑</li>
<li>主要語言：首先可在商店提供的語言，若有發佈不同國家語系，可事後新增</li>
<li>套件識別碼：選擇剛才新增的 <code>Indentifier</code>，選擇後就不能修改，對應到原生的 <code>Bundle Indentifier</code></li>
<li>SKU：App ID 為獨一無二，可任意命名，填寫後不能修改，但不會公開顯示</li>
</ul>
<p><img src="../images/ios-app-deploy/img4-5.png" alt=""></p>
<h1 id="App-資訊"><a href="#App-資訊" class="headerlink" title="App 資訊"></a>App 資訊</h1><p>新增 App 後，可先來 一般資訊 -&gt; App 資訊，填寫 App 基本資訊，這邊會分兩個區塊，一個是可本地化資訊及一般資訊</p>
<h3 id="可本地化資訊"><a href="#可本地化資訊" class="headerlink" title="可本地化資訊"></a>可本地化資訊</h3><ul>
<li>名稱：必填，為一開始輸入的 App 名稱</li>
<li>副標題：必填，商店中會位於 App 名稱下方，建議使用簡短語句說明 App</li>
<li>隱私權政策：必填，聲明你的 App 隱私權政策的網址，不限制格式</li>
</ul>
<p><img src="../images/ios-app-deploy/img16.png" alt=""></p>
<h3 id="一般資訊"><a href="#一般資訊" class="headerlink" title="一般資訊"></a>一般資訊</h3><ul>
<li>Apple ID：由 Apple 產生，作為網頁上的編號，可至 <a href="https://apps.apple.com/tw/app/id`${你的" target="_blank" rel="noopener">https://apps.apple.com/tw/app/id`${你的</a> Apple ID}`，找到你的App</li>
<li>內容版權：聲明你的 App 是否有第三方內容，像是以校務通來說，資料來源於學校，就可以視為第三方內容 </li>
<li>年齡分級：必填，根據填寫 <a href="#/年齡分級問卷">年齡分級問卷</a> 的結果</li>
<li>許可協議：必填，預設使用 <a href="https://www.apple.com/legal/internet-services/itunes/dev/stdeula/" target="_blank" rel="noopener">《Apple 標準終端使用者許可協議》(EULA)</a>，可點擊自訂許可協議</li>
<li>類別：必填，在商店的分類，可選擇兩個，也作為與同類型App排名的分類</li>
</ul>
<p><img src="../images/ios-app-deploy/img17.png" alt=""></p>
<h1 id="定價與供應狀況"><a href="#定價與供應狀況" class="headerlink" title="定價與供應狀況"></a>定價與供應狀況</h1><ul>
<li>價格排程：選擇你的App定價方式，最低免費到最高 32900元，使用者付費購買後90天內都可以反悔</li>
<li>預定：第一次上架前會顯示，自訂日期在App成功發布後，會通知預定的使用者</li>
<li>供應狀況：需先填寫<code>供應國家與地區</code>，若選擇停止供應，會從商店下架，直到重新供應為止</li>
<li>Mac 上的 iOS App：如果你的iOS App有使用到 <a href="https://developer.apple.com/mac-catalyst/" target="_blank" rel="noopener">Mac Catalyst
</a>(Flutter 目前不支援)，會將你的iOS App發佈至 Mac App Store，若有發佈macOS App，則優先發布 macOS App</li>
<li>App發布方式：根據你的開發者帳號，若個人開發者帳號只能選擇公開在Apple Store，若是企業開發者帳號，則可以發布到私人的商店發布</li>
</ul>
<p><img src="../images/ios-app-deploy/img18.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img18-1.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img26.png" alt=""></p>
<h1 id="App版本資訊"><a href="#App版本資訊" class="headerlink" title="App版本資訊"></a>App版本資訊</h1><p>進入 App <code>版本資訊</code> 後</p>
<p>首先設定 <code>App預覽與截圖</code> 可參考以下規格 <strong><code>每個至少三張</code></strong></p>
<p>12.9 吋 iPad Pro 第三代 及 第二代 尺寸是可以相容的 故截圖第三代 可直接上傳到第二代</p>
<p>建議使用模擬器截圖 上傳完可用滑鼠拖曳改變顯示順序</p>
<table>
<thead>
<tr>
<th style="text-align:center">螢幕尺寸說明</th>
<th style="text-align:center">平台</th>
<th style="text-align:center">截圖尺寸</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 6.5 吋</td>
<td style="text-align:center">iPhone 11 Pro Max、iPhone 11、iPhone X S Max、iPhone XR</td>
<td style="text-align:center">1242 x 2688 像素（直向） 2688 x 1242 像素（橫向）</td>
</tr>
<tr>
<td style="text-align:center">iPhone 5.5 吋</td>
<td style="text-align:center">iPhone 8 Plus、iPhone 7 Plus、iPhone 6s Plus</td>
<td style="text-align:center">1242 x 2208 像素（直向） 2208 x 1242 像素（橫向）</td>
</tr>
<tr>
<td style="text-align:center">12.9 吋 iPad Pro（第三代）</td>
<td style="text-align:center">iPad Pro 2018、iPad Pro 2020</td>
<td style="text-align:center">2048 x 2732 像素（直向） 2732 x 2048 像素（橫向）</td>
</tr>
<tr>
<td style="text-align:center">12.9 吋 iPad Pro（第二代）</td>
<td style="text-align:center">iPad Pro 2017</td>
<td style="text-align:center">2048 x 2732 像素（直向） 2732 x 2048 像素（橫向）</td>
</tr>
</tbody>
</table>
<p>更多詳細資訊 <a href="https://help.apple.com/app-store-connect/#/devd274dd925" target="_blank" rel="noopener">可參考</a></p>
<p><img src="../images/ios-app-deploy/img5.png" alt=""></p>
<p>接著填寫</p>
<ul>
<li>行銷宣傳文字：作為 App 行銷宣傳標語，建議簡短的文字，也要符合App的性質</li>
<li>關鍵字：在商店搜尋時，透過關鍵字加強找到App，並使用逗點隔開</li>
<li>描述：詳細介紹App的功能與特色</li>
<li>支援URL：對應商店開發者網頁</li>
<li>行銷URL：待補充</li>
<li>版本：可參考 <a href="https://semver.org/lang/zh-TW/" target="_blank" rel="noopener">語意化版本</a>，不限定兩碼或三碼，不能與先前定義的相同</li>
<li>版權：宣告App版權的註解</li>
<li>年齡分級：根據填寫 <a href="#/年齡分級問卷">年齡分級問卷</a> 的結果（需點擊編輯填寫）</li>
</ul>
<p><img src="../images/ios-app-deploy/img6.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img7.png" alt=""></p>
<p>對應在商店的位置可參考</p>
<p><img src="../images/ios-app-deploy/img6-1.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img6-2.png" alt=""></p>
<h2 id="年齡分級問卷"><a href="#年齡分級問卷" class="headerlink" title="年齡分級問卷"></a>年齡分級問卷</h2><p>針對App的內容填寫是否有兒童不宜的</p>
<p><img src="../images/ios-app-deploy/img9.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img10.png" alt=""></p>
<h2 id="App審查資訊"><a href="#App審查資訊" class="headerlink" title="App審查資訊"></a>App審查資訊</h2><p>蘋果在審查時都是採用 <code>人工審查</code>，審查過程都須填寫完整的資料</p>
<ul>
<li>登入資訊：若你的App有設計登入功能，需提供測試帳號給審查人員</li>
<li>聯絡人資訊：當審查有問題時的聯絡人資訊，電話號碼需要加入國際冠碼</li>
<li>備註：資訊則提供其他資訊供審查人員了解你的App，像是之前就被問過這幾個問題，爾後我都在新的App加入這些回答<ul>
<li>Who is the target audience?</li>
<li>How do users obtain an account?</li>
<li>Is this app meant for internal distribution in your own company, in the company of one target client, or in multiple target clients’ companies?</li>
<li>In which countries will this app primarily be distributed?</li>
<li>If this app is meant for internal distribution, will the app be accessible by both internal and external partners? Or will it be exclusive to in-house employees?<ul>
<li>附件：可附上App操作影片，若你的App無法提供帳號測試，或是有些功能需要提供範例影片操作(ex.何時會使用到讀取wifi連線資訊的功能)，都需要附上影片</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="../images/ios-app-deploy/img8.png" alt=""></p>
<h3 id="建制版本"><a href="#建制版本" class="headerlink" title="建制版本"></a>建制版本</h3><p>接著選擇要送至審查的App版本，需先透過Xcode <code>Archive</code> 後上傳至App Store Connect，點擊藍色按鈕</p>
<p><img src="../images/ios-app-deploy/img11.png" alt=""></p>
<p>選擇對應想提交的版本，通常上傳完會需要一段時間處理，當完成處理都會email通知</p>
<p><img src="../images/ios-app-deploy/img11-1.png" alt=""></p>
<p>屆時才會出現在這邊</p>
<p><img src="../images/ios-app-deploy/img12.png" alt=""></p>
<p>接著選擇這次提交的出口合規資訊，點擊是否有使用加密功能，若點擊是的話，需要另外填寫出口法律資訊</p>
<p><img src="../images/ios-app-deploy/img13.png" alt=""></p>
<h3 id="廣告識別碼"><a href="#廣告識別碼" class="headerlink" title="廣告識別碼"></a>廣告識別碼</h3><p>最後是填寫是否有使用到 <code>廣告識別碼</code>，像是 Firebase Analytics 或是 Ad Mod 等第三方的廣告或分析工具，就需要聲明有使用到，若審查後發現錯誤，則需要重新上傳新的App版本</p>
<p><img src="../images/ios-app-deploy/img14.png" alt=""></p>
<p><strong>最後回到最上方點擊完成，並點擊審查，結著就會進入正在等待審查</strong></p>
<p><img src="../images/ios-app-deploy/img20.png" alt=""></p>
<p>通常審查時間已台灣都是晚上開始到半夜，對應到美國的白天時間，第一次審查都會比較久，大約2~3天，要耐心等待</p>
<p>但有時候會審查失敗，也會寄送 email 通知，可至連結查詢問題，並回覆審查人員</p>
<p>iOS Resolve Center : <a href="">https://appstoreconnect.apple.com/apps/<code>{apple id}</code>/appstore/platform/ios/resolutioncenter?m=</a></p>
<p>macOS Resolve Center : <a href="">https://appstoreconnect.apple.com/apps/<code>{apple id}</code>/appstore/platform/osx/resolutioncenter?m=</a></p>
<p><img src="../images/ios-app-deploy/img21.png" alt=""></p>
<p><img src="../images/ios-app-deploy/img21-1.png" alt=""></p>
<p>若審查成功，則會通知 <code>Ready for Sale</code>，完成這次版本審查</p>
<p><img src="../images/ios-app-deploy/img22.png" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/dc2c1f00.html" data-id="ckrhj40630001gxb3dhr7cdg2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-window-10-安裝-docker-無法開啟-問題" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/archives/b0c060c4.html" class="article-date">
  <time datetime="2018-08-27T08:21:28.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Docker/">Docker</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/archives/b0c060c4.html">window 10 安裝 docker 無法開啟 問題</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>若開啟docker後，vmware無法執行須關閉docker使用的hyper-v兩者會相衝，只能同時開其一<br><a href="https://stackoverflow.com/questions/48066994/docker-no-matching-manifest-for-windows-amd64-in-the-manifest-list-entries" target="_blank" rel="noopener">https://stackoverflow.com/questions/48066994/docker-no-matching-manifest-for-windows-amd64-in-the-manifest-list-entries</a></p>
<p>關閉系統hyper-v<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype off</span><br></pre></td></tr></table></figure></p>
<p>重新打開<br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure></p>
<p>上述兩指令 執行完都須重新開機</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.rainvisitor.me/archives/b0c060c4.html" data-id="ckrhj406a0004gxb35iri385y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Dart/">Dart</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flutter/">Flutter</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/3d/" rel="tag">3d</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/" rel="tag">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/announcements/" rel="tag">announcements</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cross-platform/" rel="tag">cross-platform</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dart/" rel="tag">dart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dartlang/" rel="tag">dartlang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/education-technology/" rel="tag">education-technology</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/enterprise-technology/" rel="tag">enterprise-technology</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter/" rel="tag">flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter-app-development/" rel="tag">flutter-app-development</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter-development/" rel="tag">flutter-development</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter-web/" rel="tag">flutter-web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flutter-web-development/" rel="tag">flutter-web-development</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional-programming/" rel="tag">functional-programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/game-development/" rel="tag">game-development</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/games/" rel="tag">games</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/google-io-2024/" rel="tag">google-io-2024</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/google-summer-of-code/" rel="tag">google-summer-of-code</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/graphics-programming/" rel="tag">graphics-programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/guides-and-tutorials/" rel="tag">guides-and-tutorials</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/interoperability/" rel="tag">interoperability</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/" rel="tag">ios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios-app-development/" rel="tag">ios-app-development</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/open-source/" rel="tag">open-source</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/realm/" rel="tag">realm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/recaps/" rel="tag">recaps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/release-notes/" rel="tag">release-notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/releases/" rel="tag">releases</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wasm/" rel="tag">wasm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webassembly/" rel="tag">webassembly</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/3d/" style="font-size: 10px;">3d</a> <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Flutter/" style="font-size: 11.43px;">Flutter</a> <a href="/tags/announcements/" style="font-size: 15.71px;">announcements</a> <a href="/tags/cross-platform/" style="font-size: 10px;">cross-platform</a> <a href="/tags/dart/" style="font-size: 18.57px;">dart</a> <a href="/tags/dartlang/" style="font-size: 17.14px;">dartlang</a> <a href="/tags/education-technology/" style="font-size: 10px;">education-technology</a> <a href="/tags/enterprise-technology/" style="font-size: 10px;">enterprise-technology</a> <a href="/tags/flutter/" style="font-size: 20px;">flutter</a> <a href="/tags/flutter-app-development/" style="font-size: 14.29px;">flutter-app-development</a> <a href="/tags/flutter-development/" style="font-size: 10px;">flutter-development</a> <a href="/tags/flutter-web/" style="font-size: 10px;">flutter-web</a> <a href="/tags/flutter-web-development/" style="font-size: 10px;">flutter-web-development</a> <a href="/tags/functional-programming/" style="font-size: 10px;">functional-programming</a> <a href="/tags/game-development/" style="font-size: 11.43px;">game-development</a> <a href="/tags/games/" style="font-size: 10px;">games</a> <a href="/tags/google-io-2024/" style="font-size: 10px;">google-io-2024</a> <a href="/tags/google-summer-of-code/" style="font-size: 10px;">google-summer-of-code</a> <a href="/tags/graphics-programming/" style="font-size: 10px;">graphics-programming</a> <a href="/tags/guides-and-tutorials/" style="font-size: 10px;">guides-and-tutorials</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/interoperability/" style="font-size: 10px;">interoperability</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a> <a href="/tags/ios-app-development/" style="font-size: 10px;">ios-app-development</a> <a href="/tags/open-source/" style="font-size: 10px;">open-source</a> <a href="/tags/realm/" style="font-size: 10px;">realm</a> <a href="/tags/recaps/" style="font-size: 10px;">recaps</a> <a href="/tags/release-notes/" style="font-size: 11.43px;">release-notes</a> <a href="/tags/releases/" style="font-size: 12.86px;">releases</a> <a href="/tags/wasm/" style="font-size: 10px;">wasm</a> <a href="/tags/webassembly/" style="font-size: 10px;">webassembly</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/08/">八月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/archives/14c13b13.html">【文章翻譯】Announcing Dart 3.5, and an update on the Dart roadmap</a>
          </li>
        
          <li>
            <a href="/archives/8ddf18fb.html">【文章翻譯】Getting started with Flutter GPU</a>
          </li>
        
          <li>
            <a href="/archives/6243ded4.html">【文章翻譯】Announcing Flutter 3.24 and Dart 3.5</a>
          </li>
        
          <li>
            <a href="/archives/6243ded4.html">【文章翻譯】What’s new in Flutter 3.24</a>
          </li>
        
          <li>
            <a href="/archives/3378cc1.html">【文章翻譯】All the Flutter news from a busy Google I/O 2024</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 Rainvisitor<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FZZFH3T2TV"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FZZFH3T2TV');
</script>
  </div>
</body>
</html>