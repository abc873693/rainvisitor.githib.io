<!DOCTYPE html>
<html lang="zh-tw,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rainvisitor.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/page/4/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.rainvisitor.me/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-tw'
  };
</script>

  <title>RainVisitor Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RainVisitor Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">RainVisitor</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/6d81769b.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/6d81769b.html" class="post-title-link" itemprop="url">【文章翻譯】Starting 2024 strong with Flutter and Dart</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-15 19:30:03" itemprop="dateCreated datePublished" datetime="2024-02-15T19:30:03+08:00">2024-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="強勢開啓-2024：Flutter-和-Dart-的新篇章"><a href="#強勢開啓-2024：Flutter-和-Dart-的新篇章" class="headerlink" title="強勢開啓 2024：Flutter 和 Dart 的新篇章"></a>強勢開啓 2024：Flutter 和 Dart 的新篇章</h2><p><em>我們興奮地宣布今年首個季度 Flutter 和 Dart 的 SDK 版本更新——Flutter 3.19 和 Dart 3.3，以及一些令人興奮的人工智慧相關消息。</em></p>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*gO0yYMh4FUkpue3w" />
</figure>

<p><strong>Flutter 和 Dart 的價值與未來</strong></p>

<p>我最近加入了 Flutter 和 Dart 團隊，我很高興能在 AI 迅速發展以提升開發人員生產力並解鎖新型使用者體驗的時刻，與我們的開發人員社群合作。我看到了 Flutter 和 Dart 在幫助塑造未來方面發揮的無限潛力。我同樣受到 Flutter 的最初願景的啟發，即改進為任何設備構建漂亮、高效、多平台應用程式的體驗。</p>

<p>從數百萬支援 Flutter 的才華橫溢且富有創造力的開發人員（他們為框架做出貢獻，或構建令人驚嘆的體驗）來看，很明顯，其他人也看到了這個願景，並有動力去幫助實現它。核心使命仍然相同：提供強大的語言架構配對，讓富有創造力的開發人員能夠為任何設備構建漂亮、豐富且高效能的應用程式。讓我們一起完成吧！</p>

<p><strong>將 Flutter 和 Dart 帶入 Gemini 時代</strong></p>

<p>今天，我們推出了 [Google AI Dart SDK](https://medium.com/flutter/harness-gemini-in-your-dart-and-flutter-apps-00573e560381)，一個新的 pub.dev 套件，[google_generative_ai](https://pub.dev/packages/google_generative_ai)，以及 [支援資源](https://ai.google.dev/tutorials/dart_quickstart)；這些工具共同讓您可以使用 Gemini API 在 Dart 和 Flutter 應用程式中構建自己的基於生成式 AI 的功能，例如智慧聊天機器人、視覺搜尋引擎和圖片描述。Flutter 和 Dart 的跨平台功能以及這個新的 SDK 使您能夠更輕鬆地在不同平台上構建互動式體驗。</p>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*5hGoIuMtVnvrZ2id" />
</figure>

<p>這僅僅是我們正在利用 AI 為 Flutter 和 Dart 開發帶來的創新浪潮的開始。例如，Flutter 和 Dart 開發人員很快就可以在 [Google 的 AI Studio](https://aistudio.google.com/?utm_source=flutter&amp;utm_medium=referral&amp;utm_campaign=blog_umbrella_announcement&amp;utm_content=) 中完善您的用例提示後直接複製 Dart 程式碼。</p>

<p>在 [深入探討的部落格文章](https://medium.com/flutter/harness-gemini-in-your-dart-and-flutter-apps-00573e560381) 中了解更多關於 Google AI Dart SDK 的資訊。</p>

<p>許多開發人員已經開始以令人興奮的方式將 Flutter 和 AI 工具結合在一起：</p>

<ul>
<li>LeanCode 團隊已使用 Gemini 模型構建了 [arb_translate](https://leancode.co/arb_translate)，一個允許開發人員自動執行翻譯任務的套件。</li>
<li>We Spot Turtles! 將 Flutter 和 AI 結合到他們的使命中，旨在拯救海龜免於滅絕。他們最近被 Google Play 的 [WeArePlay 活動](https://play.google.com/console/about/weareplay/) 報導。請查看下面的影片。</li>
<li>AutoGPT，一個基於大型語言模型 (LLM) 的實驗性開源專案，擁有一個 [Flutter 客戶端](https://github.com/Significant-Gravitas/auto_gpt_flutter_client)，可以在 iOS、Android、網頁、macOS 和 Windows 上運行。</li>
</ul>

<p>[#WeArePlay | Caitlin and Nicolas | We Spot Turtles! | Australia](https://youtu.be/CfzhLOiczDQ?si=Qgc4Yb4Q9xKI6byF)</p>

<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FCfzhLOiczDQ%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DCfzhLOiczDQ&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FCfzhLOiczDQ%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/c589a07e2318b9c8d79af8b3e2dc5a53/href">https://medium.com/media/c589a07e2318b9c8d79af8b3e2dc5a53/href</a></iframe>

<p>在您探索 Gemini 模型的功能時，請務必使用 #BuildWithGemini 標籤與我們分享您正在構建的全新且創新的體驗。</p>

<p><strong>兩個新的 SDK 版本</strong></p>

<p>除了 AI 帶來的興奮之外，我們仍然專注於持續構建一個強大的 UI 架構，它能夠交付您想要在任何想要構建的螢幕上構建的任何體驗。您會在今天的 SDK 版本 Flutter 3.19 和 Dart 3.3 中看到朝著這個願景的進展。</p>

<p>這些版本重點關注完善和效能改進，這些改進建立在 Flutter 和 Dart 去年 [設定的軌跡](https://medium.com/flutter/whats-next-for-flutter-b94ce089f49c) 之上。在此 Flutter 版本中，您將發現：</p>

<ul>
<li>對我們透過持續在 Impeller 上的工作來生成突破性圖形效能的努力進行更新。</li>
<li>透過 Flutter iOS 原生字體和深層連結網頁驗證器的早期版本，朝向提供平台之間的無縫整合邁出更多步驟。</li>
<li>持續關注開發人員體驗，包括對 DevTools 的更新和 [Flutter 套件生態系統進展報告](https://medium.com/flutter/progress-of-the-flutter-package-ecosystem-17cded9a0703?source=collection_home---4------1-----------------------)。</li>
<li>最後，我們很高興分享我們在幫助定義 Web 未來的 Wasm 任務上的進展。</li>
</ul>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*2UG76__vsbp6NHtN" />
</figure>

<p>反過來，Dart 3.3 引入了擴展類型，一種與 Web 上的 JavaScript 互動的新模型，並且更新了我們對支援存取更多、更好的 Web 函式庫的工作。您可以在 [Flutter 3.19](https://medium.com/flutter/whats-new-in-flutter-3-19-58b1aae242d2) 和 [Dart 3.3](https://medium.com/dartlang/dart-3-3-325bf2bf6c13) 的部落格文章中分別了解更多關於每個版本的資訊。</p>

<p><strong>2024 年策略與路線圖</strong></p>

<p>這些功能中的每一個都是我們今年正在進行的一個更大旅程中的小小一步，您可以在我們的 [2024 年路線圖](https://github.com/flutter/flutter/wiki/Roadmap) 中看到。與往常一樣，這些路線圖源於我們希望公開我們的計劃的願望，因為我們知道你們中的許多人將 Flutter 和 Dart 視為職業和業務中必不可少的組成部分。話雖如此，即使制定了計劃，進展也很難預測。</p>

<p>雖然我們將盡最大努力繼續保持透明度，因為不可避免的變化會迫使我們轉移重點並做出取捨，但我們想強調，在 Google 之外，Flutter 和 Dart 的貢獻者比我們在這裡工作的員工還要多，這意味著我們的路線圖中提到的內容僅僅是今年 Dart 和 Flutter 將發生的數千次變更中的一小部分。</p>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*oAoUwrRrrYWIbu_u" />
<figcaption>2024 roadmap</figcaption>
</figure>

<p><strong>將所有內容整合在一起</strong></p>

<p>我在 Google 和 YouTube 的 17 年多的時間裡參與過許多有趣且創新的專案，但這是對新的機會感到最熱情的時刻。我從軟體工程師開始我的職業生涯，我在 Google 的第一份工作是地圖 API 和地理開發者工具的產品經理，因此能夠回到我的開發人員根源真是太好了。</p>

<p>推動我熱情的一部分是，嗯，您的熱情。僅僅在 2024 年，我看到了這個社群取得了如此令人驚嘆的成就，包括：</p>

<ul>
<li>超過 2,700 位開發人員加入了我們的 [全球遊戲挑戰](http://flutter.dev/global-gamers)，這是我們與國際倡導機構 Global Citizen 合作舉辦的，旨在挑戰您利用自己的技能構建 Flutter 遊戲，激勵世界以更可持續的方式生活。</li>
<li>[Superlist](https://youtu.be/37qvcjmE51w)，在昨天宣布了 1.0 版本，正在使用 Flutter 重塑任務管理、筆記記錄以及介於兩者之間的一切。</li>
</ul>

<p>最後，我的孩子們正在學習電腦科學，我致力於幫助創造軟體開發體驗，幫助下一代為更美好的世界做出改變。</p>

<p>今年對於創造這樣的未來來說至關重要，我迫不及待地想看看 Flutter 和 Dart 如何支援它。與往常一樣，我們非常感謝您持續的支持，我們迫不及待地想看看我們將共同創造的成果。下次再見！</p>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=cae9845264fe" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/starting-2024-strong-with-flutter-and-dart-cae9845264fe">強勢開啓 2024：Flutter 和 Dart 的新篇章</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/4e7f9fc1.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/4e7f9fc1.html" class="post-title-link" itemprop="url">【文章翻譯】Sharing Flutter’s 2024 roadmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-15 19:28:44" itemprop="dateCreated datePublished" datetime="2024-02-15T19:28:44+08:00">2024-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="分享-Flutter-2024-年的路線圖"><a href="#分享-Flutter-2024-年的路線圖" class="headerlink" title="分享 Flutter 2024 年的路線圖"></a>分享 Flutter 2024 年的路線圖</h2><p>作為一個擁有蓬勃發展的社群的開源專案，我們致力於對我們的計畫保持透明，從問題到設計規格，所有內容都在公開場合分享。我們聽到了許多人對 Flutter 功能路線圖的興趣。這些路線圖在可預測性方面可能會很困難，因為這些計畫往往會在全年調整和適應，但我們仍然認為分享我們的整體計畫很重要，並帶有以下聲明：計畫可能會改變。</p>

<p>我們一直在發佈我們的路線圖，從 2020 年開始，而今天我們將分享我們的 2024 年路線圖。這是對前幾年工作的自然延續，我們仍然致力於我們的長期目標，即打造 *最受歡迎、成長最迅速、生產力最高的跨平台 UI 架構，用於建立豐富的應用程式體驗*。</p>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*8v__Z0fIVOBm4uxFnMLAVg.png" />
</figure>

<p>請注意，我們在此列出的内容主要來自那些作為 Google 員工在 Flutter 上工作的我們。到目前為止，非 Google 貢獻者的數量已超過 Google 員工，因此這並不是我們希望今年在 Flutter 中出現的所有新事物和令人興奮事物的詳盡清單！</p>

<p>我們對社群和您的持續支持表示衷心的感謝。我們迫不及待地想看看您將建立什麼！</p>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=22debd2bbd22" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/sharing-flutters-2024-roadmap-22debd2bbd22">分享 Flutter 的 2024 年路線圖</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/f19218e4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/f19218e4.html" class="post-title-link" itemprop="url">【文章翻譯】New in Dart 3.3: Extension Types, JavaScript Interop, and More</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-15 19:01:49" itemprop="dateCreated datePublished" datetime="2024-02-15T19:01:49+08:00">2024-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 20:20:40" itemprop="dateModified" datetime="2024-09-30T20:20:40+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Dart-3-3-來了，帶來效能和跨平台開發的重大變革！"><a href="#Dart-3-3-來了，帶來效能和跨平台開發的重大變革！" class="headerlink" title="Dart 3.3 來了，帶來效能和跨平台開發的重大變革！"></a>Dart 3.3 來了，帶來效能和跨平台開發的重大變革！</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*p4TBp0I66rJTq0LvnSuE7g.png" />
</figure>

<p><strong>Dart 3.3 已經推出，它將徹底改變效能和跨平台開發！</strong> 準備好使用 <strong>擴展類型</strong> 為您的應用程式增強能量，徹底改變效能優化，以及您與原生程式碼互動的方式。此外，我們改版後的 <strong>JavaScript 互操作</strong> 模型引入了強大的類型安全性，以及一種開發人員友好的方式來利用 Web 平台的強大功能。所有這些都為 <strong>WebAssembly</strong> 支援鋪平了道路。哦，還有 <strong>在您的 Dart 應用程式中使用 Google AI</strong>？當然可以！這一切都在 Dart 3.3 中。讓我們深入了解！</p>
<h3 id="介紹擴展類型"><a href="#介紹擴展類型" class="headerlink" title="介紹擴展類型"></a>介紹擴展類型</h3><p>擴展類型為類型引入了零成本封裝。使用它們來優化效能敏感的程式碼，特別是在與主機平台進行互操作時。擴展類型提供了自訂類型的便利性，這些自訂類型具有特定的成員，同時消除了典型的封裝分配開銷。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extension</span> type Wrapper(<span class="built_in">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">void</span> showValue() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;my value is <span class="subst">$i</span>&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">final</span> wrapper = Wrapper(<span class="number">42</span>);</span><br><span class="line">  wrapper.showValue(); <span class="comment">// Prints &#x27;my value is 42&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上範例將 <strong>Wrapper</strong> 定義為擴展類型，但將其用於像一個簡單的 Dart 類型。您可以實例化它並呼叫函數。Dart 將其編譯為一個正常的 Dart <strong>int</strong>，這才是關鍵的差別。擴展類型允許您在不產生分配典型封裝類型的間接成本的情況下，建立一個具有獨特成員的類型。因此，雖然 <a href="https://dart.dev/language/extension-methods">擴展成員</a> 功能（自 Dart 2.7 以來可用）允許您為現有類型新增函數和屬性，但擴展類型功能可以做同樣的事情，<em>而且還可以</em> 定義一個隱藏底層表示的新 API。</p>
<p>這對於與主機平台的互操作性特別有用。原生類型可以直接使用，而無需建立封裝器和相關的間接成本，同時仍然提供乾淨的生產 Dart API。在 <a href="http://dart.dev/language/extension-types">新的擴展類型文件</a> 中了解更多資訊。</p>
<h3 id="改進-JavaScript-互操作"><a href="#改進-JavaScript-互操作" class="headerlink" title="改進 JavaScript 互操作"></a>改進 JavaScript 互操作</h3><p>Dart 3.3 引入了一個新的模型，用於與 JavaScript 函式庫和 Web 進行互操作。它從一組與 JavaScript 互動的新 API 開始：<a href="https://api.dart.dev/dart-js_interop/dart-js_interop-library.html">dart:js_interop</a> 函式庫。現在 Dart 開發人員可以使用類型化的 API 與 JavaScript 進行交互。此 API 清晰地定義了兩種語言之間的界限，並進行了靜態強制。這消除了 <em>在</em> 編譯時間之前的一整類問題。除了存取 JavaScript 程式碼的新 API 之外，Dart 現在還包括一個使用擴展類型在 Dart 中表示 JavaScript 類型的模型。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dart:js_interop&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">Represents the <span class="code">`console`</span> browser API.</span></span></span><br><span class="line"><span class="keyword">extension</span> type MyConsole(JSObject _) <span class="keyword">implements</span> JSObject &#123;</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">void</span> log(JSAny? value);</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">void</span> debug(JSAny? value);</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">void</span> info(JSAny? value);</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">void</span> warn(JSAny? value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基於擴展類型的語法允許比擴展成員更具表現力和健全性。這簡化了從 Dart 利用 JavaScript API。在 <a href="https://dart.dev/interop/js-interop">新的 JS 互操作文件</a> 中了解更多資訊。</p>
<h3 id="改進瀏覽器函式庫"><a href="#改進瀏覽器函式庫" class="headerlink" title="改進瀏覽器函式庫"></a>改進瀏覽器函式庫</h3><p>自 1.0 版本以來，Dart SDK 已包含一組全面的瀏覽器函式庫。其中包括核心 <a href="https://api.dart.dev/dart-html/dart-html-library.html">dart:html</a> 函式庫，以及用於 SVG、WebGL 和其他功能的函式庫。</p>
<p>改進的 JavaScript 互操作模型提供了重新構想這些函式庫的機會。展望未來，我們的瀏覽器函式庫支援將專注於 <a href="https://pub.dev/packages/web">package:web</a>。這簡化了版本控制，加速了更新，並與 <a href="https://developer.mozilla.org/">MDN</a> 資源保持一致。</p>
<p>這條改進鏈引導我們走向下一件大事：將 Dart 編譯為 <a href="https://webassembly.org/">WebAssembly</a>。</p>
<h3 id="立即開始，為-WebAssembly-的未來做好準備"><a href="#立即開始，為-WebAssembly-的未來做好準備" class="headerlink" title="立即開始，為 WebAssembly 的未來做好準備"></a>立即開始，為 WebAssembly 的未來做好準備</h3><p>有了 Dart 3.3，套件和應用程式作者可以為編譯為 <a href="https://webassembly.org/">WebAssembly</a> 的 Web 應用程式奠定基礎。雖然 Flutter Web 中的 WebAssembly 支援仍然是實驗性的，但團隊正在努力穩定實作。若要使用 WebAssembly 在 Web 上運行 Flutter 應用程式，您需要遷移所有程式碼——從應用程式和所有相依項——以使用新的 JavaScript 互操作機制和 <a href="https://pub.dev/packages/web">package:web</a>。傳統的 JavaScript 和瀏覽器函式庫保持不變，並支援編譯為 JavaScript 程式碼。但是，編譯為 WebAssembly 需要遷移。</p>
<p>我們創建了一個 <a href="https://dart.dev/go/package-web">遷移指南</a> 來幫助作者開始包含 Wasm。我們希望在將其納入穩定版本時，最受歡迎的套件都支援 Wasm。</p>
<h3 id="另外一件事：介紹-Google-AI-Dart-SDK"><a href="#另外一件事：介紹-Google-AI-Dart-SDK" class="headerlink" title="另外一件事：介紹 Google AI Dart SDK"></a>另外一件事：介紹 Google AI Dart SDK</h3><p>Google 已將 Google AI Dart SDK 發佈到測試版。您可以將生成式 AI 功能構建到您的 Dart 或 Flutter 應用程式中。這些應用程式使用 Gemini，這是 Google 最新一代的 AI 模型。查看 <a href="https://pub.dev/packages/google_generative_ai">package:google_generative_ai</a>。在 <a href="https://medium.com/flutter/harness-gemini-in-your-dart-and-flutter-apps-00573e560381">這篇部落格文章</a> 中了解如何使用 Google AI Dart SDK 進行構建，或者直接跳到 <a href="https://ai.google.dev/tutorials/dart_quickstart">快速入門</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*0DiCLVhk_ipZIHKd" />
</figure>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=325bf2bf6c13" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/dart-3-3-325bf2bf6c13">Dart 3.3 的新功能：擴展類型、JavaScript 互操作等等</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p>undefined</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/777cb561.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/777cb561.html" class="post-title-link" itemprop="url">【文章翻譯】Harness the Gemini API in your Dart and Flutter Apps</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-15 14:51:44" itemprop="dateCreated datePublished" datetime="2024-02-15T14:51:44+08:00">2024-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="介紹-Google-AI-Dart-SDK"><a href="#介紹-Google-AI-Dart-SDK" class="headerlink" title="介紹 Google AI Dart SDK"></a>介紹 Google AI Dart SDK</h2><p>我們很興奮地宣布推出 Google AI Dart SDK，用於 Gemini API。新的 pub.dev 套件，<a href="https://pub.dev/packages/google_generative_ai">google_generative_ai</a>，以及 <a href="https://ai.google.dev/tutorials/dart_quickstart">支援資源</a> 讓您可以透過與 Gemini API 的慣用 Dart 整合，將您自己的基於生成式 AI 的功能建立到 Dart 和 Flutter 應用程式中。它為從單一程式碼庫為 Android、iOS、網頁、macOS、Windows 和 Linux 建立智慧、高效能的應用程式開闢了廣泛的可能性。</p>
<p>使用 Google AI Dart SDK，您可以：</p>
<ul>
<li><strong>輕鬆整合生成式 AI 功能：</strong>透過最少的設定，將進階文字生成、摘要、聊天等功能添加到您的 Dart 或 Flutter 應用程式中。</li>
<li><strong>利用 Google 目前最具能力和通用性的模型：</strong>Gemini 模型汲取了 Google 在機器學習方面的廣泛研究和開發成果，讓您可以使用持續改進的生成式 AI 功能。</li>
<li><strong>加速您的 AI 驅動應用程式開發：</strong>專注於您的應用程式邏輯和使用者體驗，而 SDK 則處理與 AI 模型互動的複雜細節。</li>
<li><strong>建立跨平台的 AI 驅動應用程式：</strong>使用 Flutter，輕鬆地在桌面、網頁和行動應用程式中建立生成式 AI 功能。</li>
<li><strong>在 180 多個國家和地區使用 Gemini API：</strong>查看 <a href="https://ai.google.dev/available_regions#available_regions">可用區域</a> 以獲取 Gemini API 和 Google AI Studio（以下將進一步說明）目前可用的國家和地區清單。</li>
</ul>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*-KkJmzvv3jNhh88TWxIBJg.png" />
</figure>

<p><strong>您可以建立什麼？</strong></p>
<p>我們相信生成式 AI 具有巨大潛力，可以幫助您實現應用程式和業務目標。由於 Gemini 模型是多模態的（它能夠處理來自多種方式的資訊，包括圖片和文字），因此它讓您發揮極大的創造力。然而，我們經常從應用程式開發人員那裡（甚至從我們自己的團隊內部）得到的第一个問題是「我實際上可以使用 Gemini API 做些什麼？」以下是一些您可能為您的 Dart 或 Flutter 應用程式建立的功能範例：</p>
<ul>
<li><strong>文字摘要：</strong>從文字輸入中生成長文章、研究論文或網站內容的簡潔摘要。</li>
<li><strong>智慧聊天機器人：</strong>建立更具吸引力且更像人類的對話介面，增強您的應用程式中的使用者體驗。</li>
<li><strong>視覺搜尋引擎：</strong>使用者可以上傳圖片，應用程式使用 Gemini API 傳回圖片中內容、樣式，甚至如何製作圖片中內容的描述。</li>
<li><strong>為無障礙使用生成圖片描述：</strong>生成上傳圖片的詳細文字描述，以幫助視障使用者。</li>
<li><strong>圖表和圖表解析：</strong>使用者可以上傳圖表、圖表或圖形的圖片，Gemini API 可以提供資料的文字分析和說明。</li>
</ul>
<p>這個清單可以一直列下去，因為可能性幾乎是無限的！</p>
<figure>
<img alt="A screenshot of the Flutter sample app that uses the Google AI Dart SDK" src="https://cdn-images-1.medium.com/max/1024/0*7Zvr0YiN7O22wTOy" />
<figcaption>使用 Google AI Dart SDK 的 Flutter 範例應用程式的螢幕截圖</figcaption>
</figure>

<p><strong>入門</strong></p>
<p>查看 <a href="https://ai.google.dev/tutorials/dart_quickstart">Dart 快速入門</a> 以獲取有關如何建立設定的詳細分步指南。總體而言，以下是您將執行的操作：</p>
<ol>
<li>從 Google AI Studio 獲取 Gemini API 金鑰。確保此金鑰安全。我們強烈建議您不要將金鑰直接包含在您的程式碼中，也不要將包含金鑰的文件检入版本控制系統。在開發過程中，我們建議使用 <code>flutter run -d [DEVICE NAME] — dart-define=API_KEY=[YOUR API KEY]</code> 在模擬器&#x2F;模擬器中運行應用程式，使用您的 API 金鑰作為環境變數。</li>
<li>透過分別運行 <code>dart pub add google_generative_ai</code> 或 <code>flutter pub add google_generative_ai</code>，將 Google AI Dart SDK 添加到您的 Dart 或 Flutter 應用程式中。這會將 <code>google_generative_ai</code> 添加為 <code>pubspec.yaml</code> 檔案中的相依性。</li>
<li>在您的程式碼中初始化生成式模型：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;package:google_generative_ai/google_generative_ai.dart&#x27;;</span><br><span class="line"></span><br><span class="line">// 將您的 API 金鑰作為環境變數存取（見上述第一步）</span><br><span class="line">final apiKey = Platform.environment[&#x27;API_KEY&#x27;];</span><br><span class="line">if (apiKey == null) &#123;</span><br><span class="line">  print(&#x27;No $API_KEY environment variable&#x27;);</span><br><span class="line">  exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final model = GenerativeModel(model: &#x27;MODEL_NAME&#x27;, apiKey: apiKey);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>現在您可以開始探索使用 Gemini API 實作不同的用例。例如，當提示輸入包含文字和圖片時，使用 gemini-pro-vision 模型和 generateContent 方法，以生成文字輸出：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;dart:io&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;package:google_generative_ai/google_generative_ai.dart&#x27;;</span><br><span class="line"></span><br><span class="line">void main() async &#123;</span><br><span class="line">  // 將您的 API 金鑰作為環境變數存取（見上述第一步）</span><br><span class="line">  final apiKey = Platform.environment[&#x27;API_KEY&#x27;];</span><br><span class="line">  if (apiKey == null) &#123;</span><br><span class="line">    print(&#x27;No $API_KEY environment variable&#x27;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">  // 對於文字和圖片輸入（多模態），使用 gemini-pro-vision 模型</span><br><span class="line">  final model = GenerativeModel(model: &#x27;gemini-pro-vision&#x27;, apiKey: apiKey);</span><br><span class="line">  final (firstImage, secondImage) = await (</span><br><span class="line">    File(&#x27;image0.jpg&#x27;).readAsBytes(),</span><br><span class="line">    File(&#x27;image1.jpg&#x27;).readAsBytes()</span><br><span class="line">  ).wait;</span><br><span class="line">  final prompt = TextPart(&quot;What&#x27;s different between these pictures?&quot;);</span><br><span class="line">  final imageParts = [</span><br><span class="line">    DataPart(&#x27;image/jpeg&#x27;, firstImage),</span><br><span class="line">    DataPart(&#x27;image/jpeg&#x27;, secondImage),</span><br><span class="line">  ];</span><br><span class="line">  final response = await model.generateContent([</span><br><span class="line">    Content.multi([prompt, ...imageParts])</span><br><span class="line">  ]);</span><br><span class="line">  print(response.text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>探索 <a href="https://ai.google.dev/docs">Gemini API 文檔</a>，並查看 GitHub 儲存庫中的 <a href="https://github.com/google/generative-ai-dart/tree/main/samples">Dart 和 Flutter 範例應用程式</a>，以獲取有關如何為各種用例使用 SDK 的詳細指南和範例，或者在 <a href="https://dartpad.dev/?id=341bc46b2ed1d2055d357ab987ed5fc2">DartPad 中的此範例應用程式</a> 中查看，DartPad 是用於 Dart 和 Flutter 片段的免費開源線上編輯器，現在使用 Flutter 建立。請在 <a href="https://github.com/google/generative-ai-dart/issues/new/choose">generative-ai-dart GitHub 儲存庫</a> 中報告任何問題，或告訴我們有關功能要求。</p>
<p><strong>Google AI Studio</strong></p>
<p>除了 SDK 之外，<a href="https://aistudio.google.com/?utm_source=flutter&utm_medium=referral&utm_campaign=blog_gaidartsdk_announcment&utm_content=">Google AI Studio</a> 是一個基於瀏覽器的 IDE，用於使用生成式模型進行原型設計。它讓您可以快速迭代以開發用例的提示，然後獲取 API 金鑰以在您的應用程式開發中使用。您可以使用您的 Google 帳戶登入 Google AI Studio，並利用免費配額，允許每分鐘 60 次請求。為了幫助我們提高產品品質，當您使用免費配額時，您的 Google AI Studio 輸入和輸出可能會被訓練有素的審閱者存取。這些資料會與您的 Google 帳戶和 API 金鑰脱钩。</p>
<p>我們將很快將 Dart 添加到 Google AI Studio，請密切關注我們的公告！這將讓您可以簡單地點擊「取得程式碼」，選擇新的 Dart 標籤（它將與現有支援的語言並列），然後「複製」Dart 程式碼以將您的工作傳輸到您選擇的 IDE。</p>
<figure>
<img alt="A screenshot of Google AI Studio" src="https://cdn-images-1.medium.com/max/1024/0*xhBJ20OLOQDtQ2xi" />
<figcaption>Google AI Studio</figcaption>
</figure>

<p><strong>分享您的成果！</strong></p>
<p>我們期待看到您使用 Gemini 建立的成果，例如 LeanCode 團隊使用 Gemini API 建立的 <a href="https://leancode.co/arb_translate">arb_translate</a>。它是一個套件，可以幫助開發人員自動執行語言翻譯，簡化 Flutter 應用程式中的本地化。</p>
<p>在 Twitter&#x2F;X 上使用標籤 #BuildWithGemini 告訴我們您正在建立什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=00573e560381" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/harness-the-gemini-api-in-your-dart-and-flutter-apps-00573e560381">在您的 Dart 和 Flutter 應用程式中利用 Gemini API</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/5afe0dbd.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/5afe0dbd.html" class="post-title-link" itemprop="url">【文章翻譯】Extreme UI Adaptability in Flutter — How Google Earth supports every use case on earth</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-02-07 17:09:33" itemprop="dateCreated datePublished" datetime="2024-02-07T17:09:33+08:00">2024-02-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Flutter極致UI適應性：Google-Earth如何支援地球上所有用例"><a href="#Flutter極致UI適應性：Google-Earth如何支援地球上所有用例" class="headerlink" title="Flutter極致UI適應性：Google Earth如何支援地球上所有用例"></a>Flutter極致UI適應性：Google Earth如何支援地球上所有用例</h2><p>當Google Earth準備以Flutter重寫其行動和網頁客戶端時，他們知道他們希望讓所有使用者都能以他們喜歡的方式探索地球，無論他們使用的是哪種設備。這在一定程度上一直是他們的目標；畢竟Google Earth已經擁有現有的網頁、桌面、Android和iOS客戶端。但這次重寫，將涵蓋除了桌面之外的所有目標，需要支援現有用例的超集；再加上Earth團隊渴望探索的一些新的適應性想法。</p>
<p>Google Earth未來技術堆栈的搜尋，受到了他們現有客戶端發展速度緩慢的摩擦來源的嚴重影響。也就是說，Google Earth很早就被迫在開發新功能的速度，以及在三個獨特的程式碼庫（網頁、Android和iOS）中維持功能一致性之間做出選擇。幸運的是，UI的中心——螢幕中央的整個淡藍色點——是由一個C++引擎驅動的，該引擎已經為Google Earth的一些功能提供了統一的體驗。然而，其餘的UI邊框和選單是在每個程式碼庫中單獨實現的。這意味著任何跨平台的選擇，不僅需要徹底改革UI開發流程，還需要與Android、iOS和網頁中的一個大型遺留引擎整合。</p>
<p>選擇使用Flutter的決定因素是雙重的。首先，使用方法通道與現有的Google Earth引擎整合證明是一項簡單的任務。其次，Google Earth不僅希望簡化他們的程式碼庫，還希望徹底重新設計他們的UI。任何重大的UI改版本身就是一種重寫，Google Earth選擇寫一個新的Flutter應用程式，而不是對三個現有應用程式進行手術。這使任務更加複雜，但團隊承諾要徹底改變，並專注於適應性。最後，Google Earth團隊使用Flutter來為三個平台提供UI。</p>
<h3 id="定義適應性"><a href="#定義適應性" class="headerlink" title="定義適應性"></a>定義適應性</h3><p>於是，Google Earth團隊踏上了一段旅程，致力於突破UI適應性的極限。在創造符合不同使用者流程的UI方面，先前的經驗比比皆是——回溯到智慧型手機的黎明時期，以及整個網路集體意識到大多數網站都需要針對小螢幕重新設計。瀏覽器API和CSS模式出現了，以構建能夠感知螢幕解析度的網站；這些想法從那以後一直很突出。甚至在Flutter的最早期，開發人員都知道手機螢幕會有所不同，並讓他們應用程式的UI依賴於螢幕的解析度。如果解析度發生變化——無論是使用者旋轉手機還是調整瀏覽器視窗的大小，應用程式的UI都會做出反應。在Flutter中，就像在它之前的網頁中一樣，<strong>響應式UI</strong> 改善了使用者體驗。</p>
<p>那麼，您可能會好奇，響應式UI和適應性UI之間有什麼區別？簡而言之，響應式UI會根據可用像素的數量和長寬比調整；而適應性UI則會根據所有其他因素進行調整。響應式UI可以根據螢幕空間詳細資訊調整個別UI元素的大小，但適應性UI會回答更根本的問題，例如在哪裡渲染應用程式的導航、列表視圖是否應該導航到單獨的詳細視圖，還是與列表本身並排顯示，以及使用者連接的周邊設備如何影響點擊目標和懸停狀態等因素（稍後將詳細介紹此概念）。</p>
<blockquote>若要進一步了解，請觀看 [Decoding Flutter 的第 15 集](https://youtu.be/HD5gYnspYzk?si=8AvuBRGXNRNET9dR) 關於適應性與響應式UI，並查看來自 [Flutter](https://docs.flutter.dev/ui/layout/responsive/building-adaptive-apps) 和 [Android 文件](https://developer.android.com/develop/ui/views/layout/responsive-adaptive-design-with-views)的這些指南。</blockquote>

<p>任何曾經為網站撰寫響應式CSS的人都會告訴您，即使是最簡單的UI也可能帶有棘手的邊緣情況。明確地說，這不是CSS的錯；問題空間的許多狀態都非常細緻，幾乎感覺像模擬的。那麼，在考慮幾個額外的變數（例如設備形式因素和連接的周邊設備）時，UI開發人員應該期待什麼？當然，他們應該期待複雜性適當增加。</p>
<p>當一個早期原型表現出意外的行為時，這一切就都集中起來了。在玩那個早期版本時，一位Google Earth工程師將他們的桌面網頁瀏覽器縮小到一個非常窄的寬度。突然之間，常見的桌面功能（例如側邊導航欄和較小的點擊目標）被行動功能所取代，例如底部導航欄和更大、更適合手指的按鈕。他們的驚訝是短暫的——畢竟，<em>這正是他們告訴他們的應用程式要做的</em>。Google Earth團隊現在面臨一個深刻的問題——<em>這是一個使用者想要的嗎？</em></p>
<p>這正是Google Earth團隊即將探索的未知領域。</p>
<h3 id="為什麼要適應性？"><a href="#為什麼要適應性？" class="headerlink" title="為什麼要適應性？"></a>為什麼要適應性？</h3><p>對某些人來說，以下內容提出了一個元問題：<em>為什麼要費盡心思做這些事情？當響應式UI肯定能滿足大多數使用者時，投資報酬率是否足夠？</em></p>
<p>這些都是好問題，但它們不應該導致對Flutter猶豫不決。使用像Flutter這樣的跨平台UI框架並不會<em>引入</em>適應性UI問題；它<em>解鎖了適應性UI解決方案</em>。除此之外，以下兩個因素表明適應性UI確實非常重要：</p>
<ul>
<li>螢幕解析度不再像以前那樣有意義。桌面瀏覽器可能具有低DPI設定，而基本的斷點檢查會將其與行動環境混淆；橫向模式下的高DPI手機可能會被誤認為是舊的平板電腦（甚至桌面！）斷點；而可摺疊設備可以交替顯示您的應用程式全螢幕，以及在多個應用程式之間分割螢幕空間，如果這導致使用者在某些斷點之間來回切換，就會導致令人不快的差異。</li>
<li>帶有明顯創建與使用模式的應用程式（想想任何具有閱讀和編輯體驗的文字編寫應用程式）在行動裝置上可能會嚴重受到影響——特別是在平板電腦上。將以行動裝置為中心的體驗（可能以使用為中心）發佈到智慧型手機和平板電腦上，極大地限制了具有平板電腦、藍牙鍵盤和滑鼠的強大使用者。</li>
</ul>
<h3 id="實現適應性"><a href="#實現適應性" class="headerlink" title="實現適應性"></a>實現適應性</h3><p>Google Earth團隊經歷了漫長的實驗、使用者研究和迭代過程，才完成了最終發佈的應用程式。但最終，他們的問題空間歸結為三個高級問題：</p>
<ol>
<li>應用程式如何確定其初始UI策略？</li>
<li>應用程式如何以及何時應更改其UI策略？</li>
<li>Google Earth團隊如何清晰地實作此邏輯？</li>
</ol>
<h3 id="確定初始UI策略"><a href="#確定初始UI策略" class="headerlink" title="確定初始UI策略"></a>確定初始UI策略</h3><p>Earth團隊的早期假設之一是「具有觸控螢幕的Chromebook與具有連接藍牙鍵盤的平板電腦之間沒有區別」，並且他們的UI不應該區分這兩種設備。雖然這個想法最初是有道理的，但它在測試中沒有存活下來；隨著時間的推移，Earth團隊越來越意識到這種方法的不足之處。以橫向模式啟動應用程式的使用者，可能會發現自己處於桌面UI的像素解析度範圍內（遵循舊的響應式UI規則）。如果同一位使用者隨後將他們的平板電腦旋轉成縱向模式，並因此轉移到分配給平板電腦的像素解析度範圍，Google Earth將面臨一個艱難的選擇。動態選項將是透過從桌面UI轉換到行動UI來大幅重組所有內容；而靜態選項將是除了將桌面UI壓縮和壓縮，直到它適合新的約束條件之外，什麼都不做。這兩種選項都不令人滿意，這意味著<em>具有觸控螢幕的Chromebook和具有鍵盤的平板電腦之間</em>確實有差異。</p>
<p>最終，Earth團隊設定了一個簡單的規則：為智慧型手機和平板電腦提供行動體驗，為桌面提供桌面體驗。如果這看起來很平淡無奇，那麼，它確實是；但這僅僅是因為它將一些有趣的部分推遲到了下一個問題——<em>UI的初始策略何時應該</em> <strong>更改？</strong></p>
<h3 id="在使用者會話中更新UI策略"><a href="#在使用者會話中更新UI策略" class="headerlink" title="在使用者會話中更新UI策略"></a>在使用者會話中更新UI策略</h3><p>Earth團隊的UI更改的第一個策略，僅僅是已建立的響應式UI規則：在任何低於最低門檻值的解析度上顯示您的行動UI，在接下來的幾百種可能的寬度上顯示您的平板UI（如果您有），最後，在任何其他解析度上顯示您的桌面UI。而且，至關重要的是，當UI由於任何原因跨越了其中一個門檻值時，您會相應地重新渲染應用程式。當然，這個規則集的笨拙讓Google Earth開始了它的極致適應性之旅；因此，團隊放棄這種方法也就不足為奇了。</p>
<p>第二種可能性來自Stadia，一個具有成功的Flutter行動應用程式的Google團隊。（顯然，Stadia作為一種產品沒有存活下來；但这并非因为其行動應用程式缺乏功能！）Stadia的方法是根據最後觸摸的輸入來做出適應性UI決定。拖動電腦游標或按下鍵盤，Stadia就會切換到桌面UI模式。相反，如果您傾斜連接的主機控制器上的搖桿，Stadia就會切換到主機UI模式。但是，雖然這對Stadia來說有道理，但它被證明對Google Earth來說不太合適。一個簡單的案例排除了這種最後觸摸輸入策略：一個平板電腦使用者縮放地圖，然後回到藍牙鍵盤完成輸入內容。沒有使用者會希望在這種簡單的互動過程中發生兩次劇烈的UI轉換，因此使用者的最新輸入不能將Google Earth的UI從行動裝置切換到桌面或反之。</p>
<p>最終，Google Earth團隊設定了第二個非常簡單的規則：在一個會話中保持一致，並且在沒有使用者明確許可的情況下，絕不離開初始UI風格。如前所述，Google Earth會在智慧型手機和平板電腦上顯示其以行動裝置為中心的UI，在桌面電腦上顯示其以桌面為中心的UI；並且它絕不會自作聰明地更改此設定，除非使用者在設定面板中請求更改。</p>
<h3 id="混合式UI狀態"><a href="#混合式UI狀態" class="headerlink" title="混合式UI狀態"></a>混合式UI狀態</h3><p>在會話中保持UI一致對Google Earth很有幫助，但這並不是全部。桌面體驗中的UI功能（例如游標懸停效果）在行動裝置上沒有任何對應部分，必須重新設計。將觸控螢幕筆電當作平板電腦使用的使用者，可能會因應用程式未能將重要的懸停效果替換為適合行動裝置的替代方案而完全被阻擋。這種認識表明了一個兩層次的問題和解決方案。Google Earth的UI不僅需要在使用者請求時在行動和桌面體驗之間平滑地切換，而且個別控制項需要同時具有觸控友好的形式<em>和</em>滑鼠友好的形式，無論整體策略如何。</p>
<p>最後，Google Earth知道他們在建立什麼。他們的所有研究和迭代只留下實作問題，這些問題歸結為：</p>
<ol>
<li>如何管理兩個根本不同的UI之間的轉換，以及</li>
<li>如何建立支援非典型周邊設備的個別控制項</li>
</ol>
<h3 id="管理多個UI"><a href="#管理多個UI" class="headerlink" title="管理多個UI"></a>管理多個UI</h3><p>簡單來說，建立任何可以在兩個不同體驗之間無縫切換的Flutter應用程式，就像在Widget的<code>build</code>方法中的某處放置以下程式碼一樣簡單：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child: mode == Mode.desktop ? DesktopUI() : MobileUI()</span><br></pre></td></tr></table></figure>

<p>但是，這種策略（Google Earth使用的策略）意味著在其他地方需要做一些額外的工作才能完全實現。問題——最初是隱藏的——當<em>任何</em>應用程式狀態儲存在Stateful Widget中時就會浮出水面，因為切換<code>mode</code>變數會完全替換Widget樹，破壞所有狀態物件及其所持有的任何資訊。這個問題分為兩個層次。</p>
<p>要想像第一層，請考慮一個在桌面電腦上有多個面板的螢幕，但在行動裝置上將這些面板重新組織成一個標籤欄體驗。行動裝置使用者將有一個活動標籤，但這個概念在桌面電腦上沒有對應部分。將活動標籤索引儲存在StatefulWidget中（這是Flutter中的慣用方式！），會在透過桌面UI來回切換後，始終將行動裝置使用者的位置重置為預設標籤。解決這個問題的方法是將任何原始應用程式狀態——字串、整數等等——從StatefulWidget中移到您的狀態管理類別中。這樣一來，Widget樹中的任何惡作劇都不能重置關鍵的數值。</p>
<p>問題的第二層來自應用程式狀態，這些狀態很難從Widget樹中提取出來，例如TextEditingController或ScrollController。情況看起來像這樣：您有一個帶有TextField的ListTile，但每次使用者觸摸他們的滑鼠或觸控螢幕時，您都會重新建立該ListTile以適應使用者的最新周邊設備。如果沒有干預，這會導致Flutter破壞包含舊TextField的Widget和Element樹的整個部分，並將任何持有使用者工作的控制器一起帶走。您可能會想將這些視為原始資料（TextEditingController作為字串和ScrollController作為雙精度數），並重複上述解決方案；但控制器太豐富了，無法以這種方式輕鬆序列化（游標位置和文字選擇，誰知道呢？）。</p>
<p>為了解決這個問題，Google Earth使用GlobalKeys來讓框架在重新佈局後「重新為高度限定範圍的Widget指定父元素」。下面的<code>AdaptableTextInput</code> Widget嚴格限定在它的TextField和TextEditingController中。在UI更改重新建立過程中為<code>AdaptableTextInput</code> Widget提供相同的GlobalKey，將使TextEditingController保持有效，從而儲存使用者的工作。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdaptableTextInput</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在這裡提供一個一致的 GlobalKey！</span></span><br><span class="line">  <span class="keyword">const</span> AdaptableTextInput(&#123;<span class="keyword">super</span>.key, <span class="keyword">required</span> <span class="keyword">this</span>.mode&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Mode mode;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  State&lt;AdaptableTextInput&gt; createState() =&gt; _AdaptableTextInputState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AdaptableTextInputState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AdaptableTextInput</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _controller = TextEditingController();</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> helpText = <span class="string">&#x27;我說明這個文字輸入！&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">if</span> (widget.mode == Mode.desktop) &#123;</span><br><span class="line">      <span class="keyword">return</span> Tooltip(</span><br><span class="line">        showOnHover: helpText,</span><br><span class="line">        child: TextField(controller: _controller),</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (widget.mode == Mode.mobile) &#123;</span><br><span class="line">      <span class="keyword">return</span> Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          TextField(controller: _controller),</span><br><span class="line">          Text(helpText);</span><br><span class="line">        ],</span><br><span class="line">      );</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="導航"><a href="#導航" class="headerlink" title="導航"></a>導航</h3><p>導航堆栈和應用程式的返回按鈕也需要特別注意。繼續以上面的桌面UI的例子來說，該UI一次顯示多個面板，現在想像一個互補的行動UI，它以堆栈式UI呈現這些面板，並具有向前和向後導航。允許桌面使用行動UI，以及手機使用桌面UI，是Google Earth想要追求的重要適應性理念之一。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*nHhbCY1mlIwlvQI60jaJHA.png" />
<figcaption>UI的網格，顯示桌面設備上的桌面UI和行動裝置UI，以及行動裝置上的桌面UI和行動裝置UI</figcaption>
</figure>

<p>如果桌面UI使用者在切換到行動UI時位於紅色面板上，返回按鈕將不會自動連接，因為導航堆栈將被重置。這意味著您的桌面UI需要考慮額外的技術資訊，這些資訊僅供行動UI使用，因為行動UI隨時可能被要求接管。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*RXf-GaJ4uz5_ZKU8QgIVkw.png" />
<figcaption>一個桌面設備以兩種不同的模式渲染相同的UI——一種是典型的桌面模式，一種是典型的行動裝置模式</figcaption>
</figure>

<p>幸運的是，GoRouter 的宣告式路由 API 可以提供幫助。建立兩個單獨的路由宣告，並在使用者切換UI模式時切換到適當的路由。在這種情況下，如果桌面UI在收到啟動行動UI的請求時，已將使用者的最後活動追蹤到紅色面板，則呼叫<code>mobileRouter.go(&#39;home/blue/red&#39;)</code>將建立一個帶有合成歷史的導航堆栈，允許使用者按下返回按鈕退出紅色螢幕。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> desktopRouter = GoRouter(</span><br><span class="line">  routes: [</span><br><span class="line">    GoRoute(</span><br><span class="line">      path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      builder: (context, state) =&gt; FourPanels(),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> mobileRouter = GoRouter(</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 每个面板一个路由，配置为连接返回按钮</span></span><br><span class="line">    <span class="comment">// 如果用户到达其中一个嵌  入面板</span></span><br><span class="line">    GoRoute(</span><br><span class="line">      path: <span class="string">&#x27;/home/blue&#x27;</span>,</span><br><span class="line">      builder: (context, state) =&gt; BluePanel(),</span><br><span class="line">      routes: [</span><br><span class="line">        GoRoute(</span><br><span class="line">          path: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">          builder: (context, state) =&gt; RedPanel(),</span><br><span class="line">          routes: [</span><br><span class="line">            GoRoute(</span><br><span class="line">              path: <span class="string">&#x27;green&#x27;</span>,</span><br><span class="line">              builder: (context, state) =&gt; GreenPanel(),</span><br><span class="line">              routes: [</span><br><span class="line">                GoRoute(</span><br><span class="line">                  path: <span class="string">&#x27;yellow&#x27;</span>,</span><br><span class="line">                  builder: (context, state) =&gt; YellowPanel(),</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>像Google Earth這樣的適應性很強的UI需要一種實作，將所有可能的情況視為始終處於活動狀態，即使只渲染了特定的UI。這意味著應用程式必須始終能夠從您完全控制的資源中<em>完全</em>重建其狀態——無論是您是否有GlobalKeys來保留持有重要資訊的狀態物件，還是您已將所有相關詳細資訊儲存在狀態管理類別中。</p>
<h3 id="適應使用者輸入"><a href="#適應使用者輸入" class="headerlink" title="適應使用者輸入"></a>適應使用者輸入</h3><p>這只留下了一個棘手的適應性問題：確保UI中的控制項能够适应使用者的最后使用的外围设备，而不仅仅是当前有效的UI策略。毕竟，如果一个平板电脑用户开始点击蓝牙鼠标; Google Earth不会将UI整体切换到桌面模式，但他们确实想要稍微调整一些元素，以利用键盘和鼠标的优势。</p>
<p>仅仅使用Flutter意味着Google Earth在这方面已经取得了良好的开端。想象一下另一种情况：一个应用程序跨越三个代码库（JavaScript用于通过网页访问桌面，Swift和Kotlin用于移动设备），当Swift和Kotlin团队意识到如果<em>在某些情况下</em>，他们可以从JavaScript应用程序的UI中借用元素，那就太好了。也许他们需要的可以被简单地重新实现; 也许不行。无论哪种方式; 在一个Flutter应用程序中，您想要借用的现有工具始终位于同一个代码库中。</p>
<p>但是代码共享不是代码组织，如何连贯地实现这个问题仍然存在。在这里，Google Earth团队转向了一个老的Flutter主打工具：构建器模式。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">用户输入的高级类别。</span></span></span><br><span class="line"><span class="keyword">enum</span> InputType &#123; gamepad, keyboardAndMouse, touch &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">构建一个依赖于用户当前[InputType]的widget树。</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputTypeBuilder</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">当[InputType]数据更新时调用。</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Function</span>(BuildContext, InputTypeModel, Widget?) builder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">构建一个包装widget，只要[InputType]</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">改变就会调用[builder]。</span></span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">有关如何更改[InputType]的详细信息，请参见[InputTypeModel]。</span></span></span><br><span class="line">  <span class="keyword">const</span> InputTypeBuilder(&#123;</span><br><span class="line">    Key? key,</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">this</span>.builder,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Consumer&lt;InputTypeModel&gt;(</span><br><span class="line">      builder: (context, inputTypeModel, _) &#123;</span><br><span class="line">        <span class="keyword">return</span> builder(</span><br><span class="line">          context,</span><br><span class="line">          inputTypeModel.inputType,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像<code>InputTypeBuilder</code>这样的Widget会监听一个顶层机制，即<code>InputTypeModel</code>，它本身会订阅Flutter引擎以接收有关最后使用的输入的更新。<code>InputTypeModel.inputType</code>是<code>InputType</code>枚举的属性。有了它，子Widget就可以根据用户当前与应用程序的交互方式做出本地化决策，决定如何渲染自身。例如，如果您一直在使用鼠标，但随后用手指点击了触摸屏，以前只有在鼠标悬停时才会出现的可视提示现在会在整个应用程序中显示。同样地，如果您切换回使用鼠标，这个<code>InputTypeBuilder</code>将允许他们撤销更改。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> InputTypeBuilder(</span><br><span class="line">    builder: (context, inputTypeModel, child) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">bool</span> isHoveredOrTouchInput = isHovered || inputTypeModel.inputType == InputType.touch;</span><br><span class="line">      <span class="keyword">return</span> Row(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          isHoveredOrTouchInput ? DragIndicator() : Container(),</span><br><span class="line">          RestOfRow(),</span><br><span class="line">        ],</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下GIF显示了Google Earth 的桌面UI（在Chrome中运行），巧妙地适应了用户在触摸屏和鼠标操作之间切换的操作。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/810/1*7hP0qPviv5Hrh7U82WWhQg.gif" />
<figcaption>Google Earth 的 UI 在最终用户与不同的外围设备交互时，在典型的桌面和移动可视提示之间切换</figcaption>
</figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>使用Flutter重新构建Google Earth带来的最大的意外收获，来自平板电脑和网页等中间环境的使用者。这些设备夹在手机和平板电脑之间，可以在物理上支持两种类型的体验，但很少享有与之匹配的软件灵活性。同样地，网页体验可以在任何设备上加载；在桌面电脑上，浏览器可以任意调整大小。根据应用程序的不同，所有这些都可能意味着截然不同的UI。对于大多数将每个构建目标的代码库分开的开发团队来说，完全支持身处这些中间状态的使用者是不可能的。（想象一下说服你的老板花时间在行动装置上重建你的整个桌面UI，仅仅因为平板电脑使用者想要它！）</p>
<p>但是，正如Google Earth团队所发现的，虽然在一个代码库中构建完全適應性的 UI确实意味着額外的複雜性，但它被满足所有使用者需求所獲得的使用者體驗改進所抵消。</p>
<p>您今天就可以嘗試Google Earth的新Flutter實作，方法是在Android或iOS上下载應用程式，或访问 <a href="https://earth.google.com/">https://earth.google.com</a>。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=6db4661e7a17" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/extreme-ui-adaptability-in-flutter-how-google-earth-supports-every-use-case-on-earth-6db4661e7a17">Flutter極致UI適應性：Google Earth如何支援地球上所有用例</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/47d3587.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/47d3587.html" class="post-title-link" itemprop="url">【文章翻譯】Progress of the Flutter Package Ecosystem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-22 20:05:00" itemprop="dateCreated datePublished" datetime="2024-01-22T20:05:00+08:00">2024-01-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Flutter-和-Dart-套件生態系統的進展"><a href="#Flutter-和-Dart-套件生態系統的進展" class="headerlink" title="Flutter 和 Dart 套件生態系統的進展"></a>Flutter 和 Dart 套件生態系統的進展</h2><p>Flutter 和 Dart 套件生態系統仍然是開發人員從單一程式碼庫為任何螢幕構建美麗、高效能應用程式的關鍵推動因素。該生態系統在 2023 年成長了 26%，從 1 月份的 38,000 個套件增加到 12 月份的 48,000 個。</p>
<figure>
<img alt="Line chart depicting the growth in number of packages on pub.dev in 2023" src="https://cdn-images-1.medium.com/max/1024/0*tkq_040X0xa_Noms" />
</figure>

<p>截至 2024 年 1 月，Pub.dev 擁有超過 700,000 名月活躍使用者。Flutter 團隊仍然熱衷並致力於支持這種未來發展，並使開發人員能夠使用和貢獻 Flutter 和 Dart。在此更新中，我們將回顧最新的 Flutter Favorites、套件生態系統虛擬峰會的結果，並分享一些值得注意的更新和需要了解的事項。</p>
<h3 id="新的-Flutter-Favorites"><a href="#新的-Flutter-Favorites" class="headerlink" title="新的 Flutter Favorites"></a>新的 Flutter Favorites</h3><figure>
<img alt="Flutter Favorite logo" src="https://cdn-images-1.medium.com/max/150/0*gI42oCiw6spGZfOy" />
</figure>

<p><a href="https://docs.flutter.dev/packages-and-plugins/favorites">Flutter Favorites</a> 程式表彰並幫助開發人員發現最高品質的套件，供他們在應用程式中考慮使用。我們很高興宣布七個新的 Flutter Favorite 套件，它們已證明了卓越的品質、人氣和社群參與度，使它們成為 Flutter 開發人員的無價工具。讓我們深入了解每個套件：</p>
<ol>
<li><a href="https://pub.dev/packages/flame">flame</a>：一個適用於 Flutter 的高性能 2D 遊戲引擎。其直觀的 API 和豐富的功能集使其成為構建視覺上令人驚嘆且引人入勝的遊戲的理想選擇。查看 <a href="https://codelabs.developers.google.com/codelabs/flutter-flame-game">這個 Codelab</a> 以嘗試使用 flame 構建遊戲。</li>
<li><a href="https://pub.dev/packages/flutter_animate">flutter_animate</a>：使用這個強大的動畫函式庫讓您的 UI 動起來，它可以簡化複雜的動畫，並使所有 Flutter 開發人員都能使用它。其宣告式語法和豐富的文檔使建立流暢且富表現力的動畫變得輕而易舉。</li>
<li><a href="https://pub.dev/packages/riverpod">riverpod</a>：一個優雅的套件，提供一種功能強大且直觀的方法來管理應用程式狀態。其簡化的 API、性能、可擴展性和可測試性使其成為現代 Flutter 應用程式的引人注目的選擇。</li>
<li><a href="https://pub.dev/packages/video_player">video_player</a>：對於任何希望在其 Flutter 應用程式中整合影片播放的人來說，這都是必不可少的。它提供了一個 Widget 來顯示影片內容。它支援各種格式和來源，包括網路資源和基於檔案的影片。這使其成為構建富含多媒體的 Flutter 應用程式的多功能工具。</li>
<li><a href="https://pub.dev/packages/macos_ui">macos_ui</a>：對於以 macOS 為目標的開發人員來說，這個套件可以在該平台上創造出設計感覺恰如其分的應用程式。它提供了一套豐富的 Widget 和组件，這些 Widget 和组件的樣式符合 macOS 設計語言，確保您的 Flutter 應用程式不僅在 macOS 上運行良好，而且看起來和感覺都像原生應用程式。</li>
<li><a href="https://pub.dev/packages/fpdart">fpdart</a>：這個套件在 Dart 中啟用函數式編程。它非常適合實現商業邏輯，例如，在函數式編程範式（如不可變性、純函數和高階函數）以及 fpdart 對 Dart 類型系統的使用方面，它有助於構建更易於維護和可預測的程式碼。</li>
<li><a href="https://pub.dev/packages/flutter_rust_bridge">flutter_rust_bridge</a>：對於希望在應用程式中利用 Rust 和 Flutter 最佳功能的開發人員來說，flutter_rust_bridge 在兩個世界之間提供了一個無縫的橋樑。它使原生 Rust 程式碼能夠與 Flutter 無縫交互，解鎖 Rust 性能和記憶體安全性在 Flutter 應用程式中的潛力。</li>
</ol>
<h3 id="終止-Happy-Paths-程式"><a href="#終止-Happy-Paths-程式" class="headerlink" title="終止 Happy Paths 程式"></a>終止 Happy Paths 程式</h3><p>我們決定終止 Happy Paths 程式，以便專注於 Flutter Favorites。Happy Paths 建議的願景是幫助您做出明智的決定，以便找到和使用套件來為您的應用程式添加功能。我們很幸運有像 <a href="https://fluttergems.dev/">Flutter Gems</a> 這樣的社群倡議，它們是導航分類良好的套件選項的綜合資源。隨著我們專注於 Flutter Favorites 程式，我們將繼續在 Flutter 和 Dart 社群的意見和回饋的基礎上對其進行改進。</p>
<h3 id="套件生態系統虛擬峰會"><a href="#套件生態系統虛擬峰會" class="headerlink" title="套件生態系統虛擬峰會"></a>套件生態系統虛擬峰會</h3><figure>
<img alt="The Flutter and Dart Ecosystem Virtual Summit 2023 landing page" src="https://cdn-images-1.medium.com/max/1024/0*NzfQsOUhVaeUcGB8" />
</figure>

<p>在 2023 年 8 月底，我們為 Flutter 和 Dart 套件生態系統舉辦了首次 <a href="https://rsvp.withgoogle.com/events/flutter-package-ecosystem-summit-2023">虛擬峰會</a>，超過 50 位非 Google 和 Google 貢獻者參加了 <a href="https://pub.dev/">pub.dev</a>。我們最初的邀請名單相對較小，以適合 unconference-style 的格式，並在弄清楚未來可能呈現的樣子之前，從這次首次活動中學習。目的是將貢獻者聚集在一起，進行 unconference-style 的討論，以便在社群中進行規劃、教育、學習和分享。我們進行了三個討論會，每個討論的主題都是由註冊參加者在峰會開始前的幾週中投票決定的。三個討論主題是：1）構建高品質套件——最佳實踐和挑戰，2）長期維護套件——可持續模式，以及 3）Flutter 和 Dart DevTools 擴展。對活動後調查的回覆為我們提供了寶貴的回饋，我們將在未來的活動規劃中將這些回饋納入其中。謝謝您！總體而言，我們認為這次首次峰會取得了成功。展望未來，我們渴望與社群合作舉辦類似的獨立活動，或者將焦點放在 Flutter 和 Dart 生態系統上的議程，並將其設定在更通用的活動中。</p>
<h3 id="對-Pigeon-套件的更新"><a href="#對-Pigeon-套件的更新" class="headerlink" title="對 Pigeon 套件的更新"></a>對 Pigeon 套件的更新</h3><p><a href="https://pub.dev/packages/pigeon">Pigeon 套件</a> 是一個程式碼生成工具，它簡化了 Flutter 應用程式與平台特定程式碼之間通信的設定過程。這使得 Pigeon 在以下兩種情況下都很有用：1）在直接撰寫 Flutter 應用程式與平台原生 API 之間的自定義整合時，例如在 <a href="https://docs.flutter.dev/add-to-app">add-to-app</a> 情況下，以及 2）在撰寫 <a href="https://docs.flutter.dev/packages-and-plugins/developing-packages#types">Flutter Plugin</a> 以為平台原生 API 提供 Dart API 表面時。它由 Flutter 團隊維護，該團隊在今年對該套件進行了以下值得注意的改進：</p>
<ul>
<li>加入對 Swift、Kotlin 和 C++ 的支援（C++ 解鎖 Windows 支援）。</li>
<li>現在強制執行空安全。</li>
<li>擴展對原始數據類型支持的支持。例如，枚舉被加入為支援的類型。</li>
<li>加入可空參數。</li>
<li>在主機和 Flutter API 上加入錯誤處理。</li>
<li>改進了工具的人體工程學，使其更易於使用和更直觀。例如，我們加入了對預設參數和命名參數的支持。</li>
</ul>
<p>在 1 月份的 v5.0.0 和 12 月份的 v15.0.2 之間，還有很多我們無法在此處列出的開發工作，因此請查看 <a href="https://pub.dev/packages/pigeon/changelog">變更日誌</a> 中的所有變更！</p>
<h3 id="DartPad-中的套件"><a href="#DartPad-中的套件" class="headerlink" title="DartPad 中的套件"></a>DartPad 中的套件</h3><p><a href="https://dartpad.dev/">DartPad</a> 支援一組固定的套件，您可以透過點擊螢幕右下角的資訊圖示來查看這些套件。Google 的 Flutter 和 Dart 團隊會持續審查和優先處理套件請求。如果您希望將套件加入到 DartPad，請為 <a href="https://github.com/dart-lang/dart-pad/issues?q=is:issue+is:open+label:suggested-package+sort:reactions-+1-desc">現有套件建議</a> 點擊赞成（如果有），或者 <a href="https://github.com/dart-lang/dart-pad/issues/new?assignees=&amp;labels=&amp;projects=&amp;template=everything-else.md&amp;title=%22">開啟一個新的議題</a> 提出您的建議。</p>
<figure>
<img alt="Screenshot of packages on Dartpad.dev" src="https://cdn-images-1.medium.com/max/1024/0*U2blC-2k01FIuCsZ" />
</figure>

<h3 id="建議在-pub-dev-上使用規範主題"><a href="#建議在-pub-dev-上使用規範主題" class="headerlink" title="建議在 pub.dev 上使用規範主題"></a>建議在 pub.dev 上使用規範主題</h3><p>在 2023 年，我們推出了讓套件作者能夠在 pubspec 檔案中使用 1-5 個自由文本主題為其套件加標籤的功能。目標是透過加入一種套件分類方式來改善潛在使用者發現套件的體驗。我們看到這個功能取得了良好的效果，許多套件都進行了標籤化。我們正在探討一個提案，透過合併實際上相同的主题來改進這個功能（例如，widget 和 widgets）。我們邀請社群對此 <a href="https://github.com/dart-lang/pub-dev/issues/7263">規範主题議題</a> 分享回饋或貢獻 PR。</p>
<figure>
<img alt="An example of Topics on a package on pub.dev" src="https://cdn-images-1.medium.com/max/1024/0*BhBIcosj4JSij9xk" />
</figure>

<p>目前就這些了！若要與優秀的套件作者社群互動，請查看 <a href="https://discord.com/channels/608014603317936148/1014208569706561567">Discord 頻道 #package-authors</a>（您首先需要加入 <a href="https://github.com/flutter/flutter/wiki/Chat">Flutter Discord 伺服器</a>）。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=17cded9a0703" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/progress-of-the-flutter-package-ecosystem-17cded9a0703">Flutter 套件生態系統的進展</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/c67f4a32.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/c67f4a32.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing the</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-01-09 19:46:22" itemprop="dateCreated datePublished" datetime="2024-01-09T19:46:22+08:00">2024-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h3 id="構建史詩級的-Flutter-遊戲，協助保衛地球"><a href="#構建史詩級的-Flutter-遊戲，協助保衛地球" class="headerlink" title="構建史詩級的 Flutter 遊戲，協助保衛地球"></a>構建史詩級的 Flutter 遊戲，協助保衛地球</h3><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*e6DUZrDIvURyxTW2" />
</figure>

<p>我們知道 Flutter 開發人員喜歡挑戰，因此，適逢新年到來之際，我們很興奮地宣布下一場 Flutter 挑戰！</p>
<p><a href="http://flutter.dev/global-gamers">全球玩家挑戰</a> 是一場為期 8 週的比賽，由 Flutter 和 <a href="https://www.globalcitizen.org/en/">Global Citizen</a> 贊助，旨在設計、構建和發佈可持續的遊戲。比賽的獲獎者將獲得在 2024 年 9 月前往紐約市的機會，與 Flutter 團隊會面，進行一天的研討會和指導，然後在 2024 年的 Global Citizen Festival 上與多達 60,000 位其他 Global Citizen 共同慶祝他們的成就。</p>
<h3 id="什麼是可持續的遊戲？"><a href="#什麼是可持續的遊戲？" class="headerlink" title="什麼是可持續的遊戲？"></a>什麼是可持續的遊戲？</h3><p>可持續的遊戲利用遊戲的力量來激勵積極的環境行動。想像一下 Candy Crush，但不是粉碎糖果，而是粉碎塑膠污染！或者，想像一下像 <a href="https://superdash.flutter.dev/">Super Dash</a> 這樣的遊戲，但不是收集橡子，而是你在 Dash 的家中想辦法透過優化使用窗戶而不是空調的氣流路徑來降溫。以下是一些受目前正在執行的 Global Citizen 活動啟發的更多想法：</p>
<ol>
<li><p><strong>鼓勵減少家庭能源使用</strong><br><br>資料顯示，美國家庭的平均用電量是全球其他典型家庭的三倍。您可以構建一個遊戲來幫助減少對低效率能源的依賴嗎？</p>
</li>
<li><p><strong>鼓勵減少使用一次性塑膠</strong><br><br>東南亞的塑膠污染水平居世界之首。考慮構建一個遊戲來鼓勵人們進行替換，例如選擇可重複使用的水瓶而不是一次性水瓶。</p>
</li>
<li><p><strong>鼓勵在短距離內使用公共運輸工具，在長距離內使用陸路運輸</strong><br><br>歐洲擁有世界上許多最好的公共運輸系統。有效的遊戲可以鼓勵人們在短距離內使用當地公共運輸，以及長距離內使用陸路運輸（例如火車而不是飛機）。</p>
</li>
</ol>
<p>我們相信遊戲可以鼓勵玩家採取一些小的、真實的行動，這些行動加起來對環境產生巨大的影響。事實上，<a href="https://www.globalcitizen.org/en/categories/defend-the-planet/">如果您想直接採取行動，請查看 Global Citizen 目前正在執行的活動</a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*BI7eVnRDmTOmFkaQ" />
</figure>

<h3 id="為什麼要加入全球玩家挑戰？"><a href="#為什麼要加入全球玩家挑戰？" class="headerlink" title="為什麼要加入全球玩家挑戰？"></a>為什麼要加入全球玩家挑戰？</h3><h3 id="保衛地球"><a href="#保衛地球" class="headerlink" title="保衛地球"></a>保衛地球</h3><p>此比賽的靈感來自 <a href="https://www.playing4theplanet.org/">Playing for the Planet 聯盟</a>，這是一個由聯合國促成的 50 個遊戲工作室和公司的聯盟，<a href="https://blog.google/around-the-globe/google-europe/sustainable-gaming-with-the-playing-for-the-planet-alliance/">包括 Google</a>，其使命是減少該行業的環境影響，並利用遊戲的力量來提高人們對氣候變化、生物多樣性喪失和污染等重要環境問題的認識，並協調行動。</p>
<p>Playing for the Planet 聯盟成員製作的遊戲總觸達人數超過 10 億人。透過聯盟的旗艦計畫 <a href="https://www.playing4theplanet.org/green-game-jam-2023">Green Game Jam</a>，參與的遊戲已透過籌款來種植 275 萬棵樹，並籌集了約 150 萬美元來保護野生動物和支持環境事業，創造了實際的影響。</p>
<p>我們已與 Playing for the Planet 聯盟合作，為環境遊戲來源 <a href="https://igda-website.s3.us-east-2.amazonaws.com/wp-content/uploads/2022/04/06100719/EnvironmentalGameDesignPlaybook_Alpha_Release_Adj.pdf">最佳實務</a>，並將它們加入到此挑戰中提供的資源包中。這是您構建有助於保護地球的事物的機會！</p>
<h3 id="學習新知識"><a href="#學習新知識" class="headerlink" title="學習新知識"></a>學習新知識</h3><p>無論您是 Flutter 開發人員，對遊戲很陌生，還是遊戲開發人員，對 Flutter 很陌生，或者您同時對遊戲開發和 Flutter 很陌生，在對世界產生積極影響的過程中，您一定會學到一些技巧。</p>
<h3 id="詳細資訊"><a href="#詳細資訊" class="headerlink" title="詳細資訊"></a>詳細資訊</h3><h3 id="時間表"><a href="#時間表" class="headerlink" title="時間表"></a>時間表</h3><p>所有專案必須在 2024 年 3 月 5 日下午 2:59 PT (GMT -8) 之前提交。前 20 名將於 2024 年 3 月下旬公布，最終獲獎者將於 2024 年 5 月公布。</p>
<h3 id="提交指南"><a href="#提交指南" class="headerlink" title="提交指南"></a>提交指南</h3><p>註冊和提交條目說明可在 <a href="http://globalgamers.devpost.com/">DevPost</a> 找到。</p>
<h3 id="獎項"><a href="#獎項" class="headerlink" title="獎項"></a>獎項</h3><p>獲勝者將根據以下標準進行評估：</p>
<ul>
<li>原創性和創造力</li>
<li>可持續的行動和故事</li>
<li>動畫的使用</li>
<li>有效的多平台部署</li>
</ul>
<p>雖然我們不僅會獎勵出色的程式設計能力，但是我們也會為好點子、演示影片、遊戲的教育內容以及更多內容提供獎勵！</p>
<p><strong>資源</strong></p>
<p>我們編譯了一系列 <a href="http://flutter.dev/global-gamers/#resources">資源</a> 來幫助您構建遊戲，其中包括一個 <a href="http://flutter.dev/global-gamers/#guide">指南</a> 來引導您完成此挑戰，就像遊戲地圖一樣。它會向您展示您需要的資源，幫助您透過 Global Citizen 應用程式中的 <a href="https://glblctzn.co/hQ5oyPFbcGb">全新學習旅程</a> 成為 Global Citizen，並包含有關如何註冊和提交遊戲的說明。</p>
<h3 id="團隊"><a href="#團隊" class="headerlink" title="團隊"></a>團隊</h3><p>我們建議您以團隊的形式完成此挑戰。當您在 Devpost 上 <a href="http://globalgamers.devpost.com/">註冊參加挑戰</a> 時，您將能夠分享您的技能、團隊狀態和想法。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fJPnnrD19GKt6MiK" />
</figure>

<p>因此，無論您有很棒的想法，但需要技術技能的隊友來實現它，或者您擁有技術技能，但想要很棒的想法，請務必相應地填寫您的個人資料，然後瀏覽 <a href="https://globalgamers.devpost.com/participants">參與者標籤</a>，尋找個人資料詳細資訊與您尋找的內容相符的人！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*L51Psa66pNh99Rsd" />
</figure>

<p>我們對技術專家和活動家共同努力實現共同目標的想法特別感興趣。如果您需要額外的支援來尋找隊友，請閱讀這篇 <a href="https://help.devpost.com/hc/en-us/articles/360022031411-Participants-page-forming-a-team">幫助文章</a>。</p>
<p>最後，請注意，團隊可以是任何規模，但如果專案被選為決賽，每個團隊只有 3 人可以前往紐約市。</p>
<h3 id="開始並保持連線"><a href="#開始並保持連線" class="headerlink" title="開始並保持連線"></a>開始並保持連線</h3><p>在 <a href="https://flutter.dev/global-gamers">flutter.dev&#x2F;global-gamers</a> 的官方比賽網站上查看您需要了解的所有資訊。您也可以訪問 <a href="https://globalgamers.devpost.com/">DevPost</a> 進行註冊並提交您的遊戲。</p>
<p>提交截止日期為 3 月 5 日，所以不要猶豫！我們迫不及待想看看您將構建什麼！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2c5315c87898" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/announcing-the-globalgamers-challenge-2c5315c87898">宣布 #GlobalGamers 挑戰</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/cf245e26.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/cf245e26.html" class="post-title-link" itemprop="url">【文章翻譯】How we built it: Ask Dash — A generative AI Flutter application</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-12-13 18:36:03" itemprop="dateCreated datePublished" datetime="2023-12-13T18:36:03+08:00">2023-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 20:17:11" itemprop="dateModified" datetime="2024-09-30T20:17:11+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="如何打造：Ask-Dash-一款生成式-AI-Flutter-應用程式"><a href="#如何打造：Ask-Dash-一款生成式-AI-Flutter-應用程式" class="headerlink" title="如何打造：Ask Dash - 一款生成式 AI Flutter 應用程式"></a>如何打造：Ask Dash - 一款生成式 AI Flutter 應用程式</h2><p>作為 [Google Cloud 應用 AI 峰會](https://cloudonair.withgoogle.com/events/summit-applied-ml-summit-23?talk=t1_s5_vertexaisearchandconversation) 的一部分，Flutter 和 Vertex AI 團隊與 [Very Good Ventures](https://verygood.ventures/) 合作，使用 Google Cloud 的 [Vertex AI Search and Conversation](https://cloud.google.com/vertex-ai-search-and-conversation) 打造出了一款 AI 驅動的 Flutter 範例應用程式 [Ask Dash](https://github.com/VeryGoodOpenSource/dash_ai_search)。 Vertex AI Search and Conversation 使您能夠快速構建和部署搜尋和對話式應用程式，幾乎不需要任何 AI 經驗。 Flutter 是構建美觀、自訂搜尋體驗的絕佳方式，可以展示這兩款產品如何在短短幾週內共同構建強大的應用程式！</p>

<p>Vertex AI Search and Conversation 讓您能夠建立與您的資料互動的應用程式，這些應用程式會提供個人化的回應，展示生成式 AI 的強大功能。最重要的是，它讓您完全控制您的應用程式存取和索引的資料，以便您可以控制向哪些使用者顯示哪些資訊。所有應用程式資料和使用者互動都儲存在您自己的雲端實例中，從未使用於訓練 Google 的基礎機器學習模型。</p>

<p>由於我們使用 Flutter 打造了範例應用程式，因此我們決定使用 Flutter 文件作為訓練資料。我們與 Google Cloud 團隊合作，針對 Flutter 和 Dart 開發人員文件特別訓練了模型，以便為以下類型的問題提供生成式 AI 回應：Flutter 是什麼？它支援哪些平台？熱重載是什麼？雖然這些資料中的大部分在公開的 AI 模型中很容易獲得，但此範例展現了如何僅根據您自己的資料訓練模型，以建立強大的 AI 體驗。</p>

<p>本文將帶領您瞭解我們的合作夥伴 Very Good Ventures 如何打造 Flutter 網頁應用程式，以及我們如何在雲端主控台中連接應用程式。</p>

<h4>如何打造 Flutter 網頁應用程式</h4>

<p>建立基於 Flutter 文件訓練的搜尋應用程式的想法很簡單。事實上，[Flutter 的官方文件](https://docs.flutter.dev/) 已經提供了簡單的搜尋體驗，可以為有關 Flutter 的問題提供相關的頁面結果。但是，在構思要建立什麼時，我們希望展示 Flutter 如何用於建立視覺上吸引人的互動式體驗，這些體驗有趣且引人入勝。</p>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/777/0*92qfA1AlxG0HMJCE" />
</figure>

<p><strong>在 Flutter 中建立互動式動畫</strong></p>

<p>Flutter 使團隊能夠無縫地實作各種動畫。它豐富的動畫集，加上 Widget 的靈活性，讓我們能夠建立轉場、引人入勝的動作效果和流暢的使用者互動。從在生成結果時建立動畫載入狀態，到在答案出現時揮手的 Dash 精靈，Flutter 提供了靈活性，可以將基本的文字回應變成使用者可以互動的有趣內容。</p>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/933/0*0gsPB_1VlYop9DPL" />
</figure>

<p><strong>視覺化自然語言搜尋結果</strong></p>

<p>與傳統的搜尋體驗不同，Vertex AI Search 會針對提問提供自然語言回應。答案是使用從 Flutter 文件中多個頁面擷取的 AI 生成的，並以摘要回應的形式呈現，以及顯示 AI 使用的相關頁面的卡片。每張卡片都提供了頁面的標題和描述，以便使用者可以翻閱卡片以更深入地了解 AI 回應。</p>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1000/0*FapWwJ2wFpi8l9ZZ" />
</figure>

<p>此外，在自然語言回應中，Vertex AI Search 會提供一個連結，指向回應中每個句子的來源，讓使用者可以更深入地了解每個回應部分的來源。在範例中，點擊每個句子旁邊的數字就會翻轉卡片到相關的來源頁面。</p>

<p><strong>在更短的時間內更引人入勝</strong></p>

<p>在開始這個專案時，我們有一個很緊迫的時程表，要讓範例應用程式在 [Google Cloud 應用 AI 峰會](https://cloudonair.withgoogle.com/events/summit-applied-ml-summit-23?talk=t1_s5_vertexaisearchandconversation) 上發佈。Flutter 的高效開發和易於使用，大大加快了兩個開發人員團隊的開發過程。它提供了建立複雜動畫所需的工具和框架，使我們的團隊能夠在活動開始前的兩週內完成這個範例應用程式的打造和發佈。</p>

<h4>將 Flutter 應用程式連接到 Vertex API</h4>

<p>我們使用 [http 包](https://pub.dev/packages/http) 進行簡單的請求，將前端網頁應用程式與 Vertex AI Search API 整合。 Vertex AI Search 在無需任何預先建立 AI 經驗的情況下，會提供使用者生成的問答的 JSON 回應，這些回應會被解析並顯示在動畫 Widget 中。這讓團隊可以專注於 Flutter 開發，以從生成的資料中建立引人入勝的體驗。</p>

<h4>在您的應用程式中設定生成式 AI 搜尋</h4>

<p>設定 Vertex AI 並為我們的 Flutter 應用程式託管 API 也非常簡單。在我們的例子中，我們使用 [https://docs.flutter.dev/](https://docs.flutter.dev/) 作為我們的資料源，並直接在 Google Cloud 主控台中設定它。作為 Google Cloud 客戶，開始使用 Vertex AI 只需三個步驟：</p>

<ol>
<li><strong>建立資料儲存庫</strong></li>
</ol>

<p>這是您網站的數位資料庫，它儲存了您根據根 URL 生成 AI 模型所需的所有資訊。Google Cloud 會爬取您的網站以查找相關資料，並為您建立一個可以查詢的資料源。若要在 Google Cloud 主控台中設定此項目，請選取 **Search and Conversation**。選擇 **Data Stores**，然後選擇 **New Data Store**。選擇 **Website URL** 作為來源，並提供您網站的 URL。</p>

<p>2.<strong>存取您的資料</strong></p>

<p>接下來，在 Cloud 主控台中建立一個應用程式，以導航模型索引的資料，並將其連結到您先前建立的資料儲存庫。在 **Search and Conversation** 下，選擇 **Apps**，然後選擇 **New App**。選擇 **Search** 作為類型，並為您的應用程式提供一個反映其用途的名稱，例如 Ask Dash。</p>

<p>3.<strong>製作一個 Cloud 函式</strong></p>

<p>最後，建立一個 Cloud 函式。這是將 Vertex AI 資料公開給其他應用程式的 API 介面。在主控台中，前往 **Cloud Functions**，然後選擇 **Create Function**。</p>

<p>就是這樣！</p>

<p>從這裡，您可以像使用任何 API 一樣在前端應用程式中使用 API，傳送請求並接收應用程式可以顯示的格式化回應。若要測試它，請前往 **Function** 頁面，然後選擇 **Testing**。輸入一個 JSON 物件，其中包含用於提問的「search_term」金鑰（例如「hot reload」），然後查看包含自然語言摘要、相關引文和引用的頁面簡要摘要的詳細回應。</p>

<p>在 Google Cloud 的文件  中瞭解如何開始使用 [Vertex AI Search](https://cloud.google.com/generative-ai-app-builder/docs/try-enterprise-search)。</p>

<h4>在 Flutter 中打造的生成式 AI 應用程式</h4>

<p>若要查看 Ask Dash 的實際操作，並瞭解我們如何打造它，請查看 [Google Cloud 應用 AI 峰會](https://cloudonair.withgoogle.com/events/summit-applied-ml-summit-23?talk=t1_s5_vertexaisearchandconversation) 的影片議程，其中 Google Cloud 產品經理 Alan Blount 詳細介紹了打造過程，以展示 Vertex AI Search 在 Flutter 應用程式中的潛力。查看 [範例的開源 Flutter 程式碼](https://github.com/VeryGoodOpenSource/dash_ai_search)，並開始在 Google Cloud 主控台中體驗自己的 AI 搜尋體驗。</p>

<p>Ask Dash 僅是一個開始，展示了 Flutter 如何在應用程式中為互動式生成式 AI 體驗提供動力。我們迫不及待地想看看你將打造什麼！</p>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=79a836ced058" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/how-we-built-it-ask-dash-a-generative-ai-flutter-application-79a836ced058">如何打造：Ask Dash - 一款生成式 AI Flutter 應用程式</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/143a994c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/143a994c.html" class="post-title-link" itemprop="url">【文章翻譯】How we built the Super Dash demo in Flutter and Flame in just six weeks!</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-30 17:01:52" itemprop="dateCreated datePublished" datetime="2023-11-30T17:01:52+08:00">2023-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="了解我們如何用兩位開發人員在桌面瀏覽器、Android-和-iOS-上推出了-Super-Dash，一款多平台遊戲範例"><a href="#了解我們如何用兩位開發人員在桌面瀏覽器、Android-和-iOS-上推出了-Super-Dash，一款多平台遊戲範例" class="headerlink" title="了解我們如何用兩位開發人員在桌面瀏覽器、Android 和 iOS 上推出了 Super Dash，一款多平台遊戲範例"></a>了解我們如何用兩位開發人員在桌面瀏覽器、Android 和 iOS 上推出了 Super Dash，一款多平台遊戲範例</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*7Yf06e3HC80KZyZvfL9dZw.png" />
</figure>

<p>Super Dash 是一款使用 <a href="https://github.com/flutter/games/tree/main/templates/endless_runner">Endless Runner Flame Template</a> 建立的新 Flutter 範例遊戲，它隨最近更新的 Flutter <a href="https://medium.com/flutter/building-your-next-casual-game-with-flutter-716ef457e440">休閒遊戲工具包</a> 推出。</p>
<p>我們與 Google 的 Flutter 團隊合作，在短短六週內使用 Flutter 和 Flame 從想法到推出開發了一款適用於 Android、iOS 和 Web 的多平台遊戲。這款遊戲的靈感來自超級瑪利歐等懷舊經典，玩家可以在橫向捲軸平台遊戲中扮演 Dash，她會收集橡果和雞蛋以最大限度地提高分數，並逐級闖關。</p>
<p>這款遊戲可以在 <a href="https://superdash.flutter.dev/">桌面瀏覽器</a> 上玩，並可在 <a href="https://apps.apple.com/app/super-dash-flutter-game/id6473050393">Apple App Store</a> 和 <a href="https://play.google.com/store/apps/details?id=com.verygoodventures.super_dash">Google Play</a> 上使用行動裝置玩。這款遊戲的程式碼（包括行動平台）是開源的，可在 GitHub 上的 <a href="https://github.com/flutter/super_dash">super_dash</a> 儲存庫中取得。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/1*7q5jOLZfD5UNvaUNiSEbug.gif" />
</figure>

<h4 id="如何遊玩"><a href="#如何遊玩" class="headerlink" title="如何遊玩"></a>如何遊玩</h4><p>Dash 會在每一關中收集橡果（10 分）和雞蛋（1000 分）以提高分數。按下空格鍵或點選螢幕即可開始遊戲，並跳躍避開蟲子和掉進坑洞，以完成每一關。抓住金羽毛即可將 Dash 變身為鳳凰，增加她的跳躍高度，並讓她獲得額外一條生命。</p>
<h4 id="使用-Flutter-快速無縫地進行遊戲開發"><a href="#使用-Flutter-快速無縫地進行遊戲開發" class="headerlink" title="使用 Flutter 快速無縫地進行遊戲開發"></a>使用 Flutter 快速無縫地進行遊戲開發</h4><p>Flutter 使我們能夠在短短六週內，僅憑我們團隊中的兩位開發人員，將想法變成實際的遊戲。這個框架能夠透過熱重載功能快速迭代變更，加上平台的可組合性、模組化和可用工具，讓團隊能夠快速行動，並與設計團隊的合作成果一起快速測試和開發遊戲。</p>
<p>它還加快了團隊針對行動裝置建立響應式 UI 的速度，同時也鎖定瀏覽器和桌面。這讓我們能夠將更多開發時間投入到遊戲本身，並減少花在確保遊戲在不同設備和螢幕上運作的時間。</p>
<p>此外，Flutter 和 Dart 強大的 <a href="https://pub.dev/">套件生態系統</a> 以及與 Firebase 等 Google 服務的整合，讓我們能夠輕鬆找到工具，例如 <a href="https://pub.dev/packages/flutter_bloc">Flutter_Bloc</a>，它使我們能夠無縫建立遊戲邏輯和狀態管理。</p>
<h4 id="Flame-動力的-Flutter-冒險"><a href="#Flame-動力的-Flutter-冒險" class="headerlink" title="Flame 動力的 Flutter 冒險"></a>Flame 動力的 Flutter 冒險</h4><p>Super Dash 使用 <a href="https://flame-engine.org/">Flame</a>，一個用 Flutter 建立的開源遊戲引擎。雖然許多休閒遊戲可以使用 Flutter 單獨建立，但 Flame 擴展了 Flutter 的遊戲開發功能，適用於需要遊戲迴圈、碰撞和地圖的遊戲。</p>
<p>Super Dash 利用 <a href="https://github.com/kurtome/leap">Leap 專案</a> 擴展了在 <a href="https://flutter.dev/games">休閒遊戲工具包</a> 中可用的 Flame Template 的基本功能，這是一個由 <a href="https://github.com/kurtome">Kurtome</a>（Flame 社群成員）建立的開源專案。在使用 Leap 之前，您應該對 Flame 的 <a href="https://docs.flame-engine.org/1.3.0/flame/game.html#flamegame">FlameGame</a>、<a href="https://docs.flame-engine.org/1.3.0/flame/components.html#positioncomponent">PositionComponent</a>、<a href="https://docs.flame-engine.org/1.3.0/flame/components.html#tiledcomponent">TiledComponent</a> 和 <a href="https://docs.flame-engine.org/1.3.0/flame/camera_and_viewport.html#camera">Camera</a> 組件有基本的了解。</p>
<p>在儲存庫中，您會找到我們為除錯遊戲而建立的自訂工具，包括帶有各種動作和工具的 macOS 版本。我們加入了一個「傳送至終點」按鈕，讓 Dash 無需玩完全程就能直接到達終點畫面，以及另一個讓 Dash 不死的按鈕，讓您可以在不重新啟動的情況下玩完全程。您可以在 <a href="https://github.com/flutter/super_dash">super_dash 儲存庫</a> 中找到這個工具，並在建立或擴展遊戲時親自嘗試。</p>
<p>所有物理物件都有矩形碰撞盒，由物件的大小和位置定義，它們不必與物件的視覺外觀相同，這大大提高了可玩性。</p>
<p>團隊使用 <a href="https://firebase.google.com/docs/app-distribution">Firebase 分發</a> 輕鬆共享應用程式和遊戲的測試版本，特別是 iOS，因為 iOS 有時會很複雜。</p>
<h4 id="設計一個互動式的-Dash-世界"><a href="#設計一個互動式的-Dash-世界" class="headerlink" title="設計一個互動式的 Dash 世界"></a>設計一個互動式的 Dash 世界</h4><p>Super Dash 的設計非常直觀，易於玩。我們使用開源的 <a href="https://www.mapeditor.org/">Tiled</a> 工具設計關卡，並使用 <a href="https://pub.dev/packages/leap">leap</a> 套件將關卡整合到遊戲中。</p>
<p>Leap 使用 <a href="https://pub.dev/packages/flame_tiled">flame_tiled</a> 套件（其中實作了 TiledComponent），並在此基礎上建立，加入了平台物理和有用的類別，例如適用於物件、敵人和玩家的 PhysicalEntity。flame_tiled 套件解析來自 tiled  的檔案以渲染地圖、圖層和物件。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*CAzGZZFIAi0oszNtLTJBEA.png" />
<figcaption>Background static image</figcaption>
</figure>

<p><strong>LeapMap</strong></p>
<p>一個透過 <code>LeapGame.leapMap</code> 可以存取的組件，<code>LeapMap</code> 管理 <code>Tiledmap</code>，並自動為地面地形建立具有適當碰撞偵測的方塊。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">  runApp(GameWidget(game: MyLeapGame()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyLeapGame extends LeapGame with HasTappables, HasKeyboardHandlerComponents &#123;</span><br><span class="line">  late final Player player;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Future&lt;void&gt; onLoad() async &#123;</span><br><span class="line">    await super.onLoad();</span><br><span class="line"></span><br><span class="line">    // &quot;map.tmx&quot; should be a Tiled map the meets the Leap requirements defined below</span><br><span class="line">    await loadWorldAndMap(&#x27;map.tmx&#x27;, 16);</span><br><span class="line">    setFixedViewportInTiles(32, 16);</span><br><span class="line"></span><br><span class="line">    player = Player();</span><br><span class="line">    add(player);</span><br><span class="line">    camera.followComponent(player);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要加入自訂行為，請透過 <code>LeapGame.leapMap.tiledMap</code> 存取圖層，並為方塊或物件整合您自己的特殊行為</p>
<h4 id="自訂圖層名稱和類別"><a href="#自訂圖層名稱和類別" class="headerlink" title="自訂圖層名稱和類別"></a>自訂圖層名稱和類別</h4><p>您可以要求 Leap 使用不同的類別、類型或名稱。若要這樣做，請建立並將自訂 <code>LeapConfiguration</code> 傳遞給遊戲。</p>
<p>以下範例建立了自訂 <code>LeapConfiguration</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyLeapGame extends LeapGame &#123;</span><br><span class="line">  MyLeapGame() : super(</span><br><span class="line">    configuration: LeapConfiguration(</span><br><span class="line">      tiled: const TiledOptions(</span><br><span class="line">        groundLayerName: &#x27;Ground&#x27;,</span><br><span class="line">        metadataLayerName: &#x27;Metadata&#x27;,</span><br><span class="line">        playerSpawnClass: &#x27;PlayerSpawn&#x27;,</span><br><span class="line">        hazardClass: &#x27;Hazard&#x27;,</span><br><span class="line">        damageProperty: &#x27;Damage&#x27;,</span><br><span class="line">        platformClass: &#x27;Platform&#x27;,</span><br><span class="line">        slopeType: &#x27;Slope&#x27;,</span><br><span class="line">        slopeRightTopProperty: &#x27;RightTop&#x27;,</span><br><span class="line">        slopeLeftTopProperty: &#x27;LeftTop&#x27;,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我們與 <a href="https://www.hopr.tv/">HOPR</a> Studio 合作設計和製作遊戲的美術作品。為了建立更無縫的工作流程，我們建立了描述項目行為的通用語言。例如，一個「I」代表無限，表示項目會以相同的方式重複執行（從左到右或反之亦然）。這使得每個團隊更容易理解遊戲的目標。地圖準備好後，我們便將其整合到遊戲開發中。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vXIAYAtllF-90sECtDHfkg.png" />
<figcaption>Super Dash Game instructions</figcaption>
</figure>

<h4 id="接下來的目標"><a href="#接下來的目標" class="headerlink" title="接下來的目標"></a>接下來的目標</h4><p>Super Dash 範例在 2023 年 11 月更新的 <a href="http://flutter.dev/games">Flutter 休閒遊戲工具包</a> 之後發佈，並使用了 <a href="https://github.com/flutter/games/tree/main/templates/endless_runner">新的遊戲範例</a>，展示了 Flame。透過強調我們在短短六週內就完成了從想法到推出，我們希望展示 Flutter 如何幫助您提高生產力，並在各種平台上接觸更多使用者。查看 <a href="https://github.com/flutter/super_dash">開源程式碼</a> 以了解我們是如何建立的。</p>
<p>現在可以在桌面瀏覽器上 <a href="https://superdash.flutter.dev/">玩遊戲</a>，或在 <a href="https://apps.apple.com/app/super-dash-flutter-game/id6473050393">Apple App Store</a> 和 <a href="https://play.google.com/store/apps/details?id=com.verygoodventures.super_dash">Google Play</a> 上下載行動裝置應用程式！你能打破最高分記錄嗎？</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9c7aa2a5ad31" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/how-we-built-the-new-super-dash-demo-in-flutter-and-flame-in-just-six-weeks-9c7aa2a5ad31">我們如何在短短六週內使用 Flutter 和 Flame 建立 Super Dash 範例！</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/6c7c35de.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/6c7c35de.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Dart 3.2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-15 21:44:57" itemprop="dateCreated datePublished" datetime="2023-11-15T21:44:57+08:00">2023-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 01:41:48" itemprop="dateModified" datetime="2024-09-30T01:41:48+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Dart/" itemprop="url" rel="index"><span itemprop="name">Dart</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Dart-3-2"><a href="#宣布-Dart-3-2" class="headerlink" title="宣布 Dart 3.2"></a>宣布 Dart 3.2</h2><p>作者： <a href="https://medium.com/u/441fe70f4b5e">Kevin Moore</a> 和 <a href="https://medium.com/u/a6d788faa5e5">Michael Thomsen</a></p>
<p>今天，我們宣布推出 Dart 3.2，其中包含一個新的語言功能，用於對私有 final 欄位進行非空推斷，透過新的互操作性功能改進開發人員體驗，支援 DevTools 中的擴展，以及關於我們的 Web 路線圖的更新，包括對 Wasm（又名 WebAssembly）的支援。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*u5YRn1uMmXf94b2aPbcLRQ.png" />
</figure>

<h3 id="私有-final-欄位的非空推斷"><a href="#私有-final-欄位的非空推斷" class="headerlink" title="私有 final 欄位的非空推斷"></a>私有 final 欄位的非空推斷</h3><p>自從我們在 Dart 2.12 中引入 <a href="https://medium.com/dartlang/announcing-dart-2-12-499a6e689c87">可靠的空安全</a> 已經過了好幾年。在空安全中，您可以宣告哪些類型是可空的（可能包含值或 null），以及哪些類型是非空的（始終包含值）。空安全與 <a href="https://dart.dev/null-safety/understanding-null-safety#flow-analysis">流分析</a> 結合在一起，可以偵測到可空變數何時可以「推斷」為更安全的非空類型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> definitelyInt(<span class="built_in">int?</span> aNullableInt) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aNullableInt == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果流分析到達此處，</span></span><br><span class="line">  <span class="comment">// aNullableInt 可以安全地推斷為非空的 int。</span></span><br><span class="line">  <span class="keyword">return</span> aNullableInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>類型推斷自 Dart 2.12 起一直是空安全的核心部分，但僅限於區域變數。欄位或頂層變數無法推斷，例如在這種情況下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int?</span> _fillLevel;</span><br><span class="line">  Container(<span class="keyword">this</span>._fillLevel);</span><br><span class="line">  check() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_fillLevel != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="built_in">int</span> i = _fillLevel; <span class="comment">// 在 Dart 3.2 之前，會導致錯誤。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這種限制是由于在流分析無法安全地確定何時或如何更改欄位的一些複雜情況造成的。例如，在類別的欄位推斷情況下，如果子類別使用 getter 覆蓋欄位，而 getter 有時會返回 null，就會出現問題。</p>
<p>在 Dart 3.2 中，我們改進了我們的流分析引擎，現在能夠推斷 <strong>私有 final 欄位</strong> 的類型。現在，上面的程式碼片段可以在沒有錯誤的情況下通過。這利用了這樣一種了解，即對於私有和 final 欄位，在初始賦值之後，該值永遠不會改變，因此只檢查一次被認為是安全的。私有的 final 欄位推斷從 Dart 3.2 開始可用，並且將應用於 Dart SDK <a href="https://dart.dev/guides/language/evolution#language-versioning">下限</a> 為 3.2 或更高的專案。</p>
<h3 id="package-lints-3-0-中的新的程式碼分析選項"><a href="#package-lints-3-0-中的新的程式碼分析選項" class="headerlink" title="package:lints 3.0 中的新的程式碼分析選項"></a>package:lints 3.0 中的新的程式碼分析選項</h3><p>說到程式碼分析，我們還在 <a href="https://pub.dev/packages/lints">package:lints</a> 中對我們的標準程式碼分析規則進行了一些改進。這個套件包含與使用 <code>dart create</code> 或 <code>flutter create</code> 建立的任何新專案一起提供的預設和推薦的靜態分析規則集（透過 <a href="https://pub.dev/packages/flutter_lints">package:flutter_lints</a> - package:lints 的擴展）。</p>
<p>這個 lint 集的最新主要版本 3.0 現在已經可以使用了。此修訂版在核心集添加了六個 lint，在推薦集添加了兩個 lint。它具有用於驗證 pubspec URL、驗證集合方法是否使用正確參數調用等的 lint。若要查看完整的更改列表，請查看 <a href="https://github.com/dart-lang/lints/blob/main/CHANGELOG.md#300">變更日誌</a>。3.0 版本將是下一個版本中新專案的預設版本。對於現有專案，您可以 <a href="https://github.com/dart-lang/lints#upgrading-to-the-latest-lints">立即升級</a>。</p>
<h3 id="Dart-互操作性更新"><a href="#Dart-互操作性更新" class="headerlink" title="Dart 互操作性更新"></a>Dart 互操作性更新</h3><p>在 <a href="https://dart.dev/overview#platform">各種平台</a> 上的多平台支援一直是 Dart 的核心原則。但是，即使 Dart 程式碼行可以在所有這些平台上無需更改地執行，大型應用程式仍然經常需要與現有程式碼互操作。這可能意味著來自舊專案的程式碼，或在其他函式庫或系統 API 中可用的 API。我們在這個領域進行了一系列投資，從用於 <a href="https://dart.dev/guides/libraries/c-interop">與原生 C API 互操作</a> 的 FFI 開始。我們目前正在努力將其擴展以支援與 <a href="https://dart.dev/guides/libraries/java-interop">Java 和 Kotlin</a> 以及 <a href="https://dart.dev/guides/libraries/objective-c-interop">Objective C 和 Swift</a> 互操作。有關 JS 互操作性的令人興奮的更新，請查看下面的 Dart Web 部分。</p>
<p>截至 Dart 3.2，我們對原生互操作性進行了許多改進：</p>
<ul>
<li>我們為 C FFI 引入了 <a href="https://api.dart.dev/stable/dart-ffi/NativeCallable/NativeCallable.isolateLocal.html">NativeCallable.isolateLocal</a> 建構函式，它從任意 Dart 函數建立 C 函數指標。這是 <a href="https://api.dart.dev/stable/dart-ffi/Pointer/fromFunction.html">Pointer.fromFunction</a> 提供的功能的擴展，它只能從頂層函數建立函數指標。</li>
<li>我們更新了 Objective-C 綁定生成器，以使用 <a href="https://api.dart.dev/stable/dart-ffi/NativeCallable/NativeCallable.listener.html">NativeCallable.listener</a>，我們在 Dart 3.1 中添加了它。生成器現在可以自動處理包含異步回調的 API，例如 <a href="https://developer.apple.com/documentation/coremotion">Core Motion</a>。以前，此類 API 需要手動編寫一些綁定程式碼。</li>
<li>我們繼續改進用於 Java 和 Kotlin 互操作性的 <a href="https://dart.dev/guides/libraries/java-interop">package:jnigen</a>。這使我們能夠將 <a href="https://pub.dev/packages/cronet_http">package:cronet_http</a> - Android Cronet HTTP 客戶端的包裝器 - 從手動編寫的綁定程式碼遷移到自動 <a href="https://github.com/dart-lang/http/blob/master/pkgs/cronet_http/jnigen.yaml">生成的</a> 包裝器。</li>
<li>我們在 <a href="https://github.com/dart-lang/sdk/issues/50565">原生資產</a> 功能方面取得了重大進展，該功能旨在解決與依賴原生程式碼的 Dart 套件分發相關的許多問題。它透過提供用於整合與構建 Flutter 和獨立 Dart 應用程式相關的各種構建系統的統一掛鉤來實現。若要查看預覽，請查看 <a href="http://dart.dev/guides/libraries/c-interop#native-assets">文件</a>。</li>
</ul>
<h3 id="Dart-套件的-DevTools-擴展"><a href="#Dart-套件的-DevTools-擴展" class="headerlink" title="Dart 套件的 DevTools 擴展"></a>Dart 套件的 DevTools 擴展</h3><p>Dart <a href="https://dart.dev/tools/dart-devtools">DevTools</a> 是一套用於除錯和效能分析的工具，支援純 Dart 和 Flutter 應用程式。在 Dart 3.2 和 Flutter 3.16 中，我們 <a href="https://medium.com/p/c8bc1aaf8e5f/">宣布</a> 推出一個新的 <a href="https://pub.dev/packages/devtools_extensions">擴展框架</a>，它使套件作者能夠為他們的套件構建自訂工具，並直接在 DevTools 中顯示。這允許包含框架的 pub.dev 套件提供專門針對其用例的自訂工具。例如，<a href="https://pub.dev/packages/serverpod">Serverpod</a> 的作者一直在努力為他們的套件構建開發人員工具，並且很高兴地宣布他們将在即将发布的 <a href="https://github.com/orgs/serverpod/projects/4">1.2 版本</a> 中发布 DevTools 扩展。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*N6ZSt1McXO_opQU7" />
<figcaption><em>計劃在即將推出的 ServerPod 1.2 版本中使用的 DevTools 擴展</em></figcaption>
</figure>

<h3 id="Dart-Web-和-Wasm-更新"><a href="#Dart-Web-和-Wasm-更新" class="headerlink" title="Dart Web 和 Wasm 更新"></a>Dart Web 和 Wasm 更新</h3><p>Wasm（也稱為 <a href="https://webassembly.org/">WebAssembly</a>）是一種用於 Web 瀏覽器的令人興奮的新指令格式，它提供了一種可移植、平台中立的二進制程式碼格式，以便在現代瀏覽器中執行。像 Dart 這樣的更高級別的受控語言使用垃圾收集，而垃圾收集正在添加到 Wasm 標準中。截至 Chrome 119，<a href="https://developer.chrome.com/blog/wasmgc/">Wasm 的垃圾收集支援</a>（稱為 Wasm-GC）已預設啟用。Wasm-GC 支援也即將在 Firefox 120 中推出，這是他們的下一個穩定版本。那麼 Dart、Flutter 和 Wasm-GC 的狀態如何呢？</p>
<p>Dart 到 Wasm 編譯器幾乎已完成功能。團隊對效能和相容性非常滿意。我們現在的重點是邊緣情況，以確保我們的輸出在各種情況下都能快速執行。</p>
<p>對於 Flutter Web，我們已完成一個新的「Skwasm」渲染引擎。為了最大限度地提高效能，Swasm 將編譯後的應用程式程式碼直接連接到使用 wasm 到 wasm 綁定的自訂 <a href="https://skia.org/docs/user/modules/canvaskit/">CanvasKit Wasm 模組</a>。它也是 Flutter Web 多線程渲染支援的第一個版本，它可以進一步提高幀時間。</p>
<p>在 Flutter Web 與 Wasm 擺脫目前的實驗狀態之前，還有一些事情需要完成：</p>
<ul>
<li><strong>雙重編譯：</strong> 生成 Wasm 和 JavaScript 輸出，并在運行時啟用功能偵測，以支持具有 Wasm-GC 支援和沒有 Wasm-GC 支援的瀏覽器。</li>
<li><strong>現代 JavaScript 互操作性：</strong> 基於 <a href="https://github.com/dart-lang/language/issues/2727">擴展類型</a> 的新的 JS 互操作性機制，以在針對 JavaScript 和 Wasm 時，在 Dart 程式碼、瀏覽器 API 和 JS 函式庫之間實現簡潔、類型安全的調用。</li>
<li><strong>具有 Wasm 支援的瀏覽器 API：</strong> 一個新的 package:web，基於現代 JS 互操作性機制，取代 dart:html（以及相關的函式庫）。這將為 JS 和 Wasm 目標上的瀏覽器 API 提供簡單的存取權。</li>
</ul>
<p>我們開始將許多內部專案遷移到 package:web 和新的 JS 互操作性機制，並預計在下一個穩定版本中會有更多更新。同時，您可以在我們的 <a href="https://flutter.dev/wasm">WebAssembly 支援</a> 頁面上獲取最新詳細資訊。</p>
<h3>結語</h3>

<p>今天就到這裡。Dart 3.2 現在可以從 <a href="https://dart.dev/get-dart">dart.dev</a> 中獲取，或者作為今天 <a href="https://medium.com/flutter/whats-new-in-flutter-3-16-dba6cb1015d1">Flutter 3.16</a> 版本的一部分。下次再見，祝您使用 Dart 開發愉快！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c8de8fe1b91f" width="1" height="1" alt=""><hr><p><a href="https://medium.com/dartlang/dart-3-2-c8de8fe1b91f">宣布 Dart 3.2</a> 最初發佈在 <a href="https://medium.com/dartlang">Dart</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>
<p>undefined</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rainvisitor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">170</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">184</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rainvisitor</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
