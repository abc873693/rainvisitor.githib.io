<!DOCTYPE html>
<html lang="zh-tw,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rainvisitor.me","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="RainVisitor Blog">
<meta property="og:url" content="https://blog.rainvisitor.me/page/11/index.html">
<meta property="og:site_name" content="RainVisitor Blog">
<meta property="og:locale" content="zh_TW">
<meta property="article:author" content="Rainvisitor">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.rainvisitor.me/page/11/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-tw'
  };
</script>

  <title>RainVisitor Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">RainVisitor Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">RainVisitor</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/2bed4075.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/2bed4075.html" class="post-title-link" itemprop="url">【文章翻譯】Writing a good code sample</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-23 21:37:55" itemprop="dateCreated datePublished" datetime="2021-08-23T21:37:55+08:00">2021-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="寫一個好的程式碼範例"><a href="#寫一個好的程式碼範例" class="headerlink" title="寫一個好的程式碼範例"></a>寫一個好的程式碼範例</h2><p>撰寫好的程式碼範例很難。讓我說明一下，製作一個範例來演示 API 的用法或展示 UI 慣用語可能很快且容易。難度來自於你需要添加到你的儲存庫中的額外部分，以保持程式碼範例新鮮並吸引你的開發人員。</p>
<p>首先，你需要在你的程式碼中添加一個好的 README，從一個摘要開始，說明開發人員為什麼應該投入時間和精力來研究和理解這個範例。接著，提供使用說明和連結到問題追蹤器，開發人員可以在其中提出錯誤並要求澄清，如果遇到令人困惑的部分。</p>
<p>接下來是程式碼本身。程式碼是否遵循佈局和使用的慣例？這可能像程式碼放在哪裡一樣簡單，也可能像 linter 等適當的設定一樣複雜。我喜歡已經採用了強大的程式碼格式、佈局和 linting 規則集標準的程式設計社群語言。這些標準使程式碼的外觀保持一致，從而更容易導航。若要強制執行 Dart 和 Flutter 的程式碼格式，你可以將以下命令添加到你的 CI 管線，如果格式不正確，則會使構建失敗：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dart format --output none --set-exit-if-changed .</span><br></pre></td></tr></table></figure>

<p>在程式碼格式化後，下一步是強制執行一套好的 lints。對於 Dart，我強烈建議研究 <a href="https://pub.dev/packages/lints">lints</a> 套件，對於 Flutter，我同樣建議研究 <a href="https://pub.dev/packages/flutter_lints">flutter_lints</a> 套件。若要確保 lints 在 CI 管線中通過，請添加以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dart analyze</span><br></pre></td></tr></table></figure>

<p>測試。哦，這麼多測試。單元測試、整合測試，對於 Flutter，我們還有 Widget 測試。測試對於範例來說非常棒，因為測試傳達了如何使用程式碼片段的意圖。測試還與前面提到的 CI 管線結合使用，可以使程式碼庫保持常青。想要了解更多關於 Flutter 測試功能的資訊，可以到 <a href="https://codelabs.developers.google.com/codelabs/flutter-app-testing">如何測試 Flutter 應用程式 codelab</a> 了解更多。Dart 和 Flutter 的 CI 命令分別為：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ flutter test   # 適用於 Flutter 專案</span><br><span class="line">$ dart test      # 適用於純 Dart 專案</span><br></pre></td></tr></table></figure>

<p>如果你的程式碼儲存庫託管在 GitHub 上，那麼我建議你如果擁有 Dart 專案，請使用 <a href="https://github.com/marketplace/actions/setup-dart-sdk">Dart Setup</a> 操作，如果擁有 Flutter 專案，請使用 <a href="https://github.com/marketplace/actions/flutter-action">Flutter Action</a>。為了獲得額外積分，請考慮添加 <a href="https://github.com/marketplace/actions/very-good-coverage">Very Good Coverage</a> 操作以保持高測試覆蓋率。既然你已經做到了這一步，你可能應該使用 <a href="https://docs.github.com/en/actions/managing-workflow-runs/adding-a-workflow-status-badge">工作流程狀態徽章</a> 來宣傳你的 CI 狀態。</p>
<p>希望以上添加的項目清單能夠指導你，讓你的程式碼範例對你的目標受眾更有價值。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=323358edd9f3" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/writing-a-good-code-sample-323358edd9f3">Writing a good code sample</a> was originally published in <a href="https://medium.com/flutter">Flutter</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/ca08facb.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/ca08facb.html" class="post-title-link" itemprop="url">【文章翻譯】GSoC ’21: Creating a desktop sample for Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-22 14:50:58" itemprop="dateCreated datePublished" datetime="2021-08-22T14:50:58+08:00">2021-08-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 20:22:51" itemprop="dateModified" datetime="2024-09-30T20:22:51+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="GSoC-‘21：為-Flutter-建立桌面樣本"><a href="#GSoC-‘21：為-Flutter-建立桌面樣本" class="headerlink" title="GSoC ‘21：為 Flutter 建立桌面樣本"></a>GSoC ‘21：為 Flutter 建立桌面樣本</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/923/1*aRiqWvnUYD-cSbGhxTnUsw.jpeg" />
</figure>

<p><a href="https://summerofcode.withgoogle.com/">Google Summer of Code</a> (GSoC) 是一個由 Google 贊助的開源夏季程式。在此程式期間，學生在開源組織的指導下進行專案。</p>
<p>這是 Dart 團隊第二次作為 GSoC 的指導組織參與。不幸的是，由於指導老師的可用性問題，今年的 <a href="https://docs.google.com/document/d/1KfaTPPt6rqvgPD4kkZcsaehXC9FijcJ20V4J3FDLsRk/edit#">點子列表</a> 上沒有任何 Flutter 專案。由於這是我的第二次參與 GSoC，我聯絡了去年的指導老師 Brett，看看是否有機會參與一個專案。在與他以及組織管理員討論後，我找到了一個可以參與的專案。</p>
<p>此部落格展示了我為專案所做的工作。<a href="https://summerofcode.withgoogle.com/organizations/4658845562961920/#projects">查看今年 Dart 下的所有專案</a>。所有產生的原始碼都位於 GitHub 儲存庫中，您可以透過查看個別的拉取請求 (PR) 來查看工作的進展。</p>
<h3 id="專案詳情：Flutter-桌面工具"><a href="#專案詳情：Flutter-桌面工具" class="headerlink" title="專案詳情：Flutter 桌面工具"></a>專案詳情：Flutter 桌面工具</h3><p>今年，在 Flutter Engage 中，Flutter 桌面支援的 beta 快照已包含在穩定版本中。這導致需要為 <a href="https://github.com/flutter/samples">samples</a> 儲存庫建立一個桌面樣本，該樣本日後可以在桌面應用程式商店（如 <a href="https://developer.apple.com/macos/distribution/">macOS App Store</a>、<a href="https://docs.microsoft.com/en-us/windows/uwp/publish/">Microsoft Store</a> 和 <a href="https://snapcraft.io/docs/snapcraft-overview">Linux Snap Store</a>）上發佈。在與 Brett 和團隊討論後，我們決定建立一個桌面樣本，它也將是一個工具，可以幫助開發人員管理其專案的 linting 規則。請查看 <a href="https://github.com/flutter/samples/tree/master/experimental/linting_tool">GitHub 上的 linting_tool </a>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Lh2I-A4Aak5UZXze" />
<figcaption>應用程式的螢幕截圖</figcaption>
</figure>

<p>該應用程式使用 Dart 團隊從 <a href="https://github.com/dart-lang/linter">dart-lang&#x2F;linter</a> 儲存庫中託管的 linting 規則，並且該應用程式可以執行以下操作：</p>
<p><strong>顯示可用的 Dart linting 規則列表。</strong></p>
<p>您可以從 API 獲取 linting 規則列表。該應用程式使用 <a href="https://pub.dev/packages/flutter_markdown">flutter_markdown</a> 套件來格式化詳細資訊和程式碼片段。</p>
<p>相關 PR：<a href="https://github.com/flutter/samples/pull/856">＃856</a></p>
<p><strong>將規則儲存到不同的設定檔。</strong></p>
<p>您可以為不同類型的專案建立不同的規則設定檔。該應用程式使用 <a href="https://pub.dev/packages/hive">hive</a> 資料庫來維持持久性儲存。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*FwXcFHhXjCuOEaFw" />
<figcaption>已儲存設定檔的列表</figcaption>
</figure>

<p>相關 PR：<a href="https://github.com/flutter/samples/pull/860">＃860</a></p>
<p><strong>修改和匯出設定檔。</strong></p>
<p>設定檔可以根據您的喜好進行修改，然後匯出到 Flutter 專案中，作為 analysis_options.yaml 檔案。 套件 <a href="https://pub.dev/packages/yaml">yaml</a>、<a href="https://pub.dev/packages/json2yaml">json2yaml</a> 和 <a href="https://pub.dev/packages/file_selector">file_selector</a> 用於完成此操作。</p>
<p>相關 PR：<a href="https://github.com/flutter/samples/pull/874">＃874</a>、<a href="https://github.com/flutter/samples/pull/869">＃869</a></p>
<p><strong>顯示預設設定檔。</strong></p>
<p>您可以查看 <a href="https://pub.dev/packages/effective_dart">effective_dart</a>、<a href="https://pub.dev/packages/pedantic">pedantic</a>、<a href="https://pub.dev/packages/lints">lints</a> 和 <a href="https://pub.dev/packages/flutter_lints">flutter_lints</a> 使用的預設設定檔列表。</p>
<p>相關 PR：**<a href="https://github.com/flutter/samples/pull/871">＃871</a>**</p>
<p>若要查看專案在 GSoC 期間的進展，請查看 <a href="https://github.com/flutter/samples/pulls?q=author:abd99+created:2021-06-07..2021-08-31+">這組 PR</a>。</p>
<p>我還想為專案添加一些其他內容。兩項主要内容是：能夠從現有的 analysis_options.yaml 檔案載入設定檔，以及能夠在規則列表中搜索特定規則。我還正在製作一個新的影片系列，將涵蓋如何部署 Flutter 桌面應用程式。影片系列製作完成後，我會更新此部落格，也會在 <a href="https://twitter.com/abdullahzakir99">Twitter 帳戶</a> 上分享。</p>
<h3 id="經驗"><a href="#經驗" class="headerlink" title="經驗"></a>經驗</h3><p>我這次的 Google Summer of Code (GSoC) 經驗比去年更好。（查看 <a href="https://medium.com/flutter/learn-testing-with-the-new-flutter-sample-gsoc20-work-product-e872c7f6492a">Learn testing with the new Flutter sample</a> 以閱讀更多有關我去年參與的專案的資訊。）我認為今年的經驗更好，因為專案更具技術性，涵蓋了更多概念，並且與我之前從未參與過的內容相關。這次我也認識團隊中的更多人。我認為 GSoC 將會是我永遠不會忘記的人生的一部分。</p>
<h4 id="指導"><a href="#指導" class="headerlink" title="指導"></a>指導</h4><p><a href="https://github.com/domesticmouse">Brett</a> 一直都在，幫助我解決所有問題和阻礙。當我需要更多時間來處理其他承諾（如學校、其他工作和家庭相關事項）時，他非常理解。我認為最棒的是，他給了我完全的自由去探索事物，如果我認為某些內容對專案來說是寶貴的補充，我就可以調整專案的範圍。這次我做了一件很酷的事情，就是在每次每周會議結束時，我問他一些與專案無直接關聯的一般軟體工程相關的問題，例如「Google 如何處理估計？」和「你對遠端工作怎麼看？」。這幫助我學習了一些與程式設計無關的軟體產業知識。我強烈建議你在實習或 GSoC 類專案期間嘗試一下。而且，是的，他仍然是我合作過的最酷的人。</p>
<h4 id="學習"><a href="#學習" class="headerlink" title="學習"></a>學習</h4><p>學習是開源軟體最棒的部分。我這次做的事情，很多都無法透過 Google 搜尋找到答案。我閱讀了大量的程式碼，找出不同的套件如何執行相同的事情，以及它們之間的差異模式。我還學會了如何在大量可用的套件中為專案找到合適的套件。由於這個類別對我來說是全新的，因此這次的經驗幫助我在短時間內學到很多東西。</p>
<h4 id="挑戰"><a href="#挑戰" class="headerlink" title="挑戰"></a>挑戰</h4><p>我這次遇到了一些挑戰，從中學到了一些經驗。第一個挑戰與時間表有關。今年，GSoC 的時間表縮短了一半，這迫使我們重新排序優先順序，跳過許多可能會成為專案中寶貴補充的功能。其他挑戰是：處理一個全新的類別，以及在一個不太流行的類別中，找到關於如何執行某些事情的良好資源。</p>
<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>在過去的一年中，我與 Flutter 和 samples 儲存庫合作，獲得了難以置信的經驗。我想要感謝 Brett、Flutter 團隊以及 GSoC 團隊。</p>
<p><em>關於作者：Abdullah 是一位來自印度浦那的電腦工程應屆畢業生。他在過去 4 年中一直在開發行動應用程式，並且喜歡與行動應用程式相關的內容合作。您可以在 <a href="https://twitter.com/abdullahzakir99">Twitter</a>、<a href="https://www.linkedin.com/in/abdullahzakir99/">LinkedIn</a> 和 <a href="https://github.com/abd99">GitHub</a> 上聯繫他.</em></p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=7d77e74812d6" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/gsoc-21-creating-a-desktop-sample-for-flutter-7d77e74812d6">GSoC ‘21：為 Flutter 建立桌面樣本</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/d103755c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/d103755c.html" class="post-title-link" itemprop="url">【文章翻譯】Flutter Hot Reload</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-19 18:00:00" itemprop="dateCreated datePublished" datetime="2021-08-19T18:00:00+08:00">2021-08-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Flutter-熱重載：原理與效能提升"><a href="#Flutter-熱重載：原理與效能提升" class="headerlink" title="Flutter 熱重載：原理與效能提升"></a>Flutter 熱重載：原理與效能提升</h2><p>Flutter 的熱重載功能非常棒，按下鍵盤上的 “r” 鍵，就能在幾秒鐘內看到變更的效果。在終端機（或 IDE 底部）您可能會看到類似的訊息：<code>Reloaded 1 of 553 libraries in 297ms</code>。但熱重載背後的運作原理是什麼？Dart 和 Flutter 團隊又是如何讓它變得更快呢？</p>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/800/1*iaLz5LEBdsZJRR_W8UCQcQ.png" />
</figure>

<h3 id="熱重載概述"><a href="#熱重載概述" class="headerlink" title="熱重載概述"></a>熱重載概述</h3><p>Flutter 的熱重載主要包含以下五個步驟：</p>

<ol>
<li><strong>flutter_tools 掃描需要的檔案變更。</strong> 它會檢查每個必要的檔案，並確認它的最後修改時間戳記是否比之前的編譯時間戳記更新。</li>
<li><strong>flutter_tools 指示正在執行的 Dart 編譯器重新編譯應用程式，並告知它哪些檔案已變更。</strong> Dart 編譯器開始重新編譯。</li>
<li><strong>flutter_tools 將更新的檔案傳送到設備。</strong> 這包括任何變更的資產和新編譯的 _delta kernel 檔案_（編譯的輸出，Dart VM 可以理解的檔案）。</li>
<li><strong>flutter_tools 要求設備上的 Dart VM 中的所有隔離區重新載入它們的來源（讀取變更的 delta kernel 檔案並執行其魔力）。</strong></li>
<li><strong>flutter_tools 指示設備上的應用程式重新組合 - 重新建立螢幕上的所有 Widget、重新載入資產、重新執行佈局、重新繪製等等。</strong></li>
</ol>
<p>在我的開發者機器上，目標設備為 Linux（也就是本地執行的桌面應用程式），在只更新 `lib/main.dart` 檔案的時間戳記後，在一個新建立的 `flutter create` 應用程式上執行第一次熱重載，我得到了以下時序（從 `flutter run -v` 中提取）：</p>

<ol>
<li>掃描檔案需要 ~13 ms。</li>
<li>重新編譯需要 ~67 ms。</li>
<li>將檔案傳送到設備需要 ~2 ms。</li>
<li>Dart VM 重新載入來源需要 ~96 ms。</li>
<li>重新組合需要 ~114 ms。</li>
</ol>
<p>如果我改用一個更大的應用程式（並變更其他檔案），我可能會得到以下時序：</p>

<ol>
<li>掃描檔案需要 ~12 ms。</li>
<li>重新編譯需要 ~386 ms。</li>
<li>將檔案傳送到設備需要 ~2 ms。</li>
<li>Dart VM 重新載入來源需要 ~171 ms。</li>
<li>重新組合需要 ~229 ms。</li>
</ol>
<p>在兩種情況下，以下步驟佔用了最多的時間：</p>

<ul>
<li>重新編譯</li>
<li>重新載入</li>
<li>重新組合</li>
</ul>
<p>要使熱重載速度更快，我們必須讓這三個步驟中的其中一個或多個步驟變得更快。 這裡我將重點關注第一部分：將變更的原始碼檔案重新編譯成 Dart VM 可以使用的內容。</p>

<h3 id="重新編譯"><a href="#重新編譯" class="headerlink" title="重新編譯"></a>重新編譯</h3><p>從邏輯上來說，如果我作為使用者變更了一個檔案，例如 `foo.dart`，我可能會期望重新編譯看起來像這樣：</p>

<ol>
<li>編譯器在記憶體中保留了舊的狀態。</li>
<li>編譯器被告知 <code>foo.dart</code> 已變更。</li>
<li>編譯器丟棄它對 <code>foo.dart</code> 的內部狀態。</li>
<li>編譯器重新編譯 <code>foo.dart</code>。</li>
<li>完成。</li>
</ol>
<p>這將非常棒。這意味著，無論我變更了哪個檔案，我只會重新編譯那個檔案，並且（可能）重新編譯速度很快。</p>

<p>不幸的是，重新編譯通常不會像這樣運作。以下是有兩個例子說明了為什麼重新編譯可能沒有那麼簡單：</p>

<ul>
<li><code>foo.dart</code> 曾經包含類別 <code>Foo</code>，該類別在各處使用。變更後的檔案不包含此類別（也許它被手動重新命名），並且每個使用此類別的檔案都應該出現編譯錯誤。</li>
<li><code>foo.dart</code> 曾經定義了一個字段為 <code>var z = 42</code>。另一個檔案使用此字段：<code>var z2 = z * 2</code>。Dart 類型推斷確定 <code>z</code> 是一個整數，而 <code>z2</code> 是一個整數，因為 <code>z</code> 是一個整數。現在，字段變更為 <code>var z = 42.2</code>。這次 Dart 類型推斷將會確定該字段是一個雙精度數，但如果不重新編譯另一個函式庫，那么 <code>z2</code> 將仍然（錯誤地）被標記為一個整數。</li>
</ul>
<p>因此，Dart 中的重新編譯長期以來都是像這樣執行的：</p>

<ol>
<li>編譯器在記憶體中保留了舊的狀態。</li>
<li>編譯器被告知 <code>foo.dart</code> 已變更。</li>
<li>編譯器丟棄它對 <code>foo.dart</code> 的內部狀態。</li>
<li>編譯器檢查哪些檔案匯入或匯出 <code>foo.dart</code>，並將這些檔案也丟棄。</li>
<li>編譯器檢查哪些檔案匯入或匯出步驟 4 中的檔案，並將這些檔案也丟棄。</li>
<li>不斷重複：丟棄所有傳遞性匯入者和匯出者。</li>
<li>編譯器重新編譯所有（現在）“遺漏”的函式庫。</li>
<li>完成。</li>
</ol>
<p>這聽起來可能很糟糕，但在許多情況下並非如此。雖然變更您自己的自訂 Widget 組合可能會導致重新編譯您編寫的所有程式碼，但它不會導致重新編譯 Flutter 框架本身，例如，因為 Flutter 框架不匯入或匯出您的函式庫。另一方面，如果您變更了 Flutter 框架的核心檔案，那麼您最終將重新編譯（幾乎）所有內容。</p>

<p>回顧一下為什麼只重新編譯單一變更檔案不起作用的原因的不完整列表，我們可能會看到一個模式：它不起作用是因為您進行了 _全局_ 變更 - 影響其他函式庫的變更。但是，如果您只變更了註釋呢？或者在您的建構方法中加入了另一個除錯列印？或者修正了實用方法中的一處錯誤？這些變更不是全局的，我們應該可以做得更好！</p>

<h3 id="改進"><a href="#改進" class="headerlink" title="改進"></a>改進</h3><p>對於非全局變更（不能影響其他函式庫編譯的變更），我們實際上可以只重新編譯變更的函式庫，並且仍然保持語義。主要問題是確定何時變更是全局的，何時不是（並且要快速完成）。幸運的是，這可以通過增量步驟來完成：我們不必立即（或根本不必）使其完美。</p>

<p>第一步可能是比較檔案的舊版本和新版本，同時忽略兩個版本的檔案中的註釋。如果，用這種方式比較時，兩個版本的檔案相同，那麼我們認為沒有全局變更，然後我們繼續重新編譯單一變更的檔案，而不是傳遞性匯入匯出圖。這種技術並不完美。例如，它仍然會在修正實用方法中的錯誤時觸發所有傳遞性匯入者和匯出者的重新編譯。但它允許您在只重新編譯一個檔案的同時修正註釋中的拼寫錯誤。</p>

<p>這裡快速說明一下：如果我們只變更了註釋，為什麼我們必須重新編譯？主要原因是堆疊追蹤。在內部，一些節點（表示您的程式碼）包含 _偏移量_ - 有關它們在檔案中的位置的資訊。如果此資訊過時，您的堆疊追蹤將包含無效的資訊。例如，它可能會聲稱某件事發生在第 42 行，而實際上並非如此。</p>

<p>若要達到可以實際上修正實用方法中的錯誤，同時仍然只重新編譯該檔案的狀態，我們必須在檢查全局變更時忽略另一件事：函數體。我們將再次比較變更檔案的之前版本和之後版本，這次同時忽略註釋和函數體。如果它們相同，我們將只重新編譯該檔案。</p>

<p>現在，我們實際上可以進行一些有用的變更，而無需重新編譯超出您變更的檔案的內容。您可以加入、移除或以其他方式變更註釋。您可以在您的建構方法中加入（和移除）除錯列印。您甚至可以修正實用方法中的錯誤。</p>

<h3 id="好消息！"><a href="#好消息！" class="headerlink" title="好消息！"></a>好消息！</h3><p>事實證明，這些對重新編譯的改進已經實現。如果您使用的是 Flutter 2.2，您可能已經注意到它了。如果沒有，您可能現在就會注意到。老實說，對於小型應用程式，您可能不會注意到多少速度提升，但對於大型應用程式，您應該會注意到。</p>

<p>我已經製作了一些非全局變更的示例，以評估其效果。</p>

<p>對於 [Veggie Seasons](https://github.com/flutter/samples/tree/master/veggieseasons) 示例應用程式（一個相對較小的應用程式）：</p>

<ul>
<li>變更 <code>lib/main.dart</code> 沒有改善。它之前編譯一個檔案，現在仍然編譯一個檔案。</li>
<li>變更 <code>lib/data/veggie.dart</code> 會帶來 30% 的改善。在我的電腦上，實際的編譯時間從 100 多毫秒下降到不到 20 毫秒（它以前編譯 18 個檔案，現在只編譯 1 個檔案）。這自然遠遠超過 30%，但由於重新編譯只是三個時間消耗中的其中一個（另外兩個是重新載入和重新組合），所以總體變更大約是 30%。</li>
</ul>
<p>對於 [Flutter Gallery](https://github.com/flutter/gallery)（一個相對較大的應用程式）：</p>

<ul>
<li>變更 <code>lib/main.dart</code> 會產生非常小的改善（它編譯 1 個檔案而不是 2 個檔案）。</li>
<li>變更 <code>lib/layout/adaptive.dart</code> 會導致重新載入時間幾乎減半。僅重新編譯時間從近 400 毫秒下降到 40 毫秒（重新編譯 1 個檔案而不是 47 個檔案）。</li>
</ul>
<p>您應該期望在實際情況中，Flutter 2.2 中的熱重載平均速度比 Flutter 2.0 中快 30%。從這個角度來看，這個變更為 Flutter 開發人員節省了超過一年時間，每 5 天就少等一次熱重載。</p>

<h3 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h3><p>我們對熱重載的變更並不總是意味著編譯器做的事情更少。例如，如果您加入或移除了一個方法，編譯器不會做的事情更少。如果您變更了字段的初始化器，編譯器不會做的事情更少。如果您變更了類別層級，編譯器不會做的事情更少。如果您變更了函數體（編譯器通常應該做的事情更少），由於混合和 FFI 方面的技術問題，編譯器可能仍然需要做同樣多的工作。</p>

<p>此外，當我們討論比較檔案時，我們跳過了幾個技術細節。首先，我們不能忽略 _所有_ 註釋：我們需要保留 [語言版本選擇器](https://dart.dev/guides/language/evolution#per-library-language-version-selection) `@dart version 標記` ，因為它具有語義意義。其次，我們不能忽略所有函數體，因為混合和 FFI 方面存在實作上的問題。</p>

<h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>Flutter 2.0 中的熱重載速度很快，但 Flutter 2.2 中的速度更快。平均而言，Flutter 2.2 中的熱重載速度比 Flutter 2.0 快約 30%，這為 Flutter 開發人員節省了超過一年時間，每 5 天就少等一次熱重載。</p>

<p>如果您尚未更新（甚至尚未嘗試使用 Flutter），現在可能是參觀 [flutter.dev](http://flutter.dev) 並嘗試一下的好時機。</p>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=f3c5994e2cee" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/flutter-hot-reload-f3c5994e2cee">Flutter 熱重載</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/7efc9369.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/7efc9369.html" class="post-title-link" itemprop="url">【文章翻譯】What can we do better to improve Flutter? — Q2 2021 user survey results</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-13 21:04:20" itemprop="dateCreated datePublished" datetime="2021-08-13T21:04:20+08:00">2021-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h3 id="我們如何才能讓-Flutter-變得更好？-2021-年第二季使用者調查結果"><a href="#我們如何才能讓-Flutter-變得更好？-2021-年第二季使用者調查結果" class="headerlink" title="我們如何才能讓 Flutter 變得更好？- 2021 年第二季使用者調查結果"></a>我們如何才能讓 Flutter 變得更好？- 2021 年第二季使用者調查結果</h3><p>撰寫者： <a href="https://medium.com/@jayoung.lee">JaYoung</a> 和 <a href="https://medium.com/@mariam.hasnany">Mariam</a></p>
<p>Flutter 團隊每季都會進行使用者調查，以聽取 Flutter 使用者的意見並為未來做出規劃。最近一次的調查是在 5 月份進行的，這是我們第 13 次使用者調查，收集了超過 7,000 份回覆。我們請 Flutter 開發人員評估他們對 Flutter 各部分的滿意度，對於那些不完全滿意的開發人員，我們請他們說明原因。團隊不僅總結了多選題調查回覆，還閱讀了調查中留下的開放式意見。總共有 3,403 則意見。我們再次回來分享我們從您那裡學到的東西。</p>
<h3 id="滿意度"><a href="#滿意度" class="headerlink" title="滿意度"></a>滿意度</h3><p>總體而言，92% 的受訪者表示他們對 Flutter 持正面滿意度（39% 有點滿意，53% 非常滿意）。Flutter 的子系統滿意度得分不同，範圍從 72% 到 93%，如下圖所示。雖然我們很高興分享我們正在維持高滿意度，但我們也關注可以改進的特定領域。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*m2ihVMc99emY4hQY" />
</figure>

<h3 id="開放式問題"><a href="#開放式問題" class="headerlink" title="開放式問題"></a>開放式問題</h3><p>調查中有兩個開放式問題：</p>
<ul>
<li><em>「您為什麼對 Flutter 不滿意？請分享您的原因：」</em></li>
<li><em>「您想對 Flutter 團隊說些什麼嗎？ 」</em></li>
</ul>
<p>我們從第一個問題收集了 847 則意見，從第二個問題收集了 2,556 則意見。這些意見首先使用機器學習演算法被劃分為各種主題（例如文件、生態系統、Web 支援等）。然後，每個主題會被分配給在該領域工作的團隊進行分析。</p>
<p>當然，團隊不能一次承擔所有工作並解決所有問題。然而，每個團隊都試圖從意見中提取見解並優先處理想法，仔細評估需要達成的效果和付出的努力。在以下章節中，我們將分享一些我們得到的結論的範例。</p>
<h4 id="範例-1：關於一般的開發者體驗"><a href="#範例-1：關於一般的開發者體驗" class="headerlink" title="範例 1：關於一般的開發者體驗"></a>範例 1：關於一般的開發者體驗</h4><p>在高層面上，透過閱讀書面回饋對我們有三個幫助：</p>
<ol>
<li>確認現有問題</li>
<li>找出新的關注領域和想法</li>
<li>察覺到對額外資訊和證據的需求</li>
</ol>
<p>首先，我們確認了在許多其他來源（例如 GitHub Issues 標籤、Reddit 和 Stack Overflow）中經常觀察到的痛點。這些範例包括但不限於記憶體消耗和升級技能的範例。我們非常了解這些挑戰，並在每個小組內為它們設定優先順序。同時，我們希望再次宣傳現有的資源，例如 <a href="https://flutter.dev/docs/development/tools/devtools/memory">使用記憶體檢視</a> 或 <a href="https://events.flutter.dev/engage/learn/beginner">學習中心</a>。</p>
<p>其次，我們發現了一些令我們驚訝的主題。例如，有幾則意見表達了對擴展到桌面和 Web 的擔憂。這些意見要求我們專注於讓 iOS 和 Android 變得更好，不要分散我們的注意力。我們理解這種擔憂，並且會注意這個問題。我們也會更好地傳達我們如何努力成為一種強大的行動技術，以及隨著時間的推移如何擴展對其他平台的支援。</p>
<p>最後，我們希望獲得有關調查中報告的一些問題的更多資訊，特別是那些與效能和文件相關的問題。如果您想與 Flutter 貢獻者進行對話，並為您的問題添加更多細節，請考慮將它們發佈到 GitHub Issues 標籤。這個標籤會定期由團隊進行分類。在您發佈時，請遵循 <a href="https://github.com/flutter/flutter/wiki/Issue-hygiene#file-bugs-for-everything">為所有問題提交錯誤</a> 中的規則。（當然，在 Stack Overflow 或 Discord 等支援論壇中回答「如何」類別的問題效果會更好！請查看 <a href="https://flutter.dev/community">社群</a> 頁面以獲取更多資訊。）</p>
<h4 id="範例-2：關於-Flutter-的-Web-支援"><a href="#範例-2：關於-Flutter-的-Web-支援" class="headerlink" title="範例 2：關於 Flutter 的 Web 支援"></a>範例 2：關於 Flutter 的 Web 支援</h4><p>團隊發現，圍繞缺乏穩定版本 Web 支援而提出的不滿意回饋，在 Flutter 2.0 於 3 月份 <a href="https://medium.com/flutter/flutter-web-support-hits-the-stable-milestone-d6b84e83b425">穩定發佈 Web 支援</a> 之後已得到緩解。我們為 Flutter Web 支援的穩定版本新增的許多功能都是基於去年的 <a href="https://medium.com/flutter/flutter-on-the-web-slivers-and-platform-specific-issues-user-survey-results-from-q3-2020-f8034236b2a8">調查</a>，在那裡我們詢問了您可能需要的 Web 應用程式功能。</p>
<p><a href="https://medium.com/flutter/flutter-on-the-web-slivers-and-platform-specific-issues-user-survey-results-from-q3-2020-f8034236b2a8">2020 年第三季調查</a> 中的 Web 特定問題是基於我們去年第二季調查中收到的開放式回饋。您的意見幫助我們確定了我們應該優先考慮的領域，以作為 Flutter Web 支援的初始穩定版本。</p>
<p>在 2020 年，15% 的意見是關於效能和卡頓的，因此我們優先改進 HTML 渲染器的效能，以及穩定 CanvasKit 渲染器。另外 15% 的意見是關於我們的 Plugin 差距，以及對 GoogleMaps、Firestore 等等的要求，因此我們確保了在 Web 穩定版本中支援了大多數 Google 自有 Plugin，包括 GoogleMaps、Firebase_analytics、cloud_firestore 等等。有幾則意見是關於捲軸和文字渲染的。雖然我們在這些領域仍然需要做更多工作，但我們能夠為支援 <a href="https://github.com/flutter/flutter/issues/70866">桌面外觀尺寸上的捲軸</a> 以及支援 <a href="https://github.com/flutter/flutter/issues/33523">富文本功能</a>（例如文字欄位中的多行文字選取）奠定堅實的基礎。</p>
<p>本季，我們得知使用者認為 Flutter 的 Web 支援仍然需要改進。Web 應用程式的「外觀和感覺」是最常被提及的不滿意 Flutter Web 支援的原因。我們也被要求提供更多 Web 特定 Widget、直觀的響應式 Widget 等等。搜尋引擎優化 (SEO) 的要求也被注意到。其他的不滿意原因是從右到左 (RTL) 文字支援、程式碼大小、路由和除錯。</p>
<p>我們計劃在下一次使用者調查中詢問一些這些領域，因為我們正在規劃下一個版本。對於其他的問題，我們已經取得了進展，例如新增 <a href="https://github.com/flutter/flutter/projects/159">RTL 文字支援</a>，透過我們目前的 <a href="https://github.com/flutter/uxr/tree/master/nav2-usability">UXR 研究</a> 了解路由問題，以及研究降低程式碼大小的方法。</p>
<h3 id="接下來要做什麼？"><a href="#接下來要做什麼？" class="headerlink" title="接下來要做什麼？"></a>接下來要做什麼？</h3><p>每季調查計劃是讓我們更好地了解您的需求的結構化方式，但它不是我們聽取 Flutter 開發者意見的唯一管道。如果您有需要後續處理的緊急問題，請在 <a href="https://github.com/flutter/flutter/issues">GitHub</a> 上提交它們。</p>
<p>Flutter UXR 團隊將繼續透過 flutter.dev 上的公告、Flutter IDE Plugin 或 Twitter @FlutterDev 每季進行調查。請繼續提供您的想法，因為團隊正在尋找重要問題的答案。您也可以透過 <a href="https://docs.google.com/forms/d/e/1FAIpQLSe0i4De809KXVCdljGKrjMj3lxhuzbuFKCtY5PEQPCYtGxFMg/viewform">註冊即將到來的 UXR 研究</a> 來參與其他研究。</p>
<p>再次感謝所有參與本次調查並提供寶貴意見的各位。我們的目標是建立您喜歡的產品，我們感謝您撥冗幫助我們。</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1037fb8f057b" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/what-can-we-do-better-to-improve-flutter-q2-2021-user-survey-results-1037fb8f057b">我們如何才能讓 Flutter 變得更好？- 2021 年第二季使用者調查結果</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/ba84fd2d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/ba84fd2d.html" class="post-title-link" itemprop="url">【文章翻譯】Adding Flutter to your existing iOS and Android codebases</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-28 17:34:30" itemprop="dateCreated datePublished" datetime="2021-07-28T17:34:30+08:00">2021-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="將-Flutter-加入現有的-iOS-和-Android-程式碼庫"><a href="#將-Flutter-加入現有的-iOS-和-Android-程式碼庫" class="headerlink" title="將 Flutter 加入現有的 iOS 和 Android 程式碼庫"></a>將 Flutter 加入現有的 iOS 和 Android 程式碼庫</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*xYlql5GqpIvedZvkJxGcaA.png" />
</figure>

<p>無論您是為小型代理商工作，為眾多客戶建立行動應用程式，還是為擁有數百個內部應用程式的龐大企業開發，支援多個程式碼庫都可能很困難且昂貴（如果真的要做到）。我們驚訝地發現，一個常見的場景是，一些公司有數十甚至數百個應用程式是用於一個主要的行動平台，但沒有為另一個平台開發。這會讓他們許多使用者（通常是員工）無法像其他人一樣高效地執行相同的任務，從而可能導致價值流失。</p>
<p>Flutter 是一個可以從單一程式碼庫支援多個平台的 UI 架構，它可以幫助解決這些問題。雖然在理想情況下，您可以使用 Flutter 從頭開始建立應用程式，但當公司已經投入時間和金錢開發一個或多個平台的應用程式時，這個計劃通常行不通。</p>
<p>在本教程中，我們將透過學習稱為 <strong><em>add-to-app</em></strong> 的功能，探討一種更務實的方法，即隨著時間推移逐步將現有的 iOS 或 Android 應用程式轉換為 Flutter。雖然此功能並不能立即為您提供完整的 Flutter 應用程式，但它允許您在轉換過程中保持與當前程式碼庫的功能一致性和穩定性，而不是需要完整的重構，而重構可能會充滿意想不到的問題和「陷阱」。</p>
<p>在我們逐步完成本教程時，我們將從一個簡單的基本案例應用程式開始，與您期望從「<a href="https://en.wikipedia.org/wiki/%22Hello,_World!%22_program">你好，世界！</a>」範例中得到的結果類似，適用於 iOS 和 Android，而不是加入已經存在的實際應用程式的複雜性。之後，我們將建立將為每個平台新增新視圖（用 Flutter 編寫）所需的基礎架構。在實作 add-to-app 時，預期您已經具備一些 Flutter 的經驗，但本教程盡可能保持簡單，以便專注於如何將 Flutter 加入非 Flutter 應用程式。透過這種方式，您最終將擁有必要的詞彙，並知道在您準備好自己嘗試時該去哪裡尋找。</p>
<p>讓我們開始進行吧！</p>
<h3 id="Flutter-安裝"><a href="#Flutter-安裝" class="headerlink" title="Flutter 安裝"></a>Flutter 安裝</h3><p>如果您尚未在電腦上安裝 Flutter SDK，現在正是時候。請按照 <a href="https://flutter.dev/docs/get-started/install">此連結</a> 中的說明來設定您的機器。我會在這裡等您：) 如果你想在沒有跟著做的情況下繼續閱讀，那也是完全可以的。</p>
<p>…</p>
<p>都準備好了嗎？太棒了！</p>
<p>因此，將 Flutter 加入現有應用程式的第一步是，毫不意外地，建立一個要加入應用程式的 Flutter 元件。從命令列介面，導航到您想要儲存 Flutter 模組的目錄，並使用 Flutter CLI 工具執行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create --template module add_to_app_flutter_module</span><br></pre></td></tr></table></figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*99QwoGv8y0bLsB7rzal4Uw.png" />
</figure>


<p>這會建立一個基本 Flutter 應用程式並將其放置在一個名為 add_to_app_flutter_module 的新目錄中，不過您可以隨意為模組命名 - 本教程假設您使用的是 add_to_app_flutter_module 名稱。</p>
<h3 id="iOS-安裝"><a href="#iOS-安裝" class="headerlink" title="iOS 安裝"></a>iOS 安裝</h3><p>通常，在實作 add-to-app 功能時，您已經有現有的 iOS 或 Android 應用程式。在本教程中，您將從頭開始建立新的應用程式，以便專注於實作基礎。您將從 Xcode 中建立一個全新的 iOS 應用程式開始。如果您沒有使用 Mac 電腦或為 iOS 開發，請隨時跳到 Android 部分，或繼續閱讀以了解此過程。我只會有點失望您沒有閱讀全部內容。啟動 Xcode。當出現第一個選項螢幕時，選擇 <strong>App</strong> 並點擊 <strong>Next</strong>。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*71k72zGf7k8gwQhoapobIQ.png" />
</figure>

<p>在下一頁，適當地填寫文字欄位。在本教程中，使用 <strong>Storyboard</strong> 介面、<strong>Swift</strong> 作為語言，以及 <strong>UIKit App Delegate</strong> 作為生命週期。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Q8oBiSt7DNywtG0z0PXm_A.png" />
</figure>

<p>此時，系統會提示您在電腦上的某個位置建立一個新的目錄，並將您的應用程式放置到其中。在本教程中，將新的 iOS 專案資料夾儲存在與您之前建立的 Flutter 模組相同的父目錄中。建立該目錄後，您將進入 Xcode 專案螢幕，資料夾結構類似於此：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/508/1*WDZwukEh-RHLPByOtEn6Bg.png" />
</figure>

<p>回到命令列，導航到您在上一步中建立的新的 iOS 專案目錄，並使用以下命令初始化 CocoaPods：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod init</span><br></pre></td></tr></table></figure>

<p>初始化 Podfile 後，從 CLI 打開它，並將其內容替換為以下內容（請記住將目標名稱從 <em>Add-to-App</em> 更改為反映您自己的應用程式名稱，並將 flutter_application_path 更改為與 Flutter 模組的路徑匹配，如果您使用的是不同的值）：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5a3461edaa403dc928c4cc82259191f9/href">https://medium.com/media/5a3461edaa403dc928c4cc82259191f9/href</a></iframe>

<p>更新 Podfile 後，儲存檔案並執行以下命令將 Flutter 模組連結到新的 iOS 專案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>

<h3 id="從-iOS-應用程式打開預設-Flutter-頁面"><a href="#從-iOS-應用程式打開預設-Flutter-頁面" class="headerlink" title="從 iOS 應用程式打開預設 Flutter 頁面"></a>從 iOS 應用程式打開預設 Flutter 頁面</h3><p>現在 Flutter 模組和 iOS 專案已連結，是時候學習如何從 iOS ViewController 導航到行動應用程式中的 Flutter 頁面了。首先打開 <strong>AppDelegate.swift</strong> 檔案，將類別設定為繼承 FlutterAppDelegate 而不是預設的 UIAppDelegate。您還想定義一個新的 FlutterEngine 物件，它是用於橋接原生 iOS 應用程式和 Flutter 類別的 Flutter 環境容器：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/082ee51f20cde17d84bdabc40d484792/href">https://medium.com/media/082ee51f20cde17d84bdabc40d484792/href</a></iframe>

<p>要完成 simpleFlutterAppDelegate 類別，請建立一個新的應用程式函數，在啟動 iOS 應用程式時註冊 FlutterEngine：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/75beb3aab5497d5f35bc23c6284adbbe/href">https://medium.com/media/75beb3aab5497d5f35bc23c6284adbbe/href</a></iframe>

<p>在 AppDelegate 類別中，您只需要執行這些操作（暫時如此）。要啟動預設的 Flutter 螢幕，請轉到專案的 <strong>ViewController.swift</strong> 檔案（不過，在更完善的應用程式中，您可以使用任何 ViewController）。新增一個名為 showFlutter() 的函數，該函數會擷取 FlutterEngine，並使用預設的 Flutter 輸入點建立一個新的 FlutterViewController 物件，然後顯示它：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/aff84a5ae1f84bdc33e6a88d81122536/href">https://medium.com/media/aff84a5ae1f84bdc33e6a88d81122536/href</a></iframe>

<p>接下來，您需要一種方法來呼叫該函數。為簡單起見，直接在 Swift 程式碼中為螢幕定義一個按鈕，不過您可以使用任何適合您的其他導航模式或技術。在本教程中，建立一個新的 UIButton，將其置於螢幕中間，將新的 showFlutter() 函數指定給按鈕的動作，然後將其附加到視圖，所有這些都來自 viewDidLoad() 生命週期函數：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/35769c462b2a1e0e52ca3c32abf186e7/href">https://medium.com/media/35769c462b2a1e0e52ca3c32abf186e7/href</a></iframe>

<p>現在嘗試執行應用程式。如果一切按預期進行（祈禱吧！），那麼您應該能夠啟動 iOS 應用程式，點擊 <em>顯示 Flutter！</em> 按鈕，然後觀看新的 Flutter 螢幕彈出：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/368/1*o4tMnqTbK73cRpJ8m4bhIw.gif" />
</figure>

<h3 id="Android-安裝"><a href="#Android-安裝" class="headerlink" title="Android 安裝"></a>Android 安裝</h3><p>現在您已經使 iOS&#x2F;Flutter 組合正常運作，是時候嘗試設定 Android 應用程式了。就像您對 iOS 專案所做的那樣，建立一個新的 Android 專案，並在第一個螢幕上選擇 <strong>基本活動</strong> 模板。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5lDz6tLm4M0LHZaF8GUYHA.png" />
</figure>

<p>在下一頁，為名稱和套件名稱填寫適當的資訊。為了使一切與此範例的 iOS 版本保持一致，請將您的專案儲存在與 Flutter 模組和 iOS 應用程式相同的父目錄下。您還需要確保在本教程中將專案的語言設定為 Kotlin，儘管相同 add-to-app 邏輯適用於使用 Java 編寫的 Android 應用程式。準備好後，點擊藍色的 <strong>完成</strong> 按鈕。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DMCxqTeZpSD5-b1RJY_pig.png" />
</figure>

<p>現在您有了基礎 Android 專案，新增您之前建立的 Flutter 模組。您可以透過轉到 <strong>檔案 -&gt; 新建 -&gt; 新模組…</strong> 來完成此操作。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*qZQDQmS47Pqvza3UucvEVA.png" />
</figure>

<p>從那裡，轉到新視窗底部的 <strong>匯入 Flutter 模組</strong> 選項，加入 Flutter 模組位置，然後點擊藍色的 <strong>完成</strong> 按鈕。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XeyFOIlwbKa8cOqlb3j4Cw.png" />
</figure>

<p>接下來，打開 <strong>settings.gradle</strong> 檔案，並將其內容替換為以下內容：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b234a9dd19a3a3a9cfdf73b8a08d3a1a/href">https://medium.com/media/b234a9dd19a3a3a9cfdf73b8a08d3a1a/href</a></iframe>

<p>這裡主要的部分是綁定並將 <strong>include_flutter.groovy</strong> 檔案加入到專案中。完成後，轉到專案級別的 <strong>build.gradle</strong> 檔案（位於 Android 專案的根目錄中），新增一個 allprojects 區塊，以便您可以編譯應用程式（這可能在以後不需要，但我遇到了 Android Studio Arctic Fox 的問題，因此我在這裡寫下來，以防有人用得上：)）</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5914fe5f6223aad361019c4eeec5ae27/href">https://medium.com/media/5914fe5f6223aad361019c4eeec5ae27/href</a></iframe>

<p>最後，打開 <em>應用程式級別</em> 的 <strong>build.gradle</strong> 檔案（位於 <em>your_project_name&#x2F;app</em> 目錄中），並在 dependencies 節點中新增一行，以將 Flutter 模組作為來源加入到 Android 專案中：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d5ea9e3d6281390e59a2431bb364dcbd/href">https://medium.com/media/d5ea9e3d6281390e59a2431bb364dcbd/href</a></iframe>

<p>此時，Android 應用程式應該可以編譯和建構，而且您會在 IDE 中看到 Flutter 模組。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/640/1*AbRB1VZYePJoXMk0sHN05A.png" />
</figure>

<h3 id="從-Android-應用程式打開預設-Flutter-頁面"><a href="#從-Android-應用程式打開預設-Flutter-頁面" class="headerlink" title="從 Android 應用程式打開預設 Flutter 頁面"></a>從 Android 應用程式打開預設 Flutter 頁面</h3><p>現在 Android 應用程式的安裝過程已完成，您需要準備好使用新的 Flutter 元件來啟動應用程式。幸運的是，現在安裝已完成，因此這相對容易。首先打開 <strong>AndroidManifest.xml</strong> 檔案。Flutter add-to-app 使用自訂 FlutterActivity 在 Android 中顯示 Flutter 內容，因此您需要確保在清單中宣告 FlutterActivity，方法是在 application 標籤內新增以下區塊：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/864ed107bf4cbdad1166e7d63c3d1f52/href">https://medium.com/media/864ed107bf4cbdad1166e7d63c3d1f52/href</a></iframe>

<p>接下來，打開 <strong>MainActivity.kt</strong> 檔案，並將應用程式 FloatingActionButton 顯示的 Snackbar 替換為以下程式碼，以啟動新的 FlutterActivity。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/5a3193658ee9998aab444caf583044c2/href">https://medium.com/media/5a3193658ee9998aab444caf583044c2/href</a></iframe>

<p>現在，當您點擊 FloatingActionButton 時，您應該會看到 Flutter 頁面直接在您的應用程式中彈出！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/346/1*0F312mW_EgR9554m6gcxWA.gif" />
</figure>

<p>除了能夠啟動完整的活動螢幕（類似於您之前在 iOS 中所做的），Android 的額外好處是能夠將 Flutter 元件作為 Fragment 或自訂視圖的一部分來啟動。雖然這兩種技術超出了本教程的範圍，但您可以在官方文件找到如何使用 <a href="https://flutter.dev/docs/development/add-to-app/android/add-flutter-fragment">FlutterFragment</a> 和 <a href="https://flutter.dev/docs/development/add-to-app/android/add-flutter-view">FlutterView</a>。</p>
<h3 id="開啟其他-Flutter-螢幕"><a href="#開啟其他-Flutter-螢幕" class="headerlink" title="開啟其他 Flutter 螢幕"></a>開啟其他 Flutter 螢幕</h3><p>雖然能夠直接從原生 iOS 或 Android 應用程式開啟 Flutter 螢幕很棒，但考慮到使用 add-to-app 的整個想法是您可以慢慢地實作各種 Flutter 功能，因此 <em>它實際上並沒有達到您想要的程度</em>。要做到這一點，您很可能需要多個輸入點和多個 Flutter 元件。幸運的是，有一種方法可以在原生應用程式中建立多個 Flutter 實例，不過值得注意的是，在撰寫本文時，此功能 <em>處於實驗階段</em>。雖然表面層面的東西很有可能保持不變，但也可能語法或其他細節會在日後發生變化。</p>
<p>首先，透過打開 <em>flutter 模組&#x2F;lib</em> 目錄中的 <strong>main.dart</strong>，更新 Flutter 模組中的程式碼以支援第二個螢幕。在 main.dart 中，透過在 main() 的宣告下方新增以下幾行，宣告您的第一個新的輸入點。請注意，此程式碼片段包含一個註釋，將此方法指定為應用程式中的新輸入點。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ea233ca8e7a30717c2a1248b04c7cfa6/href">https://medium.com/media/ea233ca8e7a30717c2a1248b04c7cfa6/href</a></iframe>

<p>MySecondAppScreen 只會返回一個具有綠色主題和新標題的新 MaterialApp，以便您可以區分它和 main() 輸入點。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7e4a43f565b3dadadce2db9650a468e1/href">https://medium.com/media/7e4a43f565b3dadadce2db9650a468e1/href</a></iframe>

<p>接下來，您可能會注意到您需要為 MySecondaryHomePage 建立另一個程式碼塊。這是一個新的 StatefulWidget，它包含 Flutter 螢幕的狀態物件。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e0075e4379e9a1ae2110c4b48a01a8f7/href">https://medium.com/media/e0075e4379e9a1ae2110c4b48a01a8f7/href</a></iframe>

<p>最後，建立新的狀態物件。在本範例中，Widget 會顯示 AppBar 和 Text Widget。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9df09644bdde328255366934c93b848f/href">https://medium.com/media/9df09644bdde328255366934c93b848f/href</a></iframe>

<p>您現在有兩個不同的 Flutter 螢幕可以從原生應用程式啟動。接下來，您將在現有的 Android 範例應用程式中實作新螢幕。</p>
<h3 id="Android-中的多個-Flutter-輸入點"><a href="#Android-中的多個-Flutter-輸入點" class="headerlink" title="Android 中的多個 Flutter 輸入點"></a>Android 中的多個 Flutter 輸入點</h3><p>此擴展的 add-to-app 功能透過建立 FlutterEngine 類別的多個實例（與用於顯示單一預設 Flutter 螢幕的工具相同）並將它們儲存在 FlutterEngineGroup 中來執行，然後在需要時呼叫適當的引擎。首先，建立一個新的應用程式類別來初始化 FlutterEngineGroup。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/1874717ba2d4d487f0c27f54b85f4501/href">https://medium.com/media/1874717ba2d4d487f0c27f54b85f4501/href</a></iframe>

<p>接下來，建立一個輔助類別，在本例中名為 EngineBindings，它會接收輸入點的名稱，並將其懶加載到 FlutterEngineGroup 中，以便可以在原生應用程式中顯示它。這是懶加載的，因為您需要確保應用程式已完全載入，然後再開始建立 FlutterEngine，否則您可能會遇到意想不到的（且難以除錯）競爭條件。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c66a7cc80c0923aa8795ba0a71e9c840/href">https://medium.com/media/c66a7cc80c0923aa8795ba0a71e9c840/href</a></iframe>

<p>您需要加入的最後一個類別會擴展您在上一節 Android 中使用的 FlutterActivity。建立一個名為 <strong>SingleFlutterActivity.kt</strong> 的新的 Kotlin 類別檔案，它會擴展 FlutterActivity：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/49cef27d6145fd5c45d09e4c965b9f0c/href">https://medium.com/media/49cef27d6145fd5c45d09e4c965b9f0c/href</a></iframe>

<p>在此檔案中，透過傳入新的輸入點名稱（在本例中為 <strong>“secondary”</strong>）來初始化 EngineBindings，以匹配您在 Dart 檔案中新增的輸入點的名稱，並為擷取適當的引擎撰寫一個輔助方法：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f3ed277ea9b2a5672d65e32376ef34f0/href">https://medium.com/media/f3ed277ea9b2a5672d65e32376ef34f0/href</a></iframe>

<p>要完成 FlutterActivity，請使用新建立的引擎從 <code>onCreate()</code> 顯示 Flutter 螢幕。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f3df93438410f99b3fd8683543a1c5c3/href">https://medium.com/media/f3df93438410f99b3fd8683543a1c5c3/href</a></iframe>

<p>接下來，您只需要再做幾件事就能完成此範例應用程式。回到 MainActivity，轉到原本用於啟動主要 Flutter 螢幕的 FloatingActionButton，並更改 Intent，使其啟動新的 SingleFlutterActivity 類別。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c3fb86b678c665b5a4a21167a1f286c1/href">https://medium.com/media/c3fb86b678c665b5a4a21167a1f286c1/href</a></iframe>

<p>最後，打開 <strong>AndroidManifest.xml</strong>，將新的應用程式類別與 application 標籤關聯起來，並新增 SingleFlutterActivity 的活動標籤。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/3166253a1f8d7ac490935790f60d64c4/href">https://medium.com/media/3166253a1f8d7ac490935790f60d64c4/href</a></iframe>

<p>您現在應該能夠執行應用程式，點擊 FloatingActionButton，並看到新的螢幕，而不是預設的 Flutter Widget。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/346/1*jQUUrVeSYGvjM4zgrt-zNg.gif" />
</figure>

<h3 id="iOS-中的多個-Flutter-輸入點"><a href="#iOS-中的多個-Flutter-輸入點" class="headerlink" title="iOS 中的多個 Flutter 輸入點"></a>iOS 中的多個 Flutter 輸入點</h3><p>您還在嗎？太好了！</p>
<p>接下來，您將在 iOS 範例應用程式中新增對多個輸入點的支援。回到 Xcode，打開 AppDelegate 類別，並將所有程式碼替換為這個簡化的版本，它會建立一個單一的 FlutterEngineGroup，可以在整個應用程式中訪問。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8271345d88a1e2b9fe910b9e58f914a5/href">https://medium.com/media/8271345d88a1e2b9fe910b9e58f914a5/href</a></iframe>

<p>類似於您在 Android 應用程式中所做的，建立一個名為 <strong>SingleFlutterViewController.swift</strong> 的新檔案，它會擴展標準的 FlutterViewController。此類別會接收一個包含您想要使用的輸入點名稱的字串，然後建立並顯示一個新的 FlutterEngine。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ddd4e938cb47b74729e137fb47ba32a1/href">https://medium.com/media/ddd4e938cb47b74729e137fb47ba32a1/href</a></iframe>

<p>最後，返回基礎 ViewController 類別，並更新 showFlutter() 函數，以便它使用指定的輸入點顯示新的 SingleFlutterViewController 類別。</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2b3785e8faaeaa2b01befb697584c893/href">https://medium.com/media/2b3785e8faaeaa2b01befb697584c893/href</a></iframe>

<p>更新完程式碼後，更新 Podfile 以使用 Flutter 模組的最新版本，因為您已將新的輸入點和螢幕程式碼新增到 <strong>main.dart</strong> 中。完成後，您應該能夠建構和執行 iOS 應用程式，以查看您的原生程式碼切換到新的 Flutter 元件。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/412/1*scdrE_wYehIvimaJhOUklQ.gif" />
</figure>

<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>嘿，您做到了！恭喜！</p>
<p>在本教程中，您學習了如何將 Flutter 逐步新增到現有的 Android 和 iOS 應用程式中，以建立一個統一且更易於維護的程式碼庫。您已經了解了如何在兩個平台上從單一輸入點新增 Flutter，以及如何建立多個輸入點。如果您有興趣了解更多資訊，我在下方包含了一個連結，連結到 Flutter 的官方文件頁面，該頁面提供了有關 add-to-app 的更多細節資訊，以及討論 <strong><em>平台通道</em></strong> 的連結，平台通道允許您在 Flutter 和原生級別程式碼之間來回通訊。最後，請查看討論 Plugin 和如何撰寫自己的 Plugin 的連結，這些連結可以讓使用 Flutter 為多個平台開發變得更容易，無論是對您還是對開發人員社群。</p>
<p>我們期待看到您的跨平台應用程式實際運作！</p>
<ul>
<li><a href="https://flutter.dev/docs/development/add-to-app">將 Flutter 加入現有應用程式</a></li>
<li><a href="https://flutter.dev/docs/development/platform-integration/platform-channels">撰寫自訂平台特定程式碼</a></li>
<li><a href="https://flutter.dev/docs/development/packages-and-plugins/using-packages">使用套件</a></li>
<li><a href="https://flutter.dev/docs/development/packages-and-plugins/developing-packages">開發套件和 Plugin</a></li>
</ul>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3e2c5a4797c1" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/adding-flutter-to-your-existing-ios-and-android-codebases-3e2c5a4797c1">將 Flutter 加入現有的 iOS 和 Android 程式碼庫</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/faf6e4ac.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/faf6e4ac.html" class="post-title-link" itemprop="url">【文章翻譯】Google I/O spotlight: Flutter in action at ByteDance</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-29 08:15:08" itemprop="dateCreated datePublished" datetime="2021-06-29T08:15:08+08:00">2021-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 20:22:51" itemprop="dateModified" datetime="2024-09-30T20:22:51+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Google-I-O-聚焦：字节跳动-Flutter-实战"><a href="#Google-I-O-聚焦：字节跳动-Flutter-实战" class="headerlink" title="Google I&#x2F;O 聚焦：字节跳动 Flutter 实战"></a>Google I&#x2F;O 聚焦：字节跳动 Flutter 实战</h2><p><em>Note: This article was originally written in Chinese by the ByteDance team and translated into English.</em></p>
<p>Flutter, a technology that ByteDance has been utilizing and contributing to for several years now, was recently highlighted on the main stage of Google I&#x2F;O. Developed and open-sourced by Google, the multi-platform framework for front-end UI development has garnered over 120,000 stars on GitHub.</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*s0fEzRKPUlPITzxE" />
<figcaption>At Google I/O, Zoey Fan, one of Flutter's product managers, talked about how the framework was adopted at ByteDance.</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*V8DV37bsn0UNXkvE" />
<figcaption>More than 70 apps by ByteDance use Flutter as their multi-platform solution.</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*jfsCt8xhuizJO7uf" />
<figcaption>Flutter has reduced development time by 33%, as compared to developing separate apps for Android and iOS.</figcaption>
</figure>

<p>Today, there are over 500 Flutter developers at ByteDance, with over 200 actively developing with the framework. These developers utilize Flutter not only for mobile apps but also experiment with it on web, desktop, and embedded platforms.</p>
<p>Beyond this, ByteDance has conducted fundamental work throughout the organization and made significant contributions to the Flutter project by submitting dozens of pull requests (PRs).</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/928/0*84RzNeoAVCQu3shZ" />
</figure>

<h3 id="How-did-ByteDance-make-Flutter-truly-work-for-them"><a href="#How-did-ByteDance-make-Flutter-truly-work-for-them" class="headerlink" title="How did ByteDance make Flutter truly work for them?"></a>How did ByteDance make Flutter truly work for them?</h3><p>The story of Flutter at ByteDance began two years ago.</p>
<p>At the time, the ByteDance front-end engineering team noticed that many teams within the company needed to develop for multiple platforms, but lacked a tool to achieve high-efficiency, high-performance, multi-platform development.</p>
<p>When Google open-sourced Flutter, the ByteDance team discovered that with Flutter, they only needed to develop the app once to support platforms such as Android, iOS, and web. Also, because Flutter has its own rendering engine, they could achieve more consistent performance across platforms.</p>
<p>With Flutter, the Android, iOS, and web versions of an app automatically stay in sync. There is no need to design and program the UI separately for each platform, eliminating a significant portion of redundant work.</p>
<p>To support business development more efficiently, the ByteDance team performed fundamental work on the framework itself, such as optimizing performance, creating app frameworks, containerizing, and supporting “add to app.” They also improved Flutter performance tools, including improvements to the Frames Per Second (FPS) info in the <a href="https://flutter.dev/docs/development/tools/devtools/performance#flutter-frames-chart">Frame chart</a> and the <a href="https://flutter.dev/docs/development/tools/devtools/performance#timeline-events-chart">timeline events chart</a>. Both of these charts are part of the <a href="https://flutter.dev/docs/development/tools/devtools/performance">Performance View</a> in <a href="https://flutter.dev/docs/development/tools/devtools/overview">Flutter DevTools</a>.</p>
<p>When adopting Flutter, the ByteDance team encountered some unique challenges. For example, Flutter must be added to the app installation package, increasing the size of the app downloaded by users. Additionally, Flutter uses the Dart programming language, which is larger in size than native code, further increasing the package size.</p>
<p>The ByteDance team started a special plan to optimize the package size by compressing the iOS data section and stripping out the Skia library and other libraries (such as BoringSSL, ICU, text rendering, and libwebp). They analyzed Flutter Dart code against iOS native code and found that to implement the same business feature, the Dart code generated more machine code instructions. To close the gap, they reduced alignment of instructions, removed debugging trap instructions, dropped redundant initialization of stores with null, removed RawInstruction headers with bare instructions mode, compressed StackMaps, removed CodeSourceMap, and so on.</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*SHp5ZrnQvQ_bva8K" />
</figure>

<p>Individually, each of these optimizations reduced the package size by 0.2 to 4 MB and significantly reduced the total package size when combined. The ByteDance team shared their experience with Google engineers, and many improvements made their way to the Flutter open source project for the benefit of the larger community.</p>
<p>However, when ByteDance released their first Flutter app, new issues emerged. Users asked: ‘Why is the UI so janky when I scroll in the app?’</p>
<p>When the ByteDance team looked into the issue, they saw that when a FlutterView extended a TextureView, the UI was noticeably jankier than when it extended SurfaceView. However, in the official <a href="https://flutter.dev/docs/development/tools/devtools/performance#timeline-events-chart">Timeline</a> tool, the UI thread time and GPU thread time for each rendered frame are about the same, with TextureView pulling a bit ahead occasionally.</p>
<p>The metrics contradicted the real-world user experience, which puzzled the team.</p>
<p>At first, the team used the <a href="https://flutter.dev/docs/development/tools/devtools/performance#timeline-events-chart">Timeline</a> tool to troubleshoot the issue, to no avail. After digging into the tool’s source code, they discovered the root cause of the issue.</p>
<p>SurfaceView had better performance than TextureView. Because SurfaceView had its own surface, and rendering was performed in its own OpenGL context, it could interact with SurfaceFlinger independently and took full advantage of triple-buffering. On the other hand, TextureView was a regular view that depended on the surface of its host window for rendering. That meant the rendering wasn’t performed immediately after the UI and GPU threads had finished their work but needed to wait for the native main thread and renderThread before the view could interact with SurfaceFlinger. That was a much longer rendering pipeline than that of SurfaceView.</p>
<p>These findings not only helped the team eliminate the jank but led to 10 PRs being submitted to the Flutter open source project. With this fundamental work done, Flutter eventually became the go-to framework for multi-platform app development at ByteDance. Soon, the ByteDance team’s work with Flutter will be available to external developers using their mobile development framework, <a href="https://www.volcengine.com/product/vemars">veMARS</a>, benefiting the entire developer community.</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/928/0*3xKb80lXnsfJg3pP" />
</figure>

<h3 id="From-experiment-to-production-How-ByteDance-put-Flutter-into-use"><a href="#From-experiment-to-production-How-ByteDance-put-Flutter-into-use" class="headerlink" title="From experiment to production: How ByteDance put Flutter into use"></a>From experiment to production: How ByteDance put Flutter into use</h3><p>It wasn’t exactly smooth sailing for ByteDance to put Flutter into real-world use.</p>
<p>At first, the ByteDance team chose a mature product and planned to re-implement the app’s video playback feature with Flutter.</p>
<p>The feature, originally written in native code for Android and iOS, wasn’t straightforward to rewrite with Flutter. After six months, the team came to the conclusion that it would be difficult to make all the live data compatible and challenging to update the existing business logic.</p>
<p>The team decided that it wasn’t productive to update the existing features of a mature product with the new framework. Flutter’s strengths would be better used in a brand-new app. The team lead said, “In a mature product, everything is already well built with native Android or iOS technology. There isn’t much gain in re-implementing the features with Flutter only to make minor improvements. It also increases the package size since the Flutter engine is included in the package. In new products or new scenarios, however, Flutter can greatly increase our productivity.”</p>
<p>With this changed mindset, the team turned their focus to new business areas such as education.</p>
<p>One of their education apps in China helps students learn the order of strokes of Chinese characters; the team wanted to add a stroke tracking feature.</p>
<p>To implement it, the team took inspiration from some open-source projects and decided to use SVG paths to represent strokes. The paths would then be adjusted and positioned to compose the characters:</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*eJK4geRY6r6kvPb-" />
</figure>

<p>They defined the skeleton of each stroke to guide the movement of the virtual brush pen, so the pen moves just like it would in calligraphy:</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*KRHUVfNaxppJLr86" />
</figure>

<p>Based on the defined order of the skeletons, a circle with a certain radius is drawn along each skeleton, and together these circles form the stroke. After that, the team added keyframes to ensure that the frame rate of the animation is high enough to avoid jank.</p>
<p>That is how they created the smooth tracking effect, as shown in the following GIF:</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/600/0*WeR31rSBMqkRT6q_" />
</figure>

<p>The feature, built with Flutter, now supports over 9,000 Chinese characters, including most of the commonly used characters. Compared to developing with native code, Flutter saved time and resources.</p>
<p>Today, many apps by ByteDance employ a hybrid approach to development, combining the strengths of Flutter and other technologies, with newer apps leaning towards pure Flutter. For apps such as Xigua Video, TikTok Volcano, and Open Language, Flutter increased the productivity of the teams by about 33%.</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/928/0*h1swTfindfOd_uAB" />
</figure>

<h3 id="ByteDancers-Embrace-the-Latest-Technology"><a href="#ByteDancers-Embrace-the-Latest-Technology" class="headerlink" title="ByteDancers Embrace the Latest Technology"></a>ByteDancers Embrace the Latest Technology</h3><p>Even now, the Flutter team at ByteDance continues to explore the latest technologies. According to the team lead, “We have in our team many tech enthusiasts with global vision, and will continue to explore global technology developments and discuss the implementation of technology. We have close connections and collaborations with many tech companies. We have quarterly sync meetings with Google, for instance, to exchange progress, thoughts, needs, and ideas from both sides.”</p>
<p>One day, the maintainer of the Dart open source project on GitHub came to the ByteDance team lead with the following remarks, “Someone from your team submitted more than a dozen PRs to Dart and they’re all very good and well thought out.”</p>
<p>The Dart open source project maintainer was talking about Frank. Frank is a passionate open-source contributor and just got his bachelor’s degree three years ago. His journey in the open source world first started during his first year of university in 2015. One of the projects he created and open-sourced on GitHub had over 700 stars. “It has had hundreds of downloads per year, and many game developers use it to create demos”, Frank said.</p>
<p>After graduation, Frank joined the Flutter team at ByteDance and became one of the most active open-source contributors on the team, contributing a number of PRs to Dart and Flutter. Frank remembers that when he was working on the package size issues, he proactively followed up on a relevant issue on the Dart GitHub project and noticed that the Specializer component could use some further tuning. He created a patch with his improvements to the Dart compiler middleware and submitted it to the project. The patch wasn’t accepted initially because of the large number of code blocks affected and a few minor concerns. He modified the patch seven times before it was accepted, and it was merged into the code base a week later.</p>
<p>There are many other open-source enthusiasts like Frank in the Flutter team at ByteDance.</p>
<p>The ByteDance team summarized this passionate attitude toward innovation with the following words:</p>
<p>“There are indeed many people in the industry who prefer mature technology, but it takes time for every technology to mature, and there will always be people like us who love to stay on the cutting edge.”</p>
<p>This is especially true for something as novel as Flutter. There needs to be some daring people who take the first steps. At ByteDance, the Flutter engineering team, as well as the engineering teams that they support, actively try and embrace new technologies. Doing this benefited ByteDance tremendously and greatly increased our productivity.</p>
<p>ByteDance has always wanted to be part of things that could push the industry forward, and Flutter is likely to be one of those things.</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c22f4b6dc9ef" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/google-i-o-spotlight-flutter-in-action-at-bytedance-c22f4b6dc9ef">Google I&#x2F;O spotlight: Flutter in action at ByteDance</a> was originally published in <a href="https://medium.com/flutter">Flutter</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/31aeddc4.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/31aeddc4.html" class="post-title-link" itemprop="url">【文章翻譯】Improving Platform Channel Performance in Flutter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-06-14 18:00:28" itemprop="dateCreated datePublished" datetime="2021-06-14T18:00:28+08:00">2021-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*0lyQIh8t-STSy1o2Yjj1tQ.png" /></figure>

<p>過去幾年，我一直對「如何讓 Flutter 與其主機平台之間的通訊更快、更容易？」這個問題感到興趣。這對 Flutter Plugin 開發人員和增加到應用程式開發人員來說，是一個特別感興趣的問題。</p>

<p>Flutter 與主機平台之間的通訊通常使用 [平台通道](https://flutter.dev/docs/development/platform-integration/platform-channels) 完成，因此我的精力一直集中在這裡。在 2019 年後期，為了解決使用平台通道所需的過多樣板和 [字串類型](https://wiki.c2.com/?StringlyTyped) 程式碼，我設計了一個程式碼產生套件 [Pigeon](https://pub.dev/packages/pigeon)，它使平台通道類型安全，並且團隊持續改進它。在 2020 年春季，我對 [平台通道和外部函式介面 (FFI) 效能進行了審查](https://docs.google.com/document/d/1bD_tiN987fWEPtw7tjXHzqZVg_g9H95IS32Cm609VZ8/edit)。現在，我將目光放在 [改進平台通道的效能](https://docs.google.com/document/d/1oNLxJr_ZqjENVhF94-PqxsGPx0qGXx-pRJxXL6LSagc/edit?usp=sharing) 上。由於 Pigeon 建立在平台通道之上，而我計畫在 Pigeon 之上建立一個 [多個 Flutter 實例的資料同步解決方案](http://flutter.dev/go/data-sync)，這是一個很好的機會，可以幫助滿足開發人員的許多不同需求，以及我的計劃。</p>

<p>經過一番調查，我能夠識別出透過平台通道傳送的資料的冗餘副本，並且能夠將其移除。您將在下面找到該變更的結果以及識別和移除這些副本的相關工作概述。</p>

<h3>結果</h3>

<p>在移除透過平台通道從 Flutter 傳送到主機平台的 1 MB 二元資料時，並響應 1 MB 的資料，我們看到 [iOS 上的效能大約提高了 42%](https://flutter-flutter-perf.skia.org/e/?begin=1620764044&amp;end=1621044607&amp;queries=sub_result%3Dplatform_channel_basic_binary_2host_1MB%26test%3Dmac_ios_platform_channels_benchmarks_ios&amp;requestType=0)。在 Android 上，結果稍微複雜一些。我們的自動化效能測試 [大約提高了 15%](https://flutter-flutter-perf.skia.org/e/?begin=1621972627&amp;end=1622677144&amp;queries=sub_result%3Dplatform_channel_basic_binary_2host_1MB%26test%3Dlinux_platform_channels_benchmarks&amp;requestType=0)，而本地測試在遷移到新的 [BinaryCodec.INSTANCE_DIRECT](https://github.com/flutter/engine/blob/b3ebb6dd62cefe3c30a7bd15ed73c578030140e2/shell/platform/android/io/flutter/plugin/common/BinaryCodec.java#L27) 編碼器時，[大約提高了 52%](https://github.com/flutter/engine/pull/26331#issuecomment-854071096)。這種差異可能是因為自動化效能測試在舊設備上運行，但也可能是微基準測試在舊設備上的執行方式產生的假象（例如，不斷地讓垃圾收集器執行）。您可以在 [platform_channels_benchmarks/lib/main.dart](https://github.com/flutter/flutter/blob/00bfe9061369bb6fdfe4a74fb27086b77df107bf/dev/benchmarks/platform_channels_benchmarks/lib/main.dart#L165) 中找到自動化效能測試的原始碼。</p>

<p>對於使用 StandardMessageCodec 的平台通道，我發現效能增益較小（[使用 14k 負載大約為 5%](https://flutter-flutter-perf.skia.org/e/?begin=1620764044&amp;end=1621044607&amp;queries=sub_result%3Dplatform_channel_basic_standard_2host_large%26test%3Dmac_ios_platform_channels_benchmarks_ios&amp;requestType=0)）。我使用一個大型支援類型陣列對其進行測試，以對編碼和解碼進行壓力測試。我發現，MessageCodecs 的編碼和解碼時間遠遠超過在平台之間複製訊息所花費的時間。大部分的編碼時間都是由於對資料結構進行遞迴，並使用反射來找出其內容的成本所致。</p>

<p>因此，根據您使用平台通道的方式和設備，您的結果可能會有很大差異。如果您想要使用平台通道進行最快的通訊，那麼您應該使用 BasicMessageChannels，並在 iOS 上使用 [FlutterBinaryCodec](https://github.com/flutter/engine/blob/b3ebb6dd62cefe3c30a7bd15ed73c578030140e2/shell/platform/darwin/common/framework/Headers/FlutterCodecs.h#L52)，在 Android 上使用 [BinaryCodec.INSTANCE_DIRECT](https://github.com/flutter/engine/blob/b3ebb6dd62cefe3c30a7bd15ed73c578030140e2/shell/platform/android/io/flutter/plugin/common/BinaryCodec.java#L27)，並為編碼和解碼訊息開發自己的協定，該協定不依賴於反射。（實作新的 MessageCodec 可能更乾淨。）</p>

<p>如果您想試用新的、更快的平台通道，它們現在已在 [master 通道](https://flutter.dev/docs/development/tools/sdk/upgrading#switching-flutter-channels) 上提供。</p>

<h3>詳細複製移除</h3>

<p>如果您對如何實現這些結果以及我必須克服的問題不感興趣，那麼現在就可以停止閱讀了。如果您喜歡了解詳細資訊，請继续阅读。</p>

<p>平台通道 API 自 2017 年以來沒有太大變化。由於平台通道是引擎和 Plugin 操作的基礎，因此它們不容易更改。雖然我對平台通道的運作方式有一定的了解，但它們在一定程度上是複雜的。因此，改進其效能的第一步是準確地了解它們的運作方式。</p>

<p>下圖概述了框架在使用平台通道與 iOS 進行通訊時從 Flutter 遵循的原始流程：</p>

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1002/0*2fUEEmUdocImYO4x" /></figure>

<p>圖表中的一些收穫：</p>

<ul>
<li>訊息會從 UI 線程跳轉到平台線程，然後再跳回 UI 線程。（在 Flutter 引擎術語中，UI 線程是執行 Dart 的位置，而平台線程是主機平台的主線程。）</li>
<li>訊息及其響應使用 C++ 作為介於 Flutter 與主機平台目標語言之間的介面層。</li>
<li>訊息的資訊在到達 Objective-C (Obj-C) 處理程式之前被複製了 4 次（步驟 3、5、7、8）。步驟 3 和 8 執行翻譯，而步驟 5 和 8 執行複製，將資料的所有權轉移到新的記憶體佈局。相同的過程反向重複以進行回覆。</li>
<li>步驟 1、9 和 16 是使用 Flutter 的開發人員編寫的程式碼。</li>
</ul>

<p>從 Flutter 傳送訊息到 Java/Kotlin 類似，只是在 C++ 和 Java 虛擬機器 (JVM) 之間有一個 Java 本機介面 (JNI) 層。</p>

<p>在確定平台通道的運作方式後，很明顯，消除在這些層之間傳輸資料時進行的複製（例如，從 C++ 到 Obj-C）是改進效能的顯而易見的方法。為了實現這一點，Flutter 引擎必須將資料放置在記憶體中，以使其可以直接從 Java/Obj-C 存取，並且具有與主機平台相容的記憶體管理語義。</p>

<p>平台通道訊息最終由主機平台的 MessageCodec 的 decodeMessage 方法使用。在 Android 上，這意味著一個 [ByteBuffer](https://github.com/flutter/engine/blob/58459a5e342f84c755919f2ad5029b22bcddd548/shell/platform/android/io/flutter/plugin/common/MessageCodec.java#L38)，在 iOS 上，這意味著一個 [NSData](https://github.com/flutter/engine/blob/58459a5e342f84c755919f2ad5029b22bcddd548/shell/platform/darwin/common/framework/Headers/FlutterCodecs.h#L38)。C++ 中的資料必須符合這些介面。在處理此問題時，我發現訊息的資訊儲存在 C++ 記憶體中，作為一個 [std::vector](https://github.com/flutter/engine/blob/70ebfc3610c38c463469ffedea85578f35ccc0a0/lib/ui/window/platform_message.h#L39)，位於由 [共用指標](https://en.wikipedia.org/wiki/Smart_pointer) 維護的 PlatformMessage 物件中。這意味著開發人員在將資料從 C++ 傳送到主機平台時，無法安全地移除複製，因為他們沒有保證資料在傳送到主機平台後不會被 C++ 變異。此外，我必須小心，因為 BinaryCodec 實作將 encodeMessage 和 decodeMessage 視為無操作，這可能導致使用 BinaryCodec 的程式碼在不知情的情況下收到直接 ByteBuffer。雖然有人可能會對 MessageCodec 的變更感到意外，但很少有人實作自己的編碼器。另一方面，使用 BinaryCodecs 非常普遍。</p>

<p>在閱讀程式碼後，我發現，雖然 PlatformMessage 由共用指標管理，但它在語義上是唯一的指標。目的是一次只允許一個客戶端存取它（這並不完全是這樣，因為在線程之間傳遞 PlatformMessage 時，暫時會存在多個副本，但这僅僅是为了方便，而并非真正意图）。這意味著我們可以從共用指標遷移到唯一指標，允許我們安全地將資料傳遞到主機平台。</p>

<p>在 [遷移到唯一指標](https://github.com/flutter/engine/commit/7424400f07be684bd87633bbe2d263821181345a#diff-d5a1c9b29bed0d80dc68f228550643925a216e65173364e1ae5a03067b60160d) 後，我必須找到一種方法，將資訊的所有權從 C++ 傳遞到 Obj-C。（我首先實作了 Obj-C，稍後將更詳細地討論 Java）。資訊儲存在一個 std::vector 中，它沒有辦法釋放底層緩衝區的所有權。您唯一的选择是复制出数据、提供一个包含std::vector的适配器、或消除std::vector的使用。</p>

<p>我的第一次嘗試是子類化 NSData，它會 std::move std::vector 並從那裡讀取其資料，從而消除複製。這種嘗試效果不佳，因為結果證明 NSData 是 [Foundation](https://developer.apple.com/documentation/foundation?language=objc) 中的 [類別叢集](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html)。這意味著您不能只子類化 NSData。在閱讀了許多 Apple 的文件之後，他們似乎建議使用組合和訊息轉發，使物件的行為和外觀像 NSData 一樣。這會欺騙使用代理物件的人，除了那些呼叫 -[NSObject isKindOfClass:] 的人以外。雖然這不太可能，但我無法排除這種可能性。雖然我認為可能有一些與 Obj-C 執行時相關的調整，可以使物件按照我想要的方式運行，但它變得越來越複雜。我選擇將記憶體從 std::vector 移動到 [我們自己的緩衝區類別](https://github.com/flutter/engine/commit/b0bb8eab1d2f7e58230298c28a28ddfeddedeb64#diff-d5a1c9b29bed0d80dc68f228550643925a216e65173364e1ae5a03067b60160d) 中，該類別允許釋放資料的所有權。這樣，我就可以使用 -[NSData dataWithBytesNoCopy:length:] 將資料的所有權傳遞到 Obj-C。</p>

<p>在 Android 上複製這個過程證明更困難。在 Android 上，平台通道符合 ByteBuffer，它具有 [直接](https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html) [ByteBuffers](https://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html) 的概念，允許 Java 程式碼直接與以 C/C++ 方式佈局的記憶體進行介面。我在短時間內實作了遷移到直接 ByteBuffers，但我沒有看到預期的改進。我花費了很長時間學習 Android 分析工具，最終選擇了追蹤語句，因為那些工具失敗了，或者返回了我無法相信的結果。事實證明，從平台線程到 UI 線程排程對平台通道訊息的回覆非常慢，而且似乎慢到這種程度，這種減速程度會隨著訊息的負載而增加。長話短說，我在編譯 Dart VM 時使用了錯誤的編譯標誌，以為 -no-optimization 代表 -no-link-time optimization，但該標誌實際上是針對運行時優化的。</p>

<p>在我發現自己的錯誤時，我忘記了在將資料傳送到 Flutter 客戶端程式碼（特別是透過自訂 MessageCodecs 或 BinaryCodec 的客戶端）時使用直接 ByteBuffer 的後果。傳送直接 ByteBuffer 意指您有一個 Java 物件正在與 C/C++ 記憶體進行通訊，因此，如果您刪除 C/C++ 記憶體，那麼 Java 會與隨機垃圾進行交互，並且可能會因作業系統的存取衝突而當機。</p>

<p>效仿 iOS 的做法，我嘗試將 C/C++ 記憶體的所有權傳遞給 Java，以便在 Java 物件被垃圾收集時，它會刪除 C/C++ 記憶體。結果證明，當直接 ByteBuffer 是透過 JNI 透過 [NewDirectByteBuffer](https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#NewDirectByteBuffer) 建立時，這是做不到的。JNI 沒有提供在 Java 物件刪除時得知的掛鉤。您無法子類化 ByteBuffer，以便在它被終止時呼叫 JNI。唯一的希望是在上圖中的步驟 5 中從 Java API 分配直接 ByteBuffer。透過 Java 分配的直接 ByteBuffers 沒有這個限制。但是，在 Java 中引入新的入口點將是一個巨大的變革，而且任何使用過 JNI 的人都知道這是很危險的。</p>

<p>相反，我選擇請團隊接受在 decodeMessage 呼叫中使用直接 ByteBuffers。起初，我在 MessageCodec 中引入了一個新的方法，bool wantsDirectByteBufferForDecoding()，以確保沒有人獲得直接 ByteBuffer，除非他們請求它，並且知道其語義（也就是，當底層 C/C++ 記憶體仍然有效時）。這被證明是複雜的，並且令人擔憂的是，開發人員可能會訂閱，但不知道直接 ByteBuffers 的語義，因為它們的運作方式與典型的 ByteBuffers 相反，可能會在他們身下刪除其 C 記憶體支援。儲存編碼的緩衝區是不尋常的使用方式，而且不太可能使用，但團隊無法排除這種可能性。經過多次討論和協商，我們決定每個 MessageCodec 都會獲得一個直接 ByteBuffer，在呼叫 decodeMessage 後會被清除。這樣，如果有人快取編碼的訊息，那麼如果他們在底層 C 記憶體被清理後嘗試使用 ByteBuffer，他們就會在 Java 中得到一個確定性的、適當的錯誤。</p>

<p>讓每個人都能獲得直接 ByteBuffers 效能提升的優點效果很好，但這對 BinaryCodec 來說是一個重大變革，其 encodeMessage 和 decodeMessage 實作是無操作的，它們只是將輸入作為返回值轉發。為了保持 BinaryCodec 的相同記憶體語義，我引入了一個 [新的實例變數](https://github.com/flutter/engine/blob/01d1ed459a313f19e2e01cf8d62331d19b907637/shell/platform/android/io/flutter/plugin/common/BinaryCodec.java#L29)，它控制解碼的訊息是直接 ByteBuffer（新的、更快的程式碼）還是標準 ByteBuffer（舊的、更慢的程式碼）。我們無法建立一種方法，讓 BinaryCodec 的所有客戶端都能獲得效能提升。</p>

<h3>未來工作</h3>

<p>現在已經消除了複製，我下一步改進 Flutter 與主機平台之間通訊的努力是：

<ol>
<li>為 Pigeon 實作自訂 MessageCodec，該編碼器不依賴於反射，以實現更快的編碼和解碼。</li>
<li>實作 FFI 平台通道，讓您可以在不跳轉 UI 和平台線程之間的情況下，從 Dart 呼叫主機平台。</li>
</ol>

<p>我希望您喜歡這次對此效能改進的詳細資訊的深入探討！</p>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=e5b4e5df04af" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/improving-platform-channel-performance-in-flutter-e5b4e5df04af">改進 Flutter 中的平台通道效能</a> 最初發表在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/3418b624.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/3418b624.html" class="post-title-link" itemprop="url">【文章翻譯】What’s new in Flutter 2.2</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-19 18:32:20" itemprop="dateCreated datePublished" datetime="2021-05-19T18:32:20+08:00">2021-05-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="Flutter-2-2-新功能"><a href="#Flutter-2-2-新功能" class="headerlink" title="Flutter 2.2 新功能"></a>Flutter 2.2 新功能</h2><p><em>Flutter 2.2 版本專注於完善和優化，包括 iOS 效能改進、Android 延遲組件、更新的 Flutter Web 服務工作者等等！</em></p>
<p>今天，我們正式發佈 Flutter 2.2。您可以透過切換到 stable channel 並升級您目前的 Flutter 安裝，或前往 <a href="http://flutter.dev/docs/get-started">flutter.dev&#x2F;docs&#x2F;get-started</a> 開始新的安裝來取得它。</p>
<p>儘管距離 Flutter 2 發佈只有幾個月，但我們在 2.2 版本中有很多改進要分享。此版本合併了框架、引擎和 Plugin 儲存庫中的 2,456 個 PR 並解決了 3,105 個問題。特別感謝廣大的 Flutter 社群，他們提供了大量的 PR 和 PR 審查，包括貢獻最多 PR（17 個）的 <a href="https://github.com/Abhishek01039">Abhishek01039</a> 和審查最多 PR（9 個）的 <a href="https://github.com/xu-baolin">xu-baolin</a>，他們為 Flutter 2.2 做出了貢獻。感謝所有貢獻者幫助將 Flutter 2.2 帶入 stable channel。沒有您的協助，我們無法做到。</p>
<p>隨著每個新的 Flutter 版本穩定發佈，都會有一系列新的更新，無論是效能增強、新功能還是錯誤修復。此外，發佈版本還包含一些尚未準備好投入生產使用的功能，但我們希望您能夠驗證它們是否按您的預期運作。最後，每個新版本都帶有一組相關的工具更新和來自更廣泛的 Flutter 社群的更新。老實說，如今每次 Flutter 新版本發佈時都會發生很多事情，我們不可能在一篇部落格文章中涵蓋所有內容，但我們會盡力突出重點。</p>
<h3 id="穩定版-Flutter-2-2-更新"><a href="#穩定版-Flutter-2-2-更新" class="headerlink" title="穩定版 Flutter 2.2 更新"></a>穩定版 Flutter 2.2 更新</h3><p>此版本在 Flutter 2 的基礎上涵蓋了廣泛的改進，包括 Android、iOS 和 Web 的更新，新的 Material 圖示、文字處理更新、捲軸行為和 TextSpan Widget 的滑鼠游標支援，以及有關如何從單一原始碼庫最佳支援多種平台的新指南。所有這些功能現在都可以在 stable 版本中使用，您可以用於生產應用程式。所有這些功能都建立在新的 Dart 版本之上。</p>
<h4 id="Dart-2-13"><a href="#Dart-2-13" class="headerlink" title="Dart 2.13"></a>Dart 2.13</h4><p>Flutter 2.2 與 Dart 2.13 版本一起發佈。除了其他功能外，此 Dart 更新還包含一個新的類型別名功能，使您能夠為類型和函數建立別名：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/0e191a2788d6baa097a5d30aef8ab23e/href">https://medium.com/media/0e191a2788d6baa097a5d30aef8ab23e/href</a></iframe>

<p>類型別名使您能夠為長而複雜的類型提供簡潔的短名稱，它還讓您以非破壞性的方式重新命名類別。Dart 2.13 中還有更多新功能；在 <a href="https://medium.com/dartlang/announcing-dart-2-13-c6d547b57067">Dart 2.13 發佈公告</a> 中查看詳細資訊。</p>
<h4 id="Flutter-Web-更新"><a href="#Flutter-Web-更新" class="headerlink" title="Flutter Web 更新"></a>Flutter Web 更新</h4><p>Flutter 最新的穩定平台 Web 在此版本中得到了改進。</p>
<p>首先，我們使用新的服務工作者載入機制優化了快取行為，並修復了 <code>main.dart.js</code> 的重複下載問題。在以前的 Flutter Web 版本中，服務工作者在向使用者提供應用程式的舊版本時，會在背景中下載應用程式的更新。下載更新後，使用者必須刷新瀏覽器頁面幾次才能看到這些更改。從 Flutter 2.2 開始，當新的服務工作者偵測到更改時，使用者將等待更新下載才能使用應用程式，但他們將看到更新，而無需再次手動刷新頁面。</p>
<p>若要啟用此更改，您需要重新產生 Flutter 應用程式的 <code>index.html</code> 檔案。若要執行此操作，請儲存您的修改，刪除 <code>index.html</code> 檔案，然後在您的專案目錄中執行 <code>flutter create .</code> 以重新建立它。</p>
<p>我們還對兩個 Web 渲染器都進行了改進。對於 HTML，我們加入了對 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-feature-settings">字體功能</a> 的支援，以啟用設定 <a href="https://api.flutter.dev/flutter/dart-ui/FontFeature-class.html">FontFeature</a> 以及使用畫布 API 渲染文字，以便在懸停時文字顯示在正確的位置。對於 HTML 和 CanvasKit，我們加入了對著色器遮罩和 <a href="https://api.flutter.dev/flutter/painting/TextPainter/computeLineMetrics.html">computeLineMetrics</a> 的支援，解決了 Flutter Web 和行動應用程式之間的奇偶性差距。例如，開發人員現在可以使用 <a href="https://api.flutter.dev/flutter/widgets/Opacity-class.html">不透明遮罩</a> 透過著色器遮罩執行淡出轉場，並像在行動應用程式中一樣使用 <code>computeLineMetrics</code>。</p>
<p>對於 Flutter Web 以及 Flutter 本身，無障碍功能是我們的首要任務之一。按照設計，Flutter 透過建立 SemanticsNode 樹來實作無障碍功能。當 Flutter Web 應用程式使用者啟用無障碍功能時，框架會產生一個與 RenderObject DOM 樹平行的 DOM 樹，並將語義屬性轉換為 Aira。在此版本中，我們改進了語義節點位置，以在使用轉換時縮短行動和桌面 Web 應用程式之間的差距，這意味著當 Widget 透過轉換進行樣式設定時，焦點框應正確顯示在元素之上。若要實際查看此功能，請查看 Victor Tsaran 的這個影片，他在影片中使用 VoiceOver 和 Flutter Gallery App：</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FA6Sx0lBP8PI%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DA6Sx0lBP8PI&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FA6Sx0lBP8PI%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="640" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/1da83a64c4b5cf1037aba0503dd22606/href">https://medium.com/media/1da83a64c4b5cf1037aba0503dd22606/href</a></iframe>

<p>我們還透過命令列標誌在配置文件和發行模式下公開了語義節點除錯樹，以幫助開發人員透過視覺化為其 Web 應用程式建立的語義節點來除錯無障碍功能。</p>
<p>若要為您自己的 Flutter Web 應用程式啟用此功能，請執行以下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ flutter run -d chrome --profile </span><br><span class="line">  --dart-define=FLUTTER_WEB_DEBUG_SHOW_SEMANTICS=true </span><br></pre></td></tr></table></figure>

<p>啟用該標誌後，您將可以在 Widget 上方看到語義節點，這讓您能夠除錯並查看語義元素是否放置在不應放置的位置。如果您發現此類範例，請隨時 <a href="https://goo.gle/flutter_web_issue">提交錯誤報告</a>。</p>
<p>雖然我們在支援一組核心無障碍功能方面取得了重大進展，但我們將繼續改進無障碍功能支援。在 2.2 穩定版本之後，在 master 和 dev channel 上提供的版本中，我們加入了一個 API，讓開發人員可以透過程式設計方式 <a href="https://github.com/flutter/engine/pull/25830">自動啟用應用程式的無障碍功能</a>，並且正在修復 <a href="https://github.com/flutter/engine/pull/25797">使用螢幕閱讀器與 Tab 鍵</a> 的問題。</p>
<p>最後，但同樣重要的是，最新版本的 Flutter DevTools 現在支援 Flutter Web 應用程式的佈局瀏覽器。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*fS4WbRPwmo_FQgDo" />
</figure>

<p>此更新為您提供了與行動和桌面應用程式相同的佈局除錯工具。</p>
<h4 id="iOS-頁面轉場和增量安裝"><a href="#iOS-頁面轉場和增量安裝" class="headerlink" title="iOS 頁面轉場和增量安裝"></a>iOS 頁面轉場和增量安裝</h4><p>對於 iOS，在此版本中，我們 <a href="https://github.com/flutter/flutter/pull/75670">在 Cupertino 中使頁面轉場更加流暢</a>，透過將渲染動畫畫面的時間縮短 75%，而在低端手機上可能會縮短更多時間。我們不僅尋找最終使用者效能的改進；我們始終在尋找改進開發效能的方法。</p>
<p>在此版本中，我們 <a href="https://github.com/flutter/flutter/pull/77756">在開發過程中實作了增量 iOS 安裝</a>。在我們的基準測試中，我們發現安裝更新版本的 iOS 應用程式所需的時間減少了 40%，這減少了測試應用程式更改時的週轉時間。</p>
<h4 id="使用-Flutter-建立平台適應性應用程式"><a href="#使用-Flutter-建立平台適應性應用程式" class="headerlink" title="使用 Flutter 建立平台適應性應用程式"></a>使用 Flutter 建立平台適應性應用程式</h4><p>隨著 Flutter 在 stable 版本中擴展到支援更多平台，考慮支援不同外觀尺寸（例如行動裝置、平板電腦和桌面），以及不同輸入類型（觸控 vs. 滑鼠 + 鍵盤）和具有不同慣例的平台（例如導航抽屜 vs. 系統選單用於導航）的應用程式變得很有用。我們將能夠根據不同目標平台的細節進行調整的應用程式稱為「平台適應性」應用程式。</p>
<p>對於在建立平台適應性應用程式時需要牢記的考量，我們建議您參考 Kevin Moore 的 <a href="https://events.google.com/io/session/868dfd56-7f8c-49ee-84ad-ac69a23ba19d?lng=en">建立平台適應性應用程式</a> 議程。若要更詳細地查看，請查看 <a href="https://flutter.dev/docs/development/ui/layout/building-adaptive-apps">flutter.dev 上的平台適應性應用程式指南</a>。</p>
<p>最後，對於根據這些原則為多個平台編寫的範例應用程式，我們建議您使用 gSkinner 的 <a href="https://flutter.gskinner.com/flokk">Flokk</a> 和 <a href="https://flutter.gskinner.com/folio">Flutter Folio</a> 應用程式。您可以下載 <a href="https://github.com/gskinnerTeam/flokk">Flokk</a> 和 <a href="https://github.com/gskinnerTeam/flutter-folio">Folio</a> 的程式碼，以及從各個應用程式商店下載 <a href="https://flutter.gskinner.com/flokk/#g-download">Flokk</a> 和 <a href="https://flutter.gskinner.com/folio/#g-download">Folio</a>，或直接從瀏覽器中執行它們。另一個很棒的範例是是用於建立指南本身的應用程式：</p>
<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F8YUIrIGGc3Y%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D8YUIrIGGc3Y&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F8YUIrIGGc3Y%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/77a372bd95e8a21fd997f4fce6dc2f53/href">https://medium.com/media/77a372bd95e8a21fd997f4fce6dc2f53/href</a></iframe>

<p>Flutter 平台適應性應用程式指南的 UX 部分是基於新的 <a href="https://material.io/blog/material-design-for-large-screens">Material 大型螢幕指南</a>。Material 團隊的這項新指南包括重新設計多個主要佈局文章，以及更新多個元件和更新的設計工具包，所有這些都是針對大螢幕進行的。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ROXD5MqgkYuZgDZQ" />
</figure>

<p>Flutter 的目標一直是啟用不僅可以在多個平台上執行，而且在所有目標平台上都能 <em>出色</em> 執行的應用程式。Flutter 擁有您需要的支援，不僅可以將應用程式定位到多個平台，而且還打算為每個平台的螢幕大小、輸入模式和慣例 <em>量身打造</em> 您的應用程式。</p>
<h4 id="更多-Material-圖示"><a href="#更多-Material-圖示" class="headerlink" title="更多 Material 圖示"></a>更多 Material 圖示</h4><p>談到 Material 指南，在此版本中，我們不僅加入了一個，而是 <a href="https://github.com/flutter/flutter/pull/76607">兩個</a> <a href="https://github.com/flutter/flutter/pull/78311">獨立的</a> PR，為 Flutter 加入新的 Material 圖示，包括 Dash 本人的圖示！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*hlsSKR8Uco4AurMH" />
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*K7L6ppH1A1gBmVY-" />
</figure>

<p>這些更新使您的應用程式可用的 Material 圖示總數增加到 7,000 多個。如果您在這麼多豐富的圖示中找不到您要尋找的圖示（誰會呢？），您可以在 <a href="http://fonts.google.com/icons">fonts.google.com&#x2F;icons</a> 根據類別和名稱搜尋。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*NofBGAEBtDHtwclP" />
<figcaption>根據名稱搜尋 Flutter Material 圖示</figcaption>
</figure>

<p>找到完美的圖示後，新的「Flutter」標籤會顯示如何使用它，或者您可以僅下載該圖示以作為獨立資產用於您的應用程式中。將 Dash 加入您的 Flutter 應用程式中從未如此簡單。</p>
<h4 id="改進的文字處理"><a href="#改進的文字處理" class="headerlink" title="改進的文字處理"></a>改進的文字處理</h4><p>隨著我們繼續改進 Flutter 以支援每個平台的細節，我們繼續推進到在行動外觀尺寸上並不那麼重要，但在桌面外觀尺寸上很重要的新領域。其中一個領域是文字處理。在此版本中，我們已開始重構處理文字輸入的方式，以啟用取消鍵盤輸入（當鍵盤輸入透過 Widget 階層級別傳播時）、以及透過引入能夠完全自訂與文字動作相關的鍵盤輸入的能力。</p>
<p>能夠取消鍵盤輸入讓 Flutter 能夠實作使用空格鍵和箭頭鍵而不會觸發捲軸事件的功能，為您的最終使用者提供更直观的體驗。您可以在自己的應用程式中使用相同的功能來處理鍵盤輸入，然後再輸入到父 Widget 中。另一個範例是，在此版本中，您可以在 Flutter 應用程式中的 TextField 和按鈕之間按 Tab 鍵，並且它可以正常運作：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/9fe050af78589eeadd639f27427eb938/href">https://medium.com/media/9fe050af78589eeadd639f27427eb938/href</a></iframe>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*krVx4ycTN2nTl7wO" />
<figcaption>Flutter 2.2 可以取消鍵盤輸入從 Widget 階層級別向上傳播，例如允許 TAB 將焦點從 TextField 切換</figcaption>
</figure>

<p>自訂文字動作允許您執行諸如在 TextField 中對 Enter 鍵進行特殊處理之類的操作；例如，您可以觸發在聊天客戶端中發送訊息，同時仍然允許透過 Ctrl+Enter 插入換行符。這些相同的文字動作 <a href="https://github.com/flutter/flutter/pull/75032">讓 Flutter 本身能夠提供不同的鍵盤輸入</a>，以將文字編輯的行為與主機作業系統本身相匹配，例如 Windows 和 Linux 上的 Ctrl+C，但 macOS 上的 Cmd+C。</p>
<p>舉例來說，以下範例覆蓋了預設的左箭頭動作，並為退格鍵和刪除鍵提供了一個新的動作：</p>
<iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/802c94f664ff9b3badd620731d1dc52a/href">https://medium.com/media/802c94f664ff9b3badd620731d1dc52a/href</a></iframe>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*RFbQWBEWCoP4PF1j" />
<figcaption>不可饒恕的 TextField 範例，其中按下左箭頭或 ESC 鍵會清除文字</figcaption>
</figure>

<p>我們還有更多工作要做，但我們正在努力為您提供完整的文字編輯動作。我們的目標是，當 Flutter 桌面到達 stable 版本時，您的使用者將無法區分在 Flutter 應用程式和主機作業系統上的任何其他應用程式中編輯文字。</p>
<h4 id="自動捲軸行為"><a href="#自動捲軸行為" class="headerlink" title="自動捲軸行為"></a>自動捲軸行為</h4><p>作為我們不斷努力讓 Flutter 應用程式像每個平台上最好的應用程式一樣運作的一部分，我們在此版本中再次查看了捲軸條。在實際顯示捲軸條方面，Android 和 iOS 都是一樣的；預設情況下，它們不會顯示捲軸條。另一方面，對於桌面應用程式，當內容比容器大時，通常會自動顯示捲軸條，這需要您加入 Scrollbar 父 Widget。若</p>
<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/1bf8dfb3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/1bf8dfb3.html" class="post-title-link" itemprop="url">【文章翻譯】Announcing Flutter 2.2 at Google I/O 2021</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-18 20:02:12" itemprop="dateCreated datePublished" datetime="2021-05-18T20:02:12+08:00">2021-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 16:55:14" itemprop="dateModified" datetime="2024-09-30T16:55:14+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="宣布-Flutter-2-2：領先的多平台-UI-工具組的持續發展"><a href="#宣布-Flutter-2-2：領先的多平台-UI-工具組的持續發展" class="headerlink" title="宣布 Flutter 2.2：領先的多平台 UI 工具組的持續發展"></a>宣布 Flutter 2.2：領先的多平台 UI 工具組的持續發展</h2><p>在今天的 Google I/O 上，我們宣布了 [Flutter 2.2](https://flutter.dev/docs/whats-new)，這是我們開源工具組的最新版本，可以用於從單一平台建立適用於任何設備的精美應用程式。Flutter 2.2 是迄今為止最佳的 Flutter 版本，它提供了更新，使開發人員比以往更容易透過應用程式內購買、付款和廣告來獲利；連接到擴展應用程式以支援新功能的雲端服務和 API；以及工具和語言功能，讓開發人員能夠消除一整類錯誤，提高應用程式效能，並縮減套件大小。</p>

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*NCBwYFewFf602uvF" /></figure>

<h3 id="建立在-Flutter-2-的基礎之上"><a href="#建立在-Flutter-2-的基礎之上" class="headerlink" title="建立在 Flutter 2 的基礎之上"></a>建立在 Flutter 2 的基礎之上</h3><p>Flutter 2.2 建立在 Flutter 2 的基礎之上，Flutter 2 將 Flutter 從行動端擴展到包含 Web、桌面和嵌入式使用。它專為環境計算世界而設計，在環境計算世界中，使用者擁有各種不同的設備和外形尺寸，並希望獲得跨越他們日常生活的連貫體驗。有了 Flutter 2.2，企業、新創公司和企業家都可以建立高品質的解決方案，這些方案可以發揮其可尋址市場的全部潛力，讓創意靈感（而非目標平台）成為唯一的限制因素。</p>

<blockquote>Flutter 現在是跨平台開發最受歡迎的框架。</blockquote>

<p>最近的一項行動開發人員研究突顯了 Flutter 的成長。分析公司 [SlashData](https://www.slashdata.co/) 的 [2021 年行動開發人員人口預測](https://www.slashdata.co/reports/?category=mobile-desktop) 顯示，Flutter 現在是跨平台開發最受歡迎的框架，45% 的開發人員選擇使用它，從 2020 年第一季到 2021 年第一季成長了 47%。我們自己的數據證實了這種向 Flutter 的轉變；在過去 30 天中，Play 商店中超過八分之一的新應用程式都是使用 Flutter 建立的。</p>

<p>在 I/O 上，我們分享了現在僅在 Play 商店中就有超過 20 萬個應用程式是使用 Flutter 建立的。這些應用程式來自像騰訊這樣的公司，其 [微信](https://apps.apple.com/us/app/wechat/id414478124) 通訊應用程式在 iOS 和 Android 上擁有超過 12 億使用者；[字節跳動](https://www.bytedance.com/en/products/)，TikTok 的創始人，他們現在已經使用 Flutter 建立了 70 個不同的應用程式；以及其他來自包括 [BMW](https://www.press.bmwgroup.com/global/article/detail/T0328610EN/the-my-bmw-app:-new-features-and-tech-insights-for-march-2021?language=en)、[SHEIN](https://apps.apple.com/app/id878577184)、[Grab](https://apps.apple.com/app/id647268330) 和 [DiDi](https://play.google.com/store/apps/details?id=com.xiaojukeji.didi.global.customer&amp;hl=None) 等公司的應用程式。當然，Flutter 不僅僅被大型企業使用。一些最具創新性的應用程式來自您可能從未聽說過的名字：例如，[Wombo](https://play.google.com/store/apps/details?id=com.womboai.wombo&amp;hl=None)，病毒式的唱歌自拍應用程式；[Fastic](https://play.google.com/store/apps/details?id=de.fastic.app&amp;hl=None)，間歇性禁食應用程式；以及 [Kite](https://play.google.com/store/apps/details?id=com.zerodha.kite3&amp;hl=None)，一個精美的投資交易應用程式。</p>

<h3 id="介紹-Flutter-2-2"><a href="#介紹-Flutter-2-2" class="headerlink" title="介紹 Flutter 2.2"></a>介紹 Flutter 2.2</h3><p>Flutter 2.2 版本重點改進開發體驗，幫助您為客戶提供更可靠、更高效能的應用程式。

<p>聲明性空安全現在是新專案的預設值。空安全增加了對空引用異常的保護，讓開發人員能夠在程式碼中表達非空類型。由於 Dart 的實作是 *聲明性的*，編譯器可以在執行時消除空檢查，為您的應用程式提供更高的效能。生態系統迅速做出回應，大約有 5,000 個套件已經更新以支援空安全。</p>

<p>此版本中也包含許多效能改進：對於 Web 應用程式，我們提供了使用服務工作者的背景快取；對於 Android 應用程式，Flutter 支援延遲組成部分；對於 iOS，我們一直在努力開發工具以預先編譯著色器，以消除或減少第一次運行的卡頓。我們還為 DevTools 套件添加了一些新功能，這些功能可以幫助您了解應用程式中的記憶體分配方式，以及對第三方工具擴展的支援。</p>

<p>此外，我們一直在著手幾個重要的潤色領域，例如改進 Web 目標的可存取性。</p>

<p>我們的發展不僅限於 Flutter 的核心。我們還與其他 Google 團隊合作，幫助將 Flutter 整合到我們更廣泛的開發人員堆疊中。特別是，我們繼續建立值得信賴的服務，幫助開發人員負責任地在應用程式中獲利。此版本中更新了我們的 [新廣告 SDK](https://developers.google.com/admob/flutter/quick-start)，包含空安全和對適應性橫幅格式的支援。我們還引入了一個由 Google Pay 團隊合作開發的 [新的付款 Plugin](http://pub.dev/packages/pay)，它讓您可以在 iOS 和 Android 上對實體商品進行付款。此外，我們更新了 [應用程式內購買 Plugin](https://pub.dev/packages/in_app_purchase)，以及相應的 [Codelab](https://codelabs.developers.google.com/codelabs/flutter-in-app-purchases)。</p>

<p>作為驅動 Flutter 的「秘訣」，[Dart](https://dart.dev) 也在此版本中進行了更新。Dart 2.13 擴展了對原生互操作性的支援，包括在 FFI 中支援陣列和封包結構。它還包括對類型別名的支援，這提高了可讀性，並為某些重構情境提供了一個平緩的路徑。我們繼續為更廣泛的生態系統添加整合，包括一個 Dart [GitHub Action](https://github.com/marketplace/actions/setup-dart-sdk) 和一個經過優化的 [Docker 官方映像](https://hub.docker.com/_/dart)，專為雲端部署業務邏輯而設計。</p>

<h3 id="超越-Google-專案"><a href="#超越-Google-專案" class="headerlink" title="超越 Google 專案"></a>超越 Google 專案</h3><p>雖然 Google 仍然是 Flutter 專案的主要貢獻者，但我們很高兴看到圍繞 Flutter 的更廣泛生態系統的成長。</p>

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*zroRqBB-vjUR_UCvYCKSUg.png" /></figure>

<p>在最近幾個月中，Flutter 的成長表現特別突出，它被用於越來越多的平台和作業系統。在 Flutter Engage 上，我們宣布了 [豐田將把 Flutter 带入他們的下一代車輛信息娛樂系統](https://medium.com/googleplaydev/seamless-multi-platform-app-development-with-flutter-ea0e8003b0f9#f53d)。上個月，Canonical 發佈了他們的首個 [帶有整合 Flutter 支援的 Ubuntu](https://ubuntu.com/blog/ubuntu-21-04-is-here)，具有 Snap 整合和對 Wayland 的支援。</p>

<p>兩位新合作夥伴證明了這個不斷發展的生態系統。[三星正在將 Flutter 移植到 Tizen](https://github.com/flutter-tizen/flutter-tizen)，  開源儲存庫可供其他人貢獻。而 [索尼正在帶頭努力為嵌入式 Linux 提供解決方案](https://github.com/sony/flutter-embedded-linux)。</p>

<p>設計師也從這個專案的開源性質中受益，[Adobe 宣布了其更新的 XD to Flutter 外掛](https://medium.com/adobetech/announcing-xd-to-flutter-v2-0-82d09f3909a7)。Adobe XD 為設計師提供了一個很好的方式來實驗和迭代。現在，隨著增強的 Flutter 支援，設計師和開發人員可以在相同的資產上進行合作，讓好點子更快地投入生產。</p>

<p>最後，微軟繼續與我們合作；除了 Surface 團隊一直在努力使用 Flutter 建立可折疊體驗之外，本週還推出了為 Windows 10 建立的 [Flutter 對 UWP 應用程式的 Alpha 版支援](https://flutter.dev/desktop#windows-uwp)。我們很高兴看到更多利用 Flutter 中內建的平台適應來提供跨行動、桌面、Web 和其他平台的優質體驗的應用程式。</p>

<h3>建立出色的體驗</h3>

<p>最重要的是，我們建立 Flutter 是為了幫助開發人員建立出色的體驗。我們熱衷於這樣的想法：應用程式開發可以變得更好；我們可以透過消除傳統的障礙來讓您接觸到您的受眾，來賦予您力量。</p>

<p>我們喜歡看到您如何將 Flutter 運用於實際工作中。一個例子來自美國退伍軍人事務部的一個專案。下面的影片顯示了他們的 Flutter 應用程式如何幫助他們為患有創傷後壓力症候群的士兵提供康復服務。</p>

<iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2F2S-KkvFuLWs%3Ffeature%3Doembed&amp;display_name=YouTube&amp;url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D2S-KkvFuLWs&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2F2S-KkvFuLWs%2Fhqdefault.jpg&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/2cebe8af06aff25eb907f5adf248d40e/href">https://medium.com/media/2cebe8af06aff25eb907f5adf248d40e/href</a></iframe>

<p>Google I/O 上有 [關於 Flutter 的各種研討會、簡報和隨選課程](https://events.google.com/io/program/content?4=topic_flutter)，我們很高興能與大家分享我們的成果。不要忘記查看我們用 Flutter 建立的有趣的 [照片亭 Web 應用程式](https://photobooth.flutter.dev)，它讓您能夠與我們的 Dash 吉祥物和她的朋友們合照自拍！</p>

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*ZdwECz0chT1hOq6Y" /></figure>

<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=92f0fcbd7ef9" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/announcing-flutter-2-2-at-google-i-o-2021-92f0fcbd7ef9">在 Google I&#x2F;O 2021 上宣布 Flutter 2.2</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p>
</p> 


<p><a href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-tw,default">
    <link itemprop="mainEntityOfPage" href="https://blog.rainvisitor.me/archives/7e9fa4cc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Rainvisitor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="RainVisitor Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/archives/7e9fa4cc.html" class="post-title-link" itemprop="url">【文章翻譯】How It’s Made: I/O Photo Booth</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-17 15:07:17" itemprop="dateCreated datePublished" datetime="2021-05-17T15:07:17+08:00">2021-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-09-30 20:20:40" itemprop="dateModified" datetime="2024-09-30T20:20:40+08:00">2024-09-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>【文章內容使用 Gemini 1.5 Pro 自動產生】</p>
<h2 id="深入探討使用-Flutter-和-Firebase-建立-Web-應用程式"><a href="#深入探討使用-Flutter-和-Firebase-建立-Web-應用程式" class="headerlink" title="深入探討使用 Flutter 和 Firebase 建立 Web 應用程式"></a>深入探討使用 Flutter 和 Firebase 建立 Web 應用程式</h2><figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*diM5YKjX2b2OgNvD" />
</figure>

<p>我們（Very Good Ventures 的團隊）與 Google 合作，為今年的 Google I&#x2F;O 帶來了互動式體驗：一個 <a href="https://photobooth.flutter.dev/">照片亭</a>！您可以與知名的 Google 吉祥物合影： <a href="https://flutter.dev/dash">Flutter 的 Dash</a>、Android Jetpack、Chrome 的 Dino 和 Firebase 的 Sparky，並使用貼紙裝飾照片，包括派對帽、披薩、時髦眼鏡等等。最後，您可以將照片分享到社交媒體，並下載它們以更新您的活動個人檔案照片！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*OQnK58irOAv-Pjzq" />
<figcaption>Flutter 的 Dash、Firebase 的 Sparky、Android Jetpack 和 Chrome 的 Dino</figcaption>
</figure>

<p>我們使用 <a href="https://flutter.dev/web">網頁上的 Flutter</a> 和 <a href="https://firebase.google.com/">Firebase</a> 建立了 I&#x2F;O 照片亭。由於 <a href="https://medium.com/flutter/whats-new-in-flutter-2-0-fe8e95ecc65">Flutter 現在支援 Web 應用程式</a>，我們認為這將是一個很好的方法，讓今年的虛擬 Google I&#x2F;O 全球的與會者都能輕鬆地使用這個應用程式。Flutter 的 Web 支援消除了必須從應用程式商店安裝應用程式的障礙，也讓您能夠選擇在您偏愛的設備上運行它：行動裝置、桌面或平板電腦。這讓任何有瀏覽器和設備的人都能使用 I&#x2F;O 照片亭，而無需下載。</p>
<p>儘管 I&#x2F;O 照片亭被設計為 Web 體驗，但所有程式碼都是使用平台無關的架構撰寫的。當相机插件等元素的原生支援在各自的平台上可用時，同一程式碼可以在所有平台（桌面、Web 和行動裝置）上運行。</p>
<h3 id="使用-Flutter-建立虛擬照片亭"><a href="#使用-Flutter-建立虛擬照片亭" class="headerlink" title="使用 Flutter 建立虛擬照片亭"></a>使用 Flutter 建立虛擬照片亭</h3><h4 id="為-Web-建立-Flutter-相機-Plugin"><a href="#為-Web-建立-Flutter-相機-Plugin" class="headerlink" title="為 Web 建立 Flutter 相機 Plugin"></a>為 Web 建立 Flutter 相機 Plugin</h4><p>第一個挑戰是為網頁上的 Flutter 建立一個相機 Plugin。最初，我們聯繫了 <a href="https://www.baseflow.com/">Baseflow</a> 的團隊，因為他們維護著現有的開源 <a href="https://github.com/Baseflow/flutter-plugins">Flutter 相機 Plugin</a>。雖然 Baseflow 致力於為 iOS 和 Android 建立頂級的相機 Plugin 支援，但我們很樂意使用 <a href="https://flutter.dev/docs/development/packages-and-plugins/developing-packages#federated-plugins">聯合 Plugin 方法</a> 並行開發 Plugin 的 Web 支援。我們盡可能地遵循官方 Plugin 介面，以便在 Plugin 準備就緒時能夠將它合併回官方 Plugin 中。</p>
<p>我們識別了兩個對在 Flutter 中建立 I&#x2F;O 照片亭相機體驗至關重要的 API。</p>
<ol>
<li><strong>初始化相機：</strong> 應用程式首先需要存取您的設備相機。在桌面裝置上，這可能是網路攝影機，而在行動裝置上，我們選擇的是前置相機。我們還提供了 1080p 的預期解析度，以根據您的設備最大限度地提高相機品質。</li>
<li><strong>拍攝照片：</strong> 我們使用了內建的 <a href="https://api.flutter.dev/flutter/widgets/HtmlElementView-class.html">HtmlElementView</a>，它使用平台視圖將原生 Web 元素渲染為 Flutter Widget。在此專案中，我們將 <a href="https://api.flutter.dev/flutter/dart-html/VideoElement-class.html">VideoElement</a> 渲染為一個原生 HTML 元素，這就是您在拍攝照片之前在螢幕上看到的內容。我們使用 <a href="https://api.flutter.dev/flutter/dart-html/CanvasElement-class.html">CanvasElement</a>，它被渲染為另一個 HTML 元素。這使我們可以在您點擊拍攝照片按鈕時從媒體流中捕獲圖片。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;CameraImage&gt; takePicture() async &#123;</span><br><span class="line"> final videoWidth = videoElement.videoWidth;</span><br><span class="line"> final videoHeight = videoElement.videoHeight;</span><br><span class="line"> final canvas = html.CanvasElement(</span><br><span class="line">   width: videoWidth,</span><br><span class="line">   height: videoHeight,</span><br><span class="line"> );</span><br><span class="line"> canvas.context2D</span><br><span class="line">   ..translate(videoWidth, 0)</span><br><span class="line">   ..scale(-1, 1)</span><br><span class="line">   ..drawImageScaled(videoElement, 0, 0, videoWidth, videoHeight);</span><br><span class="line"> final blob = await canvas.toBlob();</span><br><span class="line"> return CameraImage(</span><br><span class="line">   data: html.Url.createObjectUrl(blob),</span><br><span class="line">   width: videoWidth,</span><br><span class="line">   height: videoHeight,</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相機權限"><a href="#相機權限" class="headerlink" title="相機權限"></a>相機權限</h4><p>在我們讓 Flutter 相機 Plugin 在 Web 上運作之後，我們建立了一個抽象層來顯示不同的 UI，具體取決於相機權限。例如，在等待您允許或拒絕瀏覽器使用相機的權限，或者沒有可用的相機可以存取時，我們可以顯示一個說明訊息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Camera(</span><br><span class="line"> controller: _controller,</span><br><span class="line"> placeholder: (_) =&gt; const SizedBox(),</span><br><span class="line"> preview: (context, preview) =&gt; PhotoboothPreview(</span><br><span class="line">   preview: preview,</span><br><span class="line">   onSnapPressed: _onSnapPressed,</span><br><span class="line"> ),</span><br><span class="line"> error: (context, error) =&gt; PhotoboothError(error: error),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在此抽象層中，<code>placeholder</code> 返回初始 UI，因為應用程式正在等待您授予對相機的權限。<code>preview</code> 在您授予權限後返回 UI，並提供相機的即時視訊流。<code>error builder</code> 允許我們在發生錯誤時捕獲錯誤，並渲染對應的錯誤訊息。</p>
<h4 id="鏡像照片"><a href="#鏡像照片" class="headerlink" title="鏡像照片"></a>鏡像照片</h4><p>我們的下一個挑戰是鏡像照片。如果我們直接使用相機拍攝照片，您看到的將不是您在鏡子中看到的那樣。 <a href="https://9to5mac.com/2020/07/09/iphone-mirror-selfie-photos/">一些設備有設定可以精確處理這一點</a>，因此，如果您使用前置相機拍攝照片，您會在拍攝時看到鏡像版本。</p>
<p>在我們的第一種方法中，我們嘗試捕獲預設的相機視圖，然後在 y 軸上應用 180 度變換。這似乎有效，但後來我們遇到了 <a href="https://github.com/flutter/flutter/issues/79519">一個問題</a>，Flutter 有時會覆蓋變換，導致視訊恢復為未鏡像的版本。</p>
<p>在 Flutter 團隊的幫助下，我們透過將 <code>VideoElement</code> 包裹在 <a href="https://api.flutter.dev/flutter/dart-html/DivElement-class.html">DivElement</a> 中並更新 <code>VideoElement</code> 以填充 <code>DivElement</code> 的寬度和高度解決了這個問題。這使我們能夠將鏡像應用到 <code>video element</code> 上，而不會讓 Flutter 覆蓋變換效果，因為父元素是 <code>div</code>。這種方法為我們提供了所需的鏡像相機視圖！</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*Zd9s-7LFN9u17Ouo" />
<figcaption>Un-mirrored view</figcaption>
</figure>

<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*kkxXNd0m-t4sjCAo" />
<figcaption>Mirrored view</figcaption>
</figure>

<h4 id="堅持嚴格的縱橫比"><a href="#堅持嚴格的縱橫比" class="headerlink" title="堅持嚴格的縱橫比"></a>堅持嚴格的縱橫比</h4><p>對於大型螢幕，強制執行 4:3 的嚴格縱橫比，對於小型螢幕，強制執行 3:4 的縱橫比比想像的要難！在整個 Web 應用程式的設計中強制執行這個比率，以及確保在您將照片分享到社交媒體時，照片看起來完美無瑕，這一點非常重要。這是一項具有挑戰性的任務，因為設備上內建相機的縱橫比差異很大。</p>
<p>為了強制執行嚴格的縱橫比，應用程式首先使用 JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia">getUserMedia API</a> 請求設備相機所能提供的最大解析度。然後，我們將此 API 饋送到 <code>VideoElement</code> 流中，這就是您在相機視圖中看到的內容（當然是鏡像的）。我們還應用了一個 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit">object-fit</a> CSS 屬性，以確保 <code>video element</code> 覆蓋其父容器。這使用 Flutter 中內建的 <code>AspectRatio</code> Widget 設定縱橫比。結果，相機不會對顯示的縱橫比做出任何假設；它始終返回支援的最大解析度，然後符合 Flutter 提供的約束（在本例中為 4:3 或 3:4）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final orientation = MediaQuery.of(context).orientation;</span><br><span class="line">final aspectRatio = orientation == Orientation.portrait</span><br><span class="line">   ? PhotoboothAspectRatio.portrait</span><br><span class="line">   : PhotoboothAspectRatio.landscape;</span><br><span class="line">return Scaffold(</span><br><span class="line"> body: _PhotoboothBackground(</span><br><span class="line">   aspectRatio: aspectRatio,</span><br><span class="line">   child: Camera(</span><br><span class="line">     controller: _controller,</span><br><span class="line">     placeholder: (_) =&gt; const SizedBox(),</span><br><span class="line">     preview: (context, preview) =&gt; PhotoboothPreview(</span><br><span class="line">       preview: preview,</span><br><span class="line">       onSnapPressed: () =&gt; _onSnapPressed(</span><br><span class="line">         aspectRatio: aspectRatio,</span><br><span class="line">       ),</span><br><span class="line">     ),</span><br><span class="line">     error: (context, error) =&gt; PhotoboothError(error: error),</span><br><span class="line">   ),</span><br><span class="line"> ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="使用拖放添加朋友和貼紙"><a href="#使用拖放添加朋友和貼紙" class="headerlink" title="使用拖放添加朋友和貼紙"></a>使用拖放添加朋友和貼紙</h4><p>I&#x2F;O 照片亭體驗中的一個重要部分是與您最喜歡的 Google 朋友合影並添加道具。您可以將朋友和道具拖放到照片中，以及調整它們的大小和旋轉它們，直到得到一張您喜歡的圖片。您會注意到，在將朋友添加到螢幕時，您可以拖動和調整它們的大小。朋友們也有動畫 - 精靈表來實現這個效果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (final character in state.characters)</span><br><span class="line"> DraggableResizable(   </span><br><span class="line">   canTransform: character.id == state.selectedAssetId,</span><br><span class="line">   onUpdate: (update) &#123;</span><br><span class="line">     context.read&lt;PhotoboothBloc&gt;().add(</span><br><span class="line">       PhotoCharacterDragged(</span><br><span class="line">         character: character, </span><br><span class="line">         update: update,</span><br><span class="line">       ),</span><br><span class="line">     );</span><br><span class="line">   &#125;,</span><br><span class="line">   child: _AnimatedCharacter(name: character.asset.name),</span><br><span class="line"> ),</span><br></pre></td></tr></table></figure>

<p>為了調整物件的大小，我們建立了一個可拖動、可調整大小的 Widget，它可以包裝在任何 Flutter Widget 周圍，在本例中是朋友和道具。此 Widget 使用 <a href="https://api.flutter.dev/flutter/widgets/LayoutBuilder-class.html">LayoutBuilder</a> 來根據視窗的約束處理 Widget 的縮放。在內部，我們使用 <a href="https://api.flutter.dev/flutter/widgets/GestureDetector-class.html">GestureDetectors</a> 來接入 <code>onScaleStart</code>、<code>onScaleUpdate</code> 和 <code>onScaleEnd</code>。這些回調提供關於手勢的詳細資訊，這些資訊需要反映您對朋友和道具所做的更改。</p>
<p><a href="https://api.flutter.dev/flutter/widgets/Transform-class.html">Transform</a> Widget 和 4D 矩陣變換根據您使用多個 GestureDetectors 報告的各種手勢，處理朋友和道具的縮放和旋轉。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Transform(</span><br><span class="line"> alignment: Alignment.center,</span><br><span class="line"> transform: Matrix4.identity()</span><br><span class="line">   ..scale(scale)</span><br><span class="line">   ..rotateZ(angle),</span><br><span class="line"> child: _DraggablePoint(...),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>最後，我們建立了一個單獨的套件來確定您的設備是否支援觸控輸入。可拖動、可調整大小的 Widget 根據觸控功能進行適應。在支援觸控輸入的設備上，可調整大小的錨點和旋轉圖示不可見，因為您可以捏合和拖動來直接操作圖片，而在沒有觸控輸入的設備（例如您的桌面設備）上，會添加錨點和旋轉圖示以適應點擊和拖動。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*MVI3wAXUfJdGls5X" />
</figure>

<h3 id="優先考慮網頁上的-Flutter"><a href="#優先考慮網頁上的-Flutter" class="headerlink" title="優先考慮網頁上的 Flutter"></a>優先考慮網頁上的 Flutter</h3><h4 id="使用-Flutter-進行以-Web-為中心的開發"><a href="#使用-Flutter-進行以-Web-為中心的開發" class="headerlink" title="使用 Flutter 進行以 Web 為中心的開發"></a>使用 Flutter 進行以 Web 為中心的開發</h4><p>這是我們使用 Flutter 建立的第一個 Web 專案，它與行動應用程式具有不同的特性。</p>
<p>我們需要確保應用程式對任何設備上的任何瀏覽器都 <a href="https://flutter.dev/docs/development/ui/layout/adaptive-responsive">響應式和自適應</a>。也就是說，我們必須確保 I&#x2F;O 照片亭會根據瀏覽器大小進行縮放，並且能夠處理行動裝置和 Web 輸入。我們通過以下幾種方式實現了這一點：</p>
<ul>
<li><strong>響應式調整大小：</strong> 您應該能夠將瀏覽器調整到所需的尺寸，並且 UI 應相應地調整。如果您的瀏覽器視窗處於縱向模式，則相機將從具有 4:3 縱橫比的橫向視圖翻轉到具有 3:4 縱橫比的縱向視圖。</li>
<li><strong>響應式設計：</strong> 桌面瀏覽器的設計將 Dash、Android Jetpack、Dino 和 Sparky 顯示在右側，而行動裝置則顯示在頂部。桌面設計還使用相機右側的抽屜，而行動裝置則使用 <code>BottomSheet</code> 類別。</li>
<li><strong>自適應輸入：</strong> 如果您從桌面設備存取 I&#x2F;O 照片亭，則滑鼠點擊被視為輸入，如果您使用的是平板電腦或手機，則使用觸控輸入。這在調整貼紙大小並將它們放置在照片中時尤其重要。行動裝置支援捏合和拖動，而桌面裝置支援點擊和拖動。</li>
</ul>
<h4 id="可擴展架構"><a href="#可擴展架構" class="headerlink" title="可擴展架構"></a>可擴展架構</h4><p>我們還將建立可擴展行動應用程式的方法應用於此應用程式。我們從一個堅實的基礎開始 I&#x2F;O 照片亭，包括健全的空安全、國際化，以及從第一次提交開始的 100% 單元測試和 Widget 測試覆蓋率。我們使用 <a href="https://pub.dev/packages/flutter_bloc">flutter_bloc</a> 進行狀態管理，因為它允許輕鬆地測試業務邏輯並觀察應用程式中的所有狀態更改。這對開發人員日誌和追蹤性特別有用，因為我們可以精確地看到從一個狀態到另一個狀態的變化，並更快地隔離問題。</p>
<p>我們還實作了功能驅動的單一儲存庫結構。例如，貼紙、分享和實時相機預覽是在它們自己的資料夾中實作的，每個資料夾包含其各自的 UI 組件和業務邏輯。它們與外部相依項整合，例如相機 Plugin，這些相依項存在於 <code>packages</code> 子目錄中。這種架構使我們的團隊能夠並行處理多個功能，而不會中斷他人的工作，最大限度地減少了合併衝突，並使我們能夠有效地重複使用程式碼。例如，UI 組件函式庫是一個單獨的套件，稱為 <a href="https://github.com/flutter/photobooth/tree/main/packages/photobooth_ui">photobooth_ui</a>，相機 Plugin 也是單獨的。</p>
<p>透過將組件分成獨立的套件，我們可以提取和開源不與此特定專案相關聯的單獨組件。即使是 UI 組件函式庫套件也可以開源給 Flutter 社群，類似於 <a href="https://flutter.dev/docs/development/ui/widgets/material">Material</a> 和 <a href="https://flutter.dev/docs/development/ui/widgets/cupertino">Cupertino</a> 組件函式庫。</p>
<h3 id="Firebase-Flutter-完美的搭配"><a href="#Firebase-Flutter-完美的搭配" class="headerlink" title="Firebase + Flutter &#x3D; 完美的搭配"></a>Firebase + Flutter &#x3D; 完美的搭配</h3><h4 id="Firebase-驗證、儲存、託管等等"><a href="#Firebase-驗證、儲存、託管等等" class="headerlink" title="Firebase 驗證、儲存、託管等等"></a>Firebase 驗證、儲存、託管等等</h4><p>照片亭利用 Firebase 生態系統進行各種後端整合。<a href="https://pub.dev/packages/firebase_auth">firebase_auth 包</a> 支援在應用程式啟動時匿名登入使用者。每個工作階段都使用 Firebase Auth 建立一個具有唯一 ID 的匿名使用者。</p>
<p>這在您到達分享頁面時會發揮作用。您可以下載照片以儲存為您的個人檔案照片，或者您可以直接分享到社交媒體。如果您下載了照片，它將儲存在您的設備上。如果您分享了照片，我們會使用 <a href="https://pub.dev/packages/firebase_storage">firebase_storage 包</a> 將照片儲存在 Firebase 中，以便我們以後能夠檢索它，為社交媒體貼文填充內容。</p>
<p>我們在 Firebase 儲存桶上定義了 <a href="https://firebase.google.com/docs/rules">Firebase 安全規則</a>，以使照片在建立後不可變。這可以防止其他使用者修改或刪除此儲存桶中的照片。此外，我們使用 Google Cloud 提供的 <a href="https://cloud.google.com/storage/docs/lifecycle">Object Lifecycle Management</a>，定義一個規則，刪除所有 30 天前的物件，但您可以按照應用程式中概述的說明請求更快地刪除您的照片。</p>
<p>此應用程式還使用 <a href="https://firebase.google.com/docs/hosting">Firebase 托管</a> 來快速且安全地託管 Web 應用程式。<a href="https://github.com/FirebaseExtended/action-hosting-deploy">action-hosting-deploy</a> GitHub Action 允許我們根據目標分支自動將部署到 Firebase 托管。當我們將更改合併到 main 分支時，action 會觸發一個工作流程，將應用程式的開發風味構建並部署到 Firebase 托管。同樣，當我們將更改合併到 release 分支時，action 會觸發生產部署。GitHub Action 與 Firebase 托管的組合使我們的團隊能夠快速迭代，並始終擁有最新構建的預覽。</p>
<p>最後，我們使用 <a href="https://firebase.google.com/products/performance">Firebase Performance Monitoring</a> 監控關鍵的 Web 效能指標。</p>
<h4 id="使用-Cloud-Functions-與社交媒體互動"><a href="#使用-Cloud-Functions-與社交媒體互動" class="headerlink" title="使用 Cloud Functions 與社交媒體互動"></a>使用 Cloud Functions 與社交媒體互動</h4><p>在生成您的社交媒體貼文之前，我們首先要確保照片看起來完美無瑕。最終的圖片包括一個紀念 I&#x2F;O 照片亭的精美框架，並裁剪為 4:3 或 3:4 的縱橫比，使其在社交媒體貼文中看起來很棒。</p>
<p>我們使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/OffscreenCanvas">OffscreenCanvas</a> API 或 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas">CanvasElement</a> 作為 polyfill 來組合原始照片和包含您的朋友和道具的圖層，並生成一張您可以下載的單張圖片。<a href="https://github.com/flutter/photobooth/tree/main/packages/image_compositor">image_compositor 包</a> 處理此處理步驟。</p>
<p>然後，我們利用 Firebase 強大的 <a href="https://firebase.google.com/docs/functions">Cloud Functions</a> 來幫助將照片分享到社交媒體。當您點擊分享按鈕時，您將被帶到所選平台上的新標籤頁，其中包含預先填寫的貼文。貼文包含一個 URL，該 URL 會重新導向到我們編寫的 Cloud Function。當瀏覽器分析 URL 時，它會檢測 Cloud Function 生成的動態元資訊。此資訊允許瀏覽器在您的社交媒體貼文中顯示照片的精美預覽圖片，以及指向分享頁面的連結，您的關注者可以在其中查看照片並導航回到 I&#x2F;O 照片亭應用程式以拍攝自己的照片。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function renderSharePage(imageFileName: string, baseUrl: string): string &#123;</span><br><span class="line"> const context = Object.assign(&#123;&#125;, BaseHTMLContext, &#123;</span><br><span class="line">   appUrl: baseUrl,</span><br><span class="line">   shareUrl: `$&#123;baseUrl&#125;/share/$&#123;imageFileName&#125;`,</span><br><span class="line">   shareImageUrl: bucketPathForFile(`$&#123;UPLOAD_PATH&#125;/$&#123;imageFileName&#125;`),</span><br><span class="line"> &#125;);</span><br><span class="line"> return renderTemplate(shareTmpl, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最終的產品看起來像是這樣：</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*tXpB_n44hmjGxHXf" />
</figure>

<p>有關如何在 Flutter 專案中使用 Firebase 的更多資訊，請查看此 <a href="https://firebase.google.com/codelabs/firebase-get-to-know-flutter#0">codelab</a>。</p>
<h3 id="最終產品"><a href="#最終產品" class="headerlink" title="最終產品"></a>最終產品</h3><p>這個專案很好地體現了以 Web 為中心的應用程式建立方法。我們驚訝地發現，與我們使用 Flutter 建立行動應用程式的體驗相比，建立此 Web 應用程式的流程是如此相似。我們必須考慮視窗大小、響應式、觸控與滑鼠輸入、圖片加載時間、瀏覽器相容性以及建立 Web 應用程式時需要考慮的所有其他事项。但是，我們仍然使用相同的模式、架構和編碼標準編寫 Flutter 程式碼。在為 Web 建立應用程式時，我們感到賓至如歸。Flutter 套件的工具和不斷發展的生態系統，包括 Firebase 工具套件，讓 I&#x2F;O 照片亭成為可能。</p>
<figure>
<img alt="" src="https://cdn-images-1.medium.com/max/1024/0*CN8nNM1HaOjg9SfQ" />
<figcaption>Very Good Ventures 團隊，他們參與了 I/O 照片亭的開發</figcaption>
</figure>

<p>我們已將所有程式碼開源。在 GitHub 上查看 <a href="https://github.com/flutter/photobooth">photo_booth</a> 專案，並在 Facebook 和 Twitter 上使用 #IOPhotoBooth 向我們展示您的照片！</p>
<p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3b8355d35883" width="1" height="1" alt=""><hr><p><a href="https://medium.com/flutter/how-its-made-i-o-photo-booth-3b8355d35883">製作過程：I&#x2F;O 照片亭</a> 最初發佈在 <a href="https://medium.com/flutter">Flutter</a> 上的 Medium，人們在那裡透過突出顯示和回應這個故事來繼續討論。</p> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Rainvisitor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">166</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">188</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rainvisitor</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
